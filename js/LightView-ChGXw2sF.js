var e=Object.defineProperty,i=(i,n,t)=>((i,n,t)=>n in i?e(i,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[n]=t)(i,"symbol"!=typeof n?n+"":n,t);import{B as n}from"./base-CgClm5XE.js";import{G as t,V as o,R as a,a as s,C as r,B as l,M as u,b as h,c as d,d as p,e as c,D as m}from"./three-BQT4yrvs.js";import{d as v,A as g,B as y,g as f,j as b,F as x,o as w}from"./@vue-89U3BwR9.js";const G=v({__name:"LightView",setup(e){const v=new class extends n{constructor(){super(),i(this,"particles"),i(this,"box"),i(this,"planeGroup",new t),i(this,"boxGroup",new t),i(this,"raycaster"),i(this,"pointer",new o),i(this,"map",new Map),i(this,"uuid",""),i(this,"uTime",0)}load(){this.init("#webgl"),this.animate(),this.createBoxGroup(),this.raycaster=new a,window.addEventListener("mousemove",(e=>{var i,n;e.preventDefault(),this.pointer.x=e.clientX/this.innerWidth*2-1,this.pointer.y=-e.clientY/this.innerHeight*2+1,null==(i=this.raycaster)||i.setFromCamera(this.pointer,this.camera);const t=null==(n=this.raycaster)?void 0:n.intersectObjects(this.boxGroup.children);if(t&&t.length>0){const e=t[0].object;if(this.planeGroup.children.length&&this.planeGroup.position.x==e.position.x&&this.planeGroup.position.z==e.position.z);else{this.planeGroup.clear(),e.geometry.computeBoundingBox();const{min:i,max:n}=e.geometry.boundingBox||{min:new s(.1,.2,0),max:new s(.11,.12,0)},t=Math.abs(i.x)+Math.abs(n.x)+10,o=Math.abs(i.y)+Math.abs(n.y)+10,a=Math.abs(i.z)+Math.abs(n.z)+10;this.planeMask(t,o,a,e.position)}}else this.planeGroup.clear()}))}createBoxGroup(){var e,i,n;const t=50,o=150,a=50,s={u_y:{value:-o/2},yHeighy:{value:o/2},uWidth:{value:3},uColor:{value:new r(16776960)}};for(let r=0;r<10;r++){const e=new l(t,o,a),i=new u({color:13421772});this.box=new h(e,i),i.onBeforeCompile=function(e){Object.assign(e.uniforms,s),e.vertexShader=e.vertexShader.replace("void main() {","\n          varying vec3 vPosition;\n          void main() {\n            // vPosition = vec3(modelMatrix * vec4( position, 1.0 ));\n            // 布局坐标\n            vPosition = position;//只考虑几何体的顶点位置xyz\n          "),e.fragmentShader=e.fragmentShader.replace("void main() {","\n          varying vec3 vPosition;\n          uniform float u_y;\n          uniform vec3 uColor;\n          uniform float uWidth;\n          uniform float yHeighy;\n          void main() {\n\n          "),e.fragmentShader=e.fragmentShader.replace("#include <dithering_fragment>","\n          #include <dithering_fragment>\n\n          for (int i = 0; i < 5; i++) {\n            float adjustedUy = u_y - yHeighy + float(i) * uWidth * 10.0 ; // 每次循环调整 u_y 的值\n            // y随着时间改变光带位置也会改变\n            if(vPosition.y >= adjustedUy && vPosition.y < adjustedUy + uWidth) {\n              float per = (vPosition.y - adjustedUy) / uWidth; // 范围0~1\n              per = pow(per, 2.0); // 平方\n              gl_FragColor.rgb = mix(vec3(uColor), gl_FragColor.rgb, per);\n            }\n            // y随着时间改变光带位置也会改变\n            if(vPosition.y <= adjustedUy && vPosition.y > adjustedUy - uWidth) {\n              float per = (adjustedUy - vPosition.y) / uWidth; // 范围0~1\n              per = pow(per, 2.0); // 平方\n              gl_FragColor.rgb = mix(vec3(uColor), gl_FragColor.rgb, per);\n            }\n          }\n\n          ")},this.box.onBeforeRender=()=>{s.u_y.value+=30*this.clock.getDelta(),s.u_y.value>o&&(s.u_y.value=-o)},this.box.position.set(400*Math.random()-200,o/2,500*Math.random()-200),this.box.name="box",this.boxGroup.add(this.box),this.scene.add(this.boxGroup)}const p=new d(1e3,20);null==(e=this.scene)||e.add(p);const c={color:16776960,width:3};null==(i=this.gui)||i.addColor(c,"color").onChange((()=>{s.uColor.value=new r(c.color)})),null==(n=this.gui)||n.add(c,"width",1,10).onChange((()=>{s.uWidth.value=c.width}))}planeMask(e,i,n,t){var o;const a=new Float32Array([-e/2,0,0,e/2,0,0,e/2,i,0,e/2,i,0,-e/2,i,0,-e/2,0,0]),s=new p;s.attributes.position=new c(a,3);const r=new u({color:16776960,side:m,transparent:!0}),l=new h(s,r);l.position.set(0,0,n/2);const d={yHeigh:{value:i/3*2},uTime:{value:this.uTime}};r.onBeforeCompile=e=>{Object.assign(e.uniforms,d),e.vertexShader=e.vertexShader.replace("void main() {","\n          varying vec3 vPosition;\n          void main() {\n            // vPosition = vec3(modelMatrix * vec4( position, 1.0 ));\n            // 布局坐标\n            vPosition = position;//只考虑几何体的顶点位置xyz\n\n          "),e.fragmentShader=e.fragmentShader.replace("void main() {","\n          varying vec3 vPosition;\n          uniform float yHeigh;\n          uniform float uTime;\n          void main() {\n\n          "),e.fragmentShader=e.fragmentShader.replace("#include <dithering_fragment>","\n          #include <dithering_fragment>\n\n           gl_FragColor = vec4(outgoingLight, (1.0 - vPosition.y/yHeigh) * uTime   );\n\n          ")},l.onBeforeRender=()=>{d.uTime.value+=.05,d.uTime.value>=1&&(d.uTime.value=1)},this.planeGroup.add(l);const v=l.clone();v.position.set(0,0,-n/2),this.planeGroup.add(v);const g=l.clone();g.rotateY(Math.PI/2),g.position.set(e/2,0,0),this.planeGroup.add(g);const y=l.clone();y.rotateY(Math.PI/2),y.position.set(-e/2,0,0),this.planeGroup.add(y),this.planeGroup.position.set(t.x,0,t.z),null==(o=this.scene)||o.add(this.planeGroup)}animate(){var e,i,n;null==(e=this.stats)||e.begin(),requestAnimationFrame((()=>{this.animate()})),null==(i=this.raycaster)||i.setFromCamera(this.pointer,this.camera),this.renderer.render(this.scene,this.camera),null==(n=this.stats)||n.end()}};return g((()=>{v.load()})),y((()=>{v.gui.close(),v.gui.destroy()})),(e,i)=>(w(),f(x,null,[i[0]||(i[0]=b("div",{id:"webgl"},null,-1)),i[1]||(i[1]=b("div",{class:"title-name"},"建筑",-1))],64))}});export{G as default};

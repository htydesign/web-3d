var e=Object.defineProperty,n=(n,t,s)=>((n,t,s)=>t in n?e(n,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):n[t]=s)(n,"symbol"!=typeof t?t+"":t,s);import{B as t}from"./base-T3lLSoS5.js";import{o as s,aM as o,d as a,S as i}from"./three-BLJ24qmy.js";import{d as r,z as l,A as m,g as u,j as c,F as d,o as v}from"./@vue-DISYwsDo.js";const x=r({__name:"ModelView7",setup(e){const r=new class extends t{constructor(){super(),n(this,"model")}load(){var e,n;this.init("#webgl"),null==(e=this.renderer)||e.setClearColor(16777215),null==(n=this.scene)||n.remove(this.axesHelper),this.animate(),this.create()}create(){const e=new s,n={uModelHeight:{value:0},uTime:{value:4},uProgress:{value:0},uMosaic:{value:.5}};e.load("./models/gltf/LeePerrySmith/LeePerrySmith.glb",(e=>{var t;this.model=e.scene.getObjectByName("LeePerrySmith"),this.model.geometry.scale(10,10,10),this.model.geometry.computeBoundingBox();const{max:s,min:r}=this.model.geometry.boundingBox&&this.model.geometry.boundingBox||new o;n.uModelHeight.value=s.y-r.y,this.model.position.set(0,(s.y-r.y)/2,0),this.model.geometry=this.model.geometry.toNonIndexed(),this.model.geometry.center();const l=this.model.geometry.attributes.position.array,m=[],u=[],c=[],d=[],v=[];for(let n=0;n<l.length;n+=9){const e=20*Math.random(),t=(l[n+0]+l[n+3]+l[n+6])/3*e,s=(l[n+1]+l[n+4]+l[n+7])/3*e,o=(l[n+2]+l[n+5]+l[n+8])/3*e;m.push(t,s,o),m.push(t,s,o),m.push(t,s,o),u.push(n/3,n/3,n/3);const a=.5*Math.random()+.5;c.push(a,a,a),c.push(a,a,a),c.push(a,a,a);const i=(l[n+1]+l[n+4]+l[n+7])/50+2;d.push(i,i,i),d.push(i,i,i),d.push(i,i,i);const r=.5*Math.random()+.5;v.push(r,r,r),v.push(r,r,r),v.push(r,r,r)}this.model.geometry.setAttribute("center",new a(new Float32Array(m),3)),this.model.geometry.setAttribute("index",new a(new Float32Array(u),3)),this.model.geometry.setAttribute("speed",new a(new Float32Array(c),3)),this.model.geometry.setAttribute("delay",new a(new Float32Array(d),3)),this.model.geometry.setAttribute("random",new a(new Float32Array(v),3)),this.model.material=new i({uniforms:n,vertexShader:"\n  mat4 rotation3d(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat4(\n      oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n      oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n      oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n      0.0,                                0.0,                                0.0,                                1.0\n    );\n  }\n\n  vec3 rotate(vec3 v, vec3 axis, float angle) {\n    mat4 m = rotation3d(axis, angle);\n    return (m * vec4(v, 1.0)).xyz;\n  }\n\n  float backOut(float progress, float swing){\n    float p = progress - 1.0;\n    return (p * p * ((swing + 1.0) * p + swing) + 1.0);\n  }\n\n  uniform float uTime;\n  uniform float uTriScale;\n  uniform float uMosaic;\n  uniform float uProgress;\n  uniform float uModelHeight;\n\n  varying vec2 vUv;\n  varying vec3 vPosition;\n  varying vec3 vNormal;\n\n  attribute vec3 center;\n  attribute vec3 index;\n  attribute vec3 speed;\n  attribute vec3 delay;\n\n  float PI = 3.1415925;\n\n\n  void main() {\n    vUv = uv;\n    vPosition = position;\n    vNormal = normal;\n\n    vec3 pos = position;\n\n   \n    // vec3 newPos = (pos - center) * uProgress + center;\n\n\n    // if(uTime > vx.y){\n    //    pos = mix(newPos, posPixelated, uProgress);\n    // }\n   \n    // pos += rotate(pos, vec3(0.0, 1.0, 0.0), uTime * 0.1);\n    // pos += rotate(pos, vec3(1.0, 0.0, 0.0), uTime * 0.1);\n    // pos += rotate(pos, vec3(0.0, 0.0, 1.0), uTime * 0.1);\n   \n    // if(uTime > index.x){\n    //    pos = (pos - center) * uProgress + center;\n    // }\n   \n    //控制开始时间在延迟之后执行\n    float d = uTime - delay.x;\n    if (d < 0.0) {\n      d = 0.0;\n    }\n    //限制s的时间,始终在【0 - 1】之间\n    float s = smoothstep(0.0, 1.0, d * speed.x);\n    pos = (pos - center) * s + center;    \n    vec3 posPixelated = floor(pos * (1.0 - uMosaic) + 0.5) / (1.0 - uMosaic);\n    // pos += mix(pos, posPixelated, uProgress);\n     pos += posPixelated;\n  \n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n  }\n",fragmentShader:"\n  varying vec2 vUv;\n  varying vec3 vPosition;\n  varying vec3 vNormal;\n  void main() {   \n    gl_FragColor = vec4(vNormal, 1.0);\n  }\n"}),null==(t=this.scene)||t.add(this.model),this.model.onBeforeRender=()=>{},this.gui.add(n.uMosaic,"value",0,1,.01).name("马赛克大小"),this.gui.add(n.uTime,"value",0,7,.01).name("时间")}))}animate(){var e,n,t;null==(e=this.stats)||e.begin(),requestAnimationFrame((()=>{this.animate()})),null==(n=this.renderer)||n.render(this.scene,this.camera),null==(t=this.stats)||t.end()}};return l((()=>{r.load()})),m((()=>{r.destroy()})),(e,n)=>(v(),u(d,null,[n[0]||(n[0]=c("div",{id:"webgl"},null,-1)),n[1]||(n[1]=c("div",{class:"title-name"},"模型变换",-1))],64))}});export{x as default};

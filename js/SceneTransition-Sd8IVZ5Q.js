var e=Object.defineProperty,t=(t,n,i)=>((t,n,i)=>n in t?e(t,n,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[n]=i)(t,"symbol"!=typeof n?n+"":n,i);import{aI as n,c as i,al as r,b as a,P as s,W as o,aD as l,S as f,H as d,J as c,C as h,a1 as u,a2 as x,K as m,T as v,aJ as p,B as g,M as w,D as T,n as y,$ as R,Z as b,a3 as U,as as D}from"./three-DKcIG4Oh.js";import{d as C,z as A,A as z,g as _,j as F,F as B,o as M}from"./@vue-DISYwsDo.js";class P{constructor(){t(this,"isPass",!0),t(this,"enabled",!0),t(this,"needsSwap",!0),t(this,"clear",!1),t(this,"renderToScreen",!1)}dispose(){}}const S=new n(-1,1,1,-1,0,100);new class extends i{constructor(){super(),this.setAttribute("position",new r([-1,3,0,-1,-1,0,3,-1,0,3,3,0],3)),this.setAttribute("uv",new r([0,2,0,0,2,0,2,2],2))}};class k{constructor(e){t(this,"_mesh"),this._mesh=new a(new s(2,2,100,100),e)}dispose(){this._mesh.geometry.dispose()}render(e){e.render(this._mesh,S)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}}class E extends P{constructor(e,n,i,r){super(),t(this,"material"),t(this,"fsQuad"),t(this,"sceneA"),t(this,"cameraA"),t(this,"sceneB"),t(this,"cameraB"),t(this,"renderTargetA"),t(this,"renderTargetB"),this.material=this.createMaterial(),this.fsQuad=new k(this.material),this.sceneA=e,this.cameraA=n,this.sceneB=i,this.cameraB=r,this.renderTargetA=new o,this.renderTargetA.texture.type=l,this.renderTargetB=new o,this.renderTargetB.texture.type=l}setTransition(e){this.material.uniforms.mixRatio.value=e}useTexture(e){this.material.uniforms.useTexture.value=e}setTexture(e){this.material.uniforms.tMixTexture.value=e}setTextureThreshold(e){this.material.uniforms.threshold.value=e}setEffect(e){this.material.uniforms.effect.value=e}setSize(e,t){this.renderTargetA.setSize(e,t),this.renderTargetB.setSize(e,t)}render(e,t){e.setRenderTarget(this.renderTargetA),e.render(this.sceneA,this.cameraA),e.setRenderTarget(this.renderTargetB),e.render(this.sceneB,this.cameraB);const n=this.fsQuad.material.uniforms;n.tDiffuse1.value=this.renderTargetA.texture,n.tDiffuse2.value=this.renderTargetB.texture,this.renderToScreen?(e.setRenderTarget(null),e.clear()):(e.setRenderTarget(t),this.clear&&e.clear()),this.fsQuad.render(e)}dispose(){this.renderTargetA.dispose(),this.renderTargetB.dispose(),this.material.dispose(),this.fsQuad.dispose()}createMaterial(){return new f({uniforms:{tDiffuse1:{value:null},tDiffuse2:{value:null},mixRatio:{value:.5},threshold:{value:.1},useTexture:{value:1},tMixTexture:{value:null},effect:{value:0}},vertexShader:"\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tuniform float mixRatio;\n        uniform int effect;\n        uniform int useTexture;\n\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = vec2( uv.x, uv.y );\n\n\t\t\t\t\tvec4 newPosition = modelMatrix * vec4(position, 1.0);\n\n          if(useTexture == 2 && effect == 8){\n            float dist = distance(vUv, vec2(0.5));\n            float strength = smoothstep(0.2, mixRatio, dist);\n            if(mixRatio<0.8 && mixRatio>0.2){\n              newPosition.xy *= strength * 2.5;\n            }\n          }\n          \n\n\t\t\t\t\tgl_Position = projectionMatrix  * viewMatrix * newPosition;\n\n\t\t\t\t}\n\t\t\t",fragmentShader:"\n\t\t\t\tuniform float mixRatio;\n\n\t\t\t\tuniform sampler2D tDiffuse1;\n\t\t\t\tuniform sampler2D tDiffuse2;\n\t\t\t\tuniform sampler2D tMixTexture;\n\n\t\t\t\tuniform int useTexture;\n\t\t\t\tuniform float threshold;\n        uniform int effect;\n\n\t\t\t\tvarying vec2 vUv;\n\n        // 缓动函数:easeInOutQuad\n        float easeInOutQuad(float t) {\n          return t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t;\n        }\n\n        // Perlin Noise Function\n        float fade(float t) {\n            return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n        }\n\n        float lerp(float a, float b, float t) {\n            return a + t * (b - a);\n        }\n\n        float grad(int hash, float x, float y, float z) {\n            int h = hash & 15;\n            float u = h < 8 ? x : y;\n            float v = h < 4 ? y : h == 12 || h == 14 ? x : z;\n            return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);\n        }\n\n        float noise(vec3 p) {\n            vec3 pi = floor(p);\n            vec3 pf = p - pi;\n            pi = mod(pi, 256.0);\n\n            int ix = int(pi.x);\n            int iy = int(pi.y);\n            int iz = int(pi.z);\n\n            int a = ix + iy * 256;\n            int aa = a + iz;\n            int ab = a + iz + 1;\n            int ba = a + 256 + iz;\n            int bb = a + 256 + iz + 1;\n\n            float u = fade(pf.x);\n            float v = fade(pf.y);\n            float w = fade(pf.z);\n\n            float n000 = grad(aa, pf.x, pf.y, pf.z);\n            float n001 = grad(ab, pf.x, pf.y, pf.z - 1.0);\n            float n010 = grad(ba, pf.x, pf.y - 1.0, pf.z);\n            float n011 = grad(bb, pf.x, pf.y - 1.0, pf.z - 1.0);\n            float n100 = grad(aa + 1, pf.x - 1.0, pf.y, pf.z);\n            float n101 = grad(ab + 1, pf.x - 1.0, pf.y, pf.z - 1.0);\n            float n110 = grad(ba + 1, pf.x - 1.0, pf.y - 1.0, pf.z);\n            float n111 = grad(bb + 1, pf.x - 1.0, pf.y - 1.0, pf.z - 1.0);\n\n            float x1 = lerp(n000, n100, u);\n            float x2 = lerp(n001, n101, u);\n            float x3 = lerp(n010, n110, u);\n            float x4 = lerp(n011, n111, u);\n\n            float y1 = lerp(x1, x3, v);\n            float y2 = lerp(x2, x4, v);\n\n            return lerp(y1, y2, w);\n        }\n\n\t\t\t\tvoid main() {\n\n          vec2 scaledUv = vUv * mixRatio;\n\n\t\t\t\t\tvec4 texel1 = texture2D( tDiffuse1, vUv);\n\t\t\t\t\tvec4 texel2 = texture2D( tDiffuse2, vUv );\n\n\t\t\t\t\tif (useTexture == 1) {\n\n\t\t\t\t\t\tvec4 transitionTexel = texture2D( tMixTexture, vUv );\n\t\t\t\t\t\tfloat r = mixRatio * ( 1.0 + threshold * 2.0 ) - threshold;\n\t\t\t\t\t\tfloat mixf = clamp( ( transitionTexel.r - r ) * ( 1.0 / threshold ), 0.0, 1.0 );\n\n\t\t\t\t\t\tgl_FragColor = mix( texel2, texel1, mixf );\n\n\t\t\t\t\t} else if (useTexture == 2){\n            //自定义\t\t\n            if(effect == 0){\t\t\n              //放大\n              vec4 color = vec4(0.0);              \n              vec2 center = vec2(0.5);\n\n              vec2 scale1 = center + (vUv - center) * easeInOutQuad(mixRatio);\n              vec2 scale2 = center + (vUv - center) * (1.0 - easeInOutQuad(mixRatio));\n            \n\n              if(mixRatio > 0.5){\n                color += texture2D( tDiffuse2, scale1);\n              }else{\n                color += texture2D( tDiffuse1, scale2);\n              }\n\n\n              gl_FragColor = color;\n\n            }else if(effect == 1){\n              //左两边出现\n              vec4 texture1 = texture( tDiffuse1, vUv );\n              vec4 texture2 = texture( tDiffuse2, vUv );\n\n              vec4 color = texture1 ;\n\n              float f = step(mixRatio, vUv.x);\n\n              color = f == 0.0 ? texture2 : texture1;\n\n              gl_FragColor = color;\n\n            }else if(effect == 2){\n              // 使用噪声函数生成扭曲效果\n              float noiseValue = noise(vec3(vUv * (1.0 - mixRatio) * 10.0, 1.0));\n              noiseValue = (noiseValue + 1.0) / 2.0; // 将噪声值从[-1, 1]转换到[0, 1]\n\n              // 修改纹理坐标\n              vec2 distortedTexCoord = vUv + (noiseValue - 0.5) * 0.1;\n\n              // 使用修改后的纹理坐标从纹理中采样颜色\n              vec4 color1 = texture(tDiffuse1, distortedTexCoord);\n              vec4 color2 = texture(tDiffuse2, distortedTexCoord);\n\n              gl_FragColor = mix( color1, color2, mixRatio );\n            }else if(effect == 3){\n              //旋转\n              vec2 center = vec2(0.5);\n              vec2 offset = vUv - center;\n\n              float rotationAngle = 3.14 / 2.0;\n              // 计算旋转矩阵\n              float angle = rotationAngle * mixRatio ; \n              // 根据mixRatio调整旋转角度\n              float cosA = cos(angle);\n              float sinA = sin(angle);\n\n              // 应用旋转矩阵\n              vec2 rotatedOffset = vec2(offset.x * cosA - offset.y * sinA, offset.x * sinA + offset.y * cosA);\n              vec2 rotatedTexCoord = center + rotatedOffset ;\n              vec2 rotatedTexCoord2 = center - rotatedOffset ;\n\n              // 使用旋转后的纹理坐标从纹理中采样颜色\n              vec4 color1 = texture(tDiffuse1, rotatedTexCoord);\n              vec4 color2 = texture(tDiffuse2, vUv);\n\n              gl_FragColor = mix(color1, color2, mixRatio);\n            }else if(effect == 4){\n              //百叶窗\n              vec2 gridUv = mod(vUv * 10.0, 1.0);\n              float grid = step(mixRatio, mod(gridUv.x + gridUv.x, 1.0));\n             \n              vec4 color = texel1;\n\n              color = grid == 0.0 ? texel2 : texel1;\n\n              gl_FragColor = color;\n\n            }else if(effect == 5){\n             // 先居中，再绘制圆形\n              float dist = length(vUv - vec2(0.5));\n              // float dist = distance(vUv, vec2(0.5));\n              float radius = 0.5; // 0.25\n              float grid = step(mixRatio, dist);\n             \n             \n              vec4 color = texel1;\n\n              color = grid == 0.0 ? texel2 : texel1;\n\n              gl_FragColor = color;\n\n            }else if(effect == 6){\n              //棋盘效果\n              float mask1 = step(mixRatio, fract(vUv.x * 10.0));\n              float mask2 = step(mixRatio, fract(vUv.y * 10.0));\n              float grid = mask1 + mask2;\n              vec4 color = texel1;\n\n              color = grid == 0.0 ? texel2 : texel1;\n\n              gl_FragColor = color;\n            }else if(effect == 7){\n              //\n              float distance = length(vUv - vec2(0.5));\n\n              distance = step(mixRatio*1.0, distance);\n              float mask1 = step(mixRatio/2.0, distance);\n              float mask2 = step(mixRatio/2.0, 1.0 - distance);\n\n              float grid = mask1 + mask2;\n              vec4 color = texel1;\n\n              color = distance == 0.0 ? texel2 : texel1;\n              \n              gl_FragColor = color;\n            }else if(effect == 8){\n              if(mixRatio > 0.2 && mixRatio < 0.8){\n                gl_FragColor = mix( texel1, texel2, mixRatio-0.2 );\n              }else if(mixRatio > 0.8){\n                gl_FragColor = texel2;\n              }else{\n                gl_FragColor = texel1;\n\n              }\n            }\n            \n\n\n\t\t\t\t\t} else {\n             gl_FragColor = mix( texel1, texel2, mixRatio);\n          }\n\n\t\t\t\t}\n\t\t\t"})}}const Q=C({__name:"SceneTransition",setup(e){class n{constructor(){t(this,"scene1",new d),t(this,"camera1",new c(75,window.innerWidth/window.innerHeight,.1,1e3)),t(this,"scene2",new d),t(this,"camera2",new c(75,window.innerWidth/window.innerHeight,.1,1e3)),t(this,"renderTarget1"),t(this,"renderTarget2"),t(this,"renderer"),t(this,"width"),t(this,"height"),t(this,"start",!1),t(this,"uniforms",{texture1:{value:null},texture2:{value:null},transition:{value:0}}),t(this,"composer"),t(this,"params",{transition:0,method:{},texture:0,useTexture:0,useEffect:0}),this.camera1.position.set(0,2,5),this.camera2.position.set(0,2,5),this.scene1.background=new h(4473924),this.scene2.background=new h(16720384),this.width=window.innerWidth,this.height=window.innerHeight,this.renderer=new u({antialias:!0}),this.renderer.setSize(this.width,this.height),this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.shadowMap.enabled=!0,this.renderer.shadowMap.type=x;const e=document.querySelector("#webgl");null==e||e.appendChild(this.renderer.domElement),new m(this.camera1,this.renderer.domElement),new m(this.camera2,this.renderer.domElement);const n=new v,i=[];for(let t=0;t<6;t++)i[t]=n.load("./texture/transition/transition"+(t+1)+".png");const r=window.devicePixelRatio;this.renderTarget1=new o(this.width*r,this.height*r),this.renderTarget2=new o(this.width*r,this.height*r),this.renderTarget1.texture.generateMipmaps=!1,this.renderTarget1.texture.minFilter=p,this.renderTarget2.texture.generateMipmaps=!1,this.renderTarget2.texture.minFilter=p;const s=(new v).load("./texture/xingkong.jpg"),l=new g(20,20,20),f=new w({side:T,map:s}),C=new a(l,f);this.scene1.add(C);const A=(new v).load("./texture/sky.jpg"),z=new y(25,32,32),_=new w({side:T,map:A}),F=new a(z,_);this.scene2.add(F),this.composer=new R(this.renderer);const B=new E(this.scene1,this.camera1,this.scene2,this.camera2);B.setTexture(i[this.params.texture]),B.useTexture(this.params.useTexture),B.setEffect(this.params.useEffect),this.composer.addPass(B);const M=new b;this.composer.addPass(M),new U.Tween(this.params).to({transition:1},2e3).onUpdate((()=>{B.setTransition(this.params.transition)})).repeat(1/0).delay(2e3).yoyo(!0).start();const P=new D;P.add(this.params,"transition",0,1,.01).onChange((()=>{B.setTransition(this.params.transition)}));const S=P.add(this.params,"texture",{Perlin:0,Squares:1,Cells:2,Distort:3,Gradient:4,Radial:5}).onChange((e=>{B.setTexture(i[e])})).listen();S.disable();const k=P.add(this.params,"useEffect",{"放大":0,"左边出现":1,"扭曲":2,"旋转":3,"百叶窗":4,"圆圈":5,"棋盘":6,"其它":8}).onChange((e=>{B.setEffect(e)}));k.disable();P.add({method:0},"method").options({"纹理切换":1,"自定义切换":2,"默认切换":0}).name("场景变换方式").onChange((e=>{1===e?S.enable():S.disable(),2===e?k.enable():k.disable(),B.useTexture(e)})),this.animate()}animate(){requestAnimationFrame((()=>{this.animate()})),U.update(),0===this.params.transition?this.renderer.render(this.scene1,this.camera1):1===this.params.transition?this.renderer.render(this.scene2,this.camera2):this.composer.render()}}return A((()=>{new n})),z((()=>{})),(e,t)=>(M(),_(B,null,[t[0]||(t[0]=F("div",{id:"webgl"},null,-1)),t[1]||(t[1]=F("div",{class:"title-name"},"场景切换",-1))],64))}});export{Q as default};

var e=Object.defineProperty,n=(n,t,o)=>((n,t,o)=>t in n?e(n,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):n[t]=o)(n,"symbol"!=typeof t?t+"":t,o);import{B as t}from"./base-B6zMTzfe.js";import{C as o,c as i,d as r,T as a,W as s,S as l,a as c,k as v,l as d,V as h,e as u,P as m,m as p,b as f}from"./three-hMcRR63t.js";import{d as g,o as w,l as x,F as A,G as S,H as C,E as y}from"./@vue-CBatJ08e.js";const b=g({__name:"LightFiveView",setup(e){const g=new class extends t{constructor(){super(),n(this,"renderTarget")}load(){this.init("#webgl"),this.animate(),this.create(),this.createFlow(),this.scene.background=new o(3355443)}create(){var e;const n=1e5,t=new i,h=new Float32Array(3e5);t.setAttribute("position",new r(h,3));const u=new Float32Array(n);t.setAttribute("speed",new r(u,1));const m=new Float32Array(n);t.setAttribute("aProgress",new r(m,1));for(let o=0;o<n;o++)h[3*o]=1e3*Math.random()-500,h[3*o+1]=500*Math.random()-500,h[3*o+2]=1e3*Math.random()-500,m[o]=h[3*o+1],u[o]=1+Math.random();t.attributes.position.needsUpdate=!0,t.attributes.speed.needsUpdate=!0,t.attributes.aProgress.needsUpdate=!0;const p=(new a).load("./texture/xingkong2.jpg");this.renderTarget=new s(this.innerWidth,this.innerHeight);const f=new l({uniforms:{uTexture:{value:p},uTime:{value:0},ambientLightColor:{value:new o(3355443)},directionalLightColor:{value:new o(0)},directionalLightDirection:{value:new c}},vertexShader:"\n        attribute float speed;\n        attribute float aProgress;\n        uniform float uTime;\n\n        uniform vec3 ambientLightColor;\n        uniform vec3 directionalLightColor;\n        uniform vec3 directionalLightDirection;\n\n        float uSpeed = 1.;\n\n        varying float vYCoord;\n        varying vec3 vColor;\n        varying vec2 vUv;\n\n        void main() {\n          vUv = uv;\n          vec3 normal = normalize(normalMatrix * normal);\n          vec3 lightDir = normalize(directionalLightDirection);\n          float dotProduct = max(dot(normal, lightDir), 0.0);\n          vColor = ambientLightColor + dotProduct * directionalLightColor;\n          \n          vec3 p = position;\n          float s = -uTime * speed * 100.0;\n          p.y = mod(aProgress + s , 500.0);\n          \n          vYCoord = p.y;\n\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0);\n          gl_PointSize = 3.0;\n        }\n      ",fragmentShader:"\n        \n        varying float vYCoord;\n        varying vec3 vColor;\n        varying vec2 vUv;\n\n        uniform sampler2D uTexture;\n\n        void main() {\n          float strength = distance(gl_PointCoord,vec2(0.5,0.5));\n          float dis = length(gl_PointCoord - 0.5);\n          dis = smoothstep(0.5,0.0,dis);\n          strength = step(0.5,strength);\n          strength = 1.0 - strength;\n\n\n          //渐变色\n          vec3 finalColor = vColor;      \n          if(vYCoord > 100.0){\n           finalColor = vec3(1.0,1.0,0.0);\n          }else{\n           finalColor = vec3(1.0,1.0,1.0);\n          }\n\n          float alpha = smoothstep(200.0, 100.0, vYCoord);\n          \n          if(strength == 0.0){\n            discard;\n          }\n          if(dis == 0.0){\n            discard;\n          }\n          // vec3 finalColor = texture2D(uTexture, vUv).rgb;\n          gl_FragColor = vec4(finalColor,alpha);\n        }"}),g=new v(16777215,1e3);g.position.set(0,50,1),g.castShadow=!0,g.shadow.mapSize.width=1024,g.shadow.mapSize.height=1024,g.shadow.camera.near=.5,g.shadow.camera.far=500,this.scene.add(g),f.uniforms.directionalLightDirection.value=g.position.clone().normalize();const w=new d(t,f);w.onBeforeRender=()=>{f.uniforms.uTime.value+=.01},null==(e=this.scene)||e.add(w)}createText(){}createFlow(){var e,n,t;const{width:o,height:i}=(null==(e=this.renderer)?void 0:e.getSize(new h))||{};new c(o,i,null==(n=this.renderer)?void 0:n.getPixelRatio());const r=(new a).load("./texture/xingkong.jpg");r.wrapS=u,r.wrapT=u;const s=new m(1e3,1e3),v=new l({uniforms:{iMouse:{value:new p(0,0,0,1)},iResolution:{value:new c(1e3,1e3,0)},iTime:{value:0},map:{value:r}},vertexShader:"\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      vec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\n      gl_Position = projectionMatrix * mvPosition;\n    }\n  ",fragmentShader:"\n    uniform vec4 iMouse;\n    uniform vec3 iResolution;\n    uniform float iTime;\n    uniform sampler2D map;\n    varying vec2 vUv;\n\n    float count = 500.0;\n\n\n    // Maximum number of cells a ripple can cross.\n    #define MAX_RADIUS 2\n\n    // Set to 1 to hash twice. Slower, but less patterns.\n    #define DOUBLE_HASH 0\n\n    // Hash functions shamefully stolen from:\n    // https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 .1031\n    #define HASHSCALE3 vec3(.1031, .1030, .0973)\n\n    float hash12(vec2 p)\n    {\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    vec2 hash22(vec2 p)\n    {\n      vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n      p3 += dot(p3, p3.yzx+19.19);\n      return fract((p3.xx+p3.yz)*p3.zy);\n\n    }\n\n    void main()\n    {\n      float resolution = 1. * exp2(-3.*iMouse.x/iResolution.x);\n      // vec2 uv = gl_FragCoord.xy / iResolution.xy *20.0;\n      vec2 uv = vUv * count;\n      vec2 p0 = floor(uv);\n\n        vec2 circles = vec2(0.);\n        for (int j = -MAX_RADIUS; j <= MAX_RADIUS; ++j)\n        {\n            for (int i = -MAX_RADIUS; i <= MAX_RADIUS; ++i)\n            {\n              vec2 pi = p0 + vec2(i, j);\n              #if DOUBLE_HASH\n              vec2 hsh = hash22(pi);\n              #else\n              vec2 hsh = pi;\n              #endif\n              vec2 p = pi + hash22(hsh);\n\n              float t = fract(0.3*iTime + hash12(hsh));\n              vec2 v = p - uv;\n              float d = length(v) - (float(MAX_RADIUS) + 1.)*t;\n\n              float h = 1e-3;\n              float d1 = d - h;\n              float d2 = d + h;\n              float p1 = sin(31.*d1) * smoothstep(-0.6, -0.3, d1) * smoothstep(0., -0.3, d1);\n              float p2 = sin(31.*d2) * smoothstep(-0.6, -0.3, d2) * smoothstep(0., -0.3, d2);\n              circles += 0.5 * normalize(v) * ((p2 - p1) / (2. * h) * (1. - t) * (1. - t));\n              }\n        }\n        circles /= float((MAX_RADIUS*2+1)*(MAX_RADIUS*2+1));\n\n        float intensity = mix(0.01, 0.15, smoothstep(0.1, 0.6, abs(fract(0.05*iTime + 0.5)*2.-1.)));\n        vec3 n = vec3(circles, sqrt(1. - dot(circles, circles)));\n        vec3 color = texture(map, uv/count).rgb + 15.*pow(clamp(dot(n, normalize(vec3(1., 0.7, 0.5))), 0., 1.), 6.);\n        // vec3 color = vec3(0.0,0.0,0.0) + 15.*pow(clamp(dot(n, normalize(vec3(1., 0.7, 0.5))), 0., 1.), 6.);\n        // vec3 c = texture2D(map,vUv).rgb;\n        gl_FragColor = vec4( color, 1.0);\n    }\n  "}),d=new f(s,v);d.rotateX(-Math.PI/2),null==(t=this.scene)||t.add(d),d.onBeforeRender=()=>{v.uniforms.iTime.value+=.01}}animate(){var e,n;null==(e=this.stats)||e.begin(),requestAnimationFrame((()=>{this.animate()})),this.renderer&&this.renderTarget&&(this.renderer.setRenderTarget(this.renderTarget),this.renderer.render(this.scene,this.camera),this.renderer.setRenderTarget(null),this.renderer.render(this.scene,this.camera)),null==(n=this.stats)||n.end()}};return w((()=>{g.load()})),x((()=>{g.gui.close(),g.gui.destroy()})),(e,n)=>(y(),A(C,null,[n[0]||(n[0]=S("div",{id:"webgl"},null,-1)),n[1]||(n[1]=S("div",{class:"title-name"},"灯光2",-1))],64))}});export{b as default};

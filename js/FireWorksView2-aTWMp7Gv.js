import{B as n}from"./base-DD5aOT-d.js";import{c as e,d as o,S as t,D as a,l as i,a as r,C as s,A as l,ad as u}from"./three-DHmVq3iW.js";import{d as m,z as d,A as c,g as v,j as f,F as h,o as w}from"./@vue-BDXyav1n.js";const g=m({__name:"FireWorksView2",setup(m){class g{constructor(n,s){const l=new e,m=450,d=new Float32Array(1350);l.setAttribute("position",new o(d,3));const c=new Float32Array(m);l.setAttribute("aIndex",new o(c,1));let v=0,f=50;for(let e=0;e<m;e++){c[e]=e,e%90==0&&v++,1===v?(d[3*e+1]=0,f=50):2===v?(d[3*e+1]=2,f=52):3===v?(d[3*e+1]=4,f=54):4===v?(d[3*e+1]=6,f=52):5===v&&(d[3*e+1]=8,f=50);const n=Math.sin(u.degToRad(e%90*.8*5))*f,o=Math.cos(u.degToRad(e%90*.8*5))*f;d[3*e+0]=n,d[3*e+2]=o}l.attributes.position.needsUpdate=!0,l.attributes.aIndex.needsUpdate=!0;const h=new t({uniforms:{uIndex:{value:1},uFlag:{value:0},uTime:{value:0}},vertexShader:"\n       attribute float aIndex;\n\n       varying float index;\n\n       uniform float uTime;\n\n       float PI = 3.1415925;\n\n        void main(){\n          index = mod(aIndex , 90.0);\n          \n          vec3 myPosition = position;\n\n\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(myPosition, 1.0);\n          gl_PointSize = 3.0;\n          gl_PointSize *= 100.0/-(modelViewMatrix * vec4(position, 1.0)).z;\n        }\n      ",fragmentShader:"\n        varying float index;\n        uniform float uIndex;\n        uniform float uFlag;\n\n        vec4 mColor(in float i, in float n){\n\n          float max = i + 5.0;\n          float min = i - 5.0;\n\n          if(n >= min && n <= max){\n            vec3 color = vec3(1.0, 0.0, 0.0);\n            float alpha = 1.0 ;\n\n            if(i >= n){\n              alpha = 1.0-(i - n) / 5.0;\n            }else{\n              alpha = 1.0-(n - i) / 5.0;\n            }\n\n            return vec4(color, alpha);\n          }else{\n           return vec4(0.1, 0.1, 0.1, 1.0);\n          }\n        }\n\n        void main(){\n          if(uFlag == 1.0){\n            gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n          }else{\n            gl_FragColor = mColor(uIndex,index);\n          }\n\n        }\n      ",transparent:!0,side:a}),w=new i(l,h);w.position.set(0,70,0);let g=0;let x=0;const y={n:20};s.add(y,"n",1,50,1).name("烟花间隔(毫秒)"),w.onBeforeRender=()=>{if(h.uniforms.uTime.value+=.001,h.uniforms.uIndex.value>90&&(h.uniforms.uIndex.value=0,g++),g>=2){h.uniforms.uFlag.value=1;const e=new r(40*Math.random()-20,70,40*Math.random()-20);x%y.n==0&&(new P(n,e),new p(n,e))}else h.uniforms.uIndex.value+=1;x+=1,w.rotateY(.001)},n.add(w)}}class p{constructor(n,a){const u=a,m=new r(a.x,0,a.z),d=new e,c=new s(Math.random(),Math.random(),Math.random()),v=new t({uniforms:{uTime:{value:0},uColor:{value:c},uScale:{value:0}},vertexShader:"\n        attribute vec3 toPosition;\n        uniform float uTime;\n        uniform float uScale;\n\n        void main(){\n            vec3 myPosition = position;\n            myPosition.y -= 1.0 * uTime;\n\n            vec4 mvPosition = modelViewMatrix * vec4(myPosition, 1.0);\n\n            gl_PointSize = 100.0 * 50.0 / -mvPosition.z;\n            gl_PointSize *= uScale;\n\n            gl_Position = projectionMatrix * mvPosition;\n\n        }\n      ",fragmentShader:"\n        uniform vec3 uColor;\n        void main(){\n            float alpha = 1.0 - distance(gl_PointCoord,vec2(0.5)) * 2.0;\n            gl_FragColor = vec4(uColor, alpha);\n        }\n      ",transparent:!0,blending:l,depthTest:!1}),f=new Float32Array(u);d.setAttribute("position",new o(f,3)),d.setAttribute("toPosition",new o(new Float32Array(m),3));const h=new i(d,v);let w=0;h.onBeforeRender=()=>{v.uniforms.uScale.value<=1&&(v.uniforms.uScale.value+=.1,0==w&&(w=1,new x(n,u,c))),v.uniforms.uTime.value<=70?v.uniforms.uTime.value+=.5:(h.clear(),n.remove(h))},n.add(h)}}class x{constructor(n,a,r){const s=new e,l=new Float32Array(60);s.setAttribute("position",new o(l,3));const u=new Float32Array(20);s.setAttribute("aDelay",new o(u,1));for(let e=0;e<20;e++)l[3*e+0]=a.x,l[3*e+1]=a.y,l[3*e+2]=a.z,u[e]=100*e;const m=new t({uniforms:{uTime:{value:0},uColor:{value:r}},vertexShader:"\n        attribute float aDelay;  \n\n        uniform float uTime;\n\n        void main() {\n          vec3 pos = position;\n\n          float delayTime = aDelay + uTime;\n\n         if(uTime * 1000.0 > aDelay){\n          pos.y -= (uTime * 1000.0 - aDelay) * 0.01;\n         }\n         \n\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n          gl_PointSize =7.0- 5.0 * aDelay/1000.0;\n        }\n      ",fragmentShader:"\n        uniform vec3 uColor;\n        void main() {\n          gl_FragColor = vec4(uColor, 1.0);\n        }\n      "}),d=new i(s,m);d.onBeforeRender=()=>{m.uniforms.uTime.value>7?(d.clear(),n.remove(d)):m.uniforms.uTime.value+=.05},n.add(d)}run(){}}class P{constructor(n,a){const r=500,u=new e,m=new Float32Array(1500);u.setAttribute("position",new o(m,3));const d=new Float32Array(1500);u.setAttribute("toPosition",new o(d,3));const c=new Float32Array(500);u.setAttribute("aSpeed",new o(c,1));for(let e=0;e<r;e++)m[3*e+0]=a.x,m[3*e+1]=a.y,m[3*e+2]=a.z,d[3*e+0]=30*Math.random()*Math.sin(e),d[3*e+1]=10*Math.random()-5,d[3*e+2]=30*Math.random()*Math.cos(e),c[e]=Math.random();const v=new t({uniforms:{uTime:{value:0},uColor:{value:new s(Math.random(),Math.random(),Math.random())},uScale:{value:1},uSpeed:{value:.5}},vertexShader:"\n        attribute vec3 toPosition;\n        attribute float aSpeed;\n\n        uniform float uTime;\n        uniform float uScale;\n       \n        void main(){\n            vec3 myPosition = position;\n            myPosition += toPosition * uTime ;\n\n            vec4 mvPosition = modelViewMatrix * vec4(myPosition, 1.0);\n\n            gl_PointSize = 100.0 * 30.0 / -mvPosition.z;\n            gl_PointSize *= uScale;\n            gl_Position = projectionMatrix * mvPosition;\n            \n        }\n      ",fragmentShader:"\n        uniform vec3 uColor;\n        void main(){\n            float alpha = 1.0 - distance(gl_PointCoord,vec2(0.5)) * 2.0;\n            gl_FragColor = vec4(uColor, alpha);\n        }\n      ",transparent:!0,blending:l,depthTest:!1}),f=new i(u,v);f.onBeforeRender=()=>{v.uniforms.uTime.value<1?v.uniforms.uTime.value+=.05:v.uniforms.uScale.value<0?(n.remove(f),f.clear()):v.uniforms.uScale.value-=.02},n.add(f)}}const y=new class extends n{constructor(){super()}load(){var n;this.init("#webgl"),this.animate(),this.create(),null==(n=this.scene)||n.remove(this.axesHelper),new g(this.scene,this.gui)}create(){}animate(){var n,e;null==(n=this.stats)||n.begin(),requestAnimationFrame((()=>{this.animate()})),this.renderer.render(this.scene,this.camera),null==(e=this.stats)||e.end()}};return d((()=>{y.load()})),c((()=>{y.gui.close(),y.gui.destroy()})),(n,e)=>(w(),v(h,null,[e[0]||(e[0]=f("div",{id:"webgl"},null,-1)),e[1]||(e[1]=f("div",{class:"title-name"},"烟花2",-1))],64))}});export{g as default};

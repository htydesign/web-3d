import{B as n}from"./base-Cxb8VdL3.js";import{C as e,c as o,d as a,S as t,D as i,l as r,a as s,A as l,ad as u}from"./three-DHmVq3iW.js";import{d as m,z as d,A as c,g as v,j as f,F as g,o as w}from"./@vue-BDXyav1n.js";const h=m({__name:"FireWorksView2",setup(m){class h{constructor(n){const e=new o,s=450,l=new Float32Array(1350);e.setAttribute("position",new a(l,3));const m=new Float32Array(s);e.setAttribute("aIndex",new a(m,1));let d=0,c=50;for(let o=0;o<s;o++){m[o]=o,o%90==0&&d++,1===d?(l[3*o+1]=0,c=50):2===d?(l[3*o+1]=2,c=52):3===d?(l[3*o+1]=4,c=54):4===d?(l[3*o+1]=6,c=52):5===d&&(l[3*o+1]=8,c=50);const n=Math.sin(u.degToRad(o%90*.8*5))*c,e=Math.cos(u.degToRad(o%90*.8*5))*c;l[3*o+0]=n,l[3*o+2]=e}e.attributes.position.needsUpdate=!0,e.attributes.aIndex.needsUpdate=!0;const v=new t({uniforms:{uIndex:{value:1},uFlag:{value:0}},vertexShader:"\n       attribute float aIndex;\n\n       varying float index;\n\n        void main(){\n          index = mod(aIndex , 90.0);\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n          gl_PointSize = 3.0;\n          gl_PointSize *= 100.0/-(modelViewMatrix * vec4(position, 1.0)).z;\n        }\n      ",fragmentShader:"\n        varying float index;\n        uniform float uIndex;\n        uniform float uFlag;\n\n        vec4 mColor(in float i, in float n){\n\n          float max = i + 5.0;\n          float min = i - 5.0;\n\n          if(n >= min && n <= max){\n            vec3 color = vec3(1.0, 0.0, 0.0);\n            float alpha = 1.0 ;\n\n            if(i >= n){\n              alpha = 1.0-(i - n) / 5.0;\n            }else{\n              alpha = 1.0-(n - i) / 5.0;\n            }\n\n            return vec4(color, alpha);\n          }else{\n           return vec4(0.1, 0.1, 0.1, 1.0);\n          }\n        }\n\n        void main(){\n          if(uFlag == 1.0){\n            gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n          }else{\n            gl_FragColor = mColor(uIndex,index);\n          }\n\n        }\n      ",transparent:!0,side:i}),f=new r(e,v);f.position.set(0,70,0);let g=0;let w=0;f.onBeforeRender=()=>{v.uniforms.uIndex.value>90&&(v.uniforms.uIndex.value=0,g++),g>=2?(v.uniforms.uFlag.value=1,w%20==0&&new p(n)):v.uniforms.uIndex.value+=1,w+=1},n.add(f)}}class p{constructor(n){const i=new s(80*Math.random()-40,70,80*Math.random()-40),u=new s(100,0,0),m=new o,d=new e(Math.random(),Math.random(),Math.random()),c=new t({uniforms:{uTime:{value:0},uColor:{value:d},uScale:{value:0}},vertexShader:"\n        attribute vec3 toPosition;\n        uniform float uTime;\n        uniform float uScale;\n\n        void main(){\n            vec3 myPosition = position;\n            myPosition.y -= 1.0 * uTime;\n\n            vec4 mvPosition = modelViewMatrix * vec4(myPosition, 1.0);\n\n            gl_PointSize = 100.0 * 50.0 / -mvPosition.z;\n            gl_PointSize *= uScale;\n\n            gl_Position = projectionMatrix * mvPosition;\n\n        }\n      ",fragmentShader:"\n        uniform vec3 uColor;\n        void main(){\n            float alpha = 1.0 - distance(gl_PointCoord,vec2(0.5)) * 2.0;\n            gl_FragColor = vec4(uColor, alpha);\n        }\n      ",transparent:!0,blending:l,depthTest:!1}),v=new Float32Array(i);m.setAttribute("position",new a(v,3)),m.setAttribute("toPosition",new a(new Float32Array(u),3));const f=new r(m,c);let g=0;f.onBeforeRender=()=>{c.uniforms.uScale.value<=1&&(c.uniforms.uScale.value+=.1,0==g&&(g=1,new x(n,i,d))),c.uniforms.uTime.value<=70?c.uniforms.uTime.value+=.5:(f.clear(),n.remove(f))},n.add(f)}}class x{constructor(n,e,i){const s=new o,l=new Float32Array(60);s.setAttribute("position",new a(l,3));const u=new Float32Array(20);s.setAttribute("aDelay",new a(u,1));for(let o=0;o<20;o++)l[3*o+0]=e.x,l[3*o+1]=e.y,l[3*o+2]=e.z,u[o]=100*o;const m=new t({uniforms:{uTime:{value:0},uColor:{value:i}},vertexShader:"\n        attribute float aDelay;  \n\n        uniform float uTime;\n\n        void main() {\n          vec3 pos = position;\n\n          float delayTime = aDelay + uTime;\n\n         if(uTime * 1000.0 > aDelay){\n          pos.y -= (uTime * 1000.0 - aDelay) * 0.01;\n         }\n         \n\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n          gl_PointSize =7.0- 5.0 * aDelay/1000.0;\n        }\n      ",fragmentShader:"\n        uniform vec3 uColor;\n        void main() {\n          gl_FragColor = vec4(uColor, 1.0);\n        }\n      "}),d=new r(s,m);d.onBeforeRender=()=>{m.uniforms.uTime.value>7?(d.clear(),n.remove(d)):m.uniforms.uTime.value+=.05},n.add(d)}run(){}}const y=new class extends n{constructor(){super()}load(){this.init("#webgl"),this.animate(),this.scene.background=new e(3355443),this.create(),new h(this.scene)}create(){}animate(){var n,e;null==(n=this.stats)||n.begin(),requestAnimationFrame((()=>{this.animate()})),this.renderer.render(this.scene,this.camera),null==(e=this.stats)||e.end()}};return d((()=>{y.load()})),c((()=>{y.gui.close(),y.gui.destroy()})),(n,e)=>(w(),v(g,null,[e[0]||(e[0]=f("div",{id:"webgl"},null,-1)),e[1]||(e[1]=f("div",{class:"title-name"},"烟花2",-1))],64))}});export{h as default};

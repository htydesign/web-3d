var t=Object.defineProperty,n=(n,e,i)=>((n,e,i)=>e in n?t(n,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):n[e]=i)(n,"symbol"!=typeof e?e+"":e,i);import{B as e}from"./base-rPOBNrun.js";import{q as i,an as o,al as s,S as a,D as r,B as x,y as c,b as l,z as m,e as u}from"./three-BwxZCoz6.js";import{d as p,A as v,B as f,g as h,j as d,F as y,o as g}from"./@vue-Di8-S161.js";const b=128,z=p({__name:"FaceEffectView",setup(t){const p=new class extends e{constructor(){super(),n(this,"gpgpuCompute"),n(this,"dtPosition"),n(this,"positionVariable"),n(this,"material"),n(this,"facePos"),n(this,"faceNumber",0),n(this,"time",0)}load(){var t,n,e,o;this.init("#webgl"),null==(t=this.scene)||t.remove(this.axesHelper),null==(n=this.renderer)||n.setClearColor(16777215),null==(e=this.camera)||e.position.set(0,0,10),null==(o=this.controls)||o.update();(new i).load("./models/gltf/LeePerrySmith/LeePerrySmith.glb",(t=>{const n=t.scene.children[0];this.facePos=n.geometry.attributes.position.array,this.faceNumber=this.facePos.length/3,this.initGPGPU(),this.animate(),this.addObject(n)}))}initGPGPU(){this.gpgpuCompute=new o(b,b,this.renderer),this.dtPosition=this.gpgpuCompute.createTexture(),this.fillPosition(this.dtPosition.source.data.data);this.positionVariable=this.gpgpuCompute.addVariable("texturePosition","\n      // simulation\n      uniform float time;\n\t\t\tuniform float delta;\n      uniform sampler2D texturePosition;\n      varying vec2 vUv;\n      uniform float frequency;\n      uniform float amplitude;\n      uniform float maxDistance;\n\n      //\n      // Description : Array and textureless GLSL 2D simplex noise function.\n      //      Author : Ian McEwan, Ashima Arts.\n      //  Maintainer : ijm\n      //     Lastmod : 20110822 (ijm)\n      //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n      //               Distributed under the MIT License. See LICENSE file.\n      //               https://github.com/ashima/webgl-noise\n      //\n\n      vec3 mod289(vec3 x) {\n          return x - floor(x * (1.0 / 289.0)) * 289.0;\n      }\n\n      vec2 mod289(vec2 x) {\n          return x - floor(x * (1.0 / 289.0)) * 289.0;\n      }\n\n      vec3 permute(vec3 x) {\n          return mod289(((x*34.0)+1.0)*x);\n      }\n\n      float noise(vec2 v)\n      {\n          const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                            0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                          -0.577350269189626,  // -1.0 + 2.0 * C.x\n                            0.024390243902439); // 1.0 / 41.0\n          // First corner\n          vec2 i  = floor(v + dot(v, C.yy) );\n          vec2 x0 = v -   i + dot(i, C.xx);\n\n          // Other corners\n          vec2 i1;\n          //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n          //i1.y = 1.0 - i1.x;\n          i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n          // x0 = x0 - 0.0 + 0.0 * C.xx ;\n          // x1 = x0 - i1 + 1.0 * C.xx ;\n          // x2 = x0 - 1.0 + 2.0 * C.xx ;\n          vec4 x12 = x0.xyxy + C.xxzz;\n          x12.xy -= i1;\n\n          // Permutations\n          i = mod289(i); // Avoid truncation effects in permutation\n          vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n              + i.x + vec3(0.0, i1.x, 1.0 ));\n\n          vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n          m = m*m ;\n          m = m*m ;\n\n          // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n          // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n          vec3 x = 2.0 * fract(p * C.www) - 1.0;\n          vec3 h = abs(x) - 0.5;\n          vec3 ox = floor(x + 0.5);\n          vec3 a0 = x - ox;\n\n          // Normalise gradients implicitly by scaling m\n          // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n          m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n          // Compute final noise value at P\n          vec3 g;\n          g.x  = a0.x  * x0.x  + h.x  * x0.y;\n          g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n          return 130.0 * dot(m, g);\n      }\n\n      vec3 curl(float\tx,\tfloat\ty,\tfloat\tz)\n      {\n\n          float\teps\t= 1., eps2 = 2. * eps;\n          float\tn1,\tn2,\ta,\tb;\n\n          x += time * .05;\n          y += time * .05;\n          z += time * .05;\n\n          vec3\tcurl = vec3(0.);\n\n          n1\t=\tnoise(vec2( x,\ty\t+\teps ));\n          n2\t=\tnoise(vec2( x,\ty\t-\teps ));\n          a\t=\t(n1\t-\tn2)/eps2;\n\n          n1\t=\tnoise(vec2( x,\tz\t+\teps));\n          n2\t=\tnoise(vec2( x,\tz\t-\teps));\n          b\t=\t(n1\t-\tn2)/eps2;\n\n          curl.x\t=\ta\t-\tb;\n\n          n1\t=\tnoise(vec2( y,\tz\t+\teps));\n          n2\t=\tnoise(vec2( y,\tz\t-\teps));\n          a\t=\t(n1\t-\tn2)/eps2;\n\n          n1\t=\tnoise(vec2( x\t+\teps,\tz));\n          n2\t=\tnoise(vec2( x\t+\teps,\tz));\n          b\t=\t(n1\t-\tn2)/eps2;\n\n          curl.y\t=\ta\t-\tb;\n\n          n1\t=\tnoise(vec2( x\t+\teps,\ty));\n          n2\t=\tnoise(vec2( x\t-\teps,\ty));\n          a\t=\t(n1\t-\tn2)/eps2;\n\n          n1\t=\tnoise(vec2(  y\t+\teps,\tz));\n          n2\t=\tnoise(vec2(  y\t-\teps,\tz));\n          b\t=\t(n1\t-\tn2)/eps2;\n\n          curl.z\t=\ta\t-\tb;\n\n          return\tcurl;\n      }\n\n\n\n\t\t\tvoid main()\t{\n\n\t\t\t\tvec2 uv = gl_FragCoord.xy / resolution.xy;\n\t\t\t\tvec4 tmpPos = texture2D( texturePosition, uv );\n\t\t\t\tvec3 pos = tmpPos.xyz;\n\n        float f = 0.15;\n        float amplitude = 0.005;\n\t\t\t\tvec3 target = pos + amplitude * curl(f * pos.x, f * pos.y, f * pos.z);\n\n\t\t\t\tgl_FragColor = vec4( target, 1.0 );\n\n\t\t\t}",this.dtPosition),this.positionVariable.material.uniforms.time={value:1},this.positionVariable.wrapS=s,this.positionVariable.wrapT=s;this.gpgpuCompute.init()}fillPosition(t){for(let n=0;n<t.length;n+=4){const e=Math.floor(Math.random()*this.faceNumber);if(this.facePos){const i=this.facePos[3*e+0],o=this.facePos[3*e+1],s=this.facePos[3*e+2];t[n+0]=i,t[n+1]=o,t[n+2]=s,t[n+3]=1}}}addObject(t){var n;this.material=new a({vertexShader:"\n      \n      attribute vec2 reference;\n      uniform sampler2D positionTexture;\n      uniform float time;\n\t\t\tuniform float delta;\n      uniform sampler2D texturePosition;\n      varying vec2 vUv;\n      uniform float frequency;\n      uniform float amplitude;\n      uniform float maxDistance;\n\n      //\n      // Description : Array and textureless GLSL 2D simplex noise function.\n      //      Author : Ian McEwan, Ashima Arts.\n      //  Maintainer : ijm\n      //     Lastmod : 20110822 (ijm)\n      //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n      //               Distributed under the MIT License. See LICENSE file.\n      //               https://github.com/ashima/webgl-noise\n      //\n\n      vec3 mod289(vec3 x) {\n          return x - floor(x * (1.0 / 289.0)) * 289.0;\n      }\n\n      vec2 mod289(vec2 x) {\n          return x - floor(x * (1.0 / 289.0)) * 289.0;\n      }\n\n      vec3 permute(vec3 x) {\n          return mod289(((x*34.0)+1.0)*x);\n      }\n\n      float noise(vec2 v)\n      {\n          const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                            0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                          -0.577350269189626,  // -1.0 + 2.0 * C.x\n                            0.024390243902439); // 1.0 / 41.0\n          // First corner\n          vec2 i  = floor(v + dot(v, C.yy) );\n          vec2 x0 = v -   i + dot(i, C.xx);\n\n          // Other corners\n          vec2 i1;\n          //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n          //i1.y = 1.0 - i1.x;\n          i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n          // x0 = x0 - 0.0 + 0.0 * C.xx ;\n          // x1 = x0 - i1 + 1.0 * C.xx ;\n          // x2 = x0 - 1.0 + 2.0 * C.xx ;\n          vec4 x12 = x0.xyxy + C.xxzz;\n          x12.xy -= i1;\n\n          // Permutations\n          i = mod289(i); // Avoid truncation effects in permutation\n          vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n              + i.x + vec3(0.0, i1.x, 1.0 ));\n\n          vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n          m = m*m ;\n          m = m*m ;\n\n          // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n          // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n          vec3 x = 2.0 * fract(p * C.www) - 1.0;\n          vec3 h = abs(x) - 0.5;\n          vec3 ox = floor(x + 0.5);\n          vec3 a0 = x - ox;\n\n          // Normalise gradients implicitly by scaling m\n          // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n          m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n          // Compute final noise value at P\n          vec3 g;\n          g.x  = a0.x  * x0.x  + h.x  * x0.y;\n          g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n          return 130.0 * dot(m, g);\n      }\n\n      vec3 curl(float\tx,\tfloat\ty,\tfloat\tz)\n      {\n\n          float\teps\t= 1., eps2 = 2. * eps;\n          float\tn1,\tn2,\ta,\tb;\n\n          x += time * .05;\n          y += time * .05;\n          z += time * .05;\n\n          vec3\tcurl = vec3(0.);\n\n          n1\t=\tnoise(vec2( x,\ty\t+\teps ));\n          n2\t=\tnoise(vec2( x,\ty\t-\teps ));\n          a\t=\t(n1\t-\tn2)/eps2;\n\n          n1\t=\tnoise(vec2( x,\tz\t+\teps));\n          n2\t=\tnoise(vec2( x,\tz\t-\teps));\n          b\t=\t(n1\t-\tn2)/eps2;\n\n          curl.x\t=\ta\t-\tb;\n\n          n1\t=\tnoise(vec2( y,\tz\t+\teps));\n          n2\t=\tnoise(vec2( y,\tz\t-\teps));\n          a\t=\t(n1\t-\tn2)/eps2;\n\n          n1\t=\tnoise(vec2( x\t+\teps,\tz));\n          n2\t=\tnoise(vec2( x\t+\teps,\tz));\n          b\t=\t(n1\t-\tn2)/eps2;\n\n          curl.y\t=\ta\t-\tb;\n\n          n1\t=\tnoise(vec2( x\t+\teps,\ty));\n          n2\t=\tnoise(vec2( x\t-\teps,\ty));\n          a\t=\t(n1\t-\tn2)/eps2;\n\n          n1\t=\tnoise(vec2(  y\t+\teps,\tz));\n          n2\t=\tnoise(vec2(  y\t-\teps,\tz));\n          b\t=\t(n1\t-\tn2)/eps2;\n\n          curl.z\t=\ta\t-\tb;\n\n          return\tcurl;\n      }\n      void main() {\n        vUv = reference;\n\n        vec3 pos = texture(positionTexture, reference).rgb;\n\n        vec3 newPos = position;\n        float f = 0.2;\n        float amplitude = 1.5;\n        float maxDistance = 2.0;\n\n        vec3 target = position + amplitude * curl(f * newPos.x, f * newPos.y, f * newPos.z) ;\n\n        float d = length(position - target) / maxDistance;\n        newPos = mix(position, target, pow(d, 5.0));\n\n        vec4 mvPosition = modelViewMatrix * vec4(pos , 1.0);\n\n        gl_PointSize = 20.0 * (1.0 / -mvPosition.z);\n        gl_Position = projectionMatrix * mvPosition;\n      }\n    ",fragmentShader:"\n      varying vec2 vUv;\n      uniform float time;\n      void main() {\n        vec2 uv = vUv;\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n      }",side:r,transparent:!0,uniforms:{time:{value:0},positionTexture:{value:null}}});const e=new x,i=new Float32Array(49152),o=new Float32Array(32768);for(let a=0;a<16384;a++){const t=50*Math.random()-25,n=50*Math.random()-25,e=50*Math.random()-25;i.set([t,n,e],3*a);const s=a%b/b,r=~~(a/b)/b;o.set([s,r],2*a)}e.setAttribute("position",new c(i,3)),e.setAttribute("reference",new c(o,2)),new l(5,256,256);const s=new m(e,this.material);null==(n=this.scene)||n.add(s)}animate(){var t,n,e,i;null==(t=this.stats)||t.begin(),requestAnimationFrame((()=>{this.animate()})),u.update(),this.time+=.1,null==(n=this.gpgpuCompute)||n.compute(),this.material&&(this.material.uniforms.positionTexture.value=null==(e=this.gpgpuCompute)?void 0:e.getCurrentRenderTarget(this.positionVariable).texture,this.material.uniforms.time.value=this.time,this.positionVariable.material.uniforms.time.value=this.time),this.renderer.render(this.scene,this.camera),null==(i=this.stats)||i.end()}};return v((()=>{p.load()})),f((()=>{p.gui.close(),p.gui.destroy()})),(t,n)=>(g(),h(y,null,[n[0]||(n[0]=d("div",{id:"webgl"},null,-1)),n[1]||(n[1]=d("div",{class:"title-name"},"face effect",-1))],64))}});export{z as default};

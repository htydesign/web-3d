import{B as n}from"./base-DbQo_w83.js";import{c as e,d as t,S as o,C as i,a,k as r,l as s,V as l,T as c,e as d,P as v,m as h,b as m}from"./three-C8kJxG0b.js";import{d as p,z as u,A as f,g,j as w,F as A,o as S}from"./@vue-BDXyav1n.js";const x=p({__name:"LightFiveView",setup(p){const x=new class extends n{constructor(){super()}load(){this.init("#webgl"),this.animate(),this.create()}create(){var n,p,u,f;const g=1e5,w=new e,A=new Float32Array(3e5);w.setAttribute("position",new t(A,3));const S=new Float32Array(g);w.setAttribute("speed",new t(S,1));const x=new Float32Array(g);w.setAttribute("aProgress",new t(x,1));for(let e=0;e<g;e++)A[3*e]=1e3*Math.random()-500,A[3*e+1]=500*Math.random()-500,A[3*e+2]=1e3*Math.random()-500,x[e]=A[3*e+1],S[e]=1+Math.random();w.attributes.position.needsUpdate=!0,w.attributes.speed.needsUpdate=!0,w.attributes.aProgress.needsUpdate=!0;const C=new o({uniforms:{uTime:{value:0},ambientLightColor:{value:new i(3355443)},directionalLightColor:{value:new i(0)},directionalLightDirection:{value:new a}},vertexShader:"\n        attribute float speed;\n        attribute float aProgress;\n        uniform float uTime;\n\n        uniform vec3 ambientLightColor;\n        uniform vec3 directionalLightColor;\n        uniform vec3 directionalLightDirection;\n\n        float uSpeed = 1.;\n\n        varying float vYCoord;\n        varying vec3 vColor;\n\n        void main() {\n          vec3 normal = normalize(normalMatrix * normal);\n          vec3 lightDir = normalize(directionalLightDirection);\n          float dotProduct = max(dot(normal, lightDir), 0.0);\n          vColor = ambientLightColor + dotProduct * directionalLightColor;\n          \n          vec3 p = position;\n          float s = -uTime * speed * 100.0;\n          p.y = mod(aProgress + s , 500.0);\n          \n          vYCoord = p.y;\n\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0);\n          gl_PointSize = 3.0;\n        }\n      ",fragmentShader:"\n        \n        varying float vYCoord;\n        varying vec3 vColor;\n\n        void main() {\n          float strength = distance(gl_PointCoord,vec2(0.5,0.5));\n          float dis = length(gl_PointCoord - 0.5);\n          dis = smoothstep(0.5,0.0,dis);\n          strength = step(0.5,strength);\n          strength = 1.0 - strength;\n\n\n          //渐变色\n          // vec3 finalColor = vec3(1.0,1.0,1.0) ;      \n          // if(vYCoord>100.0){\n          //  finalColor = vec3(1.0,1.0,0.0) ;\n          // }\n\n          float alpha = smoothstep(100.0, 200.0, vYCoord);\n\n          if(strength == 0.0){\n            discard;\n          }\n          if(dis == 0.0){\n            discard;\n          }\n\n          gl_FragColor = vec4(vColor, alpha);\n        }"});C.onBeforeRender=()=>{C.uniforms.uTime.value+=.01};const y=new r(16777215,1e3);y.position.set(0,50,1),y.castShadow=!0,y.shadow.mapSize.width=1024,y.shadow.mapSize.height=1024,y.shadow.camera.near=.5,y.shadow.camera.far=500,this.scene.add(y),C.uniforms.directionalLightDirection.value=y.position.clone().normalize();const M=new s(w,C);null==(n=this.scene)||n.add(M);const{width:b,height:_}=(null==(p=this.renderer)?void 0:p.getSize(new l))||{};new a(b,_,null==(u=this.renderer)?void 0:u.getPixelRatio());const D=(new c).load("./texture/xingkong.jpg");D.wrapS=d,D.wrapT=d;const U=new v(1e3,1e3),L=new o({uniforms:{iMouse:{value:new h(0,0,0,1)},iResolution:{value:new a(1e3,1e3,0)},iTime:{value:0},map:{value:D}},vertexShader:"\n        varying vec2 vUv;\n        void main() {\n          vUv = uv;\n          vec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n        }\n      ",fragmentShader:"\n        uniform vec4 iMouse;\n        uniform vec3 iResolution;\n        uniform float iTime;\n        uniform sampler2D map;\n        varying vec2 vUv;\n\n\n        // Maximum number of cells a ripple can cross.\n        #define MAX_RADIUS 2\n\n        // Set to 1 to hash twice. Slower, but less patterns.\n        #define DOUBLE_HASH 0\n\n        // Hash functions shamefully stolen from:\n        // https://www.shadertoy.com/view/4djSRW\n        #define HASHSCALE1 .1031\n        #define HASHSCALE3 vec3(.1031, .1030, .0973)\n\n        float hash12(vec2 p)\n        {\n          vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n          p3 += dot(p3, p3.yzx + 19.19);\n          return fract((p3.x + p3.y) * p3.z);\n        }\n\n        vec2 hash22(vec2 p)\n        {\n          vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n          p3 += dot(p3, p3.yzx+19.19);\n          return fract((p3.xx+p3.yz)*p3.zy);\n\n        }\n\n        void main()\n        {\n          float resolution = 10. * exp2(-3.*iMouse.x/iResolution.x);\n          // vec2 uv = gl_FragCoord.xy / iResolution.xy *20.0;\n          vec2 uv = vUv * 100.0;\n          vec2 p0 = floor(uv);\n\n            vec2 circles = vec2(0.);\n            for (int j = -MAX_RADIUS; j <= MAX_RADIUS; ++j)\n            {\n                for (int i = -MAX_RADIUS; i <= MAX_RADIUS; ++i)\n                {\n              vec2 pi = p0 + vec2(i, j);\n                    #if DOUBLE_HASH\n                    vec2 hsh = hash22(pi);\n                    #else\n                    vec2 hsh = pi;\n                    #endif\n                    vec2 p = pi + hash22(hsh);\n\n                    float t = fract(0.3*iTime + hash12(hsh));\n                    vec2 v = p - uv;\n                    float d = length(v) - (float(MAX_RADIUS) + 1.)*t;\n\n                    float h = 1e-3;\n                    float d1 = d - h;\n                    float d2 = d + h;\n                    float p1 = sin(31.*d1) * smoothstep(-0.6, -0.3, d1) * smoothstep(0., -0.3, d1);\n                    float p2 = sin(31.*d2) * smoothstep(-0.6, -0.3, d2) * smoothstep(0., -0.3, d2);\n                    circles += 0.5 * normalize(v) * ((p2 - p1) / (2. * h) * (1. - t) * (1. - t));\n                }\n            }\n            circles /= float((MAX_RADIUS*2+1)*(MAX_RADIUS*2+1));\n\n            float intensity = mix(0.01, 0.15, smoothstep(0.1, 0.6, abs(fract(0.05*iTime + 0.5)*2.-1.)));\n            vec3 n = vec3(circles, sqrt(1. - dot(circles, circles)));\n            vec3 color = texture(map, uv/resolution - intensity*n.xy).rgb + 5.*pow(clamp(dot(n, normalize(vec3(1., 0.7, 0.5))), 0., 1.), 6.);\n            // vec3 c = texture2D(map,vUv).rgb;\n            gl_FragColor = vec4( color, 1.0);\n        }\n      "});L.onBeforeRender=()=>{L.uniforms.iTime.value+=.01};const P=new m(U,L);P.rotateX(-Math.PI/2),null==(f=this.scene)||f.add(P)}animate(){var n,e;null==(n=this.stats)||n.begin(),requestAnimationFrame((()=>{this.animate()})),this.renderer.render(this.scene,this.camera),null==(e=this.stats)||e.end()}};return u((()=>{x.load()})),f((()=>{x.gui.close(),x.gui.destroy()})),(n,e)=>(S(),g(A,null,[e[0]||(e[0]=w("div",{id:"webgl"},null,-1)),e[1]||(e[1]=w("div",{class:"title-name"},"灯光2",-1))],64))}});export{x as default};

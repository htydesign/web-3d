var n=Object.defineProperty,e=(e,t,o)=>((e,t,o)=>t in e?n(e,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[t]=o)(e,"symbol"!=typeof t?t+"":t,o);import{B as t}from"./base-T3lLSoS5.js";import{V as o,b6 as i,Z as r,$ as s,a8 as a,a9 as c,a1 as l,a0 as v,b7 as m,T as x,h as u,a5 as d}from"./three-BLJ24qmy.js";import{g as h}from"./modelLoader-Dk6PwQSq.js";import{d as f,z as p,A as g,g as y,j as b,F as w,o as z}from"./@vue-DISYwsDo.js";const C=f({__name:"AlienView",setup(n){const f={uniforms:{tDiffuse:{value:null},uSize:{value:new o(window.innerWidth,window.innerHeight)},center:{value:new o(.5,.5)},angle:{value:1.57},scale:{value:1},uTime:{value:0},uProgress:{value:0}},fragmentShader:"\n\t\tuniform vec2 center;\n\t\tuniform float angle;\n\t\tuniform float scale;\n\t\tuniform vec2 uSize;\n        uniform float uTime;\n        uniform float uProgress;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n         vec3 mod289(vec3 x) {\n          return x - floor(x * (1.0 / 289.0)) * 289.0;\n        }\n\n        vec4 mod289(vec4 x) {\n          return x - floor(x * (1.0 / 289.0)) * 289.0;\n        }\n\n        vec4 permute(vec4 x) {\n            return mod289(((x*34.0)+10.0)*x);\n        }\n\n        vec4 taylorInvSqrt(vec4 r)\n        {\n          return 1.79284291400159 - 0.85373472095314 * r;\n        }\n\n        float snoise(vec3 v)\n          {\n          const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n          const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n        // First corner\n          vec3 i  = floor(v + dot(v, C.yyy) );\n          vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n        // Other corners\n          vec3 g = step(x0.yzx, x0.xyz);\n          vec3 l = 1.0 - g;\n          vec3 i1 = min( g.xyz, l.zxy );\n          vec3 i2 = max( g.xyz, l.zxy );\n\n          //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n          //   x1 = x0 - i1  + 1.0 * C.xxx;\n          //   x2 = x0 - i2  + 2.0 * C.xxx;\n          //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n          vec3 x1 = x0 - i1 + C.xxx;\n          vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n          vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n        // Permutations\n          i = mod289(i);\n          vec4 p = permute( permute( permute(\n                    i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                  + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n                  + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n        // Gradients: 7x7 points over a square, mapped onto an octahedron.\n        // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n          float n_ = 0.142857142857; // 1.0/7.0\n          vec3  ns = n_ * D.wyz - D.xzx;\n\n          vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n          vec4 x_ = floor(j * ns.z);\n          vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n          vec4 x = x_ *ns.x + ns.yyyy;\n          vec4 y = y_ *ns.x + ns.yyyy;\n          vec4 h = 1.0 - abs(x) - abs(y);\n\n          vec4 b0 = vec4( x.xy, y.xy );\n          vec4 b1 = vec4( x.zw, y.zw );\n\n          //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n          //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n          vec4 s0 = floor(b0)*2.0 + 1.0;\n          vec4 s1 = floor(b1)*2.0 + 1.0;\n          vec4 sh = -step(h, vec4(0.0));\n\n          vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n          vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n          vec3 p0 = vec3(a0.xy,h.x);\n          vec3 p1 = vec3(a0.zw,h.y);\n          vec3 p2 = vec3(a1.xy,h.z);\n          vec3 p3 = vec3(a1.zw,h.w);\n\n        //Normalise gradients\n          vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n          p0 *= norm.x;\n          p1 *= norm.y;\n          p2 *= norm.z;\n          p3 *= norm.w;\n\n        // Mix final noise value\n          vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n          m = m * m;\n          return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n        }\n\n\n\n\t\tvoid main() {\n\n            vec2 uv = vUv;\n\n\t\t\tvec4 color = texture2D( tDiffuse, vUv );\n\n            float lineOffset = snoise(vec3(0.0, 10.0 ,uTime));\n\n            float holoIntensity = 0.4 + 0.2 * snoise(vec3(0.0, 200.0 ,uTime));\n\n            float direction = mod(vUv.y * 1000.0 + uTime * 0.5, 4.0) < 2.0 ? 1.0 : -1.0;\n\n            uv.x += direction * (8.0, + 4.0 * lineOffset) / uSize.x;\n\n            vec3 hologram = texture2D(tDiffuse, uv).rgb;\n            \n            vec3 background = vec3(0.0, 0.65, 1.0) * 0.3;\n\n            vec3 combinedColor = color.rgb + hologram * holoIntensity;\n\n            vec3 luminance = vec3(0.299, 0.587, 0.114);\n            float lumFront = dot(luminance, combinedColor);\n            float lumBack = dot(luminance, background);\n\n            float d = lumFront - lumBack;\n            vec3 finalColor = background + d;\n\n            vec3 mixColor = mix(color.rgb, finalColor, uProgress);\n\n\n            gl_FragColor = vec4(vec3(mixColor), 1.0);\n\n\t\t}",vertexShader:"\n        varying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}\n      "};const C=new class extends t{constructor(){super(),e(this,"pmremGenerator"),e(this,"envMap"),e(this,"uniforms",{uTime:{value:0}}),e(this,"composer"),e(this,"modelObj"),e(this,"effectPass"),e(this,"time",0)}load(){var n,e;this.init("#webgl"),null==(n=this.renderer)||n.setClearColor(0),null==(e=this.scene)||e.remove(this.axesHelper),this.renderer.toneMapping=i,this.renderer.toneMappingExposure=.8,this.addObject(),this.initPost(),this.animate(),this.setting()}setting(){this.gui.add({exposure:0},"exposure",0,2,.01).onChange((n=>{this.renderer.toneMappingExposure=n}))}initPost(){const n=new r(this.scene,this.camera),e={threshold:.189,strength:.972,radius:.67,exposure:1.24,progress:0},t=new s(new o(window.innerWidth,window.innerHeight),1.5,.5,.08);t.threshold=e.threshold,t.strength=e.strength,t.radius=e.radius;const i=new a(c);this.effectPass=new a(f),this.composer=new l(this.renderer),new v,this.composer.addPass(n),this.composer.addPass(t),this.composer.addPass(i),this.composer.addPass(this.effectPass);const m=this.gui.addFolder("bloom");m.add(e,"threshold",0,1).onChange((function(n){t.threshold=Number(n)})),m.add(e,"strength",0,3).onChange((function(n){t.strength=Number(n)})),m.add(e,"progress",0,1,.01).onChange((n=>{this.effectPass&&(this.effectPass.uniforms.uProgress.value=n)})),this.gui.add(e,"radius",0,2).step(.01).onChange((function(n){t.radius=Number(n)}))}addObject(){this.pmremGenerator=new m(this.renderer),this.pmremGenerator.compileEquirectangularShader(),(new x).load("./texture/environment-map.jpg",(n=>{var e,t;this.envMap=null==(e=this.pmremGenerator)?void 0:e.fromEquirectangular(n).texture,null==(t=this.pmremGenerator)||t.dispose(),h("./models/gltf/LeePerrySmith/LeePerrySmith.glb").then((n=>{var e;this.modelObj=n.scene.children[0],this.modelObj.scale.set(15,15,15),null==(e=this.scene)||e.add(this.modelObj);const t=new u({envMap:this.envMap,metalness:1,roughness:.28});t.onBeforeCompile=n=>{Object.assign(n.uniforms,this.uniforms),n.fragmentShader="\n            uniform float uTime;\n\n            mat4 rotation3d(vec3 axis, float angle) {\n                axis = normalize(axis);\n                float s = sin(angle);\n                float c = cos(angle);\n                float oc = 1.0 - c;\n\n                return mat4(\n                oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0\n                );\n            }\n            vec3 rotate(vec3 v, vec3 axis, float angle) {\n                return (rotation3d(axis, angle) * vec4(v, 1.0)).xyz;\n            }\n          "+n.fragmentShader,n.fragmentShader=n.fragmentShader.replace("#include <envmap_physical_pars_fragment>","\n            #ifdef USE_ENVMAP\n\n                vec3 getIBLIrradiance( const in vec3 normal ) {\n\n                    #ifdef ENVMAP_TYPE_CUBE_UV\n\n                        vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n                        vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\n                        return PI * envMapColor.rgb * envMapIntensity;\n\n                    #else\n\n                        return vec3( 0.0 );\n\n                    #endif\n\n                }\n\n                vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\n                    #ifdef ENVMAP_TYPE_CUBE_UV\n\n                        vec3 reflectVec = reflect( - viewDir, normal );\n\n                        // Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n                        reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\n                        reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\n                        // 自定义\n                        reflectVec = rotate(reflectVec, vec3(1.0, 0.0, 0.0), uTime *1.0);\n\n                        vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\n                        return envMapColor.rgb * envMapIntensity;\n\n                    #else\n\n                        return vec3( 0.0 );\n\n                    #endif\n\n                }\n\n                #ifdef USE_ANISOTROPY\n\n                    vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\n                        #ifdef ENVMAP_TYPE_CUBE_UV\n\n                        // https://google.github.io/filament/Filament.md.html#lighting/imagebasedlights/anisotropy\n                            vec3 bentNormal = cross( bitangent, viewDir );\n                            bentNormal = normalize( cross( bentNormal, bitangent ) );\n                            bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\n                            return getIBLRadiance( viewDir, bentNormal, roughness );\n\n                        #else\n\n                            return vec3( 0.0 );\n\n                        #endif\n\n                    }\n\n                #endif\n\n            #endif\n            ")},this.modelObj.material=t}))}))}animate(){var n,e,t;null==(n=this.stats)||n.begin(),this.timer=requestAnimationFrame((()=>{this.animate()})),d.update(),this.time+=.01,this.uniforms.uTime.value=this.time,this.effectPass.uniforms.uTime.value=this.time,null==(e=this.composer)||e.render(),this.modelObj&&(this.modelObj.rotation.y+=.001),null==(t=this.stats)||t.end()}};return p((()=>{C.load()})),g((()=>{C.destroy()})),(n,e)=>(z(),y(w,null,[e[0]||(e[0]=b("div",{id:"webgl"},null,-1)),e[1]||(e[1]=b("div",{class:"title-name"},"Alien",-1))],64))}});export{C as default};

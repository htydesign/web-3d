var e=Object.defineProperty,n=(n,t,o)=>((n,t,o)=>t in n?e(n,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):n[t]=o)(n,"symbol"!=typeof t?t+"":t,o);import{B as t}from"./base-DD5aOT-d.js";import{C as o,c as i,d as r,T as a,e as s,W as l,S as c,A as d,a as v,k as h,l as u,V as m,P as p,m as f,b as g}from"./three-DHmVq3iW.js";import{d as w,z as x,A as S,g as A,j as C,F as y,o as b}from"./@vue-BDXyav1n.js";const M=w({__name:"LightFiveView",setup(e){const w=new class extends t{constructor(){super(),n(this,"renderTarget")}load(){this.init("#webgl"),this.animate(),this.create(),this.createFlow(),this.scene.background=new o(3355443)}create(){var e;const n=1e5,t=new i,m=new Float32Array(3e5);t.setAttribute("position",new r(m,3));const p=new Float32Array(n);t.setAttribute("speed",new r(p,1));const f=new Float32Array(n);t.setAttribute("aProgress",new r(f,1));for(let o=0;o<n;o++)m[3*o]=1e3*Math.random()-500,m[3*o+1]=500*Math.random()-500,m[3*o+2]=1e3*Math.random()-500,f[o]=m[3*o+1],p[o]=1+Math.random();t.attributes.position.needsUpdate=!0,t.attributes.speed.needsUpdate=!0,t.attributes.aProgress.needsUpdate=!0;const g=(new a).load("./texture/xingkong.jpg");g.wrapS=s,g.wrapT=s,this.renderTarget=new l(this.innerWidth,this.innerHeight);const w=new c({transparent:!0,blending:d,uniforms:{uTexture:{value:g},uTime:{value:0},uSpeed:{value:10},ambientLightColor:{value:new o(3355443)},directionalLightColor:{value:new o(0)},directionalLightDirection:{value:new v}},vertexShader:"\n        attribute float speed;\n        attribute float aProgress;\n        uniform float uTime;\n\n        uniform vec3 ambientLightColor;\n        uniform vec3 directionalLightColor;\n        uniform vec3 directionalLightDirection;\n\n        uniform float uSpeed;\n\n        varying float vYCoord;\n        varying vec3 vColor;\n        varying vec2 vUv;\n\n        void main() {\n          vUv = uv;\n          vec3 normal = normalize(normalMatrix * normal);\n          vec3 lightDir = normalize(directionalLightDirection);\n          float dotProduct = max(dot(normal, lightDir), 0.0);\n          vColor = ambientLightColor + dotProduct * directionalLightColor;\n          \n          vec3 p = position;\n          float s = -uTime * speed * uSpeed;\n          p.y = mod(aProgress + s , 500.0);\n          \n          vYCoord = p.y;\n\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0);\n          \n          gl_PointSize = 10.0;\n          gl_PointSize *= 100.0/-(modelViewMatrix * vec4(position, 1.0)).z;\n        }\n      ",fragmentShader:"\n        \n        varying float vYCoord;\n        varying vec3 vColor;\n        varying vec2 vUv;\n\n        uniform sampler2D uTexture;\n\n        void main() {\n          float strength = distance(gl_PointCoord,vec2(0.5,0.5));\n          float dis = length(gl_PointCoord - 0.5);\n          dis = smoothstep(0.5,0.0,dis);\n          strength = step(0.5,strength);\n          strength = 1.0 - strength;\n\n\n          //渐变色\n          vec3 finalColor = vColor;      \n          if(vYCoord > 100.0){\n           finalColor = vec3(1.0,1.0,0.0);\n          }else{\n           finalColor = vec3(1.0,1.0,1.0);\n          }\n\n          float alpha = smoothstep(200.0, 100.0, vYCoord);\n          \n          if(strength == 0.0){\n            discard;\n          }\n          if(dis == 0.0){\n            discard;\n          }\n\n\n          gl_FragColor = vec4( finalColor,1.0);\n\n        }"}),x=new h(16777215,1e3);x.position.set(0,50,1),x.castShadow=!0,x.shadow.mapSize.width=1024,x.shadow.mapSize.height=1024,x.shadow.camera.near=.5,x.shadow.camera.far=500,this.scene.add(x),w.uniforms.directionalLightDirection.value=x.position.clone().normalize();const S=new u(t,w);S.onBeforeRender=()=>{w.uniforms.uTime.value+=.01},null==(e=this.scene)||e.add(S)}createText(){}createFlow(){var e,n,t;const{width:o,height:i}=(null==(e=this.renderer)?void 0:e.getSize(new m))||{};new v(o,i,null==(n=this.renderer)?void 0:n.getPixelRatio());const r=(new a).load("./texture/xingkong.jpg");r.wrapS=s,r.wrapT=s;const l=new p(1e3,1e3),d=new c({uniforms:{iMouse:{value:new f(0,0,0,1)},iResolution:{value:new v(1e3,1e3,0)},iTime:{value:0},map:{value:r}},vertexShader:"\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      vec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\n      gl_Position = projectionMatrix * mvPosition;\n      \n    \n    }\n  ",fragmentShader:"\n    uniform vec4 iMouse;\n    uniform vec3 iResolution;\n    uniform float iTime;\n    uniform sampler2D map;\n    varying vec2 vUv;\n\n    float count = 500.0;\n\n\n    // Maximum number of cells a ripple can cross.\n    #define MAX_RADIUS 2\n\n    // Set to 1 to hash twice. Slower, but less patterns.\n    #define DOUBLE_HASH 0\n\n    // Hash functions shamefully stolen from:\n    // https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 .1031\n    #define HASHSCALE3 vec3(.1031, .1030, .0973)\n\n    float hash12(vec2 p)\n    {\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    vec2 hash22(vec2 p)\n    {\n      vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n      p3 += dot(p3, p3.yzx+19.19);\n      return fract((p3.xx+p3.yz)*p3.zy);\n\n    }\n\n    void main()\n    {\n      float resolution = 1. * exp2(-3.*iMouse.x/iResolution.x);\n      // vec2 uv = gl_FragCoord.xy / iResolution.xy *20.0;\n      vec2 uv = vUv * count;\n      vec2 p0 = floor(uv);\n\n        vec2 circles = vec2(0.);\n        for (int j = -MAX_RADIUS; j <= MAX_RADIUS; ++j)\n        {\n            for (int i = -MAX_RADIUS; i <= MAX_RADIUS; ++i)\n            {\n              vec2 pi = p0 + vec2(i, j);\n              #if DOUBLE_HASH\n              vec2 hsh = hash22(pi);\n              #else\n              vec2 hsh = pi;\n              #endif\n              vec2 p = pi + hash22(hsh);\n\n              float t = fract(0.3*iTime + hash12(hsh));\n              vec2 v = p - uv;\n              float d = length(v) - (float(MAX_RADIUS) + 1.)*t;\n\n              float h = 1e-3;\n              float d1 = d - h;\n              float d2 = d + h;\n              float p1 = sin(31.*d1) * smoothstep(-0.6, -0.3, d1) * smoothstep(0., -0.3, d1);\n              float p2 = sin(31.*d2) * smoothstep(-0.6, -0.3, d2) * smoothstep(0., -0.3, d2);\n              circles += 0.5 * normalize(v) * ((p2 - p1) / (2. * h) * (1. - t) * (1. - t));\n              }\n        }\n        circles /= float((MAX_RADIUS*2+1)*(MAX_RADIUS*2+1));\n\n        float intensity = mix(0.01, 0.15, smoothstep(0.1, 0.6, abs(fract(0.05*iTime + 0.5)*2.-1.)));\n        vec3 n = vec3(circles, sqrt(1. - dot(circles, circles)));\n        vec3 color = texture(map, uv/count).rgb + 15.*pow(clamp(dot(n, normalize(vec3(1., 0.7, 0.5))), 0., 1.), 6.);\n        // vec3 color = vec3(0.0,0.0,0.0) + 15.*pow(clamp(dot(n, normalize(vec3(1., 0.7, 0.5))), 0., 1.), 6.);\n        // vec3 c = texture2D(map,vUv).rgb;\n        gl_FragColor = vec4( color, 1.0);\n    }\n  "}),h=new g(l,d);h.rotateX(-Math.PI/2),null==(t=this.scene)||t.add(h),h.onBeforeRender=()=>{d.uniforms.iTime.value+=.01}}animate(){var e,n;null==(e=this.stats)||e.begin(),requestAnimationFrame((()=>{this.animate()})),this.renderer&&this.renderTarget&&(this.renderer.setRenderTarget(this.renderTarget),this.renderer.render(this.scene,this.camera),this.renderer.setRenderTarget(null),this.renderer.render(this.scene,this.camera)),null==(n=this.stats)||n.end()}};return x((()=>{w.load()})),S((()=>{w.gui.close(),w.gui.destroy()})),(e,n)=>(b(),A(y,null,[n[0]||(n[0]=C("div",{id:"webgl"},null,-1)),n[1]||(n[1]=C("div",{class:"title-name"},"灯光2",-1))],64))}});export{M as default};

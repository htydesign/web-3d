import{B as n}from"./base-CZc2SIvy.js";import{aw as e,aX as a,e as o,T as t,aY as i,S as s,b as r,n as c,M as l,B as v,r as x,aZ as m,a5 as d}from"./three-DbIXC9SN.js";import{d as p,z as u,A as y,g as w,j as f,F as h,o as g}from"./@vue-DISYwsDo.js";const z=p({__name:"NoiseView",setup(p){const z=new class extends n{constructor(){super()}load(){var n;this.init("#webgl"),null==(n=this.renderer)||n.setClearColor(1118481),this.animate(),this.create()}create(){var n,d;const p=new e(function(){const n=document.createElement("canvas");n.width=2,n.height=2;const e=n.getContext("2d");return e.fillStyle="white",e.fillRect(0,1,2,1),n}());p.magFilter=a,p.wrapT=o,p.wrapS=o,p.repeat.set(1,6);const u=this.light({type:"AmbientLight",color:16720384,x:0,y:0,z:0,distance:1e4});u.shadow.bias=-.005;const y={uTime:{value:0},uMap:{value:(new t).load("./texture/xingkong.jpg")}},w=new i(50,100),f=new s({transparent:!0,uniforms:y,vertexShader:"\n      vec3 mod289(vec3 x) {\n           return x - floor(x * (1.0 / 289.0)) * 289.0;\n         }\n\n         vec4 mod289(vec4 x) {\n           return x - floor(x * (1.0 / 289.0)) * 289.0;\n         }\n\n         vec4 permute(vec4 x) {\n             return mod289(((x*34.0)+10.0)*x);\n         }\n\n         vec4 taylorInvSqrt(vec4 r)\n         {\n           return 1.79284291400159 - 0.85373472095314 * r;\n         }\n\n         float snoise(vec3 v)\n           {\n           const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n           const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n         // First corner\n           vec3 i  = floor(v + dot(v, C.yyy) );\n           vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n         // Other corners\n           vec3 g = step(x0.yzx, x0.xyz);\n           vec3 l = 1.0 - g;\n           vec3 i1 = min( g.xyz, l.zxy );\n           vec3 i2 = max( g.xyz, l.zxy );\n\n           //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n           //   x1 = x0 - i1  + 1.0 * C.xxx;\n           //   x2 = x0 - i2  + 2.0 * C.xxx;\n           //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n           vec3 x1 = x0 - i1 + C.xxx;\n           vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n           vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n         // Permutations\n           i = mod289(i);\n           vec4 p = permute( permute( permute(\n                     i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                   + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n                   + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n         // Gradients: 7x7 points over a square, mapped onto an octahedron.\n         // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n           float n_ = 0.142857142857; // 1.0/7.0\n           vec3  ns = n_ * D.wyz - D.xzx;\n\n           vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n           vec4 x_ = floor(j * ns.z);\n           vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n           vec4 x = x_ *ns.x + ns.yyyy;\n           vec4 y = y_ *ns.x + ns.yyyy;\n           vec4 h = 1.0 - abs(x) - abs(y);\n\n           vec4 b0 = vec4( x.xy, y.xy );\n           vec4 b1 = vec4( x.zw, y.zw );\n\n           //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n           //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n           vec4 s0 = floor(b0)*2.0 + 1.0;\n           vec4 s1 = floor(b1)*2.0 + 1.0;\n           vec4 sh = -step(h, vec4(0.0));\n\n           vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n           vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n           vec3 p0 = vec3(a0.xy,h.x);\n           vec3 p1 = vec3(a0.zw,h.y);\n           vec3 p2 = vec3(a1.xy,h.z);\n           vec3 p3 = vec3(a1.zw,h.w);\n\n         //Normalise gradients\n           vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n           p0 *= norm.x;\n           p1 *= norm.y;\n           p2 *= norm.z;\n           p3 *= norm.w;\n\n         // Mix final noise value\n           vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n           m = m * m;\n           return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n         }\n\n         float PI = 3.14159265359;\n\n         float drawCircle(float radius,vec2 position, vec2 center){\n           return step(radius,distance(position, center));\n         }\n\n         float smoothMod(float axis, float amp, float rad){\n           float top = cos(PI * (axis / amp)) * sin(PI * (axis / amp));\n           float bottom = pow(sin(PI * (axis /amp)), 2.0) + pow(rad, 2.0);\n           float at = atan(top / bottom);\n           return amp * (1.0 / 2.0) - (1.0 / PI) * at;\n\n        }\n\n        float fit(float unscaled, float originalMin, float originalMax, float minAllowed, float maxAllowed){\n           return (maxAllowed - minAllowed) * (unscaled - originalMin) / (originalMax - originalMin) - 0.1;\n        }\n\n         float wave(vec3 position){\n           return fit(smoothMod(position.x * 5.0, 1.0, 1.5),0.3,0.7,0.0,1.0);\n         }\n\n         varying vec2 vUv;\n         varying float vDisPlacement;\n\n         uniform float uTime;\n\n         void main() {\n            vec3 newNormal = normal;\n            newNormal.y += uTime;\n            // newNormal.x += uTime;\n            vec3 noisePattern = vec3(snoise(newNormal));\n            float pattern = wave(noisePattern);\n\n            //varying\n            vUv = uv;\n            vDisPlacement = pattern;\n\n            //MVP\n            vec3 newPosition = position + normal * vDisPlacement * 20.0;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n        }\n      ",fragmentShader:"\n          varying vec2 vUv;\n          varying float vDisPlacement;\n\n          uniform sampler2D uMap;\n\n          void main(){\n           vec3 color = vec3(vDisPlacement * 2.0);\n           float alpha = 1.0;\n            if(vDisPlacement > 0.4){\n                // alpha = 0.0;\n                // discard;\n            }\n\n            gl_FragColor = vec4(color, alpha);\n        }\n      "}),h=new r(w,f);h.onBeforeRender=()=>{y.uTime.value>1&&(y.uTime.value=0),y.uTime.value+=.001},u.add(h),h.castShadow=!0,h.receiveShadow=!0,null==(n=this.scene)||n.add(u);const g=new r(new c(2,32,32),new l({color:16777215}));u.add(g);const z=new r(new v(200,200,200),new x({color:10530223,shininess:10,specular:1118481,side:m}));z.receiveShadow=!0,null==(d=this.scene)||d.add(z)}animate(){var n,e;null==(n=this.stats)||n.begin(),requestAnimationFrame((()=>{this.animate()})),d.update(),this.renderer.render(this.scene,this.camera),null==(e=this.stats)||e.end()}};return u((()=>{z.load()})),y((()=>{z.destroy()})),(n,e)=>(g(),w(h,null,[e[0]||(e[0]=f("div",{id:"webgl"},null,-1)),e[1]||(e[1]=f("div",{class:"title-name"},"噪音函数",-1))],64))}});export{z as default};

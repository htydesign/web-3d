import{B as e}from"./base-CTHtcInk.js";import{C as n,b as o,S as r,M as t,a_ as a,d as v,P as i,j as c}from"./three-U1z093Ie.js";import{d as g,z as m,A as s,g as l,j as f,F as d,o as u}from"./@vue-B4sUqkWa.js";const x=g({__name:"ShaderView",setup(g){const x=new class extends e{constructor(){super()}load(){this.init("#webgl"),this.animate(),this.create(),this.scene.background=new n(3355443)}create(){var e;const n="\n        varying vec2 vUv;\n        uniform float uTime;\n        uniform float uRepeat;\n        void main() {\n          float vColor = step(fract(vUv.y * uRepeat ),0.5);\n          vColor += step(fract(vUv.x*5.0),0.5);\n          gl_FragColor = vec4(vec3(vColor), 1.0);\n        \n        }\n      ",g="\n        varying vec2 vUv;\n        varying vec3 vNormal;\n        uniform float uTime;\n        uniform float uStrength;\n        uniform float uSpeed;\n\n        float random(vec3 pos){\n          return fract(sin(dot(pos,vec3(64.25375463,23.27536534,86.29678483)))*59482.7542);\n        }\n\n        vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n        vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n        vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\n        float cnoise(vec3 P){\n          vec3 Pi0 = floor(P); // Integer part for indexing\n          vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n          Pi0 = mod(Pi0, 289.0);\n          Pi1 = mod(Pi1, 289.0);\n          vec3 Pf0 = fract(P); // Fractional part for interpolation\n          vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n          vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n          vec4 iy = vec4(Pi0.yy, Pi1.yy);\n          vec4 iz0 = Pi0.zzzz;\n          vec4 iz1 = Pi1.zzzz;\n\n          vec4 ixy = permute(permute(ix) + iy);\n          vec4 ixy0 = permute(ixy + iz0);\n          vec4 ixy1 = permute(ixy + iz1);\n\n          vec4 gx0 = ixy0 / 7.0;\n          vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n          gx0 = fract(gx0);\n          vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n          vec4 sz0 = step(gz0, vec4(0.0));\n          gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n          gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n          vec4 gx1 = ixy1 / 7.0;\n          vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n          gx1 = fract(gx1);\n          vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n          vec4 sz1 = step(gz1, vec4(0.0));\n          gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n          gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n          vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n          vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n          vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n          vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n          vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n          vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n          vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n          vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n          vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n          g000 *= norm0.x;\n          g010 *= norm0.y;\n          g100 *= norm0.z;\n          g110 *= norm0.w;\n          vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n          g001 *= norm1.x;\n          g011 *= norm1.y;\n          g101 *= norm1.z;\n          g111 *= norm1.w;\n\n          float n000 = dot(g000, Pf0);\n          float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n          float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n          float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n          float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n          float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n          float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n          float n111 = dot(g111, Pf1);\n\n          vec3 fade_xyz = fade(Pf0);\n          vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n          vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n          float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n          return 2.2 * n_xyz;\n        }\n\n        void main() {\n          vUv = uv;\n          vec3 newPosition = position ;\n        \n\n          newPosition.y += sin(newPosition.y*0.50 * uTime / uSpeed) *uStrength;\n          newPosition.x += sin(newPosition.z*0.50 * uTime / uSpeed) *uStrength;\n\n          // newPosition += normal * cnoise(position * sin(uTime) / uSpeed)*uStrength;\n\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n\n           vNormal = normal;\n        }\n        ";let m=new o(100,32,32);const s=new r({wireframe:!1,uniforms:{uTime:{value:0},uRepeat:{value:1},uStrength:{value:1},uSpeed:{value:1}},vertexShader:g,fragmentShader:n});s.needsUpdate=!0;const l=new t(m,s);l.onBeforeRender=()=>{s.uniforms.uTime.value+=.05};const f={fragmentShader1:n,fragmentShader2:"\n        varying vec2 vUv;\n        uniform float uTime;\n        uniform float uRepeat;\n\n        void main() {\n          //中心点居中\n          // float dist = length(vUv-vec2(0.5,0.5));\n          float dist = length(fract(vUv * uRepeat) - vec2(0.5));\n          vec3 vColor = vec3(dist);\n          // vColor += step(0.25, dist);\n          //半径大小随时间周期变化\n          float radius = 0.5 * sin(uTime + vUv.x + vUv.y) * 0.5 + 0.5;\n          vColor += step(radius, fract(dist*10.0));\n\n          vec3 color=vec3(step(radius,dist));\n          gl_FragColor = vec4(color, 1.0);\n        \n        }\n      ",fragmentShader3:"\n        varying vec2 vUv;\n        uniform float uTime;\n        uniform float uRepeat;\n\n        void main() {\n          //中心点居中\n          // float dist = length(fract(vUv * uRepeat) - vec2(0.5));\n          float dist = fract((length(vUv - vec2(0.5)))/0.7 * uRepeat);\n\n          vec3 vColor = vec3(dist);\n          //半径大小随时间周期变化\n          float radius = 0.5 * sin(uTime + vUv.x + vUv.y) * 0.5 + 0.5;\n          vColor += step(radius, fract(dist*10.0));\n\n          gl_FragColor = vec4(vColor, 1.0);\n        \n        }\n      ",fragmentShader4:"\n        varying vec2 vUv;\n        uniform float uTime;\n        void main() {\n          vec3 color1 = vec3(0.0);\n          vec3 color2 = vec3(1.0);\n\n          float mixer1 =2.0- vUv.x + vUv.y;\n          vec3 vColor = mix(color1, color2, fract(mixer1 * 1.0));\n          // vColor += mix(color1, color2, fract(mixer1 * 1.0));\n\n          // vec3 vColor = mix(color1, color2, step(0.5,vUv.x));\n\n          gl_FragColor = vec4(vColor, 1.0);\n        \n        }\n      ",fragmentShader5:"\n        varying vec2 vUv;\n        uniform float uTime;\n        uniform float uRepeat;\n\n        void main() {\n          vec3 color1 = vec3(0.0,1.0,0.0);\n          vec3 color2 = vec3(0.5);\n\n          vec3 mask1 = vec3(step(0.5,fract(vUv.x * uRepeat)));\n          vec3 mask2 = vec3(step(0.5,fract(vUv.y * uRepeat)));\n\n          vec3 mixer = abs(mask1 - mask2);\n\n          vec3 vColor = mix(color1,color2,mixer);\n\n          gl_FragColor = vec4(vColor, 1.0);\n        \n        }\n      ",fragmentShader6:"\n        varying vec2 vUv;\n        uniform float uTime;\n        void main() {\n          // float mixer1=vUv.x+vUv.y;\n          // float mixer2=2.0-(vUv.x+vUv.y);\n          // float mixer=min(mixer1,mixer2);\n          // vec3 color=vec3(mixer);\n\n          float mixer=1.0-abs((vUv.x+vUv.y-1.0));\n          vec3 color=vec3(mixer);\n\n          gl_FragColor=vec4(color,1.0);\n        \n        }\n      ",fragmentShader7:"\n        varying vec2 vUv;\n        varying vec3 vNormal;\n        uniform float uTime;\n        void main() {\n          gl_FragColor=vec4(vNormal,1.0);\n        }\n      "},d={vertexShader1:g,vertexShader2:"\n        varying vec2 vUv;\n        varying vec3 vNormal;\n        uniform float uTime;\n        uniform float uStrength;\n        uniform float uSpeed;\n\n        void main() {\n           vUv = uv;\n          vec3 newPosition = position ;\n          newPosition.y += sin(newPosition.y*0.50 * uTime / uSpeed) *uStrength;\n          newPosition.x += sin(newPosition.z*0.50 * uTime / uSpeed) *uStrength;\n\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n\n          vNormal = normal;\n        }\n        ",vertexShader3:"\n        varying vec2 vUv;\n        varying vec3 vNormal;\n        uniform float uTime;\n\n        void main() {\n           vUv = uv;\n          vec3 newPosition = position ;\n          newPosition *= sin(uTime);\n\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n\n          vNormal = normal;\n        }\n        ",vertexShader4:"\n        varying vec2 vUv;\n        varying vec3 vNormal;\n        uniform float uTime;\n\n        void main() {\n          vUv = uv;\n\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n          vNormal = normal;\n        }\n        "},u={state:"SphereGeometry",vertexShader:"vertexShader1",fragmentShader:"fragmentShader1",wireframe:!1};this.gui.add(u,"state").options(["SphereGeometry","BoxGeometry","PlaneGeometry","TorusGeometry","CapsuleGeometry"]).name("几何体").onChange((e=>{switch(e){case"SphereGeometry":default:m=new o(100,32,32);break;case"BoxGeometry":m=new c(100,100,100,10,10,10);break;case"PlaneGeometry":m=new i(100,100);break;case"TorusGeometry":m=new v(50,10,16,50);break;case"CapsuleGeometry":m=new a(50,10,16,50)}l.geometry=m})),this.gui.add(u,"vertexShader").options(["vertexShader1","vertexShader2","vertexShader3","vertexShader4"]).name("顶点着色器").onChange((e=>{s.vertexShader=d[e],s.needsUpdate=!0})),this.gui.add(u,"fragmentShader").options(["fragmentShader1","fragmentShader2","fragmentShader3","fragmentShader4","fragmentShader5","fragmentShader6","fragmentShader7"]).name("片元着色器").onChange((e=>{s.fragmentShader=f[e],s.needsUpdate=!0})),this.gui.add(s.uniforms.uRepeat,"value",1,10,1).name("重复次数"),this.gui.add(s.uniforms.uStrength,"value",1,50,1).name("运动强度"),this.gui.add(s.uniforms.uSpeed,"value",1,50,1).name("运动快慢"),this.gui.add(u,"wireframe").name("显示线条").onChange((e=>{s.wireframe=e})),null==(e=this.scene)||e.add(l)}animate(){var e,n;null==(e=this.stats)||e.begin(),requestAnimationFrame((()=>{this.animate()})),this.renderer&&this.renderer.render(this.scene,this.camera),null==(n=this.stats)||n.end()}};return m((()=>{x.load()})),s((()=>{x.gui.close(),x.gui.destroy()})),(e,n)=>(u(),l(d,null,[n[0]||(n[0]=f("div",{id:"webgl"},null,-1)),n[1]||(n[1]=f("div",{class:"title-name"},"shader",-1))],64))}});export{x as default};

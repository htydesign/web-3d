var n=Object.defineProperty,e=(e,a,i)=>((e,a,i)=>a in e?n(e,a,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[a]=i)(e,"symbol"!=typeof a?a+"":a,i);import{B as a}from"./base-rPOBNrun.js";import{G as i,ah as t,h as o,ak as s,av as r,aw as u,ax as l,T as c,al as d,l as h,D as x,S as m,j as v,ay as f,M as g,e as p}from"./three-BwxZCoz6.js";import{f as M}from"./modelLoader-m5xbiiQH.js";import{d as w,A as b,B as y,g as S,j as B,F as j,o as z}from"./@vue-Di8-S161.js";const _=w({__name:"InfinityView",setup(n){const w=new class extends a{constructor(){super(),e(this,"group",new i),e(this,"group1",new i),e(this,"scene1",new t),e(this,"shaderMaterial"),e(this,"orthographicCamera"),e(this,"standardMaterial"),e(this,"uniforms",{uTime:{value:0},uOffset:{value:0},uMin:{value:new o(0,0,0)},uMax:{value:new o(0,0,0)}}),e(this,"uniforms1",{uTime:{value:0},uOffset:{value:1},uMin:{value:new o(0,0,0)},uMax:{value:new o(0,0,0)}}),e(this,"time",0)}load(){var n,e;this.init("#webgl"),null==(n=this.scene)||n.add(this.group),this.scene1.add(this.group1),this.group.rotation.x=Math.PI/4,this.group1.rotation.x=-Math.PI/4,this.renderer.setScissorTest(!0),null==(e=this.controls)||e.dispose();const a=window.innerWidth/window.innerHeight;this.orthographicCamera=new s(-10*a/2,10*a/2,5,-5,-1e4,1e4),this.orthographicCamera.position.set(0,0,10),this.controls=new r(this.orthographicCamera,this.renderer.domElement),this.addObject(),this.addLight(),this.animate()}addLight(){var n,e;const a=new u(16777215);a.position.set(0,-1,0),null==(n=this.scene)||n.add(a),this.scene1.add(a.clone());const i=new l(16777215,10.5);i.position.set(0,1,0),i.castShadow=!0,i.shadow.mapSize.width=1024,i.shadow.mapSize.height=1024,i.shadow.camera.near=.1,i.shadow.camera.far=1024,null==(e=this.scene)||e.add(i),this.scene1.add(i.clone())}getMaterial(n){const e=(new c).load("./texture/uv_grid_opengl.jpg");e.wrapS=d,e.wrapT=d;const a=new h({color:7829367,map:e,side:x});return a.onBeforeCompile=e=>{Object.assign(e.uniforms,n),e.vertexShader="\n          float mapRange(float value, float inMin, float inMax, float outMin, float outMax){\n            return (value - inMin) * (outMax - outMin) / (inMax - inMin)  + outMin;\n          }\n\n          mat4 rotation3d(vec3 axis, float angle) {\n            axis = normalize(axis);\n            float s = sin(angle);\n            float c = cos(angle);\n            float oc = 1.0 - c;\n\n            return mat4(\n              oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n              oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n              oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n              0.0,                                0.0,                                0.0,                                1.0\n            );\n          }\n          vec3 rotate(vec3 v, vec3 axis, float angle) {\n            return (rotation3d(axis, angle) * vec4(v, 1.0)).xyz;\n          }\n\n          float PI = 3.1415926535897932384626433832795;\n\n          float radius = 2.5;\n          uniform vec3 uMin;\n          uniform vec3 uMax;\n          uniform float uTime;\n          uniform float uOffset;\n\n          varying vec2 vUv;\n          varying float vDiscard;\n\n        "+e.vertexShader,e.fragmentShader=`varying float vDiscard;\n            ${e.fragmentShader}\n          `,e.vertexShader=e.vertexShader.replace("#include <beginnormal_vertex>","#include <beginnormal_vertex>\n            vec3 temp = objectNormal;\n\n            float xx = mapRange(position.x, uMin.x, uMax.x, -1.0, 1.0);\n\n            float theta = (xx + uTime + uOffset * 0.5) * 2.0 * PI;\n\n            vDiscard = mod(xx + uTime + mix(0.25, -0.25, uOffset) + uOffset * 0.5, 2.0);\n\n            temp = rotate(temp, vec3(0.0, 0.0, 1.0), theta);\n\n            objectNormal = temp;\n          "),e.vertexShader=e.vertexShader.replace("#include <begin_vertex>","#include <begin_vertex>\n            vec3 pos = transformed;\n\n            vec3 dir = vec3(sin(theta), cos(theta), 0.0);\n\n            pos = radius * dir + vec3(0.0, 0.0, pos.z) + dir * pos.y;\n\n            transformed = pos;\n          "),e.fragmentShader=e.fragmentShader.replace("#include <output_fragment>","#include <output_fragment>\n            float dotShow = step(1.0, vDiscard);\n            if(dotShow > 0.5){\n              discard;\n            }\n          ")},a}addObject(){M("./fonts/helvetiker_bold.typeface.json").then((n=>{this.shaderMaterial=new m({uniforms:{uTime:{value:0},uMin:{value:new o(0,0,0)},uMax:{value:new o(0,0,0)}},vertexShader:"\n          float mapRange(float value, float inMin, float inMax, float outMin, float outMax){\n            return (value - inMin) * (outMax - outMin) / (inMax - inMin)  + outMin;\n          }\n\n          float PI = 3.1415926535897932384626433832795;\n          float radius = 2.0;\n\n          uniform vec3 uMin;\n          uniform vec3 uMax;\n\n          varying vec2 vUv;\n          varying float vDebug;\n\n          void main() {\n            vUv = uv;\n\n            float x = mapRange(position.x, uMin.x, uMax.x, -PI, PI);\n            vDebug = x;\n\n            vec3 dir = vec3(sin(x), cos(x), 0.0);\n            vec3 pos = radius * dir + vec3(0.0, 0.0, position.z) + dir * position.y;\n\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n          }\n        ",fragmentShader:"\n          varying vec2 vUv;\n          varying float vDebug;\n\n          uniform float uTime;\n          void main() {\n            vec2 uv = vUv;\n            gl_FragColor = vec4(vec3(vDebug), 1.0);\n            gl_FragColor = vec4(vUv, 1.0, 1.0);\n          }\n        "});const e=new v(1,.5,.5,100,100,100),a=new v(.5,.001,.001).toNonIndexed(),i=e.clone();i.computeBoundingBox(),a.translate(i.boundingBox.max.x,0,0),e.center(),e.computeBoundingBox(),f([a,i]);const t=e.clone();t.computeBoundingBox();const s=[];for(let o=0;o<4;o++){const n=t.clone();n.rotateX(o*Math.PI/2),n.center(),n.translate(t.boundingBox.max.x*o*2,0,0),s.push(n)}const r=f(s);r.center(),r.computeBoundingBox(),this.uniforms.uMin.value=r.boundingBox.min.clone(),this.uniforms.uMax.value=r.boundingBox.max.clone(),this.uniforms1.uMin.value=r.boundingBox.min.clone(),this.uniforms1.uMax.value=r.boundingBox.max.clone();const u=this.getMaterial(this.uniforms),l=this.getMaterial(this.uniforms1),c=new g(r,u),d=new g(r,l);this.group.add(c),this.group1.add(d)}))}animate(){var n,e,a,i;null==(n=this.stats)||n.begin(),requestAnimationFrame((()=>{this.animate()})),p.update(),this.time+=.001,this.uniforms.uTime.value=this.time,this.uniforms1.uTime.value=this.time,null==(e=this.renderer)||e.setScissor(0,0,this.innerWidth/2,this.innerHeight),this.renderer.render(this.scene,this.orthographicCamera),null==(a=this.renderer)||a.setScissor(this.innerWidth/2,0,this.innerWidth/2,this.innerHeight),this.renderer.render(this.scene1,this.orthographicCamera),null==(i=this.stats)||i.end()}};return b((()=>{w.load()})),y((()=>{w.gui.close(),w.gui.destroy()})),(n,e)=>(z(),S(j,null,[e[0]||(e[0]=B("div",{id:"webgl"},null,-1)),e[1]||(e[1]=B("div",{class:"title-name"},"infinity",-1))],64))}});export{_ as default};

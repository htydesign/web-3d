var e=Object.defineProperty,n=(n,t,o)=>((n,t,o)=>t in n?e(n,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):n[t]=o)(n,"symbol"!=typeof t?t+"":t,o);import{B as t}from"./base-Blzby6IQ.js";import{d as o,z as i,A as r,g as a,j as s,F as l,o as c}from"./@vue-DISYwsDo.js";import{C as d,c as v,d as h,T as m,e as u,W as p,S as f,A as g,a as w,k as x,l as S,V as A,P as y,m as C,b}from"./three-CQ-nF5qD.js";const M=o({__name:"LightFiveView",setup(e){const o=new class extends t{constructor(){super(),n(this,"renderTarget")}load(){this.init("#webgl"),this.animate(),this.create(),this.createFlow(),this.scene.background=new d(3355443)}create(){var e;const n=1e5,t=new v,o=new Float32Array(3e5);t.setAttribute("position",new h(o,3));const i=new Float32Array(n);t.setAttribute("speed",new h(i,1));const r=new Float32Array(n);t.setAttribute("aProgress",new h(r,1));for(let d=0;d<n;d++)o[3*d]=1e3*Math.random()-500,o[3*d+1]=500*Math.random()-500,o[3*d+2]=1e3*Math.random()-500,r[d]=o[3*d+1],i[d]=1+Math.random();t.attributes.position.needsUpdate=!0,t.attributes.speed.needsUpdate=!0,t.attributes.aProgress.needsUpdate=!0;const a=(new m).load("./texture/xingkong.jpg");a.wrapS=u,a.wrapT=u,this.renderTarget=new p(this.innerWidth,this.innerHeight);const s=new f({transparent:!0,blending:g,uniforms:{uTexture:{value:a},uTime:{value:0},uSpeed:{value:10},ambientLightColor:{value:new d(3355443)},directionalLightColor:{value:new d(0)},directionalLightDirection:{value:new w}},vertexShader:"\n        attribute float speed;\n        attribute float aProgress;\n        uniform float uTime;\n\n        uniform vec3 ambientLightColor;\n        uniform vec3 directionalLightColor;\n        uniform vec3 directionalLightDirection;\n\n        uniform float uSpeed;\n\n        varying float vYCoord;\n        varying vec3 vColor;\n        varying vec2 vUv;\n\n        void main() {\n          vUv = uv;\n          vec3 normal = normalize(normalMatrix * normal);\n          vec3 lightDir = normalize(directionalLightDirection);\n          float dotProduct = max(dot(normal, lightDir), 0.0);\n          vColor = ambientLightColor + dotProduct * directionalLightColor;\n          \n          vec3 p = position;\n          float s = -uTime * speed * uSpeed;\n          p.y = mod(aProgress + s , 500.0);\n          \n          vYCoord = p.y;\n\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0);\n          \n          gl_PointSize = 10.0;\n          gl_PointSize *= 100.0/-(modelViewMatrix * vec4(position, 1.0)).z;\n        }\n      ",fragmentShader:"\n        \n        varying float vYCoord;\n        varying vec3 vColor;\n        varying vec2 vUv;\n\n        uniform sampler2D uTexture;\n\n        void main() {\n          float strength = distance(gl_PointCoord,vec2(0.5,0.5));\n          float dis = length(gl_PointCoord - 0.5);\n          dis = smoothstep(0.5,0.0,dis);\n          strength = step(0.5,strength);\n          strength = 1.0 - strength;\n\n\n          //渐变色\n          vec3 finalColor = vColor;      \n          if(vYCoord > 100.0){\n           finalColor = vec3(1.0,1.0,0.0);\n          }else{\n           finalColor = vec3(1.0,1.0,1.0);\n          }\n\n          float alpha = smoothstep(200.0, 100.0, vYCoord);\n          \n          if(strength == 0.0){\n            discard;\n          }\n          if(dis == 0.0){\n            discard;\n          }\n\n\n          gl_FragColor = vec4( finalColor,1.0);\n\n        }"}),l=new x(16777215,1e3);l.position.set(0,50,1),l.castShadow=!0,l.shadow.mapSize.width=1024,l.shadow.mapSize.height=1024,l.shadow.camera.near=.5,l.shadow.camera.far=500,this.scene.add(l),s.uniforms.directionalLightDirection.value=l.position.clone().normalize();const c=new S(t,s);c.onBeforeRender=()=>{s.uniforms.uTime.value+=.01},null==(e=this.scene)||e.add(c)}createText(){}createFlow(){var e,n,t;const{width:o,height:i}=(null==(e=this.renderer)?void 0:e.getSize(new A))||{};new w(o,i,null==(n=this.renderer)?void 0:n.getPixelRatio());const r=(new m).load("./texture/xingkong.jpg");r.wrapS=u,r.wrapT=u;const a=new y(1e3,1e3),s=new f({uniforms:{iMouse:{value:new C(0,0,0,1)},iResolution:{value:new w(1e3,1e3,0)},iTime:{value:0},map:{value:r}},vertexShader:"\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      vec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\n      gl_Position = projectionMatrix * mvPosition;\n      \n    \n    }\n  ",fragmentShader:"\n    uniform vec4 iMouse;\n    uniform vec3 iResolution;\n    uniform float iTime;\n    uniform sampler2D map;\n    varying vec2 vUv;\n\n    float count = 500.0;\n\n\n    // Maximum number of cells a ripple can cross.\n    #define MAX_RADIUS 2\n\n    // Set to 1 to hash twice. Slower, but less patterns.\n    #define DOUBLE_HASH 0\n\n    // Hash functions shamefully stolen from:\n    // https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 .1031\n    #define HASHSCALE3 vec3(.1031, .1030, .0973)\n\n    float hash12(vec2 p)\n    {\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    vec2 hash22(vec2 p)\n    {\n      vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n      p3 += dot(p3, p3.yzx+19.19);\n      return fract((p3.xx+p3.yz)*p3.zy);\n\n    }\n\n    void main()\n    {\n      float resolution = 1. * exp2(-3.*iMouse.x/iResolution.x);\n      // vec2 uv = gl_FragCoord.xy / iResolution.xy *20.0;\n      vec2 uv = vUv * count;\n      vec2 p0 = floor(uv);\n\n        vec2 circles = vec2(0.);\n        for (int j = -MAX_RADIUS; j <= MAX_RADIUS; ++j)\n        {\n            for (int i = -MAX_RADIUS; i <= MAX_RADIUS; ++i)\n            {\n              vec2 pi = p0 + vec2(i, j);\n              #if DOUBLE_HASH\n              vec2 hsh = hash22(pi);\n              #else\n              vec2 hsh = pi;\n              #endif\n              vec2 p = pi + hash22(hsh);\n\n              float t = fract(0.3*iTime + hash12(hsh));\n              vec2 v = p - uv;\n              float d = length(v) - (float(MAX_RADIUS) + 1.)*t;\n\n              float h = 1e-3;\n              float d1 = d - h;\n              float d2 = d + h;\n              float p1 = sin(31.*d1) * smoothstep(-0.6, -0.3, d1) * smoothstep(0., -0.3, d1);\n              float p2 = sin(31.*d2) * smoothstep(-0.6, -0.3, d2) * smoothstep(0., -0.3, d2);\n              circles += 0.5 * normalize(v) * ((p2 - p1) / (2. * h) * (1. - t) * (1. - t));\n              }\n        }\n        circles /= float((MAX_RADIUS*2+1)*(MAX_RADIUS*2+1));\n\n        float intensity = mix(0.01, 0.15, smoothstep(0.1, 0.6, abs(fract(0.05*iTime + 0.5)*2.-1.)));\n        vec3 n = vec3(circles, sqrt(1. - dot(circles, circles)));\n        vec3 color = texture(map, uv/count).rgb + 15.*pow(clamp(dot(n, normalize(vec3(1., 0.7, 0.5))), 0., 1.), 6.);\n        // vec3 color = vec3(0.0,0.0,0.0) + 15.*pow(clamp(dot(n, normalize(vec3(1., 0.7, 0.5))), 0., 1.), 6.);\n        // vec3 c = texture2D(map,vUv).rgb;\n        gl_FragColor = vec4( color, 1.0);\n    }\n  "}),l=new b(a,s);l.rotateX(-Math.PI/2),null==(t=this.scene)||t.add(l),l.onBeforeRender=()=>{s.uniforms.iTime.value+=.01}}animate(){var e,n;null==(e=this.stats)||e.begin(),requestAnimationFrame((()=>{this.animate()})),this.renderer&&this.renderTarget&&(this.renderer.setRenderTarget(this.renderTarget),this.renderer.render(this.scene,this.camera),this.renderer.setRenderTarget(null),this.renderer.render(this.scene,this.camera)),null==(n=this.stats)||n.end()}};return i((()=>{o.load()})),r((()=>{o.destroy()})),(e,n)=>(c(),a(l,null,[n[0]||(n[0]=s("div",{id:"webgl"},null,-1)),n[1]||(n[1]=s("div",{class:"title-name"},"灯光2",-1))],64))}});export{M as default};

const t={},e=function(e,i,n){let s=Promise.resolve();if(i&&i.length>0){const e=document.getElementsByTagName("link"),r=document.querySelector("meta[property=csp-nonce]"),a=(null==r?void 0:r.nonce)||(null==r?void 0:r.getAttribute("nonce"));s=Promise.allSettled(i.map((i=>{if(i=function(t,e){return new URL(t,e).href}(i,n),i in t)return;t[i]=!0;const s=i.endsWith(".css"),r=s?'[rel="stylesheet"]':"";if(!!n)for(let t=e.length-1;t>=0;t--){const n=e[t];if(n.href===i&&(!s||"stylesheet"===n.rel))return}else if(document.querySelector(`link[href="${i}"]${r}`))return;const o=document.createElement("link");return o.rel=s?"stylesheet":"modulepreload",s||(o.as="script"),o.crossOrigin="",o.href=i,a&&o.setAttribute("nonce",a),document.head.appendChild(o),s?new Promise(((t,e)=>{o.addEventListener("load",t),o.addEventListener("error",(()=>e(new Error(`Unable to preload CSS for ${i}`))))})):void 0})))}function r(t){const e=new Event("vite:preloadError",{cancelable:!0});if(e.payload=t,window.dispatchEvent(e),!e.defaultPrevented)throw t}return s.then((t=>{for(const e of t||[])"rejected"===e.status&&r(e.reason);return e().catch(r)}))},i="170",n=0,s=1,r=2,a=0,o=1,l=2,h=3,c=2,u=0,d=1,p=2,m=2,f=100,g=101,x=102,v=200,_=201,y=202,b=203,S=204,M=205,T=206,w=207,A=208,E=209,C=210,R=211,N=212,P=213,I=214,L=0,D=1,U=2,F=3,B=4,O=5,z=6,k=7,V=4,G="attached",H=301,W=302,j=303,X=306,q=1e3,$=1001,Y=1002,Z=1003,K=1004,J=1005,Q=1006,tt=1007,et=1008,it=1009,nt=1010,st=1011,rt=1012,at=1013,ot=1014,lt=1015,ht=1016,ct=1017,ut=1018,dt=1020,pt=35902,mt=1023,ft=1026,gt=1027,xt=1028,vt=1029,_t=1031,yt=1033,bt=33776,St=33777,Mt=33778,Tt=33779,wt=35840,At=35841,Et=35842,Ct=35843,Rt=36196,Nt=37492,Pt=37496,It=37808,Lt=37809,Dt=37810,Ut=37811,Ft=37812,Bt=37813,Ot=37814,zt=37815,kt=37816,Vt=37817,Gt=37818,Ht=37819,Wt=37820,jt=37821,Xt=36492,qt=36494,$t=36495,Yt=36284,Zt=36285,Kt=36286,Jt=2201,Qt=2300,te=2301,ee=2302,ie=2400,ne=2401,se=2402,re=2500,ae="",oe="srgb",le="srgb-linear",he="linear",ce="srgb",ue=7680,de=512,pe=513,me=514,fe=515,ge=516,xe=517,ve=518,_e=519,ye=35044,be="300 es",Se=2e3,Me=2001;let Te=class{addEventListener(t,e){void 0===this._listeners&&(this._listeners={});const i=this._listeners;void 0===i[t]&&(i[t]=[]),-1===i[t].indexOf(e)&&i[t].push(e)}hasEventListener(t,e){if(void 0===this._listeners)return!1;const i=this._listeners;return void 0!==i[t]&&-1!==i[t].indexOf(e)}removeEventListener(t,e){if(void 0===this._listeners)return;const i=this._listeners[t];if(void 0!==i){const t=i.indexOf(e);-1!==t&&i.splice(t,1)}}dispatchEvent(t){if(void 0===this._listeners)return;const e=this._listeners[t.type];if(void 0!==e){t.target=this;const i=e.slice(0);for(let e=0,n=i.length;e<n;e++)i[e].call(this,t);t.target=null}}};const we=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let Ae=1234567;const Ee=Math.PI/180,Ce=180/Math.PI;function Re(){const t=4294967295*Math.random()|0,e=4294967295*Math.random()|0,i=4294967295*Math.random()|0,n=4294967295*Math.random()|0;return(we[255&t]+we[t>>8&255]+we[t>>16&255]+we[t>>24&255]+"-"+we[255&e]+we[e>>8&255]+"-"+we[e>>16&15|64]+we[e>>24&255]+"-"+we[63&i|128]+we[i>>8&255]+"-"+we[i>>16&255]+we[i>>24&255]+we[255&n]+we[n>>8&255]+we[n>>16&255]+we[n>>24&255]).toLowerCase()}function Ne(t,e,i){return Math.max(e,Math.min(i,t))}function Pe(t,e){return(t%e+e)%e}function Ie(t,e,i){return(1-i)*t+i*e}function Le(t,e){switch(e.constructor){case Float32Array:return t;case Uint32Array:return t/4294967295;case Uint16Array:return t/65535;case Uint8Array:return t/255;case Int32Array:return Math.max(t/2147483647,-1);case Int16Array:return Math.max(t/32767,-1);case Int8Array:return Math.max(t/127,-1);default:throw new Error("Invalid component type.")}}function De(t,e){switch(e.constructor){case Float32Array:return t;case Uint32Array:return Math.round(4294967295*t);case Uint16Array:return Math.round(65535*t);case Uint8Array:return Math.round(255*t);case Int32Array:return Math.round(2147483647*t);case Int16Array:return Math.round(32767*t);case Int8Array:return Math.round(127*t);default:throw new Error("Invalid component type.")}}const Ue={DEG2RAD:Ee,RAD2DEG:Ce,generateUUID:Re,clamp:Ne,euclideanModulo:Pe,mapLinear:function(t,e,i,n,s){return n+(t-e)*(s-n)/(i-e)},inverseLerp:function(t,e,i){return t!==e?(i-t)/(e-t):0},lerp:Ie,damp:function(t,e,i,n){return Ie(t,e,1-Math.exp(-i*n))},pingpong:function(t,e=1){return e-Math.abs(Pe(t,2*e)-e)},smoothstep:function(t,e,i){return t<=e?0:t>=i?1:(t=(t-e)/(i-e))*t*(3-2*t)},smootherstep:function(t,e,i){return t<=e?0:t>=i?1:(t=(t-e)/(i-e))*t*t*(t*(6*t-15)+10)},randInt:function(t,e){return t+Math.floor(Math.random()*(e-t+1))},randFloat:function(t,e){return t+Math.random()*(e-t)},randFloatSpread:function(t){return t*(.5-Math.random())},seededRandom:function(t){void 0!==t&&(Ae=t);let e=Ae+=1831565813;return e=Math.imul(e^e>>>15,1|e),e^=e+Math.imul(e^e>>>7,61|e),((e^e>>>14)>>>0)/4294967296},degToRad:function(t){return t*Ee},radToDeg:function(t){return t*Ce},isPowerOfTwo:function(t){return!(t&t-1)&&0!==t},ceilPowerOfTwo:function(t){return Math.pow(2,Math.ceil(Math.log(t)/Math.LN2))},floorPowerOfTwo:function(t){return Math.pow(2,Math.floor(Math.log(t)/Math.LN2))},setQuaternionFromProperEuler:function(t,e,i,n,s){const r=Math.cos,a=Math.sin,o=r(i/2),l=a(i/2),h=r((e+n)/2),c=a((e+n)/2),u=r((e-n)/2),d=a((e-n)/2),p=r((n-e)/2),m=a((n-e)/2);switch(s){case"XYX":t.set(o*c,l*u,l*d,o*h);break;case"YZY":t.set(l*d,o*c,l*u,o*h);break;case"ZXZ":t.set(l*u,l*d,o*c,o*h);break;case"XZX":t.set(o*c,l*m,l*p,o*h);break;case"YXY":t.set(l*p,o*c,l*m,o*h);break;case"ZYZ":t.set(l*m,l*p,o*c,o*h)}},normalize:De,denormalize:Le};let Fe=class t{constructor(e=0,i=0){t.prototype.isVector2=!0,this.x=e,this.y=i}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,i=this.y,n=t.elements;return this.x=n[0]*e+n[3]*i+n[6],this.y=n[1]*e+n[4]*i+n[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const i=this.dot(t)/e;return Math.acos(Ne(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,i=this.y-t.y;return e*e+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const i=Math.cos(e),n=Math.sin(e),s=this.x-t.x,r=this.y-t.y;return this.x=s*i-r*n+t.x,this.y=s*n+r*i+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}},Be=class t{constructor(e,i,n,s,r,a,o,l,h){t.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],void 0!==e&&this.set(e,i,n,s,r,a,o,l,h)}set(t,e,i,n,s,r,a,o,l){const h=this.elements;return h[0]=t,h[1]=n,h[2]=a,h[3]=e,h[4]=s,h[5]=o,h[6]=i,h[7]=r,h[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],this}extractBasis(t,e,i){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const i=t.elements,n=e.elements,s=this.elements,r=i[0],a=i[3],o=i[6],l=i[1],h=i[4],c=i[7],u=i[2],d=i[5],p=i[8],m=n[0],f=n[3],g=n[6],x=n[1],v=n[4],_=n[7],y=n[2],b=n[5],S=n[8];return s[0]=r*m+a*x+o*y,s[3]=r*f+a*v+o*b,s[6]=r*g+a*_+o*S,s[1]=l*m+h*x+c*y,s[4]=l*f+h*v+c*b,s[7]=l*g+h*_+c*S,s[2]=u*m+d*x+p*y,s[5]=u*f+d*v+p*b,s[8]=u*g+d*_+p*S,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],i=t[1],n=t[2],s=t[3],r=t[4],a=t[5],o=t[6],l=t[7],h=t[8];return e*r*h-e*a*l-i*s*h+i*a*o+n*s*l-n*r*o}invert(){const t=this.elements,e=t[0],i=t[1],n=t[2],s=t[3],r=t[4],a=t[5],o=t[6],l=t[7],h=t[8],c=h*r-a*l,u=a*o-h*s,d=l*s-r*o,p=e*c+i*u+n*d;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);const m=1/p;return t[0]=c*m,t[1]=(n*l-h*i)*m,t[2]=(a*i-n*r)*m,t[3]=u*m,t[4]=(h*e-n*o)*m,t[5]=(n*s-a*e)*m,t[6]=d*m,t[7]=(i*o-l*e)*m,t[8]=(r*e-i*s)*m,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,i,n,s,r,a){const o=Math.cos(s),l=Math.sin(s);return this.set(i*o,i*l,-i*(o*r+l*a)+r+t,-n*l,n*o,-n*(-l*r+o*a)+a+e,0,0,1),this}scale(t,e){return this.premultiply(Oe.makeScale(t,e)),this}rotate(t){return this.premultiply(Oe.makeRotation(-t)),this}translate(t,e){return this.premultiply(Oe.makeTranslation(t,e)),this}makeTranslation(t,e){return t.isVector2?this.set(1,0,t.x,0,1,t.y,0,0,1):this.set(1,0,t,0,1,e,0,0,1),this}makeRotation(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,-i,0,i,e,0,0,0,1),this}makeScale(t,e){return this.set(t,0,0,0,e,0,0,0,1),this}equals(t){const e=this.elements,i=t.elements;for(let n=0;n<9;n++)if(e[n]!==i[n])return!1;return!0}fromArray(t,e=0){for(let i=0;i<9;i++)this.elements[i]=t[i+e];return this}toArray(t=[],e=0){const i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t}clone(){return(new this.constructor).fromArray(this.elements)}};const Oe=new Be;function ze(t){for(let e=t.length-1;e>=0;--e)if(t[e]>=65535)return!0;return!1}function ke(t){return document.createElementNS("http://www.w3.org/1999/xhtml",t)}function Ve(){const t=ke("canvas");return t.style.display="block",t}const Ge={};function He(t){t in Ge||(Ge[t]=!0)}const We={enabled:!0,workingColorSpace:le,spaces:{},convert:function(t,e,i){return!1!==this.enabled&&e!==i&&e&&i?(this.spaces[e].transfer===ce&&(t.r=je(t.r),t.g=je(t.g),t.b=je(t.b)),this.spaces[e].primaries!==this.spaces[i].primaries&&(t.applyMatrix3(this.spaces[e].toXYZ),t.applyMatrix3(this.spaces[i].fromXYZ)),this.spaces[i].transfer===ce&&(t.r=Xe(t.r),t.g=Xe(t.g),t.b=Xe(t.b)),t):t},fromWorkingColorSpace:function(t,e){return this.convert(t,this.workingColorSpace,e)},toWorkingColorSpace:function(t,e){return this.convert(t,e,this.workingColorSpace)},getPrimaries:function(t){return this.spaces[t].primaries},getTransfer:function(t){return t===ae?he:this.spaces[t].transfer},getLuminanceCoefficients:function(t,e=this.workingColorSpace){return t.fromArray(this.spaces[e].luminanceCoefficients)},define:function(t){Object.assign(this.spaces,t)},_getMatrix:function(t,e,i){return t.copy(this.spaces[e].toXYZ).multiply(this.spaces[i].fromXYZ)},_getDrawingBufferColorSpace:function(t){return this.spaces[t].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(t=this.workingColorSpace){return this.spaces[t].workingColorSpaceConfig.unpackColorSpace}};function je(t){return t<.04045?.0773993808*t:Math.pow(.9478672986*t+.0521327014,2.4)}function Xe(t){return t<.0031308?12.92*t:1.055*Math.pow(t,.41666)-.055}const qe=[.64,.33,.3,.6,.15,.06],$e=[.2126,.7152,.0722],Ye=[.3127,.329],Ze=(new Be).set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),Ke=(new Be).set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);let Je;We.define({[le]:{primaries:qe,whitePoint:Ye,transfer:he,toXYZ:Ze,fromXYZ:Ke,luminanceCoefficients:$e,workingColorSpaceConfig:{unpackColorSpace:oe},outputColorSpaceConfig:{drawingBufferColorSpace:oe}},[oe]:{primaries:qe,whitePoint:Ye,transfer:ce,toXYZ:Ze,fromXYZ:Ke,luminanceCoefficients:$e,outputColorSpaceConfig:{drawingBufferColorSpace:oe}}});let Qe=class{static getDataURL(t){if(/^data:/i.test(t.src))return t.src;if("undefined"==typeof HTMLCanvasElement)return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{void 0===Je&&(Je=ke("canvas")),Je.width=t.width,Je.height=t.height;const i=Je.getContext("2d");t instanceof ImageData?i.putImageData(t,0,0):i.drawImage(t,0,0,t.width,t.height),e=Je}return e.width>2048||e.height>2048?e.toDataURL("image/jpeg",.6):e.toDataURL("image/png")}static sRGBToLinear(t){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const e=ke("canvas");e.width=t.width,e.height=t.height;const i=e.getContext("2d");i.drawImage(t,0,0,t.width,t.height);const n=i.getImageData(0,0,t.width,t.height),s=n.data;for(let t=0;t<s.length;t++)s[t]=255*je(s[t]/255);return i.putImageData(n,0,0),e}if(t.data){const e=t.data.slice(0);for(let t=0;t<e.length;t++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[t]=Math.floor(255*je(e[t]/255)):e[t]=je(e[t]);return{data:e,width:t.width,height:t.height}}return t}},ti=0,ei=class{constructor(t=null){this.isSource=!0,Object.defineProperty(this,"id",{value:ti++}),this.uuid=Re(),this.data=t,this.dataReady=!0,this.version=0}set needsUpdate(t){!0===t&&this.version++}toJSON(t){const e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.images[this.uuid])return t.images[this.uuid];const i={uuid:this.uuid,url:""},n=this.data;if(null!==n){let t;if(Array.isArray(n)){t=[];for(let e=0,i=n.length;e<i;e++)n[e].isDataTexture?t.push(ii(n[e].image)):t.push(ii(n[e]))}else t=ii(n);i.url=t}return e||(t.images[this.uuid]=i),i}};function ii(t){return"undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap?Qe.getDataURL(t):t.data?{data:Array.from(t.data),width:t.width,height:t.height,type:t.data.constructor.name}:{}}let ni=0,si=class t extends Te{constructor(e=t.DEFAULT_IMAGE,i=t.DEFAULT_MAPPING,n=1001,s=1001,r=1006,a=1008,o=1023,l=1009,h=t.DEFAULT_ANISOTROPY,c=""){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:ni++}),this.uuid=Re(),this.name="",this.source=new ei(e),this.mipmaps=[],this.mapping=i,this.channel=0,this.wrapS=n,this.wrapT=s,this.magFilter=r,this.minFilter=a,this.anisotropy=h,this.format=o,this.internalFormat=null,this.type=l,this.offset=new Fe(0,0),this.repeat=new Fe(1,1),this.center=new Fe(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Be,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=c,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.pmremVersion=0}get image(){return this.source.data}set image(t=null){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return(new this.constructor).copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.channel=t.channel,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.colorSpace=t.colorSpace,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}toJSON(t){const e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.textures[this.uuid])return t.textures[this.uuid];const i={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(i.userData=this.userData),e||(t.textures[this.uuid]=i),i}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(300!==this.mapping)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case q:t.x=t.x-Math.floor(t.x);break;case $:t.x=t.x<0?0:1;break;case Y:1===Math.abs(Math.floor(t.x)%2)?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x)}if(t.y<0||t.y>1)switch(this.wrapT){case q:t.y=t.y-Math.floor(t.y);break;case $:t.y=t.y<0?0:1;break;case Y:1===Math.abs(Math.floor(t.y)%2)?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y)}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){!0===t&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(t){!0===t&&this.pmremVersion++}};si.DEFAULT_IMAGE=null,si.DEFAULT_MAPPING=300,si.DEFAULT_ANISOTROPY=1;let ri=class t{constructor(e=0,i=0,n=0,s=1){t.prototype.isVector4=!0,this.x=e,this.y=i,this.z=n,this.w=s}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,i,n){return this.x=t,this.y=e,this.z=i,this.w=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=void 0!==t.w?t.w:1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,i=this.y,n=this.z,s=this.w,r=t.elements;return this.x=r[0]*e+r[4]*i+r[8]*n+r[12]*s,this.y=r[1]*e+r[5]*i+r[9]*n+r[13]*s,this.z=r[2]*e+r[6]*i+r[10]*n+r[14]*s,this.w=r[3]*e+r[7]*i+r[11]*n+r[15]*s,this}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this.w/=t.w,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,i,n,s;const r=.01,a=.1,o=t.elements,l=o[0],h=o[4],c=o[8],u=o[1],d=o[5],p=o[9],m=o[2],f=o[6],g=o[10];if(Math.abs(h-u)<r&&Math.abs(c-m)<r&&Math.abs(p-f)<r){if(Math.abs(h+u)<a&&Math.abs(c+m)<a&&Math.abs(p+f)<a&&Math.abs(l+d+g-3)<a)return this.set(1,0,0,0),this;e=Math.PI;const t=(l+1)/2,o=(d+1)/2,x=(g+1)/2,v=(h+u)/4,_=(c+m)/4,y=(p+f)/4;return t>o&&t>x?t<r?(i=0,n=.707106781,s=.707106781):(i=Math.sqrt(t),n=v/i,s=_/i):o>x?o<r?(i=.707106781,n=0,s=.707106781):(n=Math.sqrt(o),i=v/n,s=y/n):x<r?(i=.707106781,n=.707106781,s=0):(s=Math.sqrt(x),i=_/s,n=y/s),this.set(i,n,s,e),this}let x=Math.sqrt((f-p)*(f-p)+(c-m)*(c-m)+(u-h)*(u-h));return Math.abs(x)<.001&&(x=1),this.x=(f-p)/x,this.y=(c-m)/x,this.z=(u-h)/x,this.w=Math.acos((l+d+g-1)/2),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this.w=e[15],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this.z=t.z+(e.z-t.z)*i,this.w=t.w+(e.w-t.w)*i,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}},ai=class extends Te{constructor(t=1,e=1,i={}){super(),this.isRenderTarget=!0,this.width=t,this.height=e,this.depth=1,this.scissor=new ri(0,0,t,e),this.scissorTest=!1,this.viewport=new ri(0,0,t,e);const n={width:t,height:e,depth:1};i=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:Q,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1},i);const s=new si(n,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.colorSpace);s.flipY=!1,s.generateMipmaps=i.generateMipmaps,s.internalFormat=i.internalFormat,this.textures=[];const r=i.count;for(let a=0;a<r;a++)this.textures[a]=s.clone(),this.textures[a].isRenderTargetTexture=!0;this.depthBuffer=i.depthBuffer,this.stencilBuffer=i.stencilBuffer,this.resolveDepthBuffer=i.resolveDepthBuffer,this.resolveStencilBuffer=i.resolveStencilBuffer,this.depthTexture=i.depthTexture,this.samples=i.samples}get texture(){return this.textures[0]}set texture(t){this.textures[0]=t}setSize(t,e,i=1){if(this.width!==t||this.height!==e||this.depth!==i){this.width=t,this.height=e,this.depth=i;for(let n=0,s=this.textures.length;n<s;n++)this.textures[n].image.width=t,this.textures[n].image.height=e,this.textures[n].image.depth=i;this.dispose()}this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return(new this.constructor).copy(this)}copy(t){this.width=t.width,this.height=t.height,this.depth=t.depth,this.scissor.copy(t.scissor),this.scissorTest=t.scissorTest,this.viewport.copy(t.viewport),this.textures.length=0;for(let i=0,n=t.textures.length;i<n;i++)this.textures[i]=t.textures[i].clone(),this.textures[i].isRenderTargetTexture=!0;const e=Object.assign({},t.texture.image);return this.texture.source=new ei(e),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.resolveDepthBuffer=t.resolveDepthBuffer,this.resolveStencilBuffer=t.resolveStencilBuffer,null!==t.depthTexture&&(this.depthTexture=t.depthTexture.clone()),this.samples=t.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}},oi=class extends ai{constructor(t=1,e=1,i={}){super(t,e,i),this.isWebGLRenderTarget=!0}},li=class extends si{constructor(t=null,e=1,i=1,n=1){super(null),this.isDataArrayTexture=!0,this.image={data:t,width:e,height:i,depth:n},this.magFilter=Z,this.minFilter=Z,this.wrapR=$,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(t){this.layerUpdates.add(t)}clearLayerUpdates(){this.layerUpdates.clear()}};class hi extends si{constructor(t=null,e=1,i=1,n=1){super(null),this.isData3DTexture=!0,this.image={data:t,width:e,height:i,depth:n},this.magFilter=Z,this.minFilter=Z,this.wrapR=$,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}let ci=class{constructor(t=0,e=0,i=0,n=1){this.isQuaternion=!0,this._x=t,this._y=e,this._z=i,this._w=n}static slerpFlat(t,e,i,n,s,r,a){let o=i[n+0],l=i[n+1],h=i[n+2],c=i[n+3];const u=s[r+0],d=s[r+1],p=s[r+2],m=s[r+3];if(0===a)return t[e+0]=o,t[e+1]=l,t[e+2]=h,void(t[e+3]=c);if(1===a)return t[e+0]=u,t[e+1]=d,t[e+2]=p,void(t[e+3]=m);if(c!==m||o!==u||l!==d||h!==p){let t=1-a;const e=o*u+l*d+h*p+c*m,i=e>=0?1:-1,n=1-e*e;if(n>Number.EPSILON){const s=Math.sqrt(n),r=Math.atan2(s,e*i);t=Math.sin(t*r)/s,a=Math.sin(a*r)/s}const s=a*i;if(o=o*t+u*s,l=l*t+d*s,h=h*t+p*s,c=c*t+m*s,t===1-a){const t=1/Math.sqrt(o*o+l*l+h*h+c*c);o*=t,l*=t,h*=t,c*=t}}t[e]=o,t[e+1]=l,t[e+2]=h,t[e+3]=c}static multiplyQuaternionsFlat(t,e,i,n,s,r){const a=i[n],o=i[n+1],l=i[n+2],h=i[n+3],c=s[r],u=s[r+1],d=s[r+2],p=s[r+3];return t[e]=a*p+h*c+o*d-l*u,t[e+1]=o*p+h*u+l*c-a*d,t[e+2]=l*p+h*d+a*u-o*c,t[e+3]=h*p-a*c-o*u-l*d,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,i,n){return this._x=t,this._y=e,this._z=i,this._w=n,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e=!0){const i=t._x,n=t._y,s=t._z,r=t._order,a=Math.cos,o=Math.sin,l=a(i/2),h=a(n/2),c=a(s/2),u=o(i/2),d=o(n/2),p=o(s/2);switch(r){case"XYZ":this._x=u*h*c+l*d*p,this._y=l*d*c-u*h*p,this._z=l*h*p+u*d*c,this._w=l*h*c-u*d*p;break;case"YXZ":this._x=u*h*c+l*d*p,this._y=l*d*c-u*h*p,this._z=l*h*p-u*d*c,this._w=l*h*c+u*d*p;break;case"ZXY":this._x=u*h*c-l*d*p,this._y=l*d*c+u*h*p,this._z=l*h*p+u*d*c,this._w=l*h*c-u*d*p;break;case"ZYX":this._x=u*h*c-l*d*p,this._y=l*d*c+u*h*p,this._z=l*h*p-u*d*c,this._w=l*h*c+u*d*p;break;case"YZX":this._x=u*h*c+l*d*p,this._y=l*d*c+u*h*p,this._z=l*h*p-u*d*c,this._w=l*h*c-u*d*p;break;case"XZY":this._x=u*h*c-l*d*p,this._y=l*d*c-u*h*p,this._z=l*h*p+u*d*c,this._w=l*h*c+u*d*p}return!0===e&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const i=e/2,n=Math.sin(i);return this._x=t.x*n,this._y=t.y*n,this._z=t.z*n,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,i=e[0],n=e[4],s=e[8],r=e[1],a=e[5],o=e[9],l=e[2],h=e[6],c=e[10],u=i+a+c;if(u>0){const t=.5/Math.sqrt(u+1);this._w=.25/t,this._x=(h-o)*t,this._y=(s-l)*t,this._z=(r-n)*t}else if(i>a&&i>c){const t=2*Math.sqrt(1+i-a-c);this._w=(h-o)/t,this._x=.25*t,this._y=(n+r)/t,this._z=(s+l)/t}else if(a>c){const t=2*Math.sqrt(1+a-i-c);this._w=(s-l)/t,this._x=(n+r)/t,this._y=.25*t,this._z=(o+h)/t}else{const t=2*Math.sqrt(1+c-i-a);this._w=(r-n)/t,this._x=(s+l)/t,this._y=(o+h)/t,this._z=.25*t}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let i=t.dot(e)+1;return i<Number.EPSILON?(i=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=i):(this._x=0,this._y=-t.z,this._z=t.y,this._w=i)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=i),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(Ne(this.dot(t),-1,1)))}rotateTowards(t,e){const i=this.angleTo(t);if(0===i)return this;const n=Math.min(1,e/i);return this.slerp(t,n),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const i=t._x,n=t._y,s=t._z,r=t._w,a=e._x,o=e._y,l=e._z,h=e._w;return this._x=i*h+r*a+n*l-s*o,this._y=n*h+r*o+s*a-i*l,this._z=s*h+r*l+i*o-n*a,this._w=r*h-i*a-n*o-s*l,this._onChangeCallback(),this}slerp(t,e){if(0===e)return this;if(1===e)return this.copy(t);const i=this._x,n=this._y,s=this._z,r=this._w;let a=r*t._w+i*t._x+n*t._y+s*t._z;if(a<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,a=-a):this.copy(t),a>=1)return this._w=r,this._x=i,this._y=n,this._z=s,this;const o=1-a*a;if(o<=Number.EPSILON){const t=1-e;return this._w=t*r+e*this._w,this._x=t*i+e*this._x,this._y=t*n+e*this._y,this._z=t*s+e*this._z,this.normalize(),this}const l=Math.sqrt(o),h=Math.atan2(l,a),c=Math.sin((1-e)*h)/l,u=Math.sin(e*h)/l;return this._w=r*c+this._w*u,this._x=i*c+this._x*u,this._y=n*c+this._y*u,this._z=s*c+this._z*u,this._onChangeCallback(),this}slerpQuaternions(t,e,i){return this.copy(t).slerp(e,i)}random(){const t=2*Math.PI*Math.random(),e=2*Math.PI*Math.random(),i=Math.random(),n=Math.sqrt(1-i),s=Math.sqrt(i);return this.set(n*Math.sin(t),n*Math.cos(t),s*Math.sin(e),s*Math.cos(e))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}},ui=class t{constructor(e=0,i=0,n=0){t.prototype.isVector3=!0,this.x=e,this.y=i,this.z=n}set(t,e,i){return void 0===i&&(i=this.z),this.x=t,this.y=e,this.z=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return this.applyQuaternion(pi.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(pi.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,i=this.y,n=this.z,s=t.elements;return this.x=s[0]*e+s[3]*i+s[6]*n,this.y=s[1]*e+s[4]*i+s[7]*n,this.z=s[2]*e+s[5]*i+s[8]*n,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,i=this.y,n=this.z,s=t.elements,r=1/(s[3]*e+s[7]*i+s[11]*n+s[15]);return this.x=(s[0]*e+s[4]*i+s[8]*n+s[12])*r,this.y=(s[1]*e+s[5]*i+s[9]*n+s[13])*r,this.z=(s[2]*e+s[6]*i+s[10]*n+s[14])*r,this}applyQuaternion(t){const e=this.x,i=this.y,n=this.z,s=t.x,r=t.y,a=t.z,o=t.w,l=2*(r*n-a*i),h=2*(a*e-s*n),c=2*(s*i-r*e);return this.x=e+o*l+r*c-a*h,this.y=i+o*h+a*l-s*c,this.z=n+o*c+s*h-r*l,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,i=this.y,n=this.z,s=t.elements;return this.x=s[0]*e+s[4]*i+s[8]*n,this.y=s[1]*e+s[5]*i+s[9]*n,this.z=s[2]*e+s[6]*i+s[10]*n,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this.z=t.z+(e.z-t.z)*i,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,e){const i=t.x,n=t.y,s=t.z,r=e.x,a=e.y,o=e.z;return this.x=n*o-s*a,this.y=s*r-i*o,this.z=i*a-n*r,this}projectOnVector(t){const e=t.lengthSq();if(0===e)return this.set(0,0,0);const i=t.dot(this)/e;return this.copy(t).multiplyScalar(i)}projectOnPlane(t){return di.copy(this).projectOnVector(t),this.sub(di)}reflect(t){return this.sub(di.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const i=this.dot(t)/e;return Math.acos(Ne(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,i=this.y-t.y,n=this.z-t.z;return e*e+i*i+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,i){const n=Math.sin(e)*t;return this.x=n*Math.sin(i),this.y=Math.cos(e)*t,this.z=n*Math.cos(i),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,i){return this.x=t*Math.sin(e),this.y=i,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),i=this.setFromMatrixColumn(t,1).length(),n=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=i,this.z=n,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,4*e)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,3*e)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}setFromColor(t){return this.x=t.r,this.y=t.g,this.z=t.b,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=Math.random()*Math.PI*2,e=2*Math.random()-1,i=Math.sqrt(1-e*e);return this.x=i*Math.cos(t),this.y=e,this.z=i*Math.sin(t),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}};const di=new ui,pi=new ci;let mi=class{constructor(t=new ui(1/0,1/0,1/0),e=new ui(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){this.makeEmpty();for(let e=0,i=t.length;e<i;e+=3)this.expandByPoint(gi.fromArray(t,e));return this}setFromBufferAttribute(t){this.makeEmpty();for(let e=0,i=t.count;e<i;e++)this.expandByPoint(gi.fromBufferAttribute(t,e));return this}setFromPoints(t){this.makeEmpty();for(let e=0,i=t.length;e<i;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const i=gi.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(i),this.max.copy(t).add(i),this}setFromObject(t,e=!1){return this.makeEmpty(),this.expandByObject(t,e)}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,e=!1){t.updateWorldMatrix(!1,!1);const i=t.geometry;if(void 0!==i){const n=i.getAttribute("position");if(!0===e&&void 0!==n&&!0!==t.isInstancedMesh)for(let e=0,i=n.count;e<i;e++)!0===t.isMesh?t.getVertexPosition(e,gi):gi.fromBufferAttribute(n,e),gi.applyMatrix4(t.matrixWorld),this.expandByPoint(gi);else void 0!==t.boundingBox?(null===t.boundingBox&&t.computeBoundingBox(),xi.copy(t.boundingBox)):(null===i.boundingBox&&i.computeBoundingBox(),xi.copy(i.boundingBox)),xi.applyMatrix4(t.matrixWorld),this.union(xi)}const n=t.children;for(let s=0,r=n.length;s<r;s++)this.expandByObject(n[s],e);return this}containsPoint(t){return t.x>=this.min.x&&t.x<=this.max.x&&t.y>=this.min.y&&t.y<=this.max.y&&t.z>=this.min.z&&t.z<=this.max.z}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return t.max.x>=this.min.x&&t.min.x<=this.max.x&&t.max.y>=this.min.y&&t.min.y<=this.max.y&&t.max.z>=this.min.z&&t.min.z<=this.max.z}intersectsSphere(t){return this.clampPoint(t.center,gi),gi.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,i;return t.normal.x>0?(e=t.normal.x*this.min.x,i=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,i=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,i+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,i+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,i+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,i+=t.normal.z*this.min.z),e<=-t.constant&&i>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(Ti),wi.subVectors(this.max,Ti),vi.subVectors(t.a,Ti),_i.subVectors(t.b,Ti),yi.subVectors(t.c,Ti),bi.subVectors(_i,vi),Si.subVectors(yi,_i),Mi.subVectors(vi,yi);let e=[0,-bi.z,bi.y,0,-Si.z,Si.y,0,-Mi.z,Mi.y,bi.z,0,-bi.x,Si.z,0,-Si.x,Mi.z,0,-Mi.x,-bi.y,bi.x,0,-Si.y,Si.x,0,-Mi.y,Mi.x,0];return!!Ci(e,vi,_i,yi,wi)&&(e=[1,0,0,0,1,0,0,0,1],!!Ci(e,vi,_i,yi,wi)&&(Ai.crossVectors(bi,Si),e=[Ai.x,Ai.y,Ai.z],Ci(e,vi,_i,yi,wi)))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return this.clampPoint(t,gi).distanceTo(t)}getBoundingSphere(t){return this.isEmpty()?t.makeEmpty():(this.getCenter(t.center),t.radius=.5*this.getSize(gi).length()),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()||(fi[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),fi[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),fi[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),fi[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),fi[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),fi[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),fi[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),fi[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(fi)),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}};const fi=[new ui,new ui,new ui,new ui,new ui,new ui,new ui,new ui],gi=new ui,xi=new mi,vi=new ui,_i=new ui,yi=new ui,bi=new ui,Si=new ui,Mi=new ui,Ti=new ui,wi=new ui,Ai=new ui,Ei=new ui;function Ci(t,e,i,n,s){for(let r=0,a=t.length-3;r<=a;r+=3){Ei.fromArray(t,r);const a=s.x*Math.abs(Ei.x)+s.y*Math.abs(Ei.y)+s.z*Math.abs(Ei.z),o=e.dot(Ei),l=i.dot(Ei),h=n.dot(Ei);if(Math.max(-Math.max(o,l,h),Math.min(o,l,h))>a)return!1}return!0}const Ri=new mi,Ni=new ui,Pi=new ui;let Ii=class{constructor(t=new ui,e=-1){this.isSphere=!0,this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const i=this.center;void 0!==e?i.copy(e):Ri.setFromPoints(t).getCenter(i);let n=0;for(let s=0,r=t.length;s<r;s++)n=Math.max(n,i.distanceToSquared(t[s]));return this.radius=Math.sqrt(n),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const i=this.center.distanceToSquared(t);return e.copy(t),i>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){if(this.isEmpty())return this.center.copy(t),this.radius=0,this;Ni.subVectors(t,this.center);const e=Ni.lengthSq();if(e>this.radius*this.radius){const t=Math.sqrt(e),i=.5*(t-this.radius);this.center.addScaledVector(Ni,i/t),this.radius+=i}return this}union(t){return t.isEmpty()?this:this.isEmpty()?(this.copy(t),this):(!0===this.center.equals(t.center)?this.radius=Math.max(this.radius,t.radius):(Pi.subVectors(t.center,this.center).setLength(t.radius),this.expandByPoint(Ni.copy(t.center).add(Pi)),this.expandByPoint(Ni.copy(t.center).sub(Pi))),this)}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return(new this.constructor).copy(this)}};const Li=new ui,Di=new ui,Ui=new ui,Fi=new ui,Bi=new ui,Oi=new ui,zi=new ui;let ki=class{constructor(t=new ui,e=new ui(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.origin).addScaledVector(this.direction,t)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,Li)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const i=e.dot(this.direction);return i<0?e.copy(this.origin):e.copy(this.origin).addScaledVector(this.direction,i)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=Li.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(Li.copy(this.origin).addScaledVector(this.direction,e),Li.distanceToSquared(t))}distanceSqToSegment(t,e,i,n){Di.copy(t).add(e).multiplyScalar(.5),Ui.copy(e).sub(t).normalize(),Fi.copy(this.origin).sub(Di);const s=.5*t.distanceTo(e),r=-this.direction.dot(Ui),a=Fi.dot(this.direction),o=-Fi.dot(Ui),l=Fi.lengthSq(),h=Math.abs(1-r*r);let c,u,d,p;if(h>0)if(c=r*o-a,u=r*a-o,p=s*h,c>=0)if(u>=-p)if(u<=p){const t=1/h;c*=t,u*=t,d=c*(c+r*u+2*a)+u*(r*c+u+2*o)+l}else u=s,c=Math.max(0,-(r*u+a)),d=-c*c+u*(u+2*o)+l;else u=-s,c=Math.max(0,-(r*u+a)),d=-c*c+u*(u+2*o)+l;else u<=-p?(c=Math.max(0,-(-r*s+a)),u=c>0?-s:Math.min(Math.max(-s,-o),s),d=-c*c+u*(u+2*o)+l):u<=p?(c=0,u=Math.min(Math.max(-s,-o),s),d=u*(u+2*o)+l):(c=Math.max(0,-(r*s+a)),u=c>0?s:Math.min(Math.max(-s,-o),s),d=-c*c+u*(u+2*o)+l);else u=r>0?-s:s,c=Math.max(0,-(r*u+a)),d=-c*c+u*(u+2*o)+l;return i&&i.copy(this.origin).addScaledVector(this.direction,c),n&&n.copy(Di).addScaledVector(Ui,u),d}intersectSphere(t,e){Li.subVectors(t.center,this.origin);const i=Li.dot(this.direction),n=Li.dot(Li)-i*i,s=t.radius*t.radius;if(n>s)return null;const r=Math.sqrt(s-n),a=i-r,o=i+r;return o<0?null:a<0?this.at(o,e):this.at(a,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(0===e)return 0===t.distanceToPoint(this.origin)?0:null;const i=-(this.origin.dot(t.normal)+t.constant)/e;return i>=0?i:null}intersectPlane(t,e){const i=this.distanceToPlane(t);return null===i?null:this.at(i,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);if(0===e)return!0;return t.normal.dot(this.direction)*e<0}intersectBox(t,e){let i,n,s,r,a,o;const l=1/this.direction.x,h=1/this.direction.y,c=1/this.direction.z,u=this.origin;return l>=0?(i=(t.min.x-u.x)*l,n=(t.max.x-u.x)*l):(i=(t.max.x-u.x)*l,n=(t.min.x-u.x)*l),h>=0?(s=(t.min.y-u.y)*h,r=(t.max.y-u.y)*h):(s=(t.max.y-u.y)*h,r=(t.min.y-u.y)*h),i>r||s>n?null:((s>i||isNaN(i))&&(i=s),(r<n||isNaN(n))&&(n=r),c>=0?(a=(t.min.z-u.z)*c,o=(t.max.z-u.z)*c):(a=(t.max.z-u.z)*c,o=(t.min.z-u.z)*c),i>o||a>n?null:((a>i||i!=i)&&(i=a),(o<n||n!=n)&&(n=o),n<0?null:this.at(i>=0?i:n,e)))}intersectsBox(t){return null!==this.intersectBox(t,Li)}intersectTriangle(t,e,i,n,s){Bi.subVectors(e,t),Oi.subVectors(i,t),zi.crossVectors(Bi,Oi);let r,a=this.direction.dot(zi);if(a>0){if(n)return null;r=1}else{if(!(a<0))return null;r=-1,a=-a}Fi.subVectors(this.origin,t);const o=r*this.direction.dot(Oi.crossVectors(Fi,Oi));if(o<0)return null;const l=r*this.direction.dot(Bi.cross(Fi));if(l<0)return null;if(o+l>a)return null;const h=-r*Fi.dot(zi);return h<0?null:this.at(h/a,s)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}},Vi=class t{constructor(e,i,n,s,r,a,o,l,h,c,u,d,p,m,f,g){t.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],void 0!==e&&this.set(e,i,n,s,r,a,o,l,h,c,u,d,p,m,f,g)}set(t,e,i,n,s,r,a,o,l,h,c,u,d,p,m,f){const g=this.elements;return g[0]=t,g[4]=e,g[8]=i,g[12]=n,g[1]=s,g[5]=r,g[9]=a,g[13]=o,g[2]=l,g[6]=h,g[10]=c,g[14]=u,g[3]=d,g[7]=p,g[11]=m,g[15]=f,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new t).fromArray(this.elements)}copy(t){const e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],e[9]=i[9],e[10]=i[10],e[11]=i[11],e[12]=i[12],e[13]=i[13],e[14]=i[14],e[15]=i[15],this}copyPosition(t){const e=this.elements,i=t.elements;return e[12]=i[12],e[13]=i[13],e[14]=i[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,i){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(t,e,i){return this.set(t.x,e.x,i.x,0,t.y,e.y,i.y,0,t.z,e.z,i.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,i=t.elements,n=1/Gi.setFromMatrixColumn(t,0).length(),s=1/Gi.setFromMatrixColumn(t,1).length(),r=1/Gi.setFromMatrixColumn(t,2).length();return e[0]=i[0]*n,e[1]=i[1]*n,e[2]=i[2]*n,e[3]=0,e[4]=i[4]*s,e[5]=i[5]*s,e[6]=i[6]*s,e[7]=0,e[8]=i[8]*r,e[9]=i[9]*r,e[10]=i[10]*r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){const e=this.elements,i=t.x,n=t.y,s=t.z,r=Math.cos(i),a=Math.sin(i),o=Math.cos(n),l=Math.sin(n),h=Math.cos(s),c=Math.sin(s);if("XYZ"===t.order){const t=r*h,i=r*c,n=a*h,s=a*c;e[0]=o*h,e[4]=-o*c,e[8]=l,e[1]=i+n*l,e[5]=t-s*l,e[9]=-a*o,e[2]=s-t*l,e[6]=n+i*l,e[10]=r*o}else if("YXZ"===t.order){const t=o*h,i=o*c,n=l*h,s=l*c;e[0]=t+s*a,e[4]=n*a-i,e[8]=r*l,e[1]=r*c,e[5]=r*h,e[9]=-a,e[2]=i*a-n,e[6]=s+t*a,e[10]=r*o}else if("ZXY"===t.order){const t=o*h,i=o*c,n=l*h,s=l*c;e[0]=t-s*a,e[4]=-r*c,e[8]=n+i*a,e[1]=i+n*a,e[5]=r*h,e[9]=s-t*a,e[2]=-r*l,e[6]=a,e[10]=r*o}else if("ZYX"===t.order){const t=r*h,i=r*c,n=a*h,s=a*c;e[0]=o*h,e[4]=n*l-i,e[8]=t*l+s,e[1]=o*c,e[5]=s*l+t,e[9]=i*l-n,e[2]=-l,e[6]=a*o,e[10]=r*o}else if("YZX"===t.order){const t=r*o,i=r*l,n=a*o,s=a*l;e[0]=o*h,e[4]=s-t*c,e[8]=n*c+i,e[1]=c,e[5]=r*h,e[9]=-a*h,e[2]=-l*h,e[6]=i*c+n,e[10]=t-s*c}else if("XZY"===t.order){const t=r*o,i=r*l,n=a*o,s=a*l;e[0]=o*h,e[4]=-c,e[8]=l*h,e[1]=t*c+s,e[5]=r*h,e[9]=i*c-n,e[2]=n*c-i,e[6]=a*h,e[10]=s*c+t}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(Wi,t,ji)}lookAt(t,e,i){const n=this.elements;return $i.subVectors(t,e),0===$i.lengthSq()&&($i.z=1),$i.normalize(),Xi.crossVectors(i,$i),0===Xi.lengthSq()&&(1===Math.abs(i.z)?$i.x+=1e-4:$i.z+=1e-4,$i.normalize(),Xi.crossVectors(i,$i)),Xi.normalize(),qi.crossVectors($i,Xi),n[0]=Xi.x,n[4]=qi.x,n[8]=$i.x,n[1]=Xi.y,n[5]=qi.y,n[9]=$i.y,n[2]=Xi.z,n[6]=qi.z,n[10]=$i.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const i=t.elements,n=e.elements,s=this.elements,r=i[0],a=i[4],o=i[8],l=i[12],h=i[1],c=i[5],u=i[9],d=i[13],p=i[2],m=i[6],f=i[10],g=i[14],x=i[3],v=i[7],_=i[11],y=i[15],b=n[0],S=n[4],M=n[8],T=n[12],w=n[1],A=n[5],E=n[9],C=n[13],R=n[2],N=n[6],P=n[10],I=n[14],L=n[3],D=n[7],U=n[11],F=n[15];return s[0]=r*b+a*w+o*R+l*L,s[4]=r*S+a*A+o*N+l*D,s[8]=r*M+a*E+o*P+l*U,s[12]=r*T+a*C+o*I+l*F,s[1]=h*b+c*w+u*R+d*L,s[5]=h*S+c*A+u*N+d*D,s[9]=h*M+c*E+u*P+d*U,s[13]=h*T+c*C+u*I+d*F,s[2]=p*b+m*w+f*R+g*L,s[6]=p*S+m*A+f*N+g*D,s[10]=p*M+m*E+f*P+g*U,s[14]=p*T+m*C+f*I+g*F,s[3]=x*b+v*w+_*R+y*L,s[7]=x*S+v*A+_*N+y*D,s[11]=x*M+v*E+_*P+y*U,s[15]=x*T+v*C+_*I+y*F,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],i=t[4],n=t[8],s=t[12],r=t[1],a=t[5],o=t[9],l=t[13],h=t[2],c=t[6],u=t[10],d=t[14];return t[3]*(+s*o*c-n*l*c-s*a*u+i*l*u+n*a*d-i*o*d)+t[7]*(+e*o*d-e*l*u+s*r*u-n*r*d+n*l*h-s*o*h)+t[11]*(+e*l*c-e*a*d-s*r*c+i*r*d+s*a*h-i*l*h)+t[15]*(-n*a*h-e*o*c+e*a*u+n*r*c-i*r*u+i*o*h)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,i){const n=this.elements;return t.isVector3?(n[12]=t.x,n[13]=t.y,n[14]=t.z):(n[12]=t,n[13]=e,n[14]=i),this}invert(){const t=this.elements,e=t[0],i=t[1],n=t[2],s=t[3],r=t[4],a=t[5],o=t[6],l=t[7],h=t[8],c=t[9],u=t[10],d=t[11],p=t[12],m=t[13],f=t[14],g=t[15],x=c*f*l-m*u*l+m*o*d-a*f*d-c*o*g+a*u*g,v=p*u*l-h*f*l-p*o*d+r*f*d+h*o*g-r*u*g,_=h*m*l-p*c*l+p*a*d-r*m*d-h*a*g+r*c*g,y=p*c*o-h*m*o-p*a*u+r*m*u+h*a*f-r*c*f,b=e*x+i*v+n*_+s*y;if(0===b)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const S=1/b;return t[0]=x*S,t[1]=(m*u*s-c*f*s-m*n*d+i*f*d+c*n*g-i*u*g)*S,t[2]=(a*f*s-m*o*s+m*n*l-i*f*l-a*n*g+i*o*g)*S,t[3]=(c*o*s-a*u*s-c*n*l+i*u*l+a*n*d-i*o*d)*S,t[4]=v*S,t[5]=(h*f*s-p*u*s+p*n*d-e*f*d-h*n*g+e*u*g)*S,t[6]=(p*o*s-r*f*s-p*n*l+e*f*l+r*n*g-e*o*g)*S,t[7]=(r*u*s-h*o*s+h*n*l-e*u*l-r*n*d+e*o*d)*S,t[8]=_*S,t[9]=(p*c*s-h*m*s-p*i*d+e*m*d+h*i*g-e*c*g)*S,t[10]=(r*m*s-p*a*s+p*i*l-e*m*l-r*i*g+e*a*g)*S,t[11]=(h*a*s-r*c*s-h*i*l+e*c*l+r*i*d-e*a*d)*S,t[12]=y*S,t[13]=(h*m*n-p*c*n+p*i*u-e*m*u-h*i*f+e*c*f)*S,t[14]=(p*a*n-r*m*n-p*i*o+e*m*o+r*i*f-e*a*f)*S,t[15]=(r*c*n-h*a*n+h*i*o-e*c*o-r*i*u+e*a*u)*S,this}scale(t){const e=this.elements,i=t.x,n=t.y,s=t.z;return e[0]*=i,e[4]*=n,e[8]*=s,e[1]*=i,e[5]*=n,e[9]*=s,e[2]*=i,e[6]*=n,e[10]*=s,e[3]*=i,e[7]*=n,e[11]*=s,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],i=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],n=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,i,n))}makeTranslation(t,e,i){return t.isVector3?this.set(1,0,0,t.x,0,1,0,t.y,0,0,1,t.z,0,0,0,1):this.set(1,0,0,t,0,1,0,e,0,0,1,i,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),i=Math.sin(t);return this.set(1,0,0,0,0,e,-i,0,0,i,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,0,i,0,0,1,0,0,-i,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,-i,0,0,i,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const i=Math.cos(e),n=Math.sin(e),s=1-i,r=t.x,a=t.y,o=t.z,l=s*r,h=s*a;return this.set(l*r+i,l*a-n*o,l*o+n*a,0,l*a+n*o,h*a+i,h*o-n*r,0,l*o-n*a,h*o+n*r,s*o*o+i,0,0,0,0,1),this}makeScale(t,e,i){return this.set(t,0,0,0,0,e,0,0,0,0,i,0,0,0,0,1),this}makeShear(t,e,i,n,s,r){return this.set(1,i,s,0,t,1,r,0,e,n,1,0,0,0,0,1),this}compose(t,e,i){const n=this.elements,s=e._x,r=e._y,a=e._z,o=e._w,l=s+s,h=r+r,c=a+a,u=s*l,d=s*h,p=s*c,m=r*h,f=r*c,g=a*c,x=o*l,v=o*h,_=o*c,y=i.x,b=i.y,S=i.z;return n[0]=(1-(m+g))*y,n[1]=(d+_)*y,n[2]=(p-v)*y,n[3]=0,n[4]=(d-_)*b,n[5]=(1-(u+g))*b,n[6]=(f+x)*b,n[7]=0,n[8]=(p+v)*S,n[9]=(f-x)*S,n[10]=(1-(u+m))*S,n[11]=0,n[12]=t.x,n[13]=t.y,n[14]=t.z,n[15]=1,this}decompose(t,e,i){const n=this.elements;let s=Gi.set(n[0],n[1],n[2]).length();const r=Gi.set(n[4],n[5],n[6]).length(),a=Gi.set(n[8],n[9],n[10]).length();this.determinant()<0&&(s=-s),t.x=n[12],t.y=n[13],t.z=n[14],Hi.copy(this);const o=1/s,l=1/r,h=1/a;return Hi.elements[0]*=o,Hi.elements[1]*=o,Hi.elements[2]*=o,Hi.elements[4]*=l,Hi.elements[5]*=l,Hi.elements[6]*=l,Hi.elements[8]*=h,Hi.elements[9]*=h,Hi.elements[10]*=h,e.setFromRotationMatrix(Hi),i.x=s,i.y=r,i.z=a,this}makePerspective(t,e,i,n,s,r,a=2e3){const o=this.elements,l=2*s/(e-t),h=2*s/(i-n),c=(e+t)/(e-t),u=(i+n)/(i-n);let d,p;if(a===Se)d=-(r+s)/(r-s),p=-2*r*s/(r-s);else{if(a!==Me)throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+a);d=-r/(r-s),p=-r*s/(r-s)}return o[0]=l,o[4]=0,o[8]=c,o[12]=0,o[1]=0,o[5]=h,o[9]=u,o[13]=0,o[2]=0,o[6]=0,o[10]=d,o[14]=p,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this}makeOrthographic(t,e,i,n,s,r,a=2e3){const o=this.elements,l=1/(e-t),h=1/(i-n),c=1/(r-s),u=(e+t)*l,d=(i+n)*h;let p,m;if(a===Se)p=(r+s)*c,m=-2*c;else{if(a!==Me)throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+a);p=s*c,m=-1*c}return o[0]=2*l,o[4]=0,o[8]=0,o[12]=-u,o[1]=0,o[5]=2*h,o[9]=0,o[13]=-d,o[2]=0,o[6]=0,o[10]=m,o[14]=-p,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}equals(t){const e=this.elements,i=t.elements;for(let n=0;n<16;n++)if(e[n]!==i[n])return!1;return!0}fromArray(t,e=0){for(let i=0;i<16;i++)this.elements[i]=t[i+e];return this}toArray(t=[],e=0){const i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t[e+9]=i[9],t[e+10]=i[10],t[e+11]=i[11],t[e+12]=i[12],t[e+13]=i[13],t[e+14]=i[14],t[e+15]=i[15],t}};const Gi=new ui,Hi=new Vi,Wi=new ui(0,0,0),ji=new ui(1,1,1),Xi=new ui,qi=new ui,$i=new ui,Yi=new Vi,Zi=new ci;let Ki=class t{constructor(e=0,i=0,n=0,s=t.DEFAULT_ORDER){this.isEuler=!0,this._x=e,this._y=i,this._z=n,this._order=s}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,i,n=this._order){return this._x=t,this._y=e,this._z=i,this._order=n,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,i=!0){const n=t.elements,s=n[0],r=n[4],a=n[8],o=n[1],l=n[5],h=n[9],c=n[2],u=n[6],d=n[10];switch(e){case"XYZ":this._y=Math.asin(Ne(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-h,d),this._z=Math.atan2(-r,s)):(this._x=Math.atan2(u,l),this._z=0);break;case"YXZ":this._x=Math.asin(-Ne(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(a,d),this._z=Math.atan2(o,l)):(this._y=Math.atan2(-c,s),this._z=0);break;case"ZXY":this._x=Math.asin(Ne(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(-c,d),this._z=Math.atan2(-r,l)):(this._y=0,this._z=Math.atan2(o,s));break;case"ZYX":this._y=Math.asin(-Ne(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(u,d),this._z=Math.atan2(o,s)):(this._x=0,this._z=Math.atan2(-r,l));break;case"YZX":this._z=Math.asin(Ne(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-h,l),this._y=Math.atan2(-c,s)):(this._x=0,this._y=Math.atan2(a,d));break;case"XZY":this._z=Math.asin(-Ne(r,-1,1)),Math.abs(r)<.9999999?(this._x=Math.atan2(u,l),this._y=Math.atan2(a,s)):(this._x=Math.atan2(-h,d),this._y=0)}return this._order=e,!0===i&&this._onChangeCallback(),this}setFromQuaternion(t,e,i){return Yi.makeRotationFromQuaternion(t),this.setFromRotationMatrix(Yi,e,i)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return Zi.setFromEuler(this),this.setFromQuaternion(Zi,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],void 0!==t[3]&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}};Ki.DEFAULT_ORDER="XYZ";let Ji=class{constructor(){this.mask=1}set(t){this.mask=1<<t>>>0}enable(t){this.mask|=1<<t}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t}disable(t){this.mask&=~(1<<t)}disableAll(){this.mask=0}test(t){return!!(this.mask&t.mask)}isEnabled(t){return!!(this.mask&1<<t)}},Qi=0;const tn=new ui,en=new ci,nn=new Vi,sn=new ui,rn=new ui,an=new ui,on=new ci,ln=new ui(1,0,0),hn=new ui(0,1,0),cn=new ui(0,0,1),un={type:"added"},dn={type:"removed"},pn={type:"childadded",child:null},mn={type:"childremoved",child:null};let fn=class t extends Te{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:Qi++}),this.uuid=Re(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=t.DEFAULT_UP.clone();const e=new ui,i=new Ki,n=new ci,s=new ui(1,1,1);i._onChange((function(){n.setFromEuler(i,!1)})),n._onChange((function(){i.setFromQuaternion(n,void 0,!1)})),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:i},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:s},modelViewMatrix:{value:new Vi},normalMatrix:{value:new Be}}),this.matrix=new Vi,this.matrixWorld=new Vi,this.matrixAutoUpdate=t.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=t.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new Ji,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return en.setFromAxisAngle(t,e),this.quaternion.multiply(en),this}rotateOnWorldAxis(t,e){return en.setFromAxisAngle(t,e),this.quaternion.premultiply(en),this}rotateX(t){return this.rotateOnAxis(ln,t)}rotateY(t){return this.rotateOnAxis(hn,t)}rotateZ(t){return this.rotateOnAxis(cn,t)}translateOnAxis(t,e){return tn.copy(t).applyQuaternion(this.quaternion),this.position.add(tn.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(ln,t)}translateY(t){return this.translateOnAxis(hn,t)}translateZ(t){return this.translateOnAxis(cn,t)}localToWorld(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(nn.copy(this.matrixWorld).invert())}lookAt(t,e,i){t.isVector3?sn.copy(t):sn.set(t,e,i);const n=this.parent;this.updateWorldMatrix(!0,!1),rn.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?nn.lookAt(rn,sn,this.up):nn.lookAt(sn,rn,this.up),this.quaternion.setFromRotationMatrix(nn),n&&(nn.extractRotation(n.matrixWorld),en.setFromRotationMatrix(nn),this.quaternion.premultiply(en.invert()))}add(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return t===this||t&&t.isObject3D&&(t.removeFromParent(),t.parent=this,this.children.push(t),t.dispatchEvent(un),pn.child=t,this.dispatchEvent(pn),pn.child=null),this}remove(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}const e=this.children.indexOf(t);return-1!==e&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(dn),mn.child=t,this.dispatchEvent(mn),mn.child=null),this}removeFromParent(){const t=this.parent;return null!==t&&t.remove(this),this}clear(){return this.remove(...this.children)}attach(t){return this.updateWorldMatrix(!0,!1),nn.copy(this.matrixWorld).invert(),null!==t.parent&&(t.parent.updateWorldMatrix(!0,!1),nn.multiply(t.parent.matrixWorld)),t.applyMatrix4(nn),t.removeFromParent(),t.parent=this,this.children.push(t),t.updateWorldMatrix(!1,!0),t.dispatchEvent(un),pn.child=t,this.dispatchEvent(pn),pn.child=null,this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let i=0,n=this.children.length;i<n;i++){const n=this.children[i].getObjectByProperty(t,e);if(void 0!==n)return n}}getObjectsByProperty(t,e,i=[]){this[t]===e&&i.push(this);const n=this.children;for(let s=0,r=n.length;s<r;s++)n[s].getObjectsByProperty(t,e,i);return i}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(rn,t,an),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(rn,on,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let i=0,n=e.length;i<n;i++)e[i].traverse(t)}traverseVisible(t){if(!1===this.visible)return;t(this);const e=this.children;for(let i=0,n=e.length;i<n;i++)e[i].traverseVisible(t)}traverseAncestors(t){const e=this.parent;null!==e&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(!0===this.matrixWorldAutoUpdate&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let i=0,n=e.length;i<n;i++){e[i].updateMatrixWorld(t)}}updateWorldMatrix(t,e){const i=this.parent;if(!0===t&&null!==i&&i.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),!0===this.matrixWorldAutoUpdate&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),!0===e){const t=this.children;for(let e=0,i=t.length;e<i;e++){t[e].updateWorldMatrix(!1,!0)}}}toJSON(t){const e=void 0===t||"string"==typeof t,i={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},i.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const n={};function s(e,i){return void 0===e[i.uuid]&&(e[i.uuid]=i.toJSON(t)),i.uuid}if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),!0===this.castShadow&&(n.castShadow=!0),!0===this.receiveShadow&&(n.receiveShadow=!0),!1===this.visible&&(n.visible=!1),!1===this.frustumCulled&&(n.frustumCulled=!1),0!==this.renderOrder&&(n.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(n.userData=this.userData),n.layers=this.layers.mask,n.matrix=this.matrix.toArray(),n.up=this.up.toArray(),!1===this.matrixAutoUpdate&&(n.matrixAutoUpdate=!1),this.isInstancedMesh&&(n.type="InstancedMesh",n.count=this.count,n.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(n.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(n.type="BatchedMesh",n.perObjectFrustumCulled=this.perObjectFrustumCulled,n.sortObjects=this.sortObjects,n.drawRanges=this._drawRanges,n.reservedRanges=this._reservedRanges,n.visibility=this._visibility,n.active=this._active,n.bounds=this._bounds.map((t=>({boxInitialized:t.boxInitialized,boxMin:t.box.min.toArray(),boxMax:t.box.max.toArray(),sphereInitialized:t.sphereInitialized,sphereRadius:t.sphere.radius,sphereCenter:t.sphere.center.toArray()}))),n.maxInstanceCount=this._maxInstanceCount,n.maxVertexCount=this._maxVertexCount,n.maxIndexCount=this._maxIndexCount,n.geometryInitialized=this._geometryInitialized,n.geometryCount=this._geometryCount,n.matricesTexture=this._matricesTexture.toJSON(t),null!==this._colorsTexture&&(n.colorsTexture=this._colorsTexture.toJSON(t)),null!==this.boundingSphere&&(n.boundingSphere={center:n.boundingSphere.center.toArray(),radius:n.boundingSphere.radius}),null!==this.boundingBox&&(n.boundingBox={min:n.boundingBox.min.toArray(),max:n.boundingBox.max.toArray()})),this.isScene)this.background&&(this.background.isColor?n.background=this.background.toJSON():this.background.isTexture&&(n.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&!0!==this.environment.isRenderTargetTexture&&(n.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){n.geometry=s(t.geometries,this.geometry);const e=this.geometry.parameters;if(void 0!==e&&void 0!==e.shapes){const i=e.shapes;if(Array.isArray(i))for(let e=0,n=i.length;e<n;e++){const n=i[e];s(t.shapes,n)}else s(t.shapes,i)}}if(this.isSkinnedMesh&&(n.bindMode=this.bindMode,n.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(s(t.skeletons,this.skeleton),n.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const e=[];for(let i=0,n=this.material.length;i<n;i++)e.push(s(t.materials,this.material[i]));n.material=e}else n.material=s(t.materials,this.material);if(this.children.length>0){n.children=[];for(let e=0;e<this.children.length;e++)n.children.push(this.children[e].toJSON(t).object)}if(this.animations.length>0){n.animations=[];for(let e=0;e<this.animations.length;e++){const i=this.animations[e];n.animations.push(s(t.animations,i))}}if(e){const e=r(t.geometries),n=r(t.materials),s=r(t.textures),a=r(t.images),o=r(t.shapes),l=r(t.skeletons),h=r(t.animations),c=r(t.nodes);e.length>0&&(i.geometries=e),n.length>0&&(i.materials=n),s.length>0&&(i.textures=s),a.length>0&&(i.images=a),o.length>0&&(i.shapes=o),l.length>0&&(i.skeletons=l),h.length>0&&(i.animations=h),c.length>0&&(i.nodes=c)}return i.object=n,i;function r(t){const e=[];for(const i in t){const n=t[i];delete n.metadata,e.push(n)}return e}}clone(t){return(new this.constructor).copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldAutoUpdate=t.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.animations=t.animations.slice(),this.userData=JSON.parse(JSON.stringify(t.userData)),!0===e)for(let i=0;i<t.children.length;i++){const e=t.children[i];this.add(e.clone())}return this}};fn.DEFAULT_UP=new ui(0,1,0),fn.DEFAULT_MATRIX_AUTO_UPDATE=!0,fn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const gn=new ui,xn=new ui,vn=new ui,_n=new ui,yn=new ui,bn=new ui,Sn=new ui,Mn=new ui,Tn=new ui,wn=new ui,An=new ri,En=new ri,Cn=new ri;let Rn=class t{constructor(t=new ui,e=new ui,i=new ui){this.a=t,this.b=e,this.c=i}static getNormal(t,e,i,n){n.subVectors(i,e),gn.subVectors(t,e),n.cross(gn);const s=n.lengthSq();return s>0?n.multiplyScalar(1/Math.sqrt(s)):n.set(0,0,0)}static getBarycoord(t,e,i,n,s){gn.subVectors(n,e),xn.subVectors(i,e),vn.subVectors(t,e);const r=gn.dot(gn),a=gn.dot(xn),o=gn.dot(vn),l=xn.dot(xn),h=xn.dot(vn),c=r*l-a*a;if(0===c)return s.set(0,0,0),null;const u=1/c,d=(l*o-a*h)*u,p=(r*h-a*o)*u;return s.set(1-d-p,p,d)}static containsPoint(t,e,i,n){return null!==this.getBarycoord(t,e,i,n,_n)&&(_n.x>=0&&_n.y>=0&&_n.x+_n.y<=1)}static getInterpolation(t,e,i,n,s,r,a,o){return null===this.getBarycoord(t,e,i,n,_n)?(o.x=0,o.y=0,"z"in o&&(o.z=0),"w"in o&&(o.w=0),null):(o.setScalar(0),o.addScaledVector(s,_n.x),o.addScaledVector(r,_n.y),o.addScaledVector(a,_n.z),o)}static getInterpolatedAttribute(t,e,i,n,s,r){return An.setScalar(0),En.setScalar(0),Cn.setScalar(0),An.fromBufferAttribute(t,e),En.fromBufferAttribute(t,i),Cn.fromBufferAttribute(t,n),r.setScalar(0),r.addScaledVector(An,s.x),r.addScaledVector(En,s.y),r.addScaledVector(Cn,s.z),r}static isFrontFacing(t,e,i,n){return gn.subVectors(i,e),xn.subVectors(t,e),gn.cross(xn).dot(n)<0}set(t,e,i){return this.a.copy(t),this.b.copy(e),this.c.copy(i),this}setFromPointsAndIndices(t,e,i,n){return this.a.copy(t[e]),this.b.copy(t[i]),this.c.copy(t[n]),this}setFromAttributeAndIndices(t,e,i,n){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,i),this.c.fromBufferAttribute(t,n),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return gn.subVectors(this.c,this.b),xn.subVectors(this.a,this.b),.5*gn.cross(xn).length()}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return t.getNormal(this.a,this.b,this.c,e)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,i){return t.getBarycoord(e,this.a,this.b,this.c,i)}getInterpolation(e,i,n,s,r){return t.getInterpolation(e,this.a,this.b,this.c,i,n,s,r)}containsPoint(e){return t.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return t.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const i=this.a,n=this.b,s=this.c;let r,a;yn.subVectors(n,i),bn.subVectors(s,i),Mn.subVectors(t,i);const o=yn.dot(Mn),l=bn.dot(Mn);if(o<=0&&l<=0)return e.copy(i);Tn.subVectors(t,n);const h=yn.dot(Tn),c=bn.dot(Tn);if(h>=0&&c<=h)return e.copy(n);const u=o*c-h*l;if(u<=0&&o>=0&&h<=0)return r=o/(o-h),e.copy(i).addScaledVector(yn,r);wn.subVectors(t,s);const d=yn.dot(wn),p=bn.dot(wn);if(p>=0&&d<=p)return e.copy(s);const m=d*l-o*p;if(m<=0&&l>=0&&p<=0)return a=l/(l-p),e.copy(i).addScaledVector(bn,a);const f=h*p-d*c;if(f<=0&&c-h>=0&&d-p>=0)return Sn.subVectors(s,n),a=(c-h)/(c-h+(d-p)),e.copy(n).addScaledVector(Sn,a);const g=1/(f+m+u);return r=m*g,a=u*g,e.copy(i).addScaledVector(yn,r).addScaledVector(bn,a)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}};const Nn={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Pn={h:0,s:0,l:0},In={h:0,s:0,l:0};function Ln(t,e,i){return i<0&&(i+=1),i>1&&(i-=1),i<1/6?t+6*(e-t)*i:i<.5?e:i<2/3?t+6*(e-t)*(2/3-i):t}let Dn=class{constructor(t,e,i){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(t,e,i)}set(t,e,i){if(void 0===e&&void 0===i){const e=t;e&&e.isColor?this.copy(e):"number"==typeof e?this.setHex(e):"string"==typeof e&&this.setStyle(e)}else this.setRGB(t,e,i);return this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t,e=oe){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(255&t)/255,We.toWorkingColorSpace(this,e),this}setRGB(t,e,i,n=We.workingColorSpace){return this.r=t,this.g=e,this.b=i,We.toWorkingColorSpace(this,n),this}setHSL(t,e,i,n=We.workingColorSpace){if(t=Pe(t,1),e=Ne(e,0,1),i=Ne(i,0,1),0===e)this.r=this.g=this.b=i;else{const n=i<=.5?i*(1+e):i+e-i*e,s=2*i-n;this.r=Ln(s,n,t+1/3),this.g=Ln(s,n,t),this.b=Ln(s,n,t-1/3)}return We.toWorkingColorSpace(this,n),this}setStyle(t,e=oe){function i(t){void 0!==t&&parseFloat(t)}let n;if(n=/^(\w+)\(([^\)]*)\)/.exec(t)){let t;const s=n[1],r=n[2];switch(s){case"rgb":case"rgba":if(t=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))return i(t[4]),this.setRGB(Math.min(255,parseInt(t[1],10))/255,Math.min(255,parseInt(t[2],10))/255,Math.min(255,parseInt(t[3],10))/255,e);if(t=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))return i(t[4]),this.setRGB(Math.min(100,parseInt(t[1],10))/100,Math.min(100,parseInt(t[2],10))/100,Math.min(100,parseInt(t[3],10))/100,e);break;case"hsl":case"hsla":if(t=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))return i(t[4]),this.setHSL(parseFloat(t[1])/360,parseFloat(t[2])/100,parseFloat(t[3])/100,e)}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(t)){const t=n[1],i=t.length;if(3===i)return this.setRGB(parseInt(t.charAt(0),16)/15,parseInt(t.charAt(1),16)/15,parseInt(t.charAt(2),16)/15,e);if(6===i)return this.setHex(parseInt(t,16),e)}else if(t&&t.length>0)return this.setColorName(t,e);return this}setColorName(t,e=oe){const i=Nn[t.toLowerCase()];return void 0!==i&&this.setHex(i,e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=je(t.r),this.g=je(t.g),this.b=je(t.b),this}copyLinearToSRGB(t){return this.r=Xe(t.r),this.g=Xe(t.g),this.b=Xe(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(t=oe){return We.fromWorkingColorSpace(Un.copy(this),t),65536*Math.round(Ne(255*Un.r,0,255))+256*Math.round(Ne(255*Un.g,0,255))+Math.round(Ne(255*Un.b,0,255))}getHexString(t=oe){return("000000"+this.getHex(t).toString(16)).slice(-6)}getHSL(t,e=We.workingColorSpace){We.fromWorkingColorSpace(Un.copy(this),e);const i=Un.r,n=Un.g,s=Un.b,r=Math.max(i,n,s),a=Math.min(i,n,s);let o,l;const h=(a+r)/2;if(a===r)o=0,l=0;else{const t=r-a;switch(l=h<=.5?t/(r+a):t/(2-r-a),r){case i:o=(n-s)/t+(n<s?6:0);break;case n:o=(s-i)/t+2;break;case s:o=(i-n)/t+4}o/=6}return t.h=o,t.s=l,t.l=h,t}getRGB(t,e=We.workingColorSpace){return We.fromWorkingColorSpace(Un.copy(this),e),t.r=Un.r,t.g=Un.g,t.b=Un.b,t}getStyle(t=oe){We.fromWorkingColorSpace(Un.copy(this),t);const e=Un.r,i=Un.g,n=Un.b;return t!==oe?`color(${t} ${e.toFixed(3)} ${i.toFixed(3)} ${n.toFixed(3)})`:`rgb(${Math.round(255*e)},${Math.round(255*i)},${Math.round(255*n)})`}offsetHSL(t,e,i){return this.getHSL(Pn),this.setHSL(Pn.h+t,Pn.s+e,Pn.l+i)}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,i){return this.r=t.r+(e.r-t.r)*i,this.g=t.g+(e.g-t.g)*i,this.b=t.b+(e.b-t.b)*i,this}lerpHSL(t,e){this.getHSL(Pn),t.getHSL(In);const i=Ie(Pn.h,In.h,e),n=Ie(Pn.s,In.s,e),s=Ie(Pn.l,In.l,e);return this.setHSL(i,n,s),this}setFromVector3(t){return this.r=t.x,this.g=t.y,this.b=t.z,this}applyMatrix3(t){const e=this.r,i=this.g,n=this.b,s=t.elements;return this.r=s[0]*e+s[3]*i+s[6]*n,this.g=s[1]*e+s[4]*i+s[7]*n,this.b=s[2]*e+s[5]*i+s[8]*n,this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}};const Un=new Dn;Dn.NAMES=Nn;let Fn=0,Bn=class extends Te{static get type(){return"Material"}get type(){return this.constructor.type}set type(t){}constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:Fn++}),this.uuid=Re(),this.name="",this.blending=1,this.side=0,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=S,this.blendDst=M,this.blendEquation=f,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new Dn(0,0,0),this.blendAlpha=0,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=ue,this.stencilZFail=ue,this.stencilZPass=ue,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(void 0!==t)for(const e in t){const i=t[e];if(void 0===i)continue;const n=this[e];void 0!==n&&(n&&n.isColor?n.set(i):n&&n.isVector3&&i&&i.isVector3?n.copy(i):this[e]=i)}}toJSON(t){const e=void 0===t||"string"==typeof t;e&&(t={textures:{},images:{}});const i={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};function n(t){const e=[];for(const i in t){const n=t[i];delete n.metadata,e.push(n)}return e}if(i.uuid=this.uuid,i.type=this.type,""!==this.name&&(i.name=this.name),this.color&&this.color.isColor&&(i.color=this.color.getHex()),void 0!==this.roughness&&(i.roughness=this.roughness),void 0!==this.metalness&&(i.metalness=this.metalness),void 0!==this.sheen&&(i.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(i.sheenColor=this.sheenColor.getHex()),void 0!==this.sheenRoughness&&(i.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(i.emissive=this.emissive.getHex()),void 0!==this.emissiveIntensity&&1!==this.emissiveIntensity&&(i.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(i.specular=this.specular.getHex()),void 0!==this.specularIntensity&&(i.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(i.specularColor=this.specularColor.getHex()),void 0!==this.shininess&&(i.shininess=this.shininess),void 0!==this.clearcoat&&(i.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(i.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(i.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(i.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(i.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,i.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),void 0!==this.dispersion&&(i.dispersion=this.dispersion),void 0!==this.iridescence&&(i.iridescence=this.iridescence),void 0!==this.iridescenceIOR&&(i.iridescenceIOR=this.iridescenceIOR),void 0!==this.iridescenceThicknessRange&&(i.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(i.iridescenceMap=this.iridescenceMap.toJSON(t).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(i.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(t).uuid),void 0!==this.anisotropy&&(i.anisotropy=this.anisotropy),void 0!==this.anisotropyRotation&&(i.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(i.anisotropyMap=this.anisotropyMap.toJSON(t).uuid),this.map&&this.map.isTexture&&(i.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(i.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(i.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(i.lightMap=this.lightMap.toJSON(t).uuid,i.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(i.aoMap=this.aoMap.toJSON(t).uuid,i.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(i.bumpMap=this.bumpMap.toJSON(t).uuid,i.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(i.normalMap=this.normalMap.toJSON(t).uuid,i.normalMapType=this.normalMapType,i.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(i.displacementMap=this.displacementMap.toJSON(t).uuid,i.displacementScale=this.displacementScale,i.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(i.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(i.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(i.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(i.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(i.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(i.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(i.envMap=this.envMap.toJSON(t).uuid,void 0!==this.combine&&(i.combine=this.combine)),void 0!==this.envMapRotation&&(i.envMapRotation=this.envMapRotation.toArray()),void 0!==this.envMapIntensity&&(i.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&(i.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&(i.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(i.gradientMap=this.gradientMap.toJSON(t).uuid),void 0!==this.transmission&&(i.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(i.transmissionMap=this.transmissionMap.toJSON(t).uuid),void 0!==this.thickness&&(i.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(i.thicknessMap=this.thicknessMap.toJSON(t).uuid),void 0!==this.attenuationDistance&&this.attenuationDistance!==1/0&&(i.attenuationDistance=this.attenuationDistance),void 0!==this.attenuationColor&&(i.attenuationColor=this.attenuationColor.getHex()),void 0!==this.size&&(i.size=this.size),null!==this.shadowSide&&(i.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&(i.sizeAttenuation=this.sizeAttenuation),1!==this.blending&&(i.blending=this.blending),0!==this.side&&(i.side=this.side),!0===this.vertexColors&&(i.vertexColors=!0),this.opacity<1&&(i.opacity=this.opacity),!0===this.transparent&&(i.transparent=!0),this.blendSrc!==S&&(i.blendSrc=this.blendSrc),this.blendDst!==M&&(i.blendDst=this.blendDst),this.blendEquation!==f&&(i.blendEquation=this.blendEquation),null!==this.blendSrcAlpha&&(i.blendSrcAlpha=this.blendSrcAlpha),null!==this.blendDstAlpha&&(i.blendDstAlpha=this.blendDstAlpha),null!==this.blendEquationAlpha&&(i.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(i.blendColor=this.blendColor.getHex()),0!==this.blendAlpha&&(i.blendAlpha=this.blendAlpha),3!==this.depthFunc&&(i.depthFunc=this.depthFunc),!1===this.depthTest&&(i.depthTest=this.depthTest),!1===this.depthWrite&&(i.depthWrite=this.depthWrite),!1===this.colorWrite&&(i.colorWrite=this.colorWrite),255!==this.stencilWriteMask&&(i.stencilWriteMask=this.stencilWriteMask),519!==this.stencilFunc&&(i.stencilFunc=this.stencilFunc),0!==this.stencilRef&&(i.stencilRef=this.stencilRef),255!==this.stencilFuncMask&&(i.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==ue&&(i.stencilFail=this.stencilFail),this.stencilZFail!==ue&&(i.stencilZFail=this.stencilZFail),this.stencilZPass!==ue&&(i.stencilZPass=this.stencilZPass),!0===this.stencilWrite&&(i.stencilWrite=this.stencilWrite),void 0!==this.rotation&&0!==this.rotation&&(i.rotation=this.rotation),!0===this.polygonOffset&&(i.polygonOffset=!0),0!==this.polygonOffsetFactor&&(i.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(i.polygonOffsetUnits=this.polygonOffsetUnits),void 0!==this.linewidth&&1!==this.linewidth&&(i.linewidth=this.linewidth),void 0!==this.dashSize&&(i.dashSize=this.dashSize),void 0!==this.gapSize&&(i.gapSize=this.gapSize),void 0!==this.scale&&(i.scale=this.scale),!0===this.dithering&&(i.dithering=!0),this.alphaTest>0&&(i.alphaTest=this.alphaTest),!0===this.alphaHash&&(i.alphaHash=!0),!0===this.alphaToCoverage&&(i.alphaToCoverage=!0),!0===this.premultipliedAlpha&&(i.premultipliedAlpha=!0),!0===this.forceSinglePass&&(i.forceSinglePass=!0),!0===this.wireframe&&(i.wireframe=!0),this.wireframeLinewidth>1&&(i.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(i.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(i.wireframeLinejoin=this.wireframeLinejoin),!0===this.flatShading&&(i.flatShading=!0),!1===this.visible&&(i.visible=!1),!1===this.toneMapped&&(i.toneMapped=!1),!1===this.fog&&(i.fog=!1),Object.keys(this.userData).length>0&&(i.userData=this.userData),e){const e=n(t.textures),s=n(t.images);e.length>0&&(i.textures=e),s.length>0&&(i.images=s)}return i}clone(){return(new this.constructor).copy(this)}copy(t){this.name=t.name,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.blendColor.copy(t.blendColor),this.blendAlpha=t.blendAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let i=null;if(null!==e){const t=e.length;i=new Array(t);for(let n=0;n!==t;++n)i[n]=e[n].clone()}return this.clippingPlanes=i,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaHash=t.alphaHash,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.forceSinglePass=t.forceSinglePass,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){!0===t&&this.version++}onBuild(){}},On=class extends Bn{static get type(){return"MeshBasicMaterial"}constructor(t){super(),this.isMeshBasicMaterial=!0,this.color=new Dn(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Ki,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}};const zn=new ui,kn=new Fe;let Vn=class{constructor(t,e,i=!1){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=t,this.itemSize=e,this.count=void 0!==t?t.length/e:0,this.normalized=i,this.usage=ye,this.updateRanges=[],this.gpuType=lt,this.version=0}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this.gpuType=t.gpuType,this}copyAt(t,e,i){t*=this.itemSize,i*=e.itemSize;for(let n=0,s=this.itemSize;n<s;n++)this.array[t+n]=e.array[i+n];return this}copyArray(t){return this.array.set(t),this}applyMatrix3(t){if(2===this.itemSize)for(let e=0,i=this.count;e<i;e++)kn.fromBufferAttribute(this,e),kn.applyMatrix3(t),this.setXY(e,kn.x,kn.y);else if(3===this.itemSize)for(let e=0,i=this.count;e<i;e++)zn.fromBufferAttribute(this,e),zn.applyMatrix3(t),this.setXYZ(e,zn.x,zn.y,zn.z);return this}applyMatrix4(t){for(let e=0,i=this.count;e<i;e++)zn.fromBufferAttribute(this,e),zn.applyMatrix4(t),this.setXYZ(e,zn.x,zn.y,zn.z);return this}applyNormalMatrix(t){for(let e=0,i=this.count;e<i;e++)zn.fromBufferAttribute(this,e),zn.applyNormalMatrix(t),this.setXYZ(e,zn.x,zn.y,zn.z);return this}transformDirection(t){for(let e=0,i=this.count;e<i;e++)zn.fromBufferAttribute(this,e),zn.transformDirection(t),this.setXYZ(e,zn.x,zn.y,zn.z);return this}set(t,e=0){return this.array.set(t,e),this}getComponent(t,e){let i=this.array[t*this.itemSize+e];return this.normalized&&(i=Le(i,this.array)),i}setComponent(t,e,i){return this.normalized&&(i=De(i,this.array)),this.array[t*this.itemSize+e]=i,this}getX(t){let e=this.array[t*this.itemSize];return this.normalized&&(e=Le(e,this.array)),e}setX(t,e){return this.normalized&&(e=De(e,this.array)),this.array[t*this.itemSize]=e,this}getY(t){let e=this.array[t*this.itemSize+1];return this.normalized&&(e=Le(e,this.array)),e}setY(t,e){return this.normalized&&(e=De(e,this.array)),this.array[t*this.itemSize+1]=e,this}getZ(t){let e=this.array[t*this.itemSize+2];return this.normalized&&(e=Le(e,this.array)),e}setZ(t,e){return this.normalized&&(e=De(e,this.array)),this.array[t*this.itemSize+2]=e,this}getW(t){let e=this.array[t*this.itemSize+3];return this.normalized&&(e=Le(e,this.array)),e}setW(t,e){return this.normalized&&(e=De(e,this.array)),this.array[t*this.itemSize+3]=e,this}setXY(t,e,i){return t*=this.itemSize,this.normalized&&(e=De(e,this.array),i=De(i,this.array)),this.array[t+0]=e,this.array[t+1]=i,this}setXYZ(t,e,i,n){return t*=this.itemSize,this.normalized&&(e=De(e,this.array),i=De(i,this.array),n=De(n,this.array)),this.array[t+0]=e,this.array[t+1]=i,this.array[t+2]=n,this}setXYZW(t,e,i,n,s){return t*=this.itemSize,this.normalized&&(e=De(e,this.array),i=De(i,this.array),n=De(n,this.array),s=De(s,this.array)),this.array[t+0]=e,this.array[t+1]=i,this.array[t+2]=n,this.array[t+3]=s,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return""!==this.name&&(t.name=this.name),this.usage!==ye&&(t.usage=this.usage),t}},Gn=class extends Vn{constructor(t,e,i){super(new Uint16Array(t),e,i)}},Hn=class extends Vn{constructor(t,e,i){super(new Uint32Array(t),e,i)}},Wn=class extends Vn{constructor(t,e,i){super(new Float32Array(t),e,i)}},jn=0;const Xn=new Vi,qn=new fn,$n=new ui,Yn=new mi,Zn=new mi,Kn=new ui;let Jn=class t extends Te{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:jn++}),this.uuid=Re(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(ze(t)?Hn:Gn)(t,1):this.index=t,this}setIndirect(t){return this.indirect=t,this}getIndirect(){return this.indirect}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return void 0!==this.attributes[t]}addGroup(t,e,i=0){this.groups.push({start:t,count:e,materialIndex:i})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;void 0!==e&&(e.applyMatrix4(t),e.needsUpdate=!0);const i=this.attributes.normal;if(void 0!==i){const e=(new Be).getNormalMatrix(t);i.applyNormalMatrix(e),i.needsUpdate=!0}const n=this.attributes.tangent;return void 0!==n&&(n.transformDirection(t),n.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(t){return Xn.makeRotationFromQuaternion(t),this.applyMatrix4(Xn),this}rotateX(t){return Xn.makeRotationX(t),this.applyMatrix4(Xn),this}rotateY(t){return Xn.makeRotationY(t),this.applyMatrix4(Xn),this}rotateZ(t){return Xn.makeRotationZ(t),this.applyMatrix4(Xn),this}translate(t,e,i){return Xn.makeTranslation(t,e,i),this.applyMatrix4(Xn),this}scale(t,e,i){return Xn.makeScale(t,e,i),this.applyMatrix4(Xn),this}lookAt(t){return qn.lookAt(t),qn.updateMatrix(),this.applyMatrix4(qn.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter($n).negate(),this.translate($n.x,$n.y,$n.z),this}setFromPoints(t){const e=this.getAttribute("position");if(void 0===e){const e=[];for(let i=0,n=t.length;i<n;i++){const n=t[i];e.push(n.x,n.y,n.z||0)}this.setAttribute("position",new Wn(e,3))}else{for(let i=0,n=e.count;i<n;i++){const n=t[i];e.setXYZ(i,n.x,n.y,n.z||0)}t.length,e.count,e.needsUpdate=!0}return this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new mi);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)this.boundingBox.set(new ui(-1/0,-1/0,-1/0),new ui(1/0,1/0,1/0));else{if(void 0!==t){if(this.boundingBox.setFromBufferAttribute(t),e)for(let t=0,i=e.length;t<i;t++){const i=e[t];Yn.setFromBufferAttribute(i),this.morphTargetsRelative?(Kn.addVectors(this.boundingBox.min,Yn.min),this.boundingBox.expandByPoint(Kn),Kn.addVectors(this.boundingBox.max,Yn.max),this.boundingBox.expandByPoint(Kn)):(this.boundingBox.expandByPoint(Yn.min),this.boundingBox.expandByPoint(Yn.max))}}else this.boundingBox.makeEmpty();isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z)}}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new Ii);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)this.boundingSphere.set(new ui,1/0);else if(t){const i=this.boundingSphere.center;if(Yn.setFromBufferAttribute(t),e)for(let t=0,s=e.length;t<s;t++){const i=e[t];Zn.setFromBufferAttribute(i),this.morphTargetsRelative?(Kn.addVectors(Yn.min,Zn.min),Yn.expandByPoint(Kn),Kn.addVectors(Yn.max,Zn.max),Yn.expandByPoint(Kn)):(Yn.expandByPoint(Zn.min),Yn.expandByPoint(Zn.max))}Yn.getCenter(i);let n=0;for(let e=0,s=t.count;e<s;e++)Kn.fromBufferAttribute(t,e),n=Math.max(n,i.distanceToSquared(Kn));if(e)for(let s=0,r=e.length;s<r;s++){const r=e[s],a=this.morphTargetsRelative;for(let e=0,s=r.count;e<s;e++)Kn.fromBufferAttribute(r,e),a&&($n.fromBufferAttribute(t,e),Kn.add($n)),n=Math.max(n,i.distanceToSquared(Kn))}this.boundingSphere.radius=Math.sqrt(n),isNaN(this.boundingSphere.radius)}}computeTangents(){const t=this.index,e=this.attributes;if(null===t||void 0===e.position||void 0===e.normal||void 0===e.uv)return;const i=e.position,n=e.normal,s=e.uv;!1===this.hasAttribute("tangent")&&this.setAttribute("tangent",new Vn(new Float32Array(4*i.count),4));const r=this.getAttribute("tangent"),a=[],o=[];for(let M=0;M<i.count;M++)a[M]=new ui,o[M]=new ui;const l=new ui,h=new ui,c=new ui,u=new Fe,d=new Fe,p=new Fe,m=new ui,f=new ui;function g(t,e,n){l.fromBufferAttribute(i,t),h.fromBufferAttribute(i,e),c.fromBufferAttribute(i,n),u.fromBufferAttribute(s,t),d.fromBufferAttribute(s,e),p.fromBufferAttribute(s,n),h.sub(l),c.sub(l),d.sub(u),p.sub(u);const r=1/(d.x*p.y-p.x*d.y);isFinite(r)&&(m.copy(h).multiplyScalar(p.y).addScaledVector(c,-d.y).multiplyScalar(r),f.copy(c).multiplyScalar(d.x).addScaledVector(h,-p.x).multiplyScalar(r),a[t].add(m),a[e].add(m),a[n].add(m),o[t].add(f),o[e].add(f),o[n].add(f))}let x=this.groups;0===x.length&&(x=[{start:0,count:t.count}]);for(let M=0,T=x.length;M<T;++M){const e=x[M],i=e.start;for(let n=i,s=i+e.count;n<s;n+=3)g(t.getX(n+0),t.getX(n+1),t.getX(n+2))}const v=new ui,_=new ui,y=new ui,b=new ui;function S(t){y.fromBufferAttribute(n,t),b.copy(y);const e=a[t];v.copy(e),v.sub(y.multiplyScalar(y.dot(e))).normalize(),_.crossVectors(b,e);const i=_.dot(o[t])<0?-1:1;r.setXYZW(t,v.x,v.y,v.z,i)}for(let M=0,T=x.length;M<T;++M){const e=x[M],i=e.start;for(let n=i,s=i+e.count;n<s;n+=3)S(t.getX(n+0)),S(t.getX(n+1)),S(t.getX(n+2))}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(void 0!==e){let i=this.getAttribute("normal");if(void 0===i)i=new Vn(new Float32Array(3*e.count),3),this.setAttribute("normal",i);else for(let t=0,e=i.count;t<e;t++)i.setXYZ(t,0,0,0);const n=new ui,s=new ui,r=new ui,a=new ui,o=new ui,l=new ui,h=new ui,c=new ui;if(t)for(let u=0,d=t.count;u<d;u+=3){const d=t.getX(u+0),p=t.getX(u+1),m=t.getX(u+2);n.fromBufferAttribute(e,d),s.fromBufferAttribute(e,p),r.fromBufferAttribute(e,m),h.subVectors(r,s),c.subVectors(n,s),h.cross(c),a.fromBufferAttribute(i,d),o.fromBufferAttribute(i,p),l.fromBufferAttribute(i,m),a.add(h),o.add(h),l.add(h),i.setXYZ(d,a.x,a.y,a.z),i.setXYZ(p,o.x,o.y,o.z),i.setXYZ(m,l.x,l.y,l.z)}else for(let t=0,u=e.count;t<u;t+=3)n.fromBufferAttribute(e,t+0),s.fromBufferAttribute(e,t+1),r.fromBufferAttribute(e,t+2),h.subVectors(r,s),c.subVectors(n,s),h.cross(c),i.setXYZ(t+0,h.x,h.y,h.z),i.setXYZ(t+1,h.x,h.y,h.z),i.setXYZ(t+2,h.x,h.y,h.z);this.normalizeNormals(),i.needsUpdate=!0}}normalizeNormals(){const t=this.attributes.normal;for(let e=0,i=t.count;e<i;e++)Kn.fromBufferAttribute(t,e),Kn.normalize(),t.setXYZ(e,Kn.x,Kn.y,Kn.z)}toNonIndexed(){function e(t,e){const i=t.array,n=t.itemSize,s=t.normalized,r=new i.constructor(e.length*n);let a=0,o=0;for(let l=0,h=e.length;l<h;l++){a=t.isInterleavedBufferAttribute?e[l]*t.data.stride+t.offset:e[l]*n;for(let t=0;t<n;t++)r[o++]=i[a++]}return new Vn(r,n,s)}if(null===this.index)return this;const i=new t,n=this.index.array,s=this.attributes;for(const t in s){const r=e(s[t],n);i.setAttribute(t,r)}const r=this.morphAttributes;for(const t in r){const s=[],a=r[t];for(let t=0,i=a.length;t<i;t++){const i=e(a[t],n);s.push(i)}i.morphAttributes[t]=s}i.morphTargetsRelative=this.morphTargetsRelative;const a=this.groups;for(let t=0,o=a.length;t<o;t++){const e=a[t];i.addGroup(e.start,e.count,e.materialIndex)}return i}toJSON(){const t={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),void 0!==this.parameters){const e=this.parameters;for(const i in e)void 0!==e[i]&&(t[i]=e[i]);return t}t.data={attributes:{}};const e=this.index;null!==e&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const i=this.attributes;for(const o in i){const e=i[o];t.data.attributes[o]=e.toJSON(t.data)}const n={};let s=!1;for(const o in this.morphAttributes){const e=this.morphAttributes[o],i=[];for(let n=0,s=e.length;n<s;n++){const s=e[n];i.push(s.toJSON(t.data))}i.length>0&&(n[o]=i,s=!0)}s&&(t.data.morphAttributes=n,t.data.morphTargetsRelative=this.morphTargetsRelative);const r=this.groups;r.length>0&&(t.data.groups=JSON.parse(JSON.stringify(r)));const a=this.boundingSphere;return null!==a&&(t.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),t}clone(){return(new this.constructor).copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const i=t.index;null!==i&&this.setIndex(i.clone(e));const n=t.attributes;for(const l in n){const t=n[l];this.setAttribute(l,t.clone(e))}const s=t.morphAttributes;for(const l in s){const t=[],i=s[l];for(let n=0,s=i.length;n<s;n++)t.push(i[n].clone(e));this.morphAttributes[l]=t}this.morphTargetsRelative=t.morphTargetsRelative;const r=t.groups;for(let l=0,h=r.length;l<h;l++){const t=r[l];this.addGroup(t.start,t.count,t.materialIndex)}const a=t.boundingBox;null!==a&&(this.boundingBox=a.clone());const o=t.boundingSphere;return null!==o&&(this.boundingSphere=o.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}};const Qn=new Vi,ts=new ki,es=new Ii,is=new ui,ns=new ui,ss=new ui,rs=new ui,as=new ui,os=new ui,ls=new ui,hs=new ui;let cs=class extends fn{constructor(t=new Jn,e=new On){super(),this.isMesh=!0,this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),void 0!==t.morphTargetInfluences&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),void 0!==t.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const i=t[e[0]];if(void 0!==i){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,e=i.length;t<e;t++){const e=i[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[e]=t}}}}getVertexPosition(t,e){const i=this.geometry,n=i.attributes.position,s=i.morphAttributes.position,r=i.morphTargetsRelative;e.fromBufferAttribute(n,t);const a=this.morphTargetInfluences;if(s&&a){os.set(0,0,0);for(let i=0,n=s.length;i<n;i++){const n=a[i],o=s[i];0!==n&&(as.fromBufferAttribute(o,t),r?os.addScaledVector(as,n):os.addScaledVector(as.sub(e),n))}e.add(os)}return e}raycast(t,e){const i=this.geometry,n=this.material,s=this.matrixWorld;if(void 0!==n){if(null===i.boundingSphere&&i.computeBoundingSphere(),es.copy(i.boundingSphere),es.applyMatrix4(s),ts.copy(t.ray).recast(t.near),!1===es.containsPoint(ts.origin)){if(null===ts.intersectSphere(es,is))return;if(ts.origin.distanceToSquared(is)>(t.far-t.near)**2)return}Qn.copy(s).invert(),ts.copy(t.ray).applyMatrix4(Qn),null!==i.boundingBox&&!1===ts.intersectsBox(i.boundingBox)||this._computeIntersections(t,e,ts)}}_computeIntersections(t,e,i){let n;const s=this.geometry,r=this.material,a=s.index,o=s.attributes.position,l=s.attributes.uv,h=s.attributes.uv1,c=s.attributes.normal,u=s.groups,d=s.drawRange;if(null!==a)if(Array.isArray(r))for(let p=0,m=u.length;p<m;p++){const s=u[p],o=r[s.materialIndex];for(let r=Math.max(s.start,d.start),u=Math.min(a.count,Math.min(s.start+s.count,d.start+d.count));r<u;r+=3){n=us(this,o,t,i,l,h,c,a.getX(r),a.getX(r+1),a.getX(r+2)),n&&(n.faceIndex=Math.floor(r/3),n.face.materialIndex=s.materialIndex,e.push(n))}}else{for(let s=Math.max(0,d.start),o=Math.min(a.count,d.start+d.count);s<o;s+=3){n=us(this,r,t,i,l,h,c,a.getX(s),a.getX(s+1),a.getX(s+2)),n&&(n.faceIndex=Math.floor(s/3),e.push(n))}}else if(void 0!==o)if(Array.isArray(r))for(let p=0,m=u.length;p<m;p++){const s=u[p],a=r[s.materialIndex];for(let r=Math.max(s.start,d.start),u=Math.min(o.count,Math.min(s.start+s.count,d.start+d.count));r<u;r+=3){n=us(this,a,t,i,l,h,c,r,r+1,r+2),n&&(n.faceIndex=Math.floor(r/3),n.face.materialIndex=s.materialIndex,e.push(n))}}else{for(let s=Math.max(0,d.start),a=Math.min(o.count,d.start+d.count);s<a;s+=3){n=us(this,r,t,i,l,h,c,s,s+1,s+2),n&&(n.faceIndex=Math.floor(s/3),e.push(n))}}}};function us(t,e,i,n,s,r,a,o,l,h){t.getVertexPosition(o,ns),t.getVertexPosition(l,ss),t.getVertexPosition(h,rs);const c=function(t,e,i,n,s,r,a,o){let l;if(l=1===e.side?n.intersectTriangle(a,r,s,!0,o):n.intersectTriangle(s,r,a,0===e.side,o),null===l)return null;hs.copy(o),hs.applyMatrix4(t.matrixWorld);const h=i.ray.origin.distanceTo(hs);return h<i.near||h>i.far?null:{distance:h,point:hs.clone(),object:t}}(t,e,i,n,ns,ss,rs,ls);if(c){const t=new ui;Rn.getBarycoord(ls,ns,ss,rs,t),s&&(c.uv=Rn.getInterpolatedAttribute(s,o,l,h,t,new Fe)),r&&(c.uv1=Rn.getInterpolatedAttribute(r,o,l,h,t,new Fe)),a&&(c.normal=Rn.getInterpolatedAttribute(a,o,l,h,t,new ui),c.normal.dot(n.direction)>0&&c.normal.multiplyScalar(-1));const e={a:o,b:l,c:h,normal:new ui,materialIndex:0};Rn.getNormal(ns,ss,rs,e.normal),c.face=e,c.barycoord=t}return c}let ds=class t extends Jn{constructor(t=1,e=1,i=1,n=1,s=1,r=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:i,widthSegments:n,heightSegments:s,depthSegments:r};const a=this;n=Math.floor(n),s=Math.floor(s),r=Math.floor(r);const o=[],l=[],h=[],c=[];let u=0,d=0;function p(t,e,i,n,s,r,p,m,f,g,x){const v=r/f,_=p/g,y=r/2,b=p/2,S=m/2,M=f+1,T=g+1;let w=0,A=0;const E=new ui;for(let a=0;a<T;a++){const r=a*_-b;for(let o=0;o<M;o++){const u=o*v-y;E[t]=u*n,E[e]=r*s,E[i]=S,l.push(E.x,E.y,E.z),E[t]=0,E[e]=0,E[i]=m>0?1:-1,h.push(E.x,E.y,E.z),c.push(o/f),c.push(1-a/g),w+=1}}for(let a=0;a<g;a++)for(let t=0;t<f;t++){const e=u+t+M*a,i=u+t+M*(a+1),n=u+(t+1)+M*(a+1),s=u+(t+1)+M*a;o.push(e,i,s),o.push(i,n,s),A+=6}a.addGroup(d,A,x),d+=A,u+=w}p("z","y","x",-1,-1,i,e,t,r,s,0),p("z","y","x",1,-1,i,e,-t,r,s,1),p("x","z","y",1,1,t,i,e,n,r,2),p("x","z","y",1,-1,t,i,-e,n,r,3),p("x","y","z",1,-1,t,e,i,n,s,4),p("x","y","z",-1,-1,t,e,-i,n,s,5),this.setIndex(o),this.setAttribute("position",new Wn(l,3)),this.setAttribute("normal",new Wn(h,3)),this.setAttribute("uv",new Wn(c,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(e){return new t(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}};function ps(t){const e={};for(const i in t){e[i]={};for(const n in t[i]){const s=t[i][n];s&&(s.isColor||s.isMatrix3||s.isMatrix4||s.isVector2||s.isVector3||s.isVector4||s.isTexture||s.isQuaternion)?s.isRenderTargetTexture?e[i][n]=null:e[i][n]=s.clone():Array.isArray(s)?e[i][n]=s.slice():e[i][n]=s}}return e}function ms(t){const e={};for(let i=0;i<t.length;i++){const n=ps(t[i]);for(const t in n)e[t]=n[t]}return e}function fs(t){const e=t.getRenderTarget();return null===e?t.outputColorSpace:!0===e.isXRRenderTarget?e.texture.colorSpace:We.workingColorSpace}const gs={clone:ps,merge:ms};let xs=class extends Bn{static get type(){return"ShaderMaterial"}constructor(t){super(),this.isShaderMaterial=!0,this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==t&&this.setValues(t)}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=ps(t.uniforms),this.uniformsGroups=function(t){const e=[];for(let i=0;i<t.length;i++)e.push(t[i].clone());return e}(t.uniformsGroups),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.fog=t.fog,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const n in this.uniforms){const i=this.uniforms[n].value;i&&i.isTexture?e.uniforms[n]={type:"t",value:i.toJSON(t).uuid}:i&&i.isColor?e.uniforms[n]={type:"c",value:i.getHex()}:i&&i.isVector2?e.uniforms[n]={type:"v2",value:i.toArray()}:i&&i.isVector3?e.uniforms[n]={type:"v3",value:i.toArray()}:i&&i.isVector4?e.uniforms[n]={type:"v4",value:i.toArray()}:i&&i.isMatrix3?e.uniforms[n]={type:"m3",value:i.toArray()}:i&&i.isMatrix4?e.uniforms[n]={type:"m4",value:i.toArray()}:e.uniforms[n]={value:i}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader,e.lights=this.lights,e.clipping=this.clipping;const i={};for(const n in this.extensions)!0===this.extensions[n]&&(i[n]=!0);return Object.keys(i).length>0&&(e.extensions=i),e}},vs=class extends fn{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new Vi,this.projectionMatrix=new Vi,this.projectionMatrixInverse=new Vi,this.coordinateSystem=Se}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this.coordinateSystem=t.coordinateSystem,this}getWorldDirection(t){return super.getWorldDirection(t).negate()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return(new this.constructor).copy(this)}};const _s=new ui,ys=new Fe,bs=new Fe;let Ss=class extends vs{constructor(t=50,e=1,i=.1,n=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=i,this.far=n,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=null===t.view?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=2*Ce*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(.5*Ee*this.fov);return.5*this.getFilmHeight()/t}getEffectiveFOV(){return 2*Ce*Math.atan(Math.tan(.5*Ee*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(t,e,i){_s.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),e.set(_s.x,_s.y).multiplyScalar(-t/_s.z),_s.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),i.set(_s.x,_s.y).multiplyScalar(-t/_s.z)}getViewSize(t,e){return this.getViewBounds(t,ys,bs),e.subVectors(bs,ys)}setViewOffset(t,e,i,n,s,r){this.aspect=t/e,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=i,this.view.offsetY=n,this.view.width=s,this.view.height=r,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(.5*Ee*this.fov)/this.zoom,i=2*e,n=this.aspect*i,s=-.5*n;const r=this.view;if(null!==this.view&&this.view.enabled){const t=r.fullWidth,a=r.fullHeight;s+=r.offsetX*n/t,e-=r.offsetY*i/a,n*=r.width/t,i*=r.height/a}const a=this.filmOffset;0!==a&&(s+=t*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+n,e,e-i,t,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,null!==this.view&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}};const Ms=-90;let Ts=class extends fn{constructor(t,e,i){super(),this.type="CubeCamera",this.renderTarget=i,this.coordinateSystem=null,this.activeMipmapLevel=0;const n=new Ss(Ms,1,t,e);n.layers=this.layers,this.add(n);const s=new Ss(Ms,1,t,e);s.layers=this.layers,this.add(s);const r=new Ss(Ms,1,t,e);r.layers=this.layers,this.add(r);const a=new Ss(Ms,1,t,e);a.layers=this.layers,this.add(a);const o=new Ss(Ms,1,t,e);o.layers=this.layers,this.add(o);const l=new Ss(Ms,1,t,e);l.layers=this.layers,this.add(l)}updateCoordinateSystem(){const t=this.coordinateSystem,e=this.children.concat(),[i,n,s,r,a,o]=e;for(const l of e)this.remove(l);if(t===Se)i.up.set(0,1,0),i.lookAt(1,0,0),n.up.set(0,1,0),n.lookAt(-1,0,0),s.up.set(0,0,-1),s.lookAt(0,1,0),r.up.set(0,0,1),r.lookAt(0,-1,0),a.up.set(0,1,0),a.lookAt(0,0,1),o.up.set(0,1,0),o.lookAt(0,0,-1);else{if(t!==Me)throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+t);i.up.set(0,-1,0),i.lookAt(-1,0,0),n.up.set(0,-1,0),n.lookAt(1,0,0),s.up.set(0,0,1),s.lookAt(0,1,0),r.up.set(0,0,-1),r.lookAt(0,-1,0),a.up.set(0,-1,0),a.lookAt(0,0,1),o.up.set(0,-1,0),o.lookAt(0,0,-1)}for(const l of e)this.add(l),l.updateMatrixWorld()}update(t,e){null===this.parent&&this.updateMatrixWorld();const{renderTarget:i,activeMipmapLevel:n}=this;this.coordinateSystem!==t.coordinateSystem&&(this.coordinateSystem=t.coordinateSystem,this.updateCoordinateSystem());const[s,r,a,o,l,h]=this.children,c=t.getRenderTarget(),u=t.getActiveCubeFace(),d=t.getActiveMipmapLevel(),p=t.xr.enabled;t.xr.enabled=!1;const m=i.texture.generateMipmaps;i.texture.generateMipmaps=!1,t.setRenderTarget(i,0,n),t.render(e,s),t.setRenderTarget(i,1,n),t.render(e,r),t.setRenderTarget(i,2,n),t.render(e,a),t.setRenderTarget(i,3,n),t.render(e,o),t.setRenderTarget(i,4,n),t.render(e,l),i.texture.generateMipmaps=m,t.setRenderTarget(i,5,n),t.render(e,h),t.setRenderTarget(c,u,d),t.xr.enabled=p,i.texture.needsPMREMUpdate=!0}},ws=class extends si{constructor(t,e,i,n,s,r,a,o,l,h){super(t=void 0!==t?t:[],e=void 0!==e?e:H,i,n,s,r,a,o,l,h),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(t){this.image=t}},As=class extends oi{constructor(t=1,e={}){super(t,t,e),this.isWebGLCubeRenderTarget=!0;const i={width:t,height:t,depth:1},n=[i,i,i,i,i,i];this.texture=new ws(n,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=void 0!==e.generateMipmaps&&e.generateMipmaps,this.texture.minFilter=void 0!==e.minFilter?e.minFilter:Q}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.colorSpace=e.colorSpace,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const i={uniforms:{tEquirect:{value:null}},vertexShader:"\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",fragmentShader:"\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"},n=new ds(5,5,5),s=new xs({name:"CubemapFromEquirect",uniforms:ps(i.uniforms),vertexShader:i.vertexShader,fragmentShader:i.fragmentShader,side:1,blending:0});s.uniforms.tEquirect.value=e;const r=new cs(n,s),a=e.minFilter;e.minFilter===et&&(e.minFilter=Q);return new Ts(1,10,this).update(t,r),e.minFilter=a,r.geometry.dispose(),r.material.dispose(),this}clear(t,e,i,n){const s=t.getRenderTarget();for(let r=0;r<6;r++)t.setRenderTarget(this,r),t.clear(e,i,n);t.setRenderTarget(s)}};const Es=new ui,Cs=new ui,Rs=new Be;let Ns=class{constructor(t=new ui(1,0,0),e=0){this.isPlane=!0,this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,i,n){return this.normal.set(t,e,i),this.constant=n,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,i){const n=Es.subVectors(i,e).cross(Cs.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(n,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(t).addScaledVector(this.normal,-this.distanceToPoint(t))}intersectLine(t,e){const i=t.delta(Es),n=this.normal.dot(i);if(0===n)return 0===this.distanceToPoint(t.start)?e.copy(t.start):null;const s=-(t.start.dot(this.normal)+this.constant)/n;return s<0||s>1?null:e.copy(t.start).addScaledVector(i,s)}intersectsLine(t){const e=this.distanceToPoint(t.start),i=this.distanceToPoint(t.end);return e<0&&i>0||i<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const i=e||Rs.getNormalMatrix(t),n=this.coplanarPoint(Es).applyMatrix4(t),s=this.normal.applyMatrix3(i).normalize();return this.constant=-n.dot(s),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return(new this.constructor).copy(this)}};const Ps=new Ii,Is=new ui;let Ls=class{constructor(t=new Ns,e=new Ns,i=new Ns,n=new Ns,s=new Ns,r=new Ns){this.planes=[t,e,i,n,s,r]}set(t,e,i,n,s,r){const a=this.planes;return a[0].copy(t),a[1].copy(e),a[2].copy(i),a[3].copy(n),a[4].copy(s),a[5].copy(r),this}copy(t){const e=this.planes;for(let i=0;i<6;i++)e[i].copy(t.planes[i]);return this}setFromProjectionMatrix(t,e=2e3){const i=this.planes,n=t.elements,s=n[0],r=n[1],a=n[2],o=n[3],l=n[4],h=n[5],c=n[6],u=n[7],d=n[8],p=n[9],m=n[10],f=n[11],g=n[12],x=n[13],v=n[14],_=n[15];if(i[0].setComponents(o-s,u-l,f-d,_-g).normalize(),i[1].setComponents(o+s,u+l,f+d,_+g).normalize(),i[2].setComponents(o+r,u+h,f+p,_+x).normalize(),i[3].setComponents(o-r,u-h,f-p,_-x).normalize(),i[4].setComponents(o-a,u-c,f-m,_-v).normalize(),e===Se)i[5].setComponents(o+a,u+c,f+m,_+v).normalize();else{if(e!==Me)throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+e);i[5].setComponents(a,c,m,v).normalize()}return this}intersectsObject(t){if(void 0!==t.boundingSphere)null===t.boundingSphere&&t.computeBoundingSphere(),Ps.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);else{const e=t.geometry;null===e.boundingSphere&&e.computeBoundingSphere(),Ps.copy(e.boundingSphere).applyMatrix4(t.matrixWorld)}return this.intersectsSphere(Ps)}intersectsSprite(t){return Ps.center.set(0,0,0),Ps.radius=.7071067811865476,Ps.applyMatrix4(t.matrixWorld),this.intersectsSphere(Ps)}intersectsSphere(t){const e=this.planes,i=t.center,n=-t.radius;for(let s=0;s<6;s++){if(e[s].distanceToPoint(i)<n)return!1}return!0}intersectsBox(t){const e=this.planes;for(let i=0;i<6;i++){const n=e[i];if(Is.x=n.normal.x>0?t.max.x:t.min.x,Is.y=n.normal.y>0?t.max.y:t.min.y,Is.z=n.normal.z>0?t.max.z:t.min.z,n.distanceToPoint(Is)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let i=0;i<6;i++)if(e[i].distanceToPoint(t)<0)return!1;return!0}clone(){return(new this.constructor).copy(this)}};function Ds(){let t=null,e=!1,i=null,n=null;function s(e,r){i(e,r),n=t.requestAnimationFrame(s)}return{start:function(){!0!==e&&null!==i&&(n=t.requestAnimationFrame(s),e=!0)},stop:function(){t.cancelAnimationFrame(n),e=!1},setAnimationLoop:function(t){i=t},setContext:function(e){t=e}}}function Us(t){const e=new WeakMap;return{get:function(t){return t.isInterleavedBufferAttribute&&(t=t.data),e.get(t)},remove:function(i){i.isInterleavedBufferAttribute&&(i=i.data);const n=e.get(i);n&&(t.deleteBuffer(n.buffer),e.delete(i))},update:function(i,n){if(i.isInterleavedBufferAttribute&&(i=i.data),i.isGLBufferAttribute){const t=e.get(i);return void((!t||t.version<i.version)&&e.set(i,{buffer:i.buffer,type:i.type,bytesPerElement:i.elementSize,version:i.version}))}const s=e.get(i);if(void 0===s)e.set(i,function(e,i){const n=e.array,s=e.usage,r=n.byteLength,a=t.createBuffer();let o;if(t.bindBuffer(i,a),t.bufferData(i,n,s),e.onUploadCallback(),n instanceof Float32Array)o=t.FLOAT;else if(n instanceof Uint16Array)o=e.isFloat16BufferAttribute?t.HALF_FLOAT:t.UNSIGNED_SHORT;else if(n instanceof Int16Array)o=t.SHORT;else if(n instanceof Uint32Array)o=t.UNSIGNED_INT;else if(n instanceof Int32Array)o=t.INT;else if(n instanceof Int8Array)o=t.BYTE;else if(n instanceof Uint8Array)o=t.UNSIGNED_BYTE;else{if(!(n instanceof Uint8ClampedArray))throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+n);o=t.UNSIGNED_BYTE}return{buffer:a,type:o,bytesPerElement:n.BYTES_PER_ELEMENT,version:e.version,size:r}}(i,n));else if(s.version<i.version){if(s.size!==i.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");!function(e,i,n){const s=i.array,r=i.updateRanges;if(t.bindBuffer(n,e),0===r.length)t.bufferSubData(n,0,s);else{r.sort(((t,e)=>t.start-e.start));let e=0;for(let t=1;t<r.length;t++){const i=r[e],n=r[t];n.start<=i.start+i.count+1?i.count=Math.max(i.count,n.start+n.count-i.start):(++e,r[e]=n)}r.length=e+1;for(let i=0,a=r.length;i<a;i++){const e=r[i];t.bufferSubData(n,e.start*s.BYTES_PER_ELEMENT,s,e.start,e.count)}i.clearUpdateRanges()}i.onUploadCallback()}(s.buffer,i,n),s.version=i.version}}}}let Fs=class t extends Jn{constructor(t=1,e=1,i=1,n=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:i,heightSegments:n};const s=t/2,r=e/2,a=Math.floor(i),o=Math.floor(n),l=a+1,h=o+1,c=t/a,u=e/o,d=[],p=[],m=[],f=[];for(let g=0;g<h;g++){const t=g*u-r;for(let e=0;e<l;e++){const i=e*c-s;p.push(i,-t,0),m.push(0,0,1),f.push(e/a),f.push(1-g/o)}}for(let g=0;g<o;g++)for(let t=0;t<a;t++){const e=t+l*g,i=t+l*(g+1),n=t+1+l*(g+1),s=t+1+l*g;d.push(e,i,s),d.push(i,n,s)}this.setIndex(d),this.setAttribute("position",new Wn(p,3)),this.setAttribute("normal",new Wn(m,3)),this.setAttribute("uv",new Wn(f,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(e){return new t(e.width,e.height,e.widthSegments,e.heightSegments)}};const Bs={alphahash_fragment:"#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",alphahash_pars_fragment:"#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif",alphatest_pars_fragment:"#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",batching_pars_vertex:"#ifdef USE_BATCHING\n\t#if ! defined( GL_ANGLE_multi_draw )\n\t#define gl_DrawID _gl_DrawID\n\tuniform int _gl_DrawID;\n\t#endif\n\tuniform highp sampler2D batchingTexture;\n\tuniform highp usampler2D batchingIdTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n\tfloat getIndirectIndex( const in int i ) {\n\t\tint size = textureSize( batchingIdTexture, 0 ).x;\n\t\tint x = i % size;\n\t\tint y = i / size;\n\t\treturn float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n\t}\n#endif\n#ifdef USE_BATCHING_COLOR\n\tuniform sampler2D batchingColorTexture;\n\tvec3 getBatchingColor( const in float i ) {\n\t\tint size = textureSize( batchingColorTexture, 0 ).x;\n\t\tint j = int( i );\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\treturn texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n\t}\n#endif",batching_vertex:"#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif",begin_vertex:"vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",iridescence_fragment:"#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n\tvec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n\tvColor.xyz *= batchingColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\n\t\temissiveColor = sRGBTransferEOTF( emissiveColor );\n\t#endif\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",colorspace_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",colorspace_pars_fragment:"vec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferEOTF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_fragment:"LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",lights_lambert_pars_fragment:"varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif ( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphinstance_vertex:"#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif",morphcolor_vertex:"#if defined( USE_MORPHCOLORS )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t#endif\n\tuniform sampler2DArray morphTargetsTexture;\n\tuniform ivec2 morphTargetsTextureSize;\n\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t}\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",normal_fragment_begin:"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",normal_fragment_maps:"#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",normal_pars_fragment:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_pars_vertex:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_vertex:"#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",iridescence_pars_fragment:"#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",opaque_fragment:"#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec4( 0., 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec4( 1., 1., 1., 1. );\n\tfloat vuf;\n\tfloat af = modf( v * PackFactors.a, vuf );\n\tfloat bf = modf( vuf * ShiftRight8, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec3( 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec3( 1., 1., 1. );\n\tfloat vuf;\n\tfloat bf = modf( v * PackFactors.b, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec2( 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec2( 1., 1. );\n\tfloat vuf;\n\tfloat gf = modf( v * 256., vuf );\n\treturn vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n\treturn dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n\treturn v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n#endif",shadowmap_pars_vertex:"#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmission_fragment:"#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",transmission_pars_fragment:"#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t\n\t\t#else\n\t\t\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",uv_pars_fragment:"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",uv_pars_vertex:"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",uv_vertex:"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",background_frag:"uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",backgroundCube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",backgroundCube_frag:"#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",cube_frag:"uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",depth_vert:"#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#elif DEPTH_PACKING == 3202\n\t\tgl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n\t#elif DEPTH_PACKING == 3203\n\t\tgl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n\t#endif\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",meshbasic_vert:"#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshnormal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",meshnormal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",shadow_vert:"#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix[ 3 ];\n\tvec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}"},Os={common:{diffuse:{value:new Dn(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new Be},alphaMap:{value:null},alphaMapTransform:{value:new Be},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new Be}},envmap:{envMap:{value:null},envMapRotation:{value:new Be},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new Be}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new Be}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new Be},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new Be},normalScale:{value:new Fe(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new Be},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new Be}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new Be}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new Be}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Dn(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Dn(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new Be},alphaTest:{value:0},uvTransform:{value:new Be}},sprite:{diffuse:{value:new Dn(16777215)},opacity:{value:1},center:{value:new Fe(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new Be},alphaMap:{value:null},alphaMapTransform:{value:new Be},alphaTest:{value:0}}},zs={basic:{uniforms:ms([Os.common,Os.specularmap,Os.envmap,Os.aomap,Os.lightmap,Os.fog]),vertexShader:Bs.meshbasic_vert,fragmentShader:Bs.meshbasic_frag},lambert:{uniforms:ms([Os.common,Os.specularmap,Os.envmap,Os.aomap,Os.lightmap,Os.emissivemap,Os.bumpmap,Os.normalmap,Os.displacementmap,Os.fog,Os.lights,{emissive:{value:new Dn(0)}}]),vertexShader:Bs.meshlambert_vert,fragmentShader:Bs.meshlambert_frag},phong:{uniforms:ms([Os.common,Os.specularmap,Os.envmap,Os.aomap,Os.lightmap,Os.emissivemap,Os.bumpmap,Os.normalmap,Os.displacementmap,Os.fog,Os.lights,{emissive:{value:new Dn(0)},specular:{value:new Dn(1118481)},shininess:{value:30}}]),vertexShader:Bs.meshphong_vert,fragmentShader:Bs.meshphong_frag},standard:{uniforms:ms([Os.common,Os.envmap,Os.aomap,Os.lightmap,Os.emissivemap,Os.bumpmap,Os.normalmap,Os.displacementmap,Os.roughnessmap,Os.metalnessmap,Os.fog,Os.lights,{emissive:{value:new Dn(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Bs.meshphysical_vert,fragmentShader:Bs.meshphysical_frag},toon:{uniforms:ms([Os.common,Os.aomap,Os.lightmap,Os.emissivemap,Os.bumpmap,Os.normalmap,Os.displacementmap,Os.gradientmap,Os.fog,Os.lights,{emissive:{value:new Dn(0)}}]),vertexShader:Bs.meshtoon_vert,fragmentShader:Bs.meshtoon_frag},matcap:{uniforms:ms([Os.common,Os.bumpmap,Os.normalmap,Os.displacementmap,Os.fog,{matcap:{value:null}}]),vertexShader:Bs.meshmatcap_vert,fragmentShader:Bs.meshmatcap_frag},points:{uniforms:ms([Os.points,Os.fog]),vertexShader:Bs.points_vert,fragmentShader:Bs.points_frag},dashed:{uniforms:ms([Os.common,Os.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Bs.linedashed_vert,fragmentShader:Bs.linedashed_frag},depth:{uniforms:ms([Os.common,Os.displacementmap]),vertexShader:Bs.depth_vert,fragmentShader:Bs.depth_frag},normal:{uniforms:ms([Os.common,Os.bumpmap,Os.normalmap,Os.displacementmap,{opacity:{value:1}}]),vertexShader:Bs.meshnormal_vert,fragmentShader:Bs.meshnormal_frag},sprite:{uniforms:ms([Os.sprite,Os.fog]),vertexShader:Bs.sprite_vert,fragmentShader:Bs.sprite_frag},background:{uniforms:{uvTransform:{value:new Be},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:Bs.background_vert,fragmentShader:Bs.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new Be}},vertexShader:Bs.backgroundCube_vert,fragmentShader:Bs.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:Bs.cube_vert,fragmentShader:Bs.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Bs.equirect_vert,fragmentShader:Bs.equirect_frag},distanceRGBA:{uniforms:ms([Os.common,Os.displacementmap,{referencePosition:{value:new ui},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Bs.distanceRGBA_vert,fragmentShader:Bs.distanceRGBA_frag},shadow:{uniforms:ms([Os.lights,Os.fog,{color:{value:new Dn(0)},opacity:{value:1}}]),vertexShader:Bs.shadow_vert,fragmentShader:Bs.shadow_frag}};zs.physical={uniforms:ms([zs.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new Be},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new Be},clearcoatNormalScale:{value:new Fe(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new Be},dispersion:{value:0},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new Be},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new Be},sheen:{value:0},sheenColor:{value:new Dn(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new Be},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new Be},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new Be},transmissionSamplerSize:{value:new Fe},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new Be},attenuationDistance:{value:0},attenuationColor:{value:new Dn(0)},specularColor:{value:new Dn(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new Be},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new Be},anisotropyVector:{value:new Fe},anisotropyMap:{value:null},anisotropyMapTransform:{value:new Be}}]),vertexShader:Bs.meshphysical_vert,fragmentShader:Bs.meshphysical_frag};const ks={r:0,b:0,g:0},Vs=new Ki,Gs=new Vi;function Hs(t,e,i,n,s,r,a){const o=new Dn(0);let l,h,c=!0===r?0:1,u=null,d=0,p=null;function m(t){let n=!0===t.isScene?t.background:null;if(n&&n.isTexture){n=(t.backgroundBlurriness>0?i:e).get(n)}return n}function f(e,i){e.getRGB(ks,fs(t)),n.buffers.color.setClear(ks.r,ks.g,ks.b,i,a)}return{getClearColor:function(){return o},setClearColor:function(t,e=1){o.set(t),c=e,f(o,c)},getClearAlpha:function(){return c},setClearAlpha:function(t){c=t,f(o,c)},render:function(e){let i=!1;const s=m(e);null===s?f(o,c):s&&s.isColor&&(f(s,1),i=!0);const r=t.xr.getEnvironmentBlendMode();"additive"===r?n.buffers.color.setClear(0,0,0,1,a):"alpha-blend"===r&&n.buffers.color.setClear(0,0,0,0,a),(t.autoClear||i)&&(n.buffers.depth.setTest(!0),n.buffers.depth.setMask(!0),n.buffers.color.setMask(!0),t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil))},addToRenderList:function(e,i){const n=m(i);n&&(n.isCubeTexture||n.mapping===X)?(void 0===h&&(h=new cs(new ds(1,1,1),new xs({name:"BackgroundCubeMaterial",uniforms:ps(zs.backgroundCube.uniforms),vertexShader:zs.backgroundCube.vertexShader,fragmentShader:zs.backgroundCube.fragmentShader,side:1,depthTest:!1,depthWrite:!1,fog:!1})),h.geometry.deleteAttribute("normal"),h.geometry.deleteAttribute("uv"),h.onBeforeRender=function(t,e,i){this.matrixWorld.copyPosition(i.matrixWorld)},Object.defineProperty(h.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),s.update(h)),Vs.copy(i.backgroundRotation),Vs.x*=-1,Vs.y*=-1,Vs.z*=-1,n.isCubeTexture&&!1===n.isRenderTargetTexture&&(Vs.y*=-1,Vs.z*=-1),h.material.uniforms.envMap.value=n,h.material.uniforms.flipEnvMap.value=n.isCubeTexture&&!1===n.isRenderTargetTexture?-1:1,h.material.uniforms.backgroundBlurriness.value=i.backgroundBlurriness,h.material.uniforms.backgroundIntensity.value=i.backgroundIntensity,h.material.uniforms.backgroundRotation.value.setFromMatrix4(Gs.makeRotationFromEuler(Vs)),h.material.toneMapped=We.getTransfer(n.colorSpace)!==ce,u===n&&d===n.version&&p===t.toneMapping||(h.material.needsUpdate=!0,u=n,d=n.version,p=t.toneMapping),h.layers.enableAll(),e.unshift(h,h.geometry,h.material,0,0,null)):n&&n.isTexture&&(void 0===l&&(l=new cs(new Fs(2,2),new xs({name:"BackgroundMaterial",uniforms:ps(zs.background.uniforms),vertexShader:zs.background.vertexShader,fragmentShader:zs.background.fragmentShader,side:0,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),Object.defineProperty(l.material,"map",{get:function(){return this.uniforms.t2D.value}}),s.update(l)),l.material.uniforms.t2D.value=n,l.material.uniforms.backgroundIntensity.value=i.backgroundIntensity,l.material.toneMapped=We.getTransfer(n.colorSpace)!==ce,!0===n.matrixAutoUpdate&&n.updateMatrix(),l.material.uniforms.uvTransform.value.copy(n.matrix),u===n&&d===n.version&&p===t.toneMapping||(l.material.needsUpdate=!0,u=n,d=n.version,p=t.toneMapping),l.layers.enableAll(),e.unshift(l,l.geometry,l.material,0,0,null))}}}function Ws(t,e){const i=t.getParameter(t.MAX_VERTEX_ATTRIBS),n={},s=h(null);let r=s,a=!1;function o(e){return t.bindVertexArray(e)}function l(e){return t.deleteVertexArray(e)}function h(t){const e=[],n=[],s=[];for(let r=0;r<i;r++)e[r]=0,n[r]=0,s[r]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:e,enabledAttributes:n,attributeDivisors:s,object:t,attributes:{},index:null}}function c(){const t=r.newAttributes;for(let e=0,i=t.length;e<i;e++)t[e]=0}function u(t){d(t,0)}function d(e,i){const n=r.newAttributes,s=r.enabledAttributes,a=r.attributeDivisors;n[e]=1,0===s[e]&&(t.enableVertexAttribArray(e),s[e]=1),a[e]!==i&&(t.vertexAttribDivisor(e,i),a[e]=i)}function p(){const e=r.newAttributes,i=r.enabledAttributes;for(let n=0,s=i.length;n<s;n++)i[n]!==e[n]&&(t.disableVertexAttribArray(n),i[n]=0)}function m(e,i,n,s,r,a,o){!0===o?t.vertexAttribIPointer(e,i,n,r,a):t.vertexAttribPointer(e,i,n,s,r,a)}function f(){g(),a=!0,r!==s&&(r=s,o(r.object))}function g(){s.geometry=null,s.program=null,s.wireframe=!1}return{setup:function(i,s,l,f,g){let x=!1;const v=function(e,i,s){const r=!0===s.wireframe;let a=n[e.id];void 0===a&&(a={},n[e.id]=a);let o=a[i.id];void 0===o&&(o={},a[i.id]=o);let l=o[r];void 0===l&&(l=h(t.createVertexArray()),o[r]=l);return l}(f,l,s);r!==v&&(r=v,o(r.object)),x=function(t,e,i,n){const s=r.attributes,a=e.attributes;let o=0;const l=i.getAttributes();for(const r in l){if(l[r].location>=0){const e=s[r];let i=a[r];if(void 0===i&&("instanceMatrix"===r&&t.instanceMatrix&&(i=t.instanceMatrix),"instanceColor"===r&&t.instanceColor&&(i=t.instanceColor)),void 0===e)return!0;if(e.attribute!==i)return!0;if(i&&e.data!==i.data)return!0;o++}}return r.attributesNum!==o||r.index!==n}(i,f,l,g),x&&function(t,e,i,n){const s={},a=e.attributes;let o=0;const l=i.getAttributes();for(const r in l){if(l[r].location>=0){let e=a[r];void 0===e&&("instanceMatrix"===r&&t.instanceMatrix&&(e=t.instanceMatrix),"instanceColor"===r&&t.instanceColor&&(e=t.instanceColor));const i={};i.attribute=e,e&&e.data&&(i.data=e.data),s[r]=i,o++}}r.attributes=s,r.attributesNum=o,r.index=n}(i,f,l,g),null!==g&&e.update(g,t.ELEMENT_ARRAY_BUFFER),(x||a)&&(a=!1,function(i,n,s,r){c();const a=r.attributes,o=s.getAttributes(),l=n.defaultAttributeValues;for(const h in o){const n=o[h];if(n.location>=0){let s=a[h];if(void 0===s&&("instanceMatrix"===h&&i.instanceMatrix&&(s=i.instanceMatrix),"instanceColor"===h&&i.instanceColor&&(s=i.instanceColor)),void 0!==s){const a=s.normalized,o=s.itemSize,l=e.get(s);if(void 0===l)continue;const h=l.buffer,c=l.type,p=l.bytesPerElement,f=c===t.INT||c===t.UNSIGNED_INT||s.gpuType===at;if(s.isInterleavedBufferAttribute){const e=s.data,l=e.stride,g=s.offset;if(e.isInstancedInterleavedBuffer){for(let t=0;t<n.locationSize;t++)d(n.location+t,e.meshPerAttribute);!0!==i.isInstancedMesh&&void 0===r._maxInstanceCount&&(r._maxInstanceCount=e.meshPerAttribute*e.count)}else for(let t=0;t<n.locationSize;t++)u(n.location+t);t.bindBuffer(t.ARRAY_BUFFER,h);for(let t=0;t<n.locationSize;t++)m(n.location+t,o/n.locationSize,c,a,l*p,(g+o/n.locationSize*t)*p,f)}else{if(s.isInstancedBufferAttribute){for(let t=0;t<n.locationSize;t++)d(n.location+t,s.meshPerAttribute);!0!==i.isInstancedMesh&&void 0===r._maxInstanceCount&&(r._maxInstanceCount=s.meshPerAttribute*s.count)}else for(let t=0;t<n.locationSize;t++)u(n.location+t);t.bindBuffer(t.ARRAY_BUFFER,h);for(let t=0;t<n.locationSize;t++)m(n.location+t,o/n.locationSize,c,a,o*p,o/n.locationSize*t*p,f)}}else if(void 0!==l){const e=l[h];if(void 0!==e)switch(e.length){case 2:t.vertexAttrib2fv(n.location,e);break;case 3:t.vertexAttrib3fv(n.location,e);break;case 4:t.vertexAttrib4fv(n.location,e);break;default:t.vertexAttrib1fv(n.location,e)}}}}p()}(i,s,l,f),null!==g&&t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,e.get(g).buffer))},reset:f,resetDefaultState:g,dispose:function(){f();for(const t in n){const e=n[t];for(const t in e){const i=e[t];for(const t in i)l(i[t].object),delete i[t];delete e[t]}delete n[t]}},releaseStatesOfGeometry:function(t){if(void 0===n[t.id])return;const e=n[t.id];for(const i in e){const t=e[i];for(const e in t)l(t[e].object),delete t[e];delete e[i]}delete n[t.id]},releaseStatesOfProgram:function(t){for(const e in n){const i=n[e];if(void 0===i[t.id])continue;const s=i[t.id];for(const t in s)l(s[t].object),delete s[t];delete i[t.id]}},initAttributes:c,enableAttribute:u,disableUnusedAttributes:p}}function js(t,e,i){let n;function s(e,s,r){0!==r&&(t.drawArraysInstanced(n,e,s,r),i.update(s,n,r))}this.setMode=function(t){n=t},this.render=function(e,s){t.drawArrays(n,e,s),i.update(s,n,1)},this.renderInstances=s,this.renderMultiDraw=function(t,s,r){if(0===r)return;e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n,t,0,s,0,r);let a=0;for(let e=0;e<r;e++)a+=s[e];i.update(a,n,1)},this.renderMultiDrawInstances=function(t,r,a,o){if(0===a)return;const l=e.get("WEBGL_multi_draw");if(null===l)for(let e=0;e<t.length;e++)s(t[e],r[e],o[e]);else{l.multiDrawArraysInstancedWEBGL(n,t,0,r,0,o,0,a);let e=0;for(let t=0;t<a;t++)e+=r[t]*o[t];i.update(e,n,1)}}}function Xs(t,e,i,n){let s;function r(e){if("highp"===e){if(t.getShaderPrecisionFormat(t.VERTEX_SHADER,t.HIGH_FLOAT).precision>0&&t.getShaderPrecisionFormat(t.FRAGMENT_SHADER,t.HIGH_FLOAT).precision>0)return"highp";e="mediump"}return"mediump"===e&&t.getShaderPrecisionFormat(t.VERTEX_SHADER,t.MEDIUM_FLOAT).precision>0&&t.getShaderPrecisionFormat(t.FRAGMENT_SHADER,t.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}let a=void 0!==i.precision?i.precision:"highp";const o=r(a);o!==a&&(a=o);const l=!0===i.logarithmicDepthBuffer,h=!0===i.reverseDepthBuffer&&e.has("EXT_clip_control"),c=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),u=t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS);return{isWebGL2:!0,getMaxAnisotropy:function(){if(void 0!==s)return s;if(!0===e.has("EXT_texture_filter_anisotropic")){const i=e.get("EXT_texture_filter_anisotropic");s=t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else s=0;return s},getMaxPrecision:r,textureFormatReadable:function(e){return e===mt||n.convert(e)===t.getParameter(t.IMPLEMENTATION_COLOR_READ_FORMAT)},textureTypeReadable:function(i){const s=i===ht&&(e.has("EXT_color_buffer_half_float")||e.has("EXT_color_buffer_float"));return!(i!==it&&n.convert(i)!==t.getParameter(t.IMPLEMENTATION_COLOR_READ_TYPE)&&i!==lt&&!s)},precision:a,logarithmicDepthBuffer:l,reverseDepthBuffer:h,maxTextures:c,maxVertexTextures:u,maxTextureSize:t.getParameter(t.MAX_TEXTURE_SIZE),maxCubemapSize:t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),maxAttributes:t.getParameter(t.MAX_VERTEX_ATTRIBS),maxVertexUniforms:t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),maxVaryings:t.getParameter(t.MAX_VARYING_VECTORS),maxFragmentUniforms:t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),vertexTextures:u>0,maxSamples:t.getParameter(t.MAX_SAMPLES)}}function qs(t){const e=this;let i=null,n=0,s=!1,r=!1;const a=new Ns,o=new Be,l={value:null,needsUpdate:!1};function h(t,i,n,s){const r=null!==t?t.length:0;let h=null;if(0!==r){if(h=l.value,!0!==s||null===h){const e=n+4*r,s=i.matrixWorldInverse;o.getNormalMatrix(s),(null===h||h.length<e)&&(h=new Float32Array(e));for(let i=0,l=n;i!==r;++i,l+=4)a.copy(t[i]).applyMatrix4(s,o),a.normal.toArray(h,l),h[l+3]=a.constant}l.value=h,l.needsUpdate=!0}return e.numPlanes=r,e.numIntersection=0,h}this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(t,e){const i=0!==t.length||e||0!==n||s;return s=e,n=t.length,i},this.beginShadows=function(){r=!0,h(null)},this.endShadows=function(){r=!1},this.setGlobalState=function(t,e){i=h(t,e,0)},this.setState=function(a,o,c){const u=a.clippingPlanes,d=a.clipIntersection,p=a.clipShadows,m=t.get(a);if(!s||null===u||0===u.length||r&&!p)r?h(null):function(){l.value!==i&&(l.value=i,l.needsUpdate=n>0);e.numPlanes=n,e.numIntersection=0}();else{const t=r?0:n,e=4*t;let s=m.clippingState||null;l.value=s,s=h(u,o,e,c);for(let n=0;n!==e;++n)s[n]=i[n];m.clippingState=s,this.numIntersection=d?this.numPlanes:0,this.numPlanes+=t}}}function $s(t){let e=new WeakMap;function i(t,e){return e===j?t.mapping=H:304===e&&(t.mapping=W),t}function n(t){const i=t.target;i.removeEventListener("dispose",n);const s=e.get(i);void 0!==s&&(e.delete(i),s.dispose())}return{get:function(s){if(s&&s.isTexture){const r=s.mapping;if(r===j||304===r){if(e.has(s)){return i(e.get(s).texture,s.mapping)}{const r=s.image;if(r&&r.height>0){const a=new As(r.height);return a.fromEquirectangularTexture(t,s),e.set(s,a),s.addEventListener("dispose",n),i(a.texture,s.mapping)}return null}}}return s},dispose:function(){e=new WeakMap}}}let Ys=class extends vs{constructor(t=-1,e=1,i=1,n=-1,s=.1,r=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=i,this.bottom=n,this.near=s,this.far=r,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=null===t.view?null:Object.assign({},t.view),this}setViewOffset(t,e,i,n,s,r){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=i,this.view.offsetY=n,this.view.width=s,this.view.height=r,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),i=(this.right+this.left)/2,n=(this.top+this.bottom)/2;let s=i-t,r=i+t,a=n+e,o=n-e;if(null!==this.view&&this.view.enabled){const t=(this.right-this.left)/this.view.fullWidth/this.zoom,e=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=t*this.view.offsetX,r=s+t*this.view.width,a-=e*this.view.offsetY,o=a-e*this.view.height}this.projectionMatrix.makeOrthographic(s,r,a,o,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,null!==this.view&&(e.object.view=Object.assign({},this.view)),e}};const Zs=[.125,.215,.35,.446,.526,.582],Ks=20,Js=new Ys,Qs=new Dn;let tr=null,er=0,ir=0,nr=!1;const sr=(1+Math.sqrt(5))/2,rr=1/sr,ar=[new ui(-sr,rr,0),new ui(sr,rr,0),new ui(-rr,0,sr),new ui(rr,0,sr),new ui(0,sr,-rr),new ui(0,sr,rr),new ui(-1,1,-1),new ui(1,1,-1),new ui(-1,1,1),new ui(1,1,1)];let or=class{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(t,e=0,i=.1,n=100){tr=this._renderer.getRenderTarget(),er=this._renderer.getActiveCubeFace(),ir=this._renderer.getActiveMipmapLevel(),nr=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(256);const s=this._allocateTargets();return s.depthBuffer=!0,this._sceneToCubeUV(t,i,n,s),e>0&&this._blur(s,0,0,e),this._applyPMREM(s),this._cleanup(s),s}fromEquirectangular(t,e=null){return this._fromTexture(t,e)}fromCubemap(t,e=null){return this._fromTexture(t,e)}compileCubemapShader(){null===this._cubemapMaterial&&(this._cubemapMaterial=ur(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){null===this._equirectMaterial&&(this._equirectMaterial=cr(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),null!==this._cubemapMaterial&&this._cubemapMaterial.dispose(),null!==this._equirectMaterial&&this._equirectMaterial.dispose()}_setSize(t){this._lodMax=Math.floor(Math.log2(t)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){null!==this._blurMaterial&&this._blurMaterial.dispose(),null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose();for(let t=0;t<this._lodPlanes.length;t++)this._lodPlanes[t].dispose()}_cleanup(t){this._renderer.setRenderTarget(tr,er,ir),this._renderer.xr.enabled=nr,t.scissorTest=!1,hr(t,0,0,t.width,t.height)}_fromTexture(t,e){t.mapping===H||t.mapping===W?this._setSize(0===t.image.length?16:t.image[0].width||t.image[0].image.width):this._setSize(t.image.width/4),tr=this._renderer.getRenderTarget(),er=this._renderer.getActiveCubeFace(),ir=this._renderer.getActiveMipmapLevel(),nr=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;const i=e||this._allocateTargets();return this._textureToCubeUV(t,i),this._applyPMREM(i),this._cleanup(i),i}_allocateTargets(){const t=3*Math.max(this._cubeSize,112),e=4*this._cubeSize,i={magFilter:Q,minFilter:Q,generateMipmaps:!1,type:ht,format:mt,colorSpace:le,depthBuffer:!1},n=lr(t,e,i);if(null===this._pingPongRenderTarget||this._pingPongRenderTarget.width!==t||this._pingPongRenderTarget.height!==e){null!==this._pingPongRenderTarget&&this._dispose(),this._pingPongRenderTarget=lr(t,e,i);const{_lodMax:n}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=function(t){const e=[],i=[],n=[];let s=t;const r=t-4+1+Zs.length;for(let a=0;a<r;a++){const r=Math.pow(2,s);i.push(r);let o=1/r;a>t-4?o=Zs[a-t+4-1]:0===a&&(o=0),n.push(o);const l=1/(r-2),h=-l,c=1+l,u=[h,h,c,h,c,c,h,h,c,c,h,c],d=6,p=6,m=3,f=2,g=1,x=new Float32Array(m*p*d),v=new Float32Array(f*p*d),_=new Float32Array(g*p*d);for(let t=0;t<d;t++){const e=t%3*2/3-1,i=t>2?0:-1,n=[e,i,0,e+2/3,i,0,e+2/3,i+1,0,e,i,0,e+2/3,i+1,0,e,i+1,0];x.set(n,m*p*t),v.set(u,f*p*t);const s=[t,t,t,t,t,t];_.set(s,g*p*t)}const y=new Jn;y.setAttribute("position",new Vn(x,m)),y.setAttribute("uv",new Vn(v,f)),y.setAttribute("faceIndex",new Vn(_,g)),e.push(y),s>4&&s--}return{lodPlanes:e,sizeLods:i,sigmas:n}}(n)),this._blurMaterial=function(t,e,i){const n=new Float32Array(Ks),s=new ui(0,1,0),r=new xs({name:"SphericalGaussianBlur",defines:{n:Ks,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/i,CUBEUV_MAX_MIP:`${t}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:n},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:s}},vertexShader:dr(),fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1});return r}(n,t,e)}return n}_compileMaterial(t){const e=new cs(this._lodPlanes[0],t);this._renderer.compile(e,Js)}_sceneToCubeUV(t,e,i,n){const s=new Ss(90,1,e,i),r=[1,-1,1,1,1,1],a=[1,1,1,-1,-1,-1],o=this._renderer,l=o.autoClear,h=o.toneMapping;o.getClearColor(Qs),o.toneMapping=0,o.autoClear=!1;const c=new On({name:"PMREM.Background",side:1,depthWrite:!1,depthTest:!1}),u=new cs(new ds,c);let d=!1;const p=t.background;p?p.isColor&&(c.color.copy(p),t.background=null,d=!0):(c.color.copy(Qs),d=!0);for(let m=0;m<6;m++){const e=m%3;0===e?(s.up.set(0,r[m],0),s.lookAt(a[m],0,0)):1===e?(s.up.set(0,0,r[m]),s.lookAt(0,a[m],0)):(s.up.set(0,r[m],0),s.lookAt(0,0,a[m]));const i=this._cubeSize;hr(n,e*i,m>2?i:0,i,i),o.setRenderTarget(n),d&&o.render(u,s),o.render(t,s)}u.geometry.dispose(),u.material.dispose(),o.toneMapping=h,o.autoClear=l,t.background=p}_textureToCubeUV(t,e){const i=this._renderer,n=t.mapping===H||t.mapping===W;n?(null===this._cubemapMaterial&&(this._cubemapMaterial=ur()),this._cubemapMaterial.uniforms.flipEnvMap.value=!1===t.isRenderTargetTexture?-1:1):null===this._equirectMaterial&&(this._equirectMaterial=cr());const s=n?this._cubemapMaterial:this._equirectMaterial,r=new cs(this._lodPlanes[0],s);s.uniforms.envMap.value=t;const a=this._cubeSize;hr(e,0,0,3*a,2*a),i.setRenderTarget(e),i.render(r,Js)}_applyPMREM(t){const e=this._renderer,i=e.autoClear;e.autoClear=!1;const n=this._lodPlanes.length;for(let s=1;s<n;s++){const e=Math.sqrt(this._sigmas[s]*this._sigmas[s]-this._sigmas[s-1]*this._sigmas[s-1]),i=ar[(n-s-1)%ar.length];this._blur(t,s-1,s,e,i)}e.autoClear=i}_blur(t,e,i,n,s){const r=this._pingPongRenderTarget;this._halfBlur(t,r,e,i,n,"latitudinal",s),this._halfBlur(r,t,i,i,n,"longitudinal",s)}_halfBlur(t,e,i,n,s,r,a){const o=this._renderer,l=this._blurMaterial,h=new cs(this._lodPlanes[n],l),c=l.uniforms,u=this._sizeLods[i]-1,d=isFinite(s)?Math.PI/(2*u):2*Math.PI/39,p=s/d,m=isFinite(s)?1+Math.floor(3*p):Ks,f=[];let g=0;for(let _=0;_<Ks;++_){const t=_/p,e=Math.exp(-t*t/2);f.push(e),0===_?g+=e:_<m&&(g+=2*e)}for(let _=0;_<f.length;_++)f[_]=f[_]/g;c.envMap.value=t.texture,c.samples.value=m,c.weights.value=f,c.latitudinal.value="latitudinal"===r,a&&(c.poleAxis.value=a);const{_lodMax:x}=this;c.dTheta.value=d,c.mipInt.value=x-i;const v=this._sizeLods[n];hr(e,3*v*(n>x-4?n-x+4:0),4*(this._cubeSize-v),3*v,2*v),o.setRenderTarget(e),o.render(h,Js)}};function lr(t,e,i){const n=new oi(t,e,i);return n.texture.mapping=X,n.texture.name="PMREM.cubeUv",n.scissorTest=!0,n}function hr(t,e,i,n,s){t.viewport.set(e,i,n,s),t.scissor.set(e,i,n,s)}function cr(){return new xs({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:dr(),fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1})}function ur(){return new xs({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:dr(),fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1})}function dr(){return"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"}function pr(t){let e=new WeakMap,i=null;function n(t){const i=t.target;i.removeEventListener("dispose",n);const s=e.get(i);void 0!==s&&(e.delete(i),s.dispose())}return{get:function(s){if(s&&s.isTexture){const r=s.mapping,a=r===j||304===r,o=r===H||r===W;if(a||o){let r=e.get(s);const l=void 0!==r?r.texture.pmremVersion:0;if(s.isRenderTargetTexture&&s.pmremVersion!==l)return null===i&&(i=new or(t)),r=a?i.fromEquirectangular(s,r):i.fromCubemap(s,r),r.texture.pmremVersion=s.pmremVersion,e.set(s,r),r.texture;if(void 0!==r)return r.texture;{const l=s.image;return a&&l&&l.height>0||o&&l&&function(t){let e=0;const i=6;for(let n=0;n<i;n++)void 0!==t[n]&&e++;return e===i}(l)?(null===i&&(i=new or(t)),r=a?i.fromEquirectangular(s):i.fromCubemap(s),r.texture.pmremVersion=s.pmremVersion,e.set(s,r),s.addEventListener("dispose",n),r.texture):null}}}return s},dispose:function(){e=new WeakMap,null!==i&&(i.dispose(),i=null)}}}function mr(t){const e={};function i(i){if(void 0!==e[i])return e[i];let n;switch(i){case"WEBGL_depth_texture":n=t.getExtension("WEBGL_depth_texture")||t.getExtension("MOZ_WEBGL_depth_texture")||t.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":n=t.getExtension("EXT_texture_filter_anisotropic")||t.getExtension("MOZ_EXT_texture_filter_anisotropic")||t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":n=t.getExtension("WEBGL_compressed_texture_s3tc")||t.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":n=t.getExtension("WEBGL_compressed_texture_pvrtc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:n=t.getExtension(i)}return e[i]=n,n}return{has:function(t){return null!==i(t)},init:function(){i("EXT_color_buffer_float"),i("WEBGL_clip_cull_distance"),i("OES_texture_float_linear"),i("EXT_color_buffer_half_float"),i("WEBGL_multisampled_render_to_texture"),i("WEBGL_render_shared_exponent")},get:function(t){const e=i(t);return null===e&&He("THREE.WebGLRenderer: "+t+" extension not supported."),e}}}function fr(t,e,i,n){const s={},r=new WeakMap;function a(t){const o=t.target;null!==o.index&&e.remove(o.index);for(const i in o.attributes)e.remove(o.attributes[i]);for(const i in o.morphAttributes){const t=o.morphAttributes[i];for(let i=0,n=t.length;i<n;i++)e.remove(t[i])}o.removeEventListener("dispose",a),delete s[o.id];const l=r.get(o);l&&(e.remove(l),r.delete(o)),n.releaseStatesOfGeometry(o),!0===o.isInstancedBufferGeometry&&delete o._maxInstanceCount,i.memory.geometries--}function o(t){const i=[],n=t.index,s=t.attributes.position;let a=0;if(null!==n){const t=n.array;a=n.version;for(let e=0,n=t.length;e<n;e+=3){const n=t[e+0],s=t[e+1],r=t[e+2];i.push(n,s,s,r,r,n)}}else{if(void 0===s)return;{const t=s.array;a=s.version;for(let e=0,n=t.length/3-1;e<n;e+=3){const t=e+0,n=e+1,s=e+2;i.push(t,n,n,s,s,t)}}}const o=new(ze(i)?Hn:Gn)(i,1);o.version=a;const l=r.get(t);l&&e.remove(l),r.set(t,o)}return{get:function(t,e){return!0===s[e.id]||(e.addEventListener("dispose",a),s[e.id]=!0,i.memory.geometries++),e},update:function(i){const n=i.attributes;for(const r in n)e.update(n[r],t.ARRAY_BUFFER);const s=i.morphAttributes;for(const r in s){const i=s[r];for(let n=0,s=i.length;n<s;n++)e.update(i[n],t.ARRAY_BUFFER)}},getWireframeAttribute:function(t){const e=r.get(t);if(e){const i=t.index;null!==i&&e.version<i.version&&o(t)}else o(t);return r.get(t)}}}function gr(t,e,i){let n,s,r;function a(e,a,o){0!==o&&(t.drawElementsInstanced(n,a,s,e*r,o),i.update(a,n,o))}this.setMode=function(t){n=t},this.setIndex=function(t){s=t.type,r=t.bytesPerElement},this.render=function(e,a){t.drawElements(n,a,s,e*r),i.update(a,n,1)},this.renderInstances=a,this.renderMultiDraw=function(t,r,a){if(0===a)return;e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n,r,0,s,t,0,a);let o=0;for(let e=0;e<a;e++)o+=r[e];i.update(o,n,1)},this.renderMultiDrawInstances=function(t,o,l,h){if(0===l)return;const c=e.get("WEBGL_multi_draw");if(null===c)for(let e=0;e<t.length;e++)a(t[e]/r,o[e],h[e]);else{c.multiDrawElementsInstancedWEBGL(n,o,0,s,t,0,h,0,l);let e=0;for(let t=0;t<l;t++)e+=o[t]*h[t];i.update(e,n,1)}}}function xr(t){const e={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:e,programs:null,autoReset:!0,reset:function(){e.calls=0,e.triangles=0,e.points=0,e.lines=0},update:function(i,n,s){switch(e.calls++,n){case t.TRIANGLES:e.triangles+=s*(i/3);break;case t.LINES:e.lines+=s*(i/2);break;case t.LINE_STRIP:e.lines+=s*(i-1);break;case t.LINE_LOOP:e.lines+=s*i;break;case t.POINTS:e.points+=s*i}}}}function vr(t,e,i){const n=new WeakMap,s=new ri;return{update:function(r,a,o){const l=r.morphTargetInfluences,h=a.morphAttributes.position||a.morphAttributes.normal||a.morphAttributes.color,c=void 0!==h?h.length:0;let u=n.get(a);if(void 0===u||u.count!==c){let t=function(){x.dispose(),n.delete(a),a.removeEventListener("dispose",t)};void 0!==u&&u.texture.dispose();const i=void 0!==a.morphAttributes.position,r=void 0!==a.morphAttributes.normal,o=void 0!==a.morphAttributes.color,l=a.morphAttributes.position||[],h=a.morphAttributes.normal||[],d=a.morphAttributes.color||[];let p=0;!0===i&&(p=1),!0===r&&(p=2),!0===o&&(p=3);let m=a.attributes.position.count*p,f=1;m>e.maxTextureSize&&(f=Math.ceil(m/e.maxTextureSize),m=e.maxTextureSize);const g=new Float32Array(m*f*4*c),x=new li(g,m,f,c);x.type=lt,x.needsUpdate=!0;const v=4*p;for(let e=0;e<c;e++){const t=l[e],n=h[e],a=d[e],c=m*f*4*e;for(let e=0;e<t.count;e++){const l=e*v;!0===i&&(s.fromBufferAttribute(t,e),g[c+l+0]=s.x,g[c+l+1]=s.y,g[c+l+2]=s.z,g[c+l+3]=0),!0===r&&(s.fromBufferAttribute(n,e),g[c+l+4]=s.x,g[c+l+5]=s.y,g[c+l+6]=s.z,g[c+l+7]=0),!0===o&&(s.fromBufferAttribute(a,e),g[c+l+8]=s.x,g[c+l+9]=s.y,g[c+l+10]=s.z,g[c+l+11]=4===a.itemSize?s.w:1)}}u={count:c,texture:x,size:new Fe(m,f)},n.set(a,u),a.addEventListener("dispose",t)}if(!0===r.isInstancedMesh&&null!==r.morphTexture)o.getUniforms().setValue(t,"morphTexture",r.morphTexture,i);else{let e=0;for(let t=0;t<l.length;t++)e+=l[t];const i=a.morphTargetsRelative?1:1-e;o.getUniforms().setValue(t,"morphTargetBaseInfluence",i),o.getUniforms().setValue(t,"morphTargetInfluences",l)}o.getUniforms().setValue(t,"morphTargetsTexture",u.texture,i),o.getUniforms().setValue(t,"morphTargetsTextureSize",u.size)}}}function _r(t,e,i,n){let s=new WeakMap;function r(t){const e=t.target;e.removeEventListener("dispose",r),i.remove(e.instanceMatrix),null!==e.instanceColor&&i.remove(e.instanceColor)}return{update:function(a){const o=n.render.frame,l=a.geometry,h=e.get(a,l);if(s.get(h)!==o&&(e.update(h),s.set(h,o)),a.isInstancedMesh&&(!1===a.hasEventListener("dispose",r)&&a.addEventListener("dispose",r),s.get(a)!==o&&(i.update(a.instanceMatrix,t.ARRAY_BUFFER),null!==a.instanceColor&&i.update(a.instanceColor,t.ARRAY_BUFFER),s.set(a,o))),a.isSkinnedMesh){const t=a.skeleton;s.get(t)!==o&&(t.update(),s.set(t,o))}return h},dispose:function(){s=new WeakMap}}}let yr=class extends si{constructor(t,e,i,n,s,r,a,o,l,h=1026){if(h!==ft&&h!==gt)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===i&&h===ft&&(i=ot),void 0===i&&h===gt&&(i=dt),super(null,n,s,r,a,o,h,i,l),this.isDepthTexture=!0,this.image={width:t,height:e},this.magFilter=void 0!==a?a:Z,this.minFilter=void 0!==o?o:Z,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(t){return super.copy(t),this.compareFunction=t.compareFunction,this}toJSON(t){const e=super.toJSON(t);return null!==this.compareFunction&&(e.compareFunction=this.compareFunction),e}};const br=new si,Sr=new yr(1,1),Mr=new li,Tr=new hi,wr=new ws,Ar=[],Er=[],Cr=new Float32Array(16),Rr=new Float32Array(9),Nr=new Float32Array(4);function Pr(t,e,i){const n=t[0];if(n<=0||n>0)return t;const s=e*i;let r=Ar[s];if(void 0===r&&(r=new Float32Array(s),Ar[s]=r),0!==e){n.toArray(r,0);for(let n=1,s=0;n!==e;++n)s+=i,t[n].toArray(r,s)}return r}function Ir(t,e){if(t.length!==e.length)return!1;for(let i=0,n=t.length;i<n;i++)if(t[i]!==e[i])return!1;return!0}function Lr(t,e){for(let i=0,n=e.length;i<n;i++)t[i]=e[i]}function Dr(t,e){let i=Er[e];void 0===i&&(i=new Int32Array(e),Er[e]=i);for(let n=0;n!==e;++n)i[n]=t.allocateTextureUnit();return i}function Ur(t,e){const i=this.cache;i[0]!==e&&(t.uniform1f(this.addr,e),i[0]=e)}function Fr(t,e){const i=this.cache;if(void 0!==e.x)i[0]===e.x&&i[1]===e.y||(t.uniform2f(this.addr,e.x,e.y),i[0]=e.x,i[1]=e.y);else{if(Ir(i,e))return;t.uniform2fv(this.addr,e),Lr(i,e)}}function Br(t,e){const i=this.cache;if(void 0!==e.x)i[0]===e.x&&i[1]===e.y&&i[2]===e.z||(t.uniform3f(this.addr,e.x,e.y,e.z),i[0]=e.x,i[1]=e.y,i[2]=e.z);else if(void 0!==e.r)i[0]===e.r&&i[1]===e.g&&i[2]===e.b||(t.uniform3f(this.addr,e.r,e.g,e.b),i[0]=e.r,i[1]=e.g,i[2]=e.b);else{if(Ir(i,e))return;t.uniform3fv(this.addr,e),Lr(i,e)}}function Or(t,e){const i=this.cache;if(void 0!==e.x)i[0]===e.x&&i[1]===e.y&&i[2]===e.z&&i[3]===e.w||(t.uniform4f(this.addr,e.x,e.y,e.z,e.w),i[0]=e.x,i[1]=e.y,i[2]=e.z,i[3]=e.w);else{if(Ir(i,e))return;t.uniform4fv(this.addr,e),Lr(i,e)}}function zr(t,e){const i=this.cache,n=e.elements;if(void 0===n){if(Ir(i,e))return;t.uniformMatrix2fv(this.addr,!1,e),Lr(i,e)}else{if(Ir(i,n))return;Nr.set(n),t.uniformMatrix2fv(this.addr,!1,Nr),Lr(i,n)}}function kr(t,e){const i=this.cache,n=e.elements;if(void 0===n){if(Ir(i,e))return;t.uniformMatrix3fv(this.addr,!1,e),Lr(i,e)}else{if(Ir(i,n))return;Rr.set(n),t.uniformMatrix3fv(this.addr,!1,Rr),Lr(i,n)}}function Vr(t,e){const i=this.cache,n=e.elements;if(void 0===n){if(Ir(i,e))return;t.uniformMatrix4fv(this.addr,!1,e),Lr(i,e)}else{if(Ir(i,n))return;Cr.set(n),t.uniformMatrix4fv(this.addr,!1,Cr),Lr(i,n)}}function Gr(t,e){const i=this.cache;i[0]!==e&&(t.uniform1i(this.addr,e),i[0]=e)}function Hr(t,e){const i=this.cache;if(void 0!==e.x)i[0]===e.x&&i[1]===e.y||(t.uniform2i(this.addr,e.x,e.y),i[0]=e.x,i[1]=e.y);else{if(Ir(i,e))return;t.uniform2iv(this.addr,e),Lr(i,e)}}function Wr(t,e){const i=this.cache;if(void 0!==e.x)i[0]===e.x&&i[1]===e.y&&i[2]===e.z||(t.uniform3i(this.addr,e.x,e.y,e.z),i[0]=e.x,i[1]=e.y,i[2]=e.z);else{if(Ir(i,e))return;t.uniform3iv(this.addr,e),Lr(i,e)}}function jr(t,e){const i=this.cache;if(void 0!==e.x)i[0]===e.x&&i[1]===e.y&&i[2]===e.z&&i[3]===e.w||(t.uniform4i(this.addr,e.x,e.y,e.z,e.w),i[0]=e.x,i[1]=e.y,i[2]=e.z,i[3]=e.w);else{if(Ir(i,e))return;t.uniform4iv(this.addr,e),Lr(i,e)}}function Xr(t,e){const i=this.cache;i[0]!==e&&(t.uniform1ui(this.addr,e),i[0]=e)}function qr(t,e){const i=this.cache;if(void 0!==e.x)i[0]===e.x&&i[1]===e.y||(t.uniform2ui(this.addr,e.x,e.y),i[0]=e.x,i[1]=e.y);else{if(Ir(i,e))return;t.uniform2uiv(this.addr,e),Lr(i,e)}}function $r(t,e){const i=this.cache;if(void 0!==e.x)i[0]===e.x&&i[1]===e.y&&i[2]===e.z||(t.uniform3ui(this.addr,e.x,e.y,e.z),i[0]=e.x,i[1]=e.y,i[2]=e.z);else{if(Ir(i,e))return;t.uniform3uiv(this.addr,e),Lr(i,e)}}function Yr(t,e){const i=this.cache;if(void 0!==e.x)i[0]===e.x&&i[1]===e.y&&i[2]===e.z&&i[3]===e.w||(t.uniform4ui(this.addr,e.x,e.y,e.z,e.w),i[0]=e.x,i[1]=e.y,i[2]=e.z,i[3]=e.w);else{if(Ir(i,e))return;t.uniform4uiv(this.addr,e),Lr(i,e)}}function Zr(t,e,i){const n=this.cache,s=i.allocateTextureUnit();let r;n[0]!==s&&(t.uniform1i(this.addr,s),n[0]=s),this.type===t.SAMPLER_2D_SHADOW?(Sr.compareFunction=515,r=Sr):r=br,i.setTexture2D(e||r,s)}function Kr(t,e,i){const n=this.cache,s=i.allocateTextureUnit();n[0]!==s&&(t.uniform1i(this.addr,s),n[0]=s),i.setTexture3D(e||Tr,s)}function Jr(t,e,i){const n=this.cache,s=i.allocateTextureUnit();n[0]!==s&&(t.uniform1i(this.addr,s),n[0]=s),i.setTextureCube(e||wr,s)}function Qr(t,e,i){const n=this.cache,s=i.allocateTextureUnit();n[0]!==s&&(t.uniform1i(this.addr,s),n[0]=s),i.setTexture2DArray(e||Mr,s)}function ta(t,e){t.uniform1fv(this.addr,e)}function ea(t,e){const i=Pr(e,this.size,2);t.uniform2fv(this.addr,i)}function ia(t,e){const i=Pr(e,this.size,3);t.uniform3fv(this.addr,i)}function na(t,e){const i=Pr(e,this.size,4);t.uniform4fv(this.addr,i)}function sa(t,e){const i=Pr(e,this.size,4);t.uniformMatrix2fv(this.addr,!1,i)}function ra(t,e){const i=Pr(e,this.size,9);t.uniformMatrix3fv(this.addr,!1,i)}function aa(t,e){const i=Pr(e,this.size,16);t.uniformMatrix4fv(this.addr,!1,i)}function oa(t,e){t.uniform1iv(this.addr,e)}function la(t,e){t.uniform2iv(this.addr,e)}function ha(t,e){t.uniform3iv(this.addr,e)}function ca(t,e){t.uniform4iv(this.addr,e)}function ua(t,e){t.uniform1uiv(this.addr,e)}function da(t,e){t.uniform2uiv(this.addr,e)}function pa(t,e){t.uniform3uiv(this.addr,e)}function ma(t,e){t.uniform4uiv(this.addr,e)}function fa(t,e,i){const n=this.cache,s=e.length,r=Dr(i,s);Ir(n,r)||(t.uniform1iv(this.addr,r),Lr(n,r));for(let a=0;a!==s;++a)i.setTexture2D(e[a]||br,r[a])}function ga(t,e,i){const n=this.cache,s=e.length,r=Dr(i,s);Ir(n,r)||(t.uniform1iv(this.addr,r),Lr(n,r));for(let a=0;a!==s;++a)i.setTexture3D(e[a]||Tr,r[a])}function xa(t,e,i){const n=this.cache,s=e.length,r=Dr(i,s);Ir(n,r)||(t.uniform1iv(this.addr,r),Lr(n,r));for(let a=0;a!==s;++a)i.setTextureCube(e[a]||wr,r[a])}function va(t,e,i){const n=this.cache,s=e.length,r=Dr(i,s);Ir(n,r)||(t.uniform1iv(this.addr,r),Lr(n,r));for(let a=0;a!==s;++a)i.setTexture2DArray(e[a]||Mr,r[a])}class _a{constructor(t,e,i){this.id=t,this.addr=i,this.cache=[],this.type=e.type,this.setValue=function(t){switch(t){case 5126:return Ur;case 35664:return Fr;case 35665:return Br;case 35666:return Or;case 35674:return zr;case 35675:return kr;case 35676:return Vr;case 5124:case 35670:return Gr;case 35667:case 35671:return Hr;case 35668:case 35672:return Wr;case 35669:case 35673:return jr;case 5125:return Xr;case 36294:return qr;case 36295:return $r;case 36296:return Yr;case 35678:case 36198:case 36298:case 36306:case 35682:return Zr;case 35679:case 36299:case 36307:return Kr;case 35680:case 36300:case 36308:case 36293:return Jr;case 36289:case 36303:case 36311:case 36292:return Qr}}(e.type)}}class ya{constructor(t,e,i){this.id=t,this.addr=i,this.cache=[],this.type=e.type,this.size=e.size,this.setValue=function(t){switch(t){case 5126:return ta;case 35664:return ea;case 35665:return ia;case 35666:return na;case 35674:return sa;case 35675:return ra;case 35676:return aa;case 5124:case 35670:return oa;case 35667:case 35671:return la;case 35668:case 35672:return ha;case 35669:case 35673:return ca;case 5125:return ua;case 36294:return da;case 36295:return pa;case 36296:return ma;case 35678:case 36198:case 36298:case 36306:case 35682:return fa;case 35679:case 36299:case 36307:return ga;case 35680:case 36300:case 36308:case 36293:return xa;case 36289:case 36303:case 36311:case 36292:return va}}(e.type)}}class ba{constructor(t){this.id=t,this.seq=[],this.map={}}setValue(t,e,i){const n=this.seq;for(let s=0,r=n.length;s!==r;++s){const r=n[s];r.setValue(t,e[r.id],i)}}}const Sa=/(\w+)(\])?(\[|\.)?/g;function Ma(t,e){t.seq.push(e),t.map[e.id]=e}function Ta(t,e,i){const n=t.name,s=n.length;for(Sa.lastIndex=0;;){const r=Sa.exec(n),a=Sa.lastIndex;let o=r[1];const l="]"===r[2],h=r[3];if(l&&(o|=0),void 0===h||"["===h&&a+2===s){Ma(i,void 0===h?new _a(o,t,e):new ya(o,t,e));break}{let t=i.map[o];void 0===t&&(t=new ba(o),Ma(i,t)),i=t}}}class wa{constructor(t,e){this.seq=[],this.map={};const i=t.getProgramParameter(e,t.ACTIVE_UNIFORMS);for(let n=0;n<i;++n){const i=t.getActiveUniform(e,n);Ta(i,t.getUniformLocation(e,i.name),this)}}setValue(t,e,i,n){const s=this.map[e];void 0!==s&&s.setValue(t,i,n)}setOptional(t,e,i){const n=e[i];void 0!==n&&this.setValue(t,i,n)}static upload(t,e,i,n){for(let s=0,r=e.length;s!==r;++s){const r=e[s],a=i[r.id];!1!==a.needsUpdate&&r.setValue(t,a.value,n)}}static seqWithValue(t,e){const i=[];for(let n=0,s=t.length;n!==s;++n){const s=t[n];s.id in e&&i.push(s)}return i}}function Aa(t,e,i){const n=t.createShader(e);return t.shaderSource(n,i),t.compileShader(n),n}let Ea=0;const Ca=new Be;function Ra(t,e,i){const n=t.getShaderParameter(e,t.COMPILE_STATUS),s=t.getShaderInfoLog(e).trim();if(n&&""===s)return"";const r=/ERROR: 0:(\d+)/.exec(s);if(r){const n=parseInt(r[1]);return i.toUpperCase()+"\n\n"+s+"\n\n"+function(t,e){const i=t.split("\n"),n=[],s=Math.max(e-6,0),r=Math.min(e+6,i.length);for(let a=s;a<r;a++){const t=a+1;n.push(`${t===e?">":" "} ${t}: ${i[a]}`)}return n.join("\n")}(t.getShaderSource(e),n)}return s}function Na(t,e){const i=function(t){We._getMatrix(Ca,We.workingColorSpace,t);const e=`mat3( ${Ca.elements.map((t=>t.toFixed(4)))} )`;switch(We.getTransfer(t)){case he:return[e,"LinearTransferOETF"];case ce:return[e,"sRGBTransferOETF"];default:return[e,"LinearTransferOETF"]}}(e);return[`vec4 ${t}( vec4 value ) {`,`\treturn ${i[1]}( vec4( value.rgb * ${i[0]}, value.a ) );`,"}"].join("\n")}function Pa(t,e){let i;switch(e){case 1:default:i="Linear";break;case 2:i="Reinhard";break;case 3:i="Cineon";break;case 4:i="ACESFilmic";break;case 6:i="AgX";break;case 7:i="Neutral";break;case 5:i="Custom"}return"vec3 "+t+"( vec3 color ) { return "+i+"ToneMapping( color ); }"}const Ia=new ui;function La(){We.getLuminanceCoefficients(Ia);return["float luminance( const in vec3 rgb ) {",`\tconst vec3 weights = vec3( ${Ia.x.toFixed(4)}, ${Ia.y.toFixed(4)}, ${Ia.z.toFixed(4)} );`,"\treturn dot( weights, rgb );","}"].join("\n")}function Da(t){return""!==t}function Ua(t,e){const i=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return t.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,i).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function Fa(t,e){return t.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const Ba=/^[ \t]*#include +<([\w\d./]+)>/gm;function Oa(t){return t.replace(Ba,ka)}const za=new Map;function ka(t,e){let i=Bs[e];if(void 0===i){const t=za.get(e);if(void 0===t)throw new Error("Can not resolve #include <"+e+">");i=Bs[t]}return Oa(i)}const Va=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function Ga(t){return t.replace(Va,Ha)}function Ha(t,e,i,n){let s="";for(let r=parseInt(e);r<parseInt(i);r++)s+=n.replace(/\[\s*i\s*\]/g,"[ "+r+" ]").replace(/UNROLLED_LOOP_INDEX/g,r);return s}function Wa(t){let e=`precision ${t.precision} float;\n\tprecision ${t.precision} int;\n\tprecision ${t.precision} sampler2D;\n\tprecision ${t.precision} samplerCube;\n\tprecision ${t.precision} sampler3D;\n\tprecision ${t.precision} sampler2DArray;\n\tprecision ${t.precision} sampler2DShadow;\n\tprecision ${t.precision} samplerCubeShadow;\n\tprecision ${t.precision} sampler2DArrayShadow;\n\tprecision ${t.precision} isampler2D;\n\tprecision ${t.precision} isampler3D;\n\tprecision ${t.precision} isamplerCube;\n\tprecision ${t.precision} isampler2DArray;\n\tprecision ${t.precision} usampler2D;\n\tprecision ${t.precision} usampler3D;\n\tprecision ${t.precision} usamplerCube;\n\tprecision ${t.precision} usampler2DArray;\n\t`;return"highp"===t.precision?e+="\n#define HIGH_PRECISION":"mediump"===t.precision?e+="\n#define MEDIUM_PRECISION":"lowp"===t.precision&&(e+="\n#define LOW_PRECISION"),e}function ja(t,e,i,n){const s=t.getContext(),r=i.defines;let a=i.vertexShader,o=i.fragmentShader;const l=function(t){let e="SHADOWMAP_TYPE_BASIC";return 1===t.shadowMapType?e="SHADOWMAP_TYPE_PCF":2===t.shadowMapType?e="SHADOWMAP_TYPE_PCF_SOFT":3===t.shadowMapType&&(e="SHADOWMAP_TYPE_VSM"),e}(i),h=function(t){let e="ENVMAP_TYPE_CUBE";if(t.envMap)switch(t.envMapMode){case H:case W:e="ENVMAP_TYPE_CUBE";break;case X:e="ENVMAP_TYPE_CUBE_UV"}return e}(i),c=function(t){let e="ENVMAP_MODE_REFLECTION";t.envMap&&t.envMapMode===W&&(e="ENVMAP_MODE_REFRACTION");return e}(i),u=function(t){let e="ENVMAP_BLENDING_NONE";if(t.envMap)switch(t.combine){case 0:e="ENVMAP_BLENDING_MULTIPLY";break;case 1:e="ENVMAP_BLENDING_MIX";break;case 2:e="ENVMAP_BLENDING_ADD"}return e}(i),d=function(t){const e=t.envMapCubeUVHeight;if(null===e)return null;const i=Math.log2(e)-2,n=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,i),112)),texelHeight:n,maxMip:i}}(i),p=function(t){return[t.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",t.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(Da).join("\n")}(i),m=function(t){const e=[];for(const i in t){const n=t[i];!1!==n&&e.push("#define "+i+" "+n)}return e.join("\n")}(r),f=s.createProgram();let g,x,v=i.glslVersion?"#version "+i.glslVersion+"\n":"";i.isRawShaderMaterial?(g=["#define SHADER_TYPE "+i.shaderType,"#define SHADER_NAME "+i.shaderName,m].filter(Da).join("\n"),g.length>0&&(g+="\n"),x=["#define SHADER_TYPE "+i.shaderType,"#define SHADER_NAME "+i.shaderName,m].filter(Da).join("\n"),x.length>0&&(x+="\n")):(g=[Wa(i),"#define SHADER_TYPE "+i.shaderType,"#define SHADER_NAME "+i.shaderName,m,i.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",i.batching?"#define USE_BATCHING":"",i.batchingColor?"#define USE_BATCHING_COLOR":"",i.instancing?"#define USE_INSTANCING":"",i.instancingColor?"#define USE_INSTANCING_COLOR":"",i.instancingMorph?"#define USE_INSTANCING_MORPH":"",i.useFog&&i.fog?"#define USE_FOG":"",i.useFog&&i.fogExp2?"#define FOG_EXP2":"",i.map?"#define USE_MAP":"",i.envMap?"#define USE_ENVMAP":"",i.envMap?"#define "+c:"",i.lightMap?"#define USE_LIGHTMAP":"",i.aoMap?"#define USE_AOMAP":"",i.bumpMap?"#define USE_BUMPMAP":"",i.normalMap?"#define USE_NORMALMAP":"",i.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",i.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",i.displacementMap?"#define USE_DISPLACEMENTMAP":"",i.emissiveMap?"#define USE_EMISSIVEMAP":"",i.anisotropy?"#define USE_ANISOTROPY":"",i.anisotropyMap?"#define USE_ANISOTROPYMAP":"",i.clearcoatMap?"#define USE_CLEARCOATMAP":"",i.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",i.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",i.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",i.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",i.specularMap?"#define USE_SPECULARMAP":"",i.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",i.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",i.roughnessMap?"#define USE_ROUGHNESSMAP":"",i.metalnessMap?"#define USE_METALNESSMAP":"",i.alphaMap?"#define USE_ALPHAMAP":"",i.alphaHash?"#define USE_ALPHAHASH":"",i.transmission?"#define USE_TRANSMISSION":"",i.transmissionMap?"#define USE_TRANSMISSIONMAP":"",i.thicknessMap?"#define USE_THICKNESSMAP":"",i.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",i.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",i.mapUv?"#define MAP_UV "+i.mapUv:"",i.alphaMapUv?"#define ALPHAMAP_UV "+i.alphaMapUv:"",i.lightMapUv?"#define LIGHTMAP_UV "+i.lightMapUv:"",i.aoMapUv?"#define AOMAP_UV "+i.aoMapUv:"",i.emissiveMapUv?"#define EMISSIVEMAP_UV "+i.emissiveMapUv:"",i.bumpMapUv?"#define BUMPMAP_UV "+i.bumpMapUv:"",i.normalMapUv?"#define NORMALMAP_UV "+i.normalMapUv:"",i.displacementMapUv?"#define DISPLACEMENTMAP_UV "+i.displacementMapUv:"",i.metalnessMapUv?"#define METALNESSMAP_UV "+i.metalnessMapUv:"",i.roughnessMapUv?"#define ROUGHNESSMAP_UV "+i.roughnessMapUv:"",i.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+i.anisotropyMapUv:"",i.clearcoatMapUv?"#define CLEARCOATMAP_UV "+i.clearcoatMapUv:"",i.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+i.clearcoatNormalMapUv:"",i.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+i.clearcoatRoughnessMapUv:"",i.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+i.iridescenceMapUv:"",i.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+i.iridescenceThicknessMapUv:"",i.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+i.sheenColorMapUv:"",i.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+i.sheenRoughnessMapUv:"",i.specularMapUv?"#define SPECULARMAP_UV "+i.specularMapUv:"",i.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+i.specularColorMapUv:"",i.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+i.specularIntensityMapUv:"",i.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+i.transmissionMapUv:"",i.thicknessMapUv?"#define THICKNESSMAP_UV "+i.thicknessMapUv:"",i.vertexTangents&&!1===i.flatShading?"#define USE_TANGENT":"",i.vertexColors?"#define USE_COLOR":"",i.vertexAlphas?"#define USE_COLOR_ALPHA":"",i.vertexUv1s?"#define USE_UV1":"",i.vertexUv2s?"#define USE_UV2":"",i.vertexUv3s?"#define USE_UV3":"",i.pointsUvs?"#define USE_POINTS_UV":"",i.flatShading?"#define FLAT_SHADED":"",i.skinning?"#define USE_SKINNING":"",i.morphTargets?"#define USE_MORPHTARGETS":"",i.morphNormals&&!1===i.flatShading?"#define USE_MORPHNORMALS":"",i.morphColors?"#define USE_MORPHCOLORS":"",i.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE_STRIDE "+i.morphTextureStride:"",i.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+i.morphTargetsCount:"",i.doubleSided?"#define DOUBLE_SIDED":"",i.flipSided?"#define FLIP_SIDED":"",i.shadowMapEnabled?"#define USE_SHADOWMAP":"",i.shadowMapEnabled?"#define "+l:"",i.sizeAttenuation?"#define USE_SIZEATTENUATION":"",i.numLightProbes>0?"#define USE_LIGHT_PROBES":"",i.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",i.reverseDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","\tuniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","\tattribute vec2 uv1;","#endif","#ifdef USE_UV2","\tattribute vec2 uv2;","#endif","#ifdef USE_UV3","\tattribute vec2 uv3;","#endif","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","\tattribute vec4 color;","#elif defined( USE_COLOR )","\tattribute vec3 color;","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(Da).join("\n"),x=[Wa(i),"#define SHADER_TYPE "+i.shaderType,"#define SHADER_NAME "+i.shaderName,m,i.useFog&&i.fog?"#define USE_FOG":"",i.useFog&&i.fogExp2?"#define FOG_EXP2":"",i.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",i.map?"#define USE_MAP":"",i.matcap?"#define USE_MATCAP":"",i.envMap?"#define USE_ENVMAP":"",i.envMap?"#define "+h:"",i.envMap?"#define "+c:"",i.envMap?"#define "+u:"",d?"#define CUBEUV_TEXEL_WIDTH "+d.texelWidth:"",d?"#define CUBEUV_TEXEL_HEIGHT "+d.texelHeight:"",d?"#define CUBEUV_MAX_MIP "+d.maxMip+".0":"",i.lightMap?"#define USE_LIGHTMAP":"",i.aoMap?"#define USE_AOMAP":"",i.bumpMap?"#define USE_BUMPMAP":"",i.normalMap?"#define USE_NORMALMAP":"",i.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",i.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",i.emissiveMap?"#define USE_EMISSIVEMAP":"",i.anisotropy?"#define USE_ANISOTROPY":"",i.anisotropyMap?"#define USE_ANISOTROPYMAP":"",i.clearcoat?"#define USE_CLEARCOAT":"",i.clearcoatMap?"#define USE_CLEARCOATMAP":"",i.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",i.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",i.dispersion?"#define USE_DISPERSION":"",i.iridescence?"#define USE_IRIDESCENCE":"",i.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",i.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",i.specularMap?"#define USE_SPECULARMAP":"",i.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",i.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",i.roughnessMap?"#define USE_ROUGHNESSMAP":"",i.metalnessMap?"#define USE_METALNESSMAP":"",i.alphaMap?"#define USE_ALPHAMAP":"",i.alphaTest?"#define USE_ALPHATEST":"",i.alphaHash?"#define USE_ALPHAHASH":"",i.sheen?"#define USE_SHEEN":"",i.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",i.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",i.transmission?"#define USE_TRANSMISSION":"",i.transmissionMap?"#define USE_TRANSMISSIONMAP":"",i.thicknessMap?"#define USE_THICKNESSMAP":"",i.vertexTangents&&!1===i.flatShading?"#define USE_TANGENT":"",i.vertexColors||i.instancingColor||i.batchingColor?"#define USE_COLOR":"",i.vertexAlphas?"#define USE_COLOR_ALPHA":"",i.vertexUv1s?"#define USE_UV1":"",i.vertexUv2s?"#define USE_UV2":"",i.vertexUv3s?"#define USE_UV3":"",i.pointsUvs?"#define USE_POINTS_UV":"",i.gradientMap?"#define USE_GRADIENTMAP":"",i.flatShading?"#define FLAT_SHADED":"",i.doubleSided?"#define DOUBLE_SIDED":"",i.flipSided?"#define FLIP_SIDED":"",i.shadowMapEnabled?"#define USE_SHADOWMAP":"",i.shadowMapEnabled?"#define "+l:"",i.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",i.numLightProbes>0?"#define USE_LIGHT_PROBES":"",i.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",i.decodeVideoTextureEmissive?"#define DECODE_VIDEO_TEXTURE_EMISSIVE":"",i.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",i.reverseDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",0!==i.toneMapping?"#define TONE_MAPPING":"",0!==i.toneMapping?Bs.tonemapping_pars_fragment:"",0!==i.toneMapping?Pa("toneMapping",i.toneMapping):"",i.dithering?"#define DITHERING":"",i.opaque?"#define OPAQUE":"",Bs.colorspace_pars_fragment,Na("linearToOutputTexel",i.outputColorSpace),La(),i.useDepthPacking?"#define DEPTH_PACKING "+i.depthPacking:"","\n"].filter(Da).join("\n")),a=Oa(a),a=Ua(a,i),a=Fa(a,i),o=Oa(o),o=Ua(o,i),o=Fa(o,i),a=Ga(a),o=Ga(o),!0!==i.isRawShaderMaterial&&(v="#version 300 es\n",g=[p,"#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+g,x=["#define varying in",i.glslVersion===be?"":"layout(location = 0) out highp vec4 pc_fragColor;",i.glslVersion===be?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+x);const _=v+g+a,y=v+x+o,b=Aa(s,s.VERTEX_SHADER,_),S=Aa(s,s.FRAGMENT_SHADER,y);function M(e){if(t.debug.checkShaderErrors){const i=s.getProgramInfoLog(f).trim(),n=s.getShaderInfoLog(b).trim(),r=s.getShaderInfoLog(S).trim();let a=!0,o=!0;if(!1===s.getProgramParameter(f,s.LINK_STATUS))if(a=!1,"function"==typeof t.debug.onShaderError)t.debug.onShaderError(s,f,b,S);else{Ra(s,b,"vertex"),Ra(s,S,"fragment")}else""!==i||""!==n&&""!==r||(o=!1);o&&(e.diagnostics={runnable:a,programLog:i,vertexShader:{log:n,prefix:g},fragmentShader:{log:r,prefix:x}})}s.deleteShader(b),s.deleteShader(S),T=new wa(s,f),w=function(t,e){const i={},n=t.getProgramParameter(e,t.ACTIVE_ATTRIBUTES);for(let s=0;s<n;s++){const n=t.getActiveAttrib(e,s),r=n.name;let a=1;n.type===t.FLOAT_MAT2&&(a=2),n.type===t.FLOAT_MAT3&&(a=3),n.type===t.FLOAT_MAT4&&(a=4),i[r]={type:n.type,location:t.getAttribLocation(e,r),locationSize:a}}return i}(s,f)}let T,w;s.attachShader(f,b),s.attachShader(f,S),void 0!==i.index0AttributeName?s.bindAttribLocation(f,0,i.index0AttributeName):!0===i.morphTargets&&s.bindAttribLocation(f,0,"position"),s.linkProgram(f),this.getUniforms=function(){return void 0===T&&M(this),T},this.getAttributes=function(){return void 0===w&&M(this),w};let A=!1===i.rendererExtensionParallelShaderCompile;return this.isReady=function(){return!1===A&&(A=s.getProgramParameter(f,37297)),A},this.destroy=function(){n.releaseStatesOfProgram(this),s.deleteProgram(f),this.program=void 0},this.type=i.shaderType,this.name=i.shaderName,this.id=Ea++,this.cacheKey=e,this.usedTimes=1,this.program=f,this.vertexShader=b,this.fragmentShader=S,this}let Xa=0;class qa{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(t){const e=t.vertexShader,i=t.fragmentShader,n=this._getShaderStage(e),s=this._getShaderStage(i),r=this._getShaderCacheForMaterial(t);return!1===r.has(n)&&(r.add(n),n.usedTimes++),!1===r.has(s)&&(r.add(s),s.usedTimes++),this}remove(t){const e=this.materialCache.get(t);for(const i of e)i.usedTimes--,0===i.usedTimes&&this.shaderCache.delete(i.code);return this.materialCache.delete(t),this}getVertexShaderID(t){return this._getShaderStage(t.vertexShader).id}getFragmentShaderID(t){return this._getShaderStage(t.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(t){const e=this.materialCache;let i=e.get(t);return void 0===i&&(i=new Set,e.set(t,i)),i}_getShaderStage(t){const e=this.shaderCache;let i=e.get(t);return void 0===i&&(i=new $a(t),e.set(t,i)),i}}class $a{constructor(t){this.id=Xa++,this.code=t,this.usedTimes=0}}function Ya(t,e,i,n,s,r,a){const o=new Ji,l=new qa,h=new Set,c=[],u=s.logarithmicDepthBuffer,d=s.vertexTextures;let p=s.precision;const m={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function f(t){return h.add(t),0===t?"uv":`uv${t}`}return{getParameters:function(r,o,c,g,x){const v=g.fog,_=x.geometry,y=r.isMeshStandardMaterial?g.environment:null,b=(r.isMeshStandardMaterial?i:e).get(r.envMap||y),S=b&&b.mapping===X?b.image.height:null,M=m[r.type];null!==r.precision&&(p=s.getMaxPrecision(r.precision),r.precision);const T=_.morphAttributes.position||_.morphAttributes.normal||_.morphAttributes.color,w=void 0!==T?T.length:0;let A,E,C,R,N=0;if(void 0!==_.morphAttributes.position&&(N=1),void 0!==_.morphAttributes.normal&&(N=2),void 0!==_.morphAttributes.color&&(N=3),M){const t=zs[M];A=t.vertexShader,E=t.fragmentShader}else A=r.vertexShader,E=r.fragmentShader,l.update(r),C=l.getVertexShaderID(r),R=l.getFragmentShaderID(r);const P=t.getRenderTarget(),I=t.state.buffers.depth.getReversed(),L=!0===x.isInstancedMesh,D=!0===x.isBatchedMesh,U=!!r.map,F=!!r.matcap,B=!!b,O=!!r.aoMap,z=!!r.lightMap,k=!!r.bumpMap,V=!!r.normalMap,G=!!r.displacementMap,H=!!r.emissiveMap,W=!!r.metalnessMap,j=!!r.roughnessMap,q=r.anisotropy>0,$=r.clearcoat>0,Y=r.dispersion>0,Z=r.iridescence>0,K=r.sheen>0,J=r.transmission>0,Q=q&&!!r.anisotropyMap,tt=$&&!!r.clearcoatMap,et=$&&!!r.clearcoatNormalMap,it=$&&!!r.clearcoatRoughnessMap,nt=Z&&!!r.iridescenceMap,st=Z&&!!r.iridescenceThicknessMap,rt=K&&!!r.sheenColorMap,at=K&&!!r.sheenRoughnessMap,ot=!!r.specularMap,lt=!!r.specularColorMap,ht=!!r.specularIntensityMap,ct=J&&!!r.transmissionMap,ut=J&&!!r.thicknessMap,dt=!!r.gradientMap,pt=!!r.alphaMap,mt=r.alphaTest>0,ft=!!r.alphaHash,gt=!!r.extensions;let xt=0;r.toneMapped&&(null!==P&&!0!==P.isXRRenderTarget||(xt=t.toneMapping));const vt={shaderID:M,shaderType:r.type,shaderName:r.name,vertexShader:A,fragmentShader:E,defines:r.defines,customVertexShaderID:C,customFragmentShaderID:R,isRawShaderMaterial:!0===r.isRawShaderMaterial,glslVersion:r.glslVersion,precision:p,batching:D,batchingColor:D&&null!==x._colorsTexture,instancing:L,instancingColor:L&&null!==x.instanceColor,instancingMorph:L&&null!==x.morphTexture,supportsVertexTextures:d,outputColorSpace:null===P?t.outputColorSpace:!0===P.isXRRenderTarget?P.texture.colorSpace:le,alphaToCoverage:!!r.alphaToCoverage,map:U,matcap:F,envMap:B,envMapMode:B&&b.mapping,envMapCubeUVHeight:S,aoMap:O,lightMap:z,bumpMap:k,normalMap:V,displacementMap:d&&G,emissiveMap:H,normalMapObjectSpace:V&&1===r.normalMapType,normalMapTangentSpace:V&&0===r.normalMapType,metalnessMap:W,roughnessMap:j,anisotropy:q,anisotropyMap:Q,clearcoat:$,clearcoatMap:tt,clearcoatNormalMap:et,clearcoatRoughnessMap:it,dispersion:Y,iridescence:Z,iridescenceMap:nt,iridescenceThicknessMap:st,sheen:K,sheenColorMap:rt,sheenRoughnessMap:at,specularMap:ot,specularColorMap:lt,specularIntensityMap:ht,transmission:J,transmissionMap:ct,thicknessMap:ut,gradientMap:dt,opaque:!1===r.transparent&&1===r.blending&&!1===r.alphaToCoverage,alphaMap:pt,alphaTest:mt,alphaHash:ft,combine:r.combine,mapUv:U&&f(r.map.channel),aoMapUv:O&&f(r.aoMap.channel),lightMapUv:z&&f(r.lightMap.channel),bumpMapUv:k&&f(r.bumpMap.channel),normalMapUv:V&&f(r.normalMap.channel),displacementMapUv:G&&f(r.displacementMap.channel),emissiveMapUv:H&&f(r.emissiveMap.channel),metalnessMapUv:W&&f(r.metalnessMap.channel),roughnessMapUv:j&&f(r.roughnessMap.channel),anisotropyMapUv:Q&&f(r.anisotropyMap.channel),clearcoatMapUv:tt&&f(r.clearcoatMap.channel),clearcoatNormalMapUv:et&&f(r.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:it&&f(r.clearcoatRoughnessMap.channel),iridescenceMapUv:nt&&f(r.iridescenceMap.channel),iridescenceThicknessMapUv:st&&f(r.iridescenceThicknessMap.channel),sheenColorMapUv:rt&&f(r.sheenColorMap.channel),sheenRoughnessMapUv:at&&f(r.sheenRoughnessMap.channel),specularMapUv:ot&&f(r.specularMap.channel),specularColorMapUv:lt&&f(r.specularColorMap.channel),specularIntensityMapUv:ht&&f(r.specularIntensityMap.channel),transmissionMapUv:ct&&f(r.transmissionMap.channel),thicknessMapUv:ut&&f(r.thicknessMap.channel),alphaMapUv:pt&&f(r.alphaMap.channel),vertexTangents:!!_.attributes.tangent&&(V||q),vertexColors:r.vertexColors,vertexAlphas:!0===r.vertexColors&&!!_.attributes.color&&4===_.attributes.color.itemSize,pointsUvs:!0===x.isPoints&&!!_.attributes.uv&&(U||pt),fog:!!v,useFog:!0===r.fog,fogExp2:!!v&&v.isFogExp2,flatShading:!0===r.flatShading,sizeAttenuation:!0===r.sizeAttenuation,logarithmicDepthBuffer:u,reverseDepthBuffer:I,skinning:!0===x.isSkinnedMesh,morphTargets:void 0!==_.morphAttributes.position,morphNormals:void 0!==_.morphAttributes.normal,morphColors:void 0!==_.morphAttributes.color,morphTargetsCount:w,morphTextureStride:N,numDirLights:o.directional.length,numPointLights:o.point.length,numSpotLights:o.spot.length,numSpotLightMaps:o.spotLightMap.length,numRectAreaLights:o.rectArea.length,numHemiLights:o.hemi.length,numDirLightShadows:o.directionalShadowMap.length,numPointLightShadows:o.pointShadowMap.length,numSpotLightShadows:o.spotShadowMap.length,numSpotLightShadowsWithMaps:o.numSpotLightShadowsWithMaps,numLightProbes:o.numLightProbes,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,dithering:r.dithering,shadowMapEnabled:t.shadowMap.enabled&&c.length>0,shadowMapType:t.shadowMap.type,toneMapping:xt,decodeVideoTexture:U&&!0===r.map.isVideoTexture&&We.getTransfer(r.map.colorSpace)===ce,decodeVideoTextureEmissive:H&&!0===r.emissiveMap.isVideoTexture&&We.getTransfer(r.emissiveMap.colorSpace)===ce,premultipliedAlpha:r.premultipliedAlpha,doubleSided:2===r.side,flipSided:1===r.side,useDepthPacking:r.depthPacking>=0,depthPacking:r.depthPacking||0,index0AttributeName:r.index0AttributeName,extensionClipCullDistance:gt&&!0===r.extensions.clipCullDistance&&n.has("WEBGL_clip_cull_distance"),extensionMultiDraw:(gt&&!0===r.extensions.multiDraw||D)&&n.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:n.has("KHR_parallel_shader_compile"),customProgramCacheKey:r.customProgramCacheKey()};return vt.vertexUv1s=h.has(1),vt.vertexUv2s=h.has(2),vt.vertexUv3s=h.has(3),h.clear(),vt},getProgramCacheKey:function(e){const i=[];if(e.shaderID?i.push(e.shaderID):(i.push(e.customVertexShaderID),i.push(e.customFragmentShaderID)),void 0!==e.defines)for(const t in e.defines)i.push(t),i.push(e.defines[t]);return!1===e.isRawShaderMaterial&&(!function(t,e){t.push(e.precision),t.push(e.outputColorSpace),t.push(e.envMapMode),t.push(e.envMapCubeUVHeight),t.push(e.mapUv),t.push(e.alphaMapUv),t.push(e.lightMapUv),t.push(e.aoMapUv),t.push(e.bumpMapUv),t.push(e.normalMapUv),t.push(e.displacementMapUv),t.push(e.emissiveMapUv),t.push(e.metalnessMapUv),t.push(e.roughnessMapUv),t.push(e.anisotropyMapUv),t.push(e.clearcoatMapUv),t.push(e.clearcoatNormalMapUv),t.push(e.clearcoatRoughnessMapUv),t.push(e.iridescenceMapUv),t.push(e.iridescenceThicknessMapUv),t.push(e.sheenColorMapUv),t.push(e.sheenRoughnessMapUv),t.push(e.specularMapUv),t.push(e.specularColorMapUv),t.push(e.specularIntensityMapUv),t.push(e.transmissionMapUv),t.push(e.thicknessMapUv),t.push(e.combine),t.push(e.fogExp2),t.push(e.sizeAttenuation),t.push(e.morphTargetsCount),t.push(e.morphAttributeCount),t.push(e.numDirLights),t.push(e.numPointLights),t.push(e.numSpotLights),t.push(e.numSpotLightMaps),t.push(e.numHemiLights),t.push(e.numRectAreaLights),t.push(e.numDirLightShadows),t.push(e.numPointLightShadows),t.push(e.numSpotLightShadows),t.push(e.numSpotLightShadowsWithMaps),t.push(e.numLightProbes),t.push(e.shadowMapType),t.push(e.toneMapping),t.push(e.numClippingPlanes),t.push(e.numClipIntersection),t.push(e.depthPacking)}(i,e),function(t,e){o.disableAll(),e.supportsVertexTextures&&o.enable(0);e.instancing&&o.enable(1);e.instancingColor&&o.enable(2);e.instancingMorph&&o.enable(3);e.matcap&&o.enable(4);e.envMap&&o.enable(5);e.normalMapObjectSpace&&o.enable(6);e.normalMapTangentSpace&&o.enable(7);e.clearcoat&&o.enable(8);e.iridescence&&o.enable(9);e.alphaTest&&o.enable(10);e.vertexColors&&o.enable(11);e.vertexAlphas&&o.enable(12);e.vertexUv1s&&o.enable(13);e.vertexUv2s&&o.enable(14);e.vertexUv3s&&o.enable(15);e.vertexTangents&&o.enable(16);e.anisotropy&&o.enable(17);e.alphaHash&&o.enable(18);e.batching&&o.enable(19);e.dispersion&&o.enable(20);e.batchingColor&&o.enable(21);t.push(o.mask),o.disableAll(),e.fog&&o.enable(0);e.useFog&&o.enable(1);e.flatShading&&o.enable(2);e.logarithmicDepthBuffer&&o.enable(3);e.reverseDepthBuffer&&o.enable(4);e.skinning&&o.enable(5);e.morphTargets&&o.enable(6);e.morphNormals&&o.enable(7);e.morphColors&&o.enable(8);e.premultipliedAlpha&&o.enable(9);e.shadowMapEnabled&&o.enable(10);e.doubleSided&&o.enable(11);e.flipSided&&o.enable(12);e.useDepthPacking&&o.enable(13);e.dithering&&o.enable(14);e.transmission&&o.enable(15);e.sheen&&o.enable(16);e.opaque&&o.enable(17);e.pointsUvs&&o.enable(18);e.decodeVideoTexture&&o.enable(19);e.decodeVideoTextureEmissive&&o.enable(20);e.alphaToCoverage&&o.enable(21);t.push(o.mask)}(i,e),i.push(t.outputColorSpace)),i.push(e.customProgramCacheKey),i.join()},getUniforms:function(t){const e=m[t.type];let i;if(e){const t=zs[e];i=gs.clone(t.uniforms)}else i=t.uniforms;return i},acquireProgram:function(e,i){let n;for(let t=0,s=c.length;t<s;t++){const e=c[t];if(e.cacheKey===i){n=e,++n.usedTimes;break}}return void 0===n&&(n=new ja(t,i,e,r),c.push(n)),n},releaseProgram:function(t){if(0==--t.usedTimes){const e=c.indexOf(t);c[e]=c[c.length-1],c.pop(),t.destroy()}},releaseShaderCache:function(t){l.remove(t)},programs:c,dispose:function(){l.dispose()}}}function Za(){let t=new WeakMap;return{has:function(e){return t.has(e)},get:function(e){let i=t.get(e);return void 0===i&&(i={},t.set(e,i)),i},remove:function(e){t.delete(e)},update:function(e,i,n){t.get(e)[i]=n},dispose:function(){t=new WeakMap}}}function Ka(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.material.id!==e.material.id?t.material.id-e.material.id:t.z!==e.z?t.z-e.z:t.id-e.id}function Ja(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.z!==e.z?e.z-t.z:t.id-e.id}function Qa(){const t=[];let e=0;const i=[],n=[],s=[];function r(i,n,s,r,a,o){let l=t[e];return void 0===l?(l={id:i.id,object:i,geometry:n,material:s,groupOrder:r,renderOrder:i.renderOrder,z:a,group:o},t[e]=l):(l.id=i.id,l.object=i,l.geometry=n,l.material=s,l.groupOrder=r,l.renderOrder=i.renderOrder,l.z=a,l.group=o),e++,l}return{opaque:i,transmissive:n,transparent:s,init:function(){e=0,i.length=0,n.length=0,s.length=0},push:function(t,e,a,o,l,h){const c=r(t,e,a,o,l,h);a.transmission>0?n.push(c):!0===a.transparent?s.push(c):i.push(c)},unshift:function(t,e,a,o,l,h){const c=r(t,e,a,o,l,h);a.transmission>0?n.unshift(c):!0===a.transparent?s.unshift(c):i.unshift(c)},finish:function(){for(let i=e,n=t.length;i<n;i++){const e=t[i];if(null===e.id)break;e.id=null,e.object=null,e.geometry=null,e.material=null,e.group=null}},sort:function(t,e){i.length>1&&i.sort(t||Ka),n.length>1&&n.sort(e||Ja),s.length>1&&s.sort(e||Ja)}}}function to(){let t=new WeakMap;return{get:function(e,i){const n=t.get(e);let s;return void 0===n?(s=new Qa,t.set(e,[s])):i>=n.length?(s=new Qa,n.push(s)):s=n[i],s},dispose:function(){t=new WeakMap}}}function eo(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let i;switch(e.type){case"DirectionalLight":i={direction:new ui,color:new Dn};break;case"SpotLight":i={position:new ui,direction:new ui,color:new Dn,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":i={position:new ui,color:new Dn,distance:0,decay:0};break;case"HemisphereLight":i={direction:new ui,skyColor:new Dn,groundColor:new Dn};break;case"RectAreaLight":i={color:new Dn,position:new ui,halfWidth:new ui,halfHeight:new ui}}return t[e.id]=i,i}}}let io=0;function no(t,e){return(e.castShadow?2:0)-(t.castShadow?2:0)+(e.map?1:0)-(t.map?1:0)}function so(t){const e=new eo,i=function(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let i;switch(e.type){case"DirectionalLight":case"SpotLight":i={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Fe};break;case"PointLight":i={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Fe,shadowCameraNear:1,shadowCameraFar:1e3}}return t[e.id]=i,i}}}(),n={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let o=0;o<9;o++)n.probe.push(new ui);const s=new ui,r=new Vi,a=new Vi;return{setup:function(s){let r=0,a=0,o=0;for(let t=0;t<9;t++)n.probe[t].set(0,0,0);let l=0,h=0,c=0,u=0,d=0,p=0,m=0,f=0,g=0,x=0,v=0;s.sort(no);for(let t=0,y=s.length;t<y;t++){const _=s[t],y=_.color,b=_.intensity,S=_.distance,M=_.shadow&&_.shadow.map?_.shadow.map.texture:null;if(_.isAmbientLight)r+=y.r*b,a+=y.g*b,o+=y.b*b;else if(_.isLightProbe){for(let t=0;t<9;t++)n.probe[t].addScaledVector(_.sh.coefficients[t],b);v++}else if(_.isDirectionalLight){const t=e.get(_);if(t.color.copy(_.color).multiplyScalar(_.intensity),_.castShadow){const t=_.shadow,e=i.get(_);e.shadowIntensity=t.intensity,e.shadowBias=t.bias,e.shadowNormalBias=t.normalBias,e.shadowRadius=t.radius,e.shadowMapSize=t.mapSize,n.directionalShadow[l]=e,n.directionalShadowMap[l]=M,n.directionalShadowMatrix[l]=_.shadow.matrix,p++}n.directional[l]=t,l++}else if(_.isSpotLight){const t=e.get(_);t.position.setFromMatrixPosition(_.matrixWorld),t.color.copy(y).multiplyScalar(b),t.distance=S,t.coneCos=Math.cos(_.angle),t.penumbraCos=Math.cos(_.angle*(1-_.penumbra)),t.decay=_.decay,n.spot[c]=t;const s=_.shadow;if(_.map&&(n.spotLightMap[g]=_.map,g++,s.updateMatrices(_),_.castShadow&&x++),n.spotLightMatrix[c]=s.matrix,_.castShadow){const t=i.get(_);t.shadowIntensity=s.intensity,t.shadowBias=s.bias,t.shadowNormalBias=s.normalBias,t.shadowRadius=s.radius,t.shadowMapSize=s.mapSize,n.spotShadow[c]=t,n.spotShadowMap[c]=M,f++}c++}else if(_.isRectAreaLight){const t=e.get(_);t.color.copy(y).multiplyScalar(b),t.halfWidth.set(.5*_.width,0,0),t.halfHeight.set(0,.5*_.height,0),n.rectArea[u]=t,u++}else if(_.isPointLight){const t=e.get(_);if(t.color.copy(_.color).multiplyScalar(_.intensity),t.distance=_.distance,t.decay=_.decay,_.castShadow){const t=_.shadow,e=i.get(_);e.shadowIntensity=t.intensity,e.shadowBias=t.bias,e.shadowNormalBias=t.normalBias,e.shadowRadius=t.radius,e.shadowMapSize=t.mapSize,e.shadowCameraNear=t.camera.near,e.shadowCameraFar=t.camera.far,n.pointShadow[h]=e,n.pointShadowMap[h]=M,n.pointShadowMatrix[h]=_.shadow.matrix,m++}n.point[h]=t,h++}else if(_.isHemisphereLight){const t=e.get(_);t.skyColor.copy(_.color).multiplyScalar(b),t.groundColor.copy(_.groundColor).multiplyScalar(b),n.hemi[d]=t,d++}}u>0&&(!0===t.has("OES_texture_float_linear")?(n.rectAreaLTC1=Os.LTC_FLOAT_1,n.rectAreaLTC2=Os.LTC_FLOAT_2):(n.rectAreaLTC1=Os.LTC_HALF_1,n.rectAreaLTC2=Os.LTC_HALF_2)),n.ambient[0]=r,n.ambient[1]=a,n.ambient[2]=o;const _=n.hash;_.directionalLength===l&&_.pointLength===h&&_.spotLength===c&&_.rectAreaLength===u&&_.hemiLength===d&&_.numDirectionalShadows===p&&_.numPointShadows===m&&_.numSpotShadows===f&&_.numSpotMaps===g&&_.numLightProbes===v||(n.directional.length=l,n.spot.length=c,n.rectArea.length=u,n.point.length=h,n.hemi.length=d,n.directionalShadow.length=p,n.directionalShadowMap.length=p,n.pointShadow.length=m,n.pointShadowMap.length=m,n.spotShadow.length=f,n.spotShadowMap.length=f,n.directionalShadowMatrix.length=p,n.pointShadowMatrix.length=m,n.spotLightMatrix.length=f+g-x,n.spotLightMap.length=g,n.numSpotLightShadowsWithMaps=x,n.numLightProbes=v,_.directionalLength=l,_.pointLength=h,_.spotLength=c,_.rectAreaLength=u,_.hemiLength=d,_.numDirectionalShadows=p,_.numPointShadows=m,_.numSpotShadows=f,_.numSpotMaps=g,_.numLightProbes=v,n.version=io++)},setupView:function(t,e){let i=0,o=0,l=0,h=0,c=0;const u=e.matrixWorldInverse;for(let d=0,p=t.length;d<p;d++){const e=t[d];if(e.isDirectionalLight){const t=n.directional[i];t.direction.setFromMatrixPosition(e.matrixWorld),s.setFromMatrixPosition(e.target.matrixWorld),t.direction.sub(s),t.direction.transformDirection(u),i++}else if(e.isSpotLight){const t=n.spot[l];t.position.setFromMatrixPosition(e.matrixWorld),t.position.applyMatrix4(u),t.direction.setFromMatrixPosition(e.matrixWorld),s.setFromMatrixPosition(e.target.matrixWorld),t.direction.sub(s),t.direction.transformDirection(u),l++}else if(e.isRectAreaLight){const t=n.rectArea[h];t.position.setFromMatrixPosition(e.matrixWorld),t.position.applyMatrix4(u),a.identity(),r.copy(e.matrixWorld),r.premultiply(u),a.extractRotation(r),t.halfWidth.set(.5*e.width,0,0),t.halfHeight.set(0,.5*e.height,0),t.halfWidth.applyMatrix4(a),t.halfHeight.applyMatrix4(a),h++}else if(e.isPointLight){const t=n.point[o];t.position.setFromMatrixPosition(e.matrixWorld),t.position.applyMatrix4(u),o++}else if(e.isHemisphereLight){const t=n.hemi[c];t.direction.setFromMatrixPosition(e.matrixWorld),t.direction.transformDirection(u),c++}}},state:n}}function ro(t){const e=new so(t),i=[],n=[];const s={lightsArray:i,shadowsArray:n,camera:null,lights:e,transmissionRenderTarget:{}};return{init:function(t){s.camera=t,i.length=0,n.length=0},state:s,setupLights:function(){e.setup(i)},setupLightsView:function(t){e.setupView(i,t)},pushLight:function(t){i.push(t)},pushShadow:function(t){n.push(t)}}}function ao(t){let e=new WeakMap;return{get:function(i,n=0){const s=e.get(i);let r;return void 0===s?(r=new ro(t),e.set(i,[r])):n>=s.length?(r=new ro(t),s.push(r)):r=s[n],r},dispose:function(){e=new WeakMap}}}class oo extends Bn{static get type(){return"MeshDepthMaterial"}constructor(t){super(),this.isMeshDepthMaterial=!0,this.depthPacking=3200,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}class lo extends Bn{static get type(){return"MeshDistanceMaterial"}constructor(t){super(),this.isMeshDistanceMaterial=!0,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(t)}copy(t){return super.copy(t),this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}function ho(t,e,i){let n=new Ls;const s=new Fe,r=new Fe,a=new ri,o=new oo({depthPacking:3201}),l=new lo,h={},c=i.maxTextureSize,m={[u]:1,[d]:0,[p]:2},f=new xs({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Fe},radius:{value:4}},vertexShader:"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),g=f.clone();g.defines.HORIZONTAL_PASS=1;const x=new Jn;x.setAttribute("position",new Vn(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const v=new cs(x,f),_=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=1;let y=this.type;function b(i,n){const r=e.update(v);f.defines.VSM_SAMPLES!==i.blurSamples&&(f.defines.VSM_SAMPLES=i.blurSamples,g.defines.VSM_SAMPLES=i.blurSamples,f.needsUpdate=!0,g.needsUpdate=!0),null===i.mapPass&&(i.mapPass=new oi(s.x,s.y)),f.uniforms.shadow_pass.value=i.map.texture,f.uniforms.resolution.value=i.mapSize,f.uniforms.radius.value=i.radius,t.setRenderTarget(i.mapPass),t.clear(),t.renderBufferDirect(n,null,r,f,v,null),g.uniforms.shadow_pass.value=i.mapPass.texture,g.uniforms.resolution.value=i.mapSize,g.uniforms.radius.value=i.radius,t.setRenderTarget(i.map),t.clear(),t.renderBufferDirect(n,null,r,g,v,null)}function S(e,i,n,s){let r=null;const a=!0===n.isPointLight?e.customDistanceMaterial:e.customDepthMaterial;if(void 0!==a)r=a;else if(r=!0===n.isPointLight?l:o,t.localClippingEnabled&&!0===i.clipShadows&&Array.isArray(i.clippingPlanes)&&0!==i.clippingPlanes.length||i.displacementMap&&0!==i.displacementScale||i.alphaMap&&i.alphaTest>0||i.map&&i.alphaTest>0){const t=r.uuid,e=i.uuid;let n=h[t];void 0===n&&(n={},h[t]=n);let s=n[e];void 0===s&&(s=r.clone(),n[e]=s,i.addEventListener("dispose",T)),r=s}if(r.visible=i.visible,r.wireframe=i.wireframe,r.side=3===s?null!==i.shadowSide?i.shadowSide:i.side:null!==i.shadowSide?i.shadowSide:m[i.side],r.alphaMap=i.alphaMap,r.alphaTest=i.alphaTest,r.map=i.map,r.clipShadows=i.clipShadows,r.clippingPlanes=i.clippingPlanes,r.clipIntersection=i.clipIntersection,r.displacementMap=i.displacementMap,r.displacementScale=i.displacementScale,r.displacementBias=i.displacementBias,r.wireframeLinewidth=i.wireframeLinewidth,r.linewidth=i.linewidth,!0===n.isPointLight&&!0===r.isMeshDistanceMaterial){t.properties.get(r).light=n}return r}function M(i,s,r,a,o){if(!1===i.visible)return;if(i.layers.test(s.layers)&&(i.isMesh||i.isLine||i.isPoints)&&(i.castShadow||i.receiveShadow&&3===o)&&(!i.frustumCulled||n.intersectsObject(i))){i.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse,i.matrixWorld);const n=e.update(i),l=i.material;if(Array.isArray(l)){const e=n.groups;for(let h=0,c=e.length;h<c;h++){const c=e[h],u=l[c.materialIndex];if(u&&u.visible){const e=S(i,u,a,o);i.onBeforeShadow(t,i,s,r,n,e,c),t.renderBufferDirect(r,null,n,e,i,c),i.onAfterShadow(t,i,s,r,n,e,c)}}}else if(l.visible){const e=S(i,l,a,o);i.onBeforeShadow(t,i,s,r,n,e,null),t.renderBufferDirect(r,null,n,e,i,null),i.onAfterShadow(t,i,s,r,n,e,null)}}const l=i.children;for(let t=0,e=l.length;t<e;t++)M(l[t],s,r,a,o)}function T(t){t.target.removeEventListener("dispose",T);for(const e in h){const i=h[e],n=t.target.uuid;if(n in i){i[n].dispose(),delete i[n]}}}this.render=function(e,i,o){if(!1===_.enabled)return;if(!1===_.autoUpdate&&!1===_.needsUpdate)return;if(0===e.length)return;const l=t.getRenderTarget(),h=t.getActiveCubeFace(),u=t.getActiveMipmapLevel(),d=t.state;d.setBlending(0),d.buffers.color.setClear(1,1,1,1),d.buffers.depth.setTest(!0),d.setScissorTest(!1);const p=3!==y&&3===this.type,m=3===y&&3!==this.type;for(let f=0,g=e.length;f<g;f++){const l=e[f],h=l.shadow;if(void 0===h)continue;if(!1===h.autoUpdate&&!1===h.needsUpdate)continue;s.copy(h.mapSize);const u=h.getFrameExtents();if(s.multiply(u),r.copy(h.mapSize),(s.x>c||s.y>c)&&(s.x>c&&(r.x=Math.floor(c/u.x),s.x=r.x*u.x,h.mapSize.x=r.x),s.y>c&&(r.y=Math.floor(c/u.y),s.y=r.y*u.y,h.mapSize.y=r.y)),null===h.map||!0===p||!0===m){const t=3!==this.type?{minFilter:Z,magFilter:Z}:{};null!==h.map&&h.map.dispose(),h.map=new oi(s.x,s.y,t),h.map.texture.name=l.name+".shadowMap",h.camera.updateProjectionMatrix()}t.setRenderTarget(h.map),t.clear();const g=h.getViewportCount();for(let t=0;t<g;t++){const e=h.getViewport(t);a.set(r.x*e.x,r.y*e.y,r.x*e.z,r.y*e.w),d.viewport(a),h.updateMatrices(l,t),n=h.getFrustum(),M(i,o,h.camera,l,this.type)}!0!==h.isPointLightShadow&&3===this.type&&b(h,o),h.needsUpdate=!1}y=this.type,_.needsUpdate=!1,t.setRenderTarget(l,h,u)}}const co={[L]:1,[U]:6,[B]:7,[F]:5,[D]:0,[z]:2,[k]:4,[O]:3};function uo(t,e){const i=new function(){let e=!1;const i=new ri;let n=null;const s=new ri(0,0,0,0);return{setMask:function(i){n===i||e||(t.colorMask(i,i,i,i),n=i)},setLocked:function(t){e=t},setClear:function(e,n,r,a,o){!0===o&&(e*=a,n*=a,r*=a),i.set(e,n,r,a),!1===s.equals(i)&&(t.clearColor(e,n,r,a),s.copy(i))},reset:function(){e=!1,n=null,s.set(-1,0,0,0)}}},n=new function(){let i=!1,n=!1,s=null,r=null,a=null;return{setReversed:function(t){if(n!==t){const t=e.get("EXT_clip_control");n?t.clipControlEXT(t.LOWER_LEFT_EXT,t.ZERO_TO_ONE_EXT):t.clipControlEXT(t.LOWER_LEFT_EXT,t.NEGATIVE_ONE_TO_ONE_EXT);const i=a;a=null,this.setClear(i)}n=t},getReversed:function(){return n},setTest:function(e){e?st(t.DEPTH_TEST):rt(t.DEPTH_TEST)},setMask:function(e){s===e||i||(t.depthMask(e),s=e)},setFunc:function(e){if(n&&(e=co[e]),r!==e){switch(e){case 0:t.depthFunc(t.NEVER);break;case 1:t.depthFunc(t.ALWAYS);break;case 2:t.depthFunc(t.LESS);break;case 3:default:t.depthFunc(t.LEQUAL);break;case 4:t.depthFunc(t.EQUAL);break;case 5:t.depthFunc(t.GEQUAL);break;case 6:t.depthFunc(t.GREATER);break;case 7:t.depthFunc(t.NOTEQUAL)}r=e}},setLocked:function(t){i=t},setClear:function(e){a!==e&&(n&&(e=1-e),t.clearDepth(e),a=e)},reset:function(){i=!1,s=null,r=null,a=null,n=!1}}},s=new function(){let e=!1,i=null,n=null,s=null,r=null,a=null,o=null,l=null,h=null;return{setTest:function(i){e||(i?st(t.STENCIL_TEST):rt(t.STENCIL_TEST))},setMask:function(n){i===n||e||(t.stencilMask(n),i=n)},setFunc:function(e,i,a){n===e&&s===i&&r===a||(t.stencilFunc(e,i,a),n=e,s=i,r=a)},setOp:function(e,i,n){a===e&&o===i&&l===n||(t.stencilOp(e,i,n),a=e,o=i,l=n)},setLocked:function(t){e=t},setClear:function(e){h!==e&&(t.clearStencil(e),h=e)},reset:function(){e=!1,i=null,n=null,s=null,r=null,a=null,o=null,l=null,h=null}}},r=new WeakMap,a=new WeakMap;let o={},l={},h=new WeakMap,c=[],u=null,d=!1,p=null,m=null,L=null,D=null,U=null,F=null,B=null,O=new Dn(0,0,0),z=0,k=!1,V=null,G=null,H=null,W=null,j=null;const X=t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let q=!1,$=0;const Y=t.getParameter(t.VERSION);-1!==Y.indexOf("WebGL")?($=parseFloat(/^WebGL (\d)/.exec(Y)[1]),q=$>=1):-1!==Y.indexOf("OpenGL ES")&&($=parseFloat(/^OpenGL ES (\d)/.exec(Y)[1]),q=$>=2);let Z=null,K={};const J=t.getParameter(t.SCISSOR_BOX),Q=t.getParameter(t.VIEWPORT),tt=(new ri).fromArray(J),et=(new ri).fromArray(Q);function it(e,i,n,s){const r=new Uint8Array(4),a=t.createTexture();t.bindTexture(e,a),t.texParameteri(e,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(e,t.TEXTURE_MAG_FILTER,t.NEAREST);for(let o=0;o<n;o++)e===t.TEXTURE_3D||e===t.TEXTURE_2D_ARRAY?t.texImage3D(i,0,t.RGBA,1,1,s,0,t.RGBA,t.UNSIGNED_BYTE,r):t.texImage2D(i+o,0,t.RGBA,1,1,0,t.RGBA,t.UNSIGNED_BYTE,r);return a}const nt={};function st(e){!0!==o[e]&&(t.enable(e),o[e]=!0)}function rt(e){!1!==o[e]&&(t.disable(e),o[e]=!1)}nt[t.TEXTURE_2D]=it(t.TEXTURE_2D,t.TEXTURE_2D,1),nt[t.TEXTURE_CUBE_MAP]=it(t.TEXTURE_CUBE_MAP,t.TEXTURE_CUBE_MAP_POSITIVE_X,6),nt[t.TEXTURE_2D_ARRAY]=it(t.TEXTURE_2D_ARRAY,t.TEXTURE_2D_ARRAY,1,1),nt[t.TEXTURE_3D]=it(t.TEXTURE_3D,t.TEXTURE_3D,1,1),i.setClear(0,0,0,1),n.setClear(1),s.setClear(0),st(t.DEPTH_TEST),n.setFunc(3),ht(!1),ct(1),st(t.CULL_FACE),lt(0);const at={[f]:t.FUNC_ADD,[g]:t.FUNC_SUBTRACT,[x]:t.FUNC_REVERSE_SUBTRACT};at[103]=t.MIN,at[104]=t.MAX;const ot={[v]:t.ZERO,[_]:t.ONE,[y]:t.SRC_COLOR,[S]:t.SRC_ALPHA,[C]:t.SRC_ALPHA_SATURATE,[A]:t.DST_COLOR,[T]:t.DST_ALPHA,[b]:t.ONE_MINUS_SRC_COLOR,[M]:t.ONE_MINUS_SRC_ALPHA,[E]:t.ONE_MINUS_DST_COLOR,[w]:t.ONE_MINUS_DST_ALPHA,[R]:t.CONSTANT_COLOR,[N]:t.ONE_MINUS_CONSTANT_COLOR,[P]:t.CONSTANT_ALPHA,[I]:t.ONE_MINUS_CONSTANT_ALPHA};function lt(e,i,n,s,r,a,o,l,h,c){if(0!==e){if(!1===d&&(st(t.BLEND),d=!0),5===e)r=r||i,a=a||n,o=o||s,i===m&&r===U||(t.blendEquationSeparate(at[i],at[r]),m=i,U=r),n===L&&s===D&&a===F&&o===B||(t.blendFuncSeparate(ot[n],ot[s],ot[a],ot[o]),L=n,D=s,F=a,B=o),!1!==l.equals(O)&&h===z||(t.blendColor(l.r,l.g,l.b,h),O.copy(l),z=h),p=e,k=!1;else if(e!==p||c!==k){if(m===f&&U===f||(t.blendEquation(t.FUNC_ADD),m=f,U=f),c)switch(e){case 1:t.blendFuncSeparate(t.ONE,t.ONE_MINUS_SRC_ALPHA,t.ONE,t.ONE_MINUS_SRC_ALPHA);break;case 2:t.blendFunc(t.ONE,t.ONE);break;case 3:t.blendFuncSeparate(t.ZERO,t.ONE_MINUS_SRC_COLOR,t.ZERO,t.ONE);break;case 4:t.blendFuncSeparate(t.ZERO,t.SRC_COLOR,t.ZERO,t.SRC_ALPHA)}else switch(e){case 1:t.blendFuncSeparate(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA,t.ONE,t.ONE_MINUS_SRC_ALPHA);break;case 2:t.blendFunc(t.SRC_ALPHA,t.ONE);break;case 3:t.blendFuncSeparate(t.ZERO,t.ONE_MINUS_SRC_COLOR,t.ZERO,t.ONE);break;case 4:t.blendFunc(t.ZERO,t.SRC_COLOR)}L=null,D=null,F=null,B=null,O.set(0,0,0),z=0,p=e,k=c}}else!0===d&&(rt(t.BLEND),d=!1)}function ht(e){V!==e&&(e?t.frontFace(t.CW):t.frontFace(t.CCW),V=e)}function ct(e){0!==e?(st(t.CULL_FACE),e!==G&&(1===e?t.cullFace(t.BACK):2===e?t.cullFace(t.FRONT):t.cullFace(t.FRONT_AND_BACK))):rt(t.CULL_FACE),G=e}function ut(e,i,n){e?(st(t.POLYGON_OFFSET_FILL),W===i&&j===n||(t.polygonOffset(i,n),W=i,j=n)):rt(t.POLYGON_OFFSET_FILL)}return{buffers:{color:i,depth:n,stencil:s},enable:st,disable:rt,bindFramebuffer:function(e,i){return l[e]!==i&&(t.bindFramebuffer(e,i),l[e]=i,e===t.DRAW_FRAMEBUFFER&&(l[t.FRAMEBUFFER]=i),e===t.FRAMEBUFFER&&(l[t.DRAW_FRAMEBUFFER]=i),!0)},drawBuffers:function(e,i){let n=c,s=!1;if(e){n=h.get(i),void 0===n&&(n=[],h.set(i,n));const r=e.textures;if(n.length!==r.length||n[0]!==t.COLOR_ATTACHMENT0){for(let e=0,i=r.length;e<i;e++)n[e]=t.COLOR_ATTACHMENT0+e;n.length=r.length,s=!0}}else n[0]!==t.BACK&&(n[0]=t.BACK,s=!0);s&&t.drawBuffers(n)},useProgram:function(e){return u!==e&&(t.useProgram(e),u=e,!0)},setBlending:lt,setMaterial:function(e,r){2===e.side?rt(t.CULL_FACE):st(t.CULL_FACE);let a=1===e.side;r&&(a=!a),ht(a),1===e.blending&&!1===e.transparent?lt(0):lt(e.blending,e.blendEquation,e.blendSrc,e.blendDst,e.blendEquationAlpha,e.blendSrcAlpha,e.blendDstAlpha,e.blendColor,e.blendAlpha,e.premultipliedAlpha),n.setFunc(e.depthFunc),n.setTest(e.depthTest),n.setMask(e.depthWrite),i.setMask(e.colorWrite);const o=e.stencilWrite;s.setTest(o),o&&(s.setMask(e.stencilWriteMask),s.setFunc(e.stencilFunc,e.stencilRef,e.stencilFuncMask),s.setOp(e.stencilFail,e.stencilZFail,e.stencilZPass)),ut(e.polygonOffset,e.polygonOffsetFactor,e.polygonOffsetUnits),!0===e.alphaToCoverage?st(t.SAMPLE_ALPHA_TO_COVERAGE):rt(t.SAMPLE_ALPHA_TO_COVERAGE)},setFlipSided:ht,setCullFace:ct,setLineWidth:function(e){e!==H&&(q&&t.lineWidth(e),H=e)},setPolygonOffset:ut,setScissorTest:function(e){e?st(t.SCISSOR_TEST):rt(t.SCISSOR_TEST)},activeTexture:function(e){void 0===e&&(e=t.TEXTURE0+X-1),Z!==e&&(t.activeTexture(e),Z=e)},bindTexture:function(e,i,n){void 0===n&&(n=null===Z?t.TEXTURE0+X-1:Z);let s=K[n];void 0===s&&(s={type:void 0,texture:void 0},K[n]=s),s.type===e&&s.texture===i||(Z!==n&&(t.activeTexture(n),Z=n),t.bindTexture(e,i||nt[e]),s.type=e,s.texture=i)},unbindTexture:function(){const e=K[Z];void 0!==e&&void 0!==e.type&&(t.bindTexture(e.type,null),e.type=void 0,e.texture=void 0)},compressedTexImage2D:function(){try{t.compressedTexImage2D.apply(t,arguments)}catch(e){}},compressedTexImage3D:function(){try{t.compressedTexImage3D.apply(t,arguments)}catch(e){}},texImage2D:function(){try{t.texImage2D.apply(t,arguments)}catch(e){}},texImage3D:function(){try{t.texImage3D.apply(t,arguments)}catch(e){}},updateUBOMapping:function(e,i){let n=a.get(i);void 0===n&&(n=new WeakMap,a.set(i,n));let s=n.get(e);void 0===s&&(s=t.getUniformBlockIndex(i,e.name),n.set(e,s))},uniformBlockBinding:function(e,i){const n=a.get(i).get(e);r.get(i)!==n&&(t.uniformBlockBinding(i,n,e.__bindingPointIndex),r.set(i,n))},texStorage2D:function(){try{t.texStorage2D.apply(t,arguments)}catch(e){}},texStorage3D:function(){try{t.texStorage3D.apply(t,arguments)}catch(e){}},texSubImage2D:function(){try{t.texSubImage2D.apply(t,arguments)}catch(e){}},texSubImage3D:function(){try{t.texSubImage3D.apply(t,arguments)}catch(e){}},compressedTexSubImage2D:function(){try{t.compressedTexSubImage2D.apply(t,arguments)}catch(e){}},compressedTexSubImage3D:function(){try{t.compressedTexSubImage3D.apply(t,arguments)}catch(e){}},scissor:function(e){!1===tt.equals(e)&&(t.scissor(e.x,e.y,e.z,e.w),tt.copy(e))},viewport:function(e){!1===et.equals(e)&&(t.viewport(e.x,e.y,e.z,e.w),et.copy(e))},reset:function(){t.disable(t.BLEND),t.disable(t.CULL_FACE),t.disable(t.DEPTH_TEST),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SCISSOR_TEST),t.disable(t.STENCIL_TEST),t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),t.blendEquation(t.FUNC_ADD),t.blendFunc(t.ONE,t.ZERO),t.blendFuncSeparate(t.ONE,t.ZERO,t.ONE,t.ZERO),t.blendColor(0,0,0,0),t.colorMask(!0,!0,!0,!0),t.clearColor(0,0,0,0),t.depthMask(!0),t.depthFunc(t.LESS),n.setReversed(!1),t.clearDepth(1),t.stencilMask(4294967295),t.stencilFunc(t.ALWAYS,0,4294967295),t.stencilOp(t.KEEP,t.KEEP,t.KEEP),t.clearStencil(0),t.cullFace(t.BACK),t.frontFace(t.CCW),t.polygonOffset(0,0),t.activeTexture(t.TEXTURE0),t.bindFramebuffer(t.FRAMEBUFFER,null),t.bindFramebuffer(t.DRAW_FRAMEBUFFER,null),t.bindFramebuffer(t.READ_FRAMEBUFFER,null),t.useProgram(null),t.lineWidth(1),t.scissor(0,0,t.canvas.width,t.canvas.height),t.viewport(0,0,t.canvas.width,t.canvas.height),o={},Z=null,K={},l={},h=new WeakMap,c=[],u=null,d=!1,p=null,m=null,L=null,D=null,U=null,F=null,B=null,O=new Dn(0,0,0),z=0,k=!1,V=null,G=null,H=null,W=null,j=null,tt.set(0,0,t.canvas.width,t.canvas.height),et.set(0,0,t.canvas.width,t.canvas.height),i.reset(),n.reset(),s.reset()}}}function po(t,e,i,n){const s=function(t){switch(t){case it:case nt:return{byteLength:1,components:1};case rt:case st:case ht:return{byteLength:2,components:1};case ct:case ut:return{byteLength:2,components:4};case ot:case at:case lt:return{byteLength:4,components:1};case pt:return{byteLength:4,components:3}}throw new Error(`Unknown texture type ${t}.`)}(n);switch(i){case 1021:case 1024:return t*e;case 1025:return t*e*2;case xt:case vt:return t*e/s.components*s.byteLength;case 1030:case _t:return t*e*2/s.components*s.byteLength;case 1022:return t*e*3/s.components*s.byteLength;case mt:case yt:return t*e*4/s.components*s.byteLength;case bt:case St:return Math.floor((t+3)/4)*Math.floor((e+3)/4)*8;case Mt:case Tt:return Math.floor((t+3)/4)*Math.floor((e+3)/4)*16;case At:case Ct:return Math.max(t,16)*Math.max(e,8)/4;case wt:case Et:return Math.max(t,8)*Math.max(e,8)/2;case Rt:case Nt:return Math.floor((t+3)/4)*Math.floor((e+3)/4)*8;case Pt:case It:return Math.floor((t+3)/4)*Math.floor((e+3)/4)*16;case Lt:return Math.floor((t+4)/5)*Math.floor((e+3)/4)*16;case Dt:return Math.floor((t+4)/5)*Math.floor((e+4)/5)*16;case Ut:return Math.floor((t+5)/6)*Math.floor((e+4)/5)*16;case Ft:return Math.floor((t+5)/6)*Math.floor((e+5)/6)*16;case Bt:return Math.floor((t+7)/8)*Math.floor((e+4)/5)*16;case Ot:return Math.floor((t+7)/8)*Math.floor((e+5)/6)*16;case zt:return Math.floor((t+7)/8)*Math.floor((e+7)/8)*16;case kt:return Math.floor((t+9)/10)*Math.floor((e+4)/5)*16;case Vt:return Math.floor((t+9)/10)*Math.floor((e+5)/6)*16;case Gt:return Math.floor((t+9)/10)*Math.floor((e+7)/8)*16;case Ht:return Math.floor((t+9)/10)*Math.floor((e+9)/10)*16;case Wt:return Math.floor((t+11)/12)*Math.floor((e+9)/10)*16;case jt:return Math.floor((t+11)/12)*Math.floor((e+11)/12)*16;case Xt:case qt:case $t:return Math.ceil(t/4)*Math.ceil(e/4)*16;case 36283:case Yt:return Math.ceil(t/4)*Math.ceil(e/4)*8;case Zt:case Kt:return Math.ceil(t/4)*Math.ceil(e/4)*16}throw new Error(`Unable to determine texture byte length for ${i} format.`)}function mo(t,e,i,n,s,r,a){const o=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,l="undefined"!=typeof navigator&&/OculusBrowser/g.test(navigator.userAgent),h=new Fe,c=new WeakMap;let u;const d=new WeakMap;let p=!1;try{p="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(G){}function m(t,e){return p?new OffscreenCanvas(t,e):ke("canvas")}function f(t,e,i){let n=1;const s=V(t);if((s.width>i||s.height>i)&&(n=i/Math.max(s.width,s.height)),n<1){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap||"undefined"!=typeof VideoFrame&&t instanceof VideoFrame){const i=Math.floor(n*s.width),r=Math.floor(n*s.height);void 0===u&&(u=m(i,r));const a=e?m(i,r):u;a.width=i,a.height=r;return a.getContext("2d").drawImage(t,0,0,i,r),a}return t}return t}function g(t){return t.generateMipmaps}function x(e){t.generateMipmap(e)}function v(e){return e.isWebGLCubeRenderTarget?t.TEXTURE_CUBE_MAP:e.isWebGL3DRenderTarget?t.TEXTURE_3D:e.isWebGLArrayRenderTarget||e.isCompressedArrayTexture?t.TEXTURE_2D_ARRAY:t.TEXTURE_2D}function _(i,n,s,r,a=!1){if(null!==i&&void 0!==t[i])return t[i];let o=n;if(n===t.RED&&(s===t.FLOAT&&(o=t.R32F),s===t.HALF_FLOAT&&(o=t.R16F),s===t.UNSIGNED_BYTE&&(o=t.R8)),n===t.RED_INTEGER&&(s===t.UNSIGNED_BYTE&&(o=t.R8UI),s===t.UNSIGNED_SHORT&&(o=t.R16UI),s===t.UNSIGNED_INT&&(o=t.R32UI),s===t.BYTE&&(o=t.R8I),s===t.SHORT&&(o=t.R16I),s===t.INT&&(o=t.R32I)),n===t.RG&&(s===t.FLOAT&&(o=t.RG32F),s===t.HALF_FLOAT&&(o=t.RG16F),s===t.UNSIGNED_BYTE&&(o=t.RG8)),n===t.RG_INTEGER&&(s===t.UNSIGNED_BYTE&&(o=t.RG8UI),s===t.UNSIGNED_SHORT&&(o=t.RG16UI),s===t.UNSIGNED_INT&&(o=t.RG32UI),s===t.BYTE&&(o=t.RG8I),s===t.SHORT&&(o=t.RG16I),s===t.INT&&(o=t.RG32I)),n===t.RGB_INTEGER&&(s===t.UNSIGNED_BYTE&&(o=t.RGB8UI),s===t.UNSIGNED_SHORT&&(o=t.RGB16UI),s===t.UNSIGNED_INT&&(o=t.RGB32UI),s===t.BYTE&&(o=t.RGB8I),s===t.SHORT&&(o=t.RGB16I),s===t.INT&&(o=t.RGB32I)),n===t.RGBA_INTEGER&&(s===t.UNSIGNED_BYTE&&(o=t.RGBA8UI),s===t.UNSIGNED_SHORT&&(o=t.RGBA16UI),s===t.UNSIGNED_INT&&(o=t.RGBA32UI),s===t.BYTE&&(o=t.RGBA8I),s===t.SHORT&&(o=t.RGBA16I),s===t.INT&&(o=t.RGBA32I)),n===t.RGB&&s===t.UNSIGNED_INT_5_9_9_9_REV&&(o=t.RGB9_E5),n===t.RGBA){const e=a?he:We.getTransfer(r);s===t.FLOAT&&(o=t.RGBA32F),s===t.HALF_FLOAT&&(o=t.RGBA16F),s===t.UNSIGNED_BYTE&&(o=e===ce?t.SRGB8_ALPHA8:t.RGBA8),s===t.UNSIGNED_SHORT_4_4_4_4&&(o=t.RGBA4),s===t.UNSIGNED_SHORT_5_5_5_1&&(o=t.RGB5_A1)}return o!==t.R16F&&o!==t.R32F&&o!==t.RG16F&&o!==t.RG32F&&o!==t.RGBA16F&&o!==t.RGBA32F||e.get("EXT_color_buffer_float"),o}function y(e,i){let n;return e?null===i||i===ot||i===dt?n=t.DEPTH24_STENCIL8:i===lt?n=t.DEPTH32F_STENCIL8:i===rt&&(n=t.DEPTH24_STENCIL8):null===i||i===ot||i===dt?n=t.DEPTH_COMPONENT24:i===lt?n=t.DEPTH_COMPONENT32F:i===rt&&(n=t.DEPTH_COMPONENT16),n}function b(t,e){return!0===g(t)||t.isFramebufferTexture&&t.minFilter!==Z&&t.minFilter!==Q?Math.log2(Math.max(e.width,e.height))+1:void 0!==t.mipmaps&&t.mipmaps.length>0?t.mipmaps.length:t.isCompressedTexture&&Array.isArray(t.image)?e.mipmaps.length:1}function S(t){const e=t.target;e.removeEventListener("dispose",S),function(t){const e=n.get(t);if(void 0===e.__webglInit)return;const i=t.source,s=d.get(i);if(s){const n=s[e.__cacheKey];n.usedTimes--,0===n.usedTimes&&T(t),0===Object.keys(s).length&&d.delete(i)}n.remove(t)}(e),e.isVideoTexture&&c.delete(e)}function M(e){const i=e.target;i.removeEventListener("dispose",M),function(e){const i=n.get(e);e.depthTexture&&(e.depthTexture.dispose(),n.remove(e.depthTexture));if(e.isWebGLCubeRenderTarget)for(let n=0;n<6;n++){if(Array.isArray(i.__webglFramebuffer[n]))for(let e=0;e<i.__webglFramebuffer[n].length;e++)t.deleteFramebuffer(i.__webglFramebuffer[n][e]);else t.deleteFramebuffer(i.__webglFramebuffer[n]);i.__webglDepthbuffer&&t.deleteRenderbuffer(i.__webglDepthbuffer[n])}else{if(Array.isArray(i.__webglFramebuffer))for(let e=0;e<i.__webglFramebuffer.length;e++)t.deleteFramebuffer(i.__webglFramebuffer[e]);else t.deleteFramebuffer(i.__webglFramebuffer);if(i.__webglDepthbuffer&&t.deleteRenderbuffer(i.__webglDepthbuffer),i.__webglMultisampledFramebuffer&&t.deleteFramebuffer(i.__webglMultisampledFramebuffer),i.__webglColorRenderbuffer)for(let e=0;e<i.__webglColorRenderbuffer.length;e++)i.__webglColorRenderbuffer[e]&&t.deleteRenderbuffer(i.__webglColorRenderbuffer[e]);i.__webglDepthRenderbuffer&&t.deleteRenderbuffer(i.__webglDepthRenderbuffer)}const s=e.textures;for(let r=0,o=s.length;r<o;r++){const e=n.get(s[r]);e.__webglTexture&&(t.deleteTexture(e.__webglTexture),a.memory.textures--),n.remove(s[r])}n.remove(e)}(i)}function T(e){const i=n.get(e);t.deleteTexture(i.__webglTexture);const s=e.source;delete d.get(s)[i.__cacheKey],a.memory.textures--}let w=0;function A(e,s){const r=n.get(e);if(e.isVideoTexture&&function(t){const e=a.render.frame;c.get(t)!==e&&(c.set(t,e),t.update())}(e),!1===e.isRenderTargetTexture&&e.version>0&&r.__version!==e.version){const t=e.image;if(null===t);else if(!1!==t.complete)return void I(r,e,s)}i.bindTexture(t.TEXTURE_2D,r.__webglTexture,t.TEXTURE0+s)}const E={[q]:t.REPEAT,[$]:t.CLAMP_TO_EDGE,[Y]:t.MIRRORED_REPEAT},C={[Z]:t.NEAREST,[K]:t.NEAREST_MIPMAP_NEAREST,[J]:t.NEAREST_MIPMAP_LINEAR,[Q]:t.LINEAR,[tt]:t.LINEAR_MIPMAP_NEAREST,[et]:t.LINEAR_MIPMAP_LINEAR},R={[de]:t.NEVER,[_e]:t.ALWAYS,[pe]:t.LESS,[fe]:t.LEQUAL,[me]:t.EQUAL,[ve]:t.GEQUAL,[ge]:t.GREATER,[xe]:t.NOTEQUAL};function N(i,r){if(r.type===lt&&!1===e.has("OES_texture_float_linear")&&(r.magFilter===Q||r.magFilter===tt||r.magFilter===J||r.magFilter===et||r.minFilter===Q||r.minFilter===tt||r.minFilter===J||r.minFilter),t.texParameteri(i,t.TEXTURE_WRAP_S,E[r.wrapS]),t.texParameteri(i,t.TEXTURE_WRAP_T,E[r.wrapT]),i!==t.TEXTURE_3D&&i!==t.TEXTURE_2D_ARRAY||t.texParameteri(i,t.TEXTURE_WRAP_R,E[r.wrapR]),t.texParameteri(i,t.TEXTURE_MAG_FILTER,C[r.magFilter]),t.texParameteri(i,t.TEXTURE_MIN_FILTER,C[r.minFilter]),r.compareFunction&&(t.texParameteri(i,t.TEXTURE_COMPARE_MODE,t.COMPARE_REF_TO_TEXTURE),t.texParameteri(i,t.TEXTURE_COMPARE_FUNC,R[r.compareFunction])),!0===e.has("EXT_texture_filter_anisotropic")){if(r.magFilter===Z)return;if(r.minFilter!==J&&r.minFilter!==et)return;if(r.type===lt&&!1===e.has("OES_texture_float_linear"))return;if(r.anisotropy>1||n.get(r).__currentAnisotropy){const a=e.get("EXT_texture_filter_anisotropic");t.texParameterf(i,a.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(r.anisotropy,s.getMaxAnisotropy())),n.get(r).__currentAnisotropy=r.anisotropy}}}function P(e,i){let n=!1;void 0===e.__webglInit&&(e.__webglInit=!0,i.addEventListener("dispose",S));const s=i.source;let r=d.get(s);void 0===r&&(r={},d.set(s,r));const o=function(t){const e=[];return e.push(t.wrapS),e.push(t.wrapT),e.push(t.wrapR||0),e.push(t.magFilter),e.push(t.minFilter),e.push(t.anisotropy),e.push(t.internalFormat),e.push(t.format),e.push(t.type),e.push(t.generateMipmaps),e.push(t.premultiplyAlpha),e.push(t.flipY),e.push(t.unpackAlignment),e.push(t.colorSpace),e.join()}(i);if(o!==e.__cacheKey){void 0===r[o]&&(r[o]={texture:t.createTexture(),usedTimes:0},a.memory.textures++,n=!0),r[o].usedTimes++;const s=r[e.__cacheKey];void 0!==s&&(r[e.__cacheKey].usedTimes--,0===s.usedTimes&&T(i)),e.__cacheKey=o,e.__webglTexture=r[o].texture}return n}function I(e,a,o){let l=t.TEXTURE_2D;(a.isDataArrayTexture||a.isCompressedArrayTexture)&&(l=t.TEXTURE_2D_ARRAY),a.isData3DTexture&&(l=t.TEXTURE_3D);const h=P(e,a),c=a.source;i.bindTexture(l,e.__webglTexture,t.TEXTURE0+o);const u=n.get(c);if(c.version!==u.__version||!0===h){i.activeTexture(t.TEXTURE0+o);const e=We.getPrimaries(We.workingColorSpace),n=a.colorSpace===ae?null:We.getPrimaries(a.colorSpace),d=a.colorSpace===ae||e===n?t.NONE:t.BROWSER_DEFAULT_WEBGL;t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,a.flipY),t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,a.premultiplyAlpha),t.pixelStorei(t.UNPACK_ALIGNMENT,a.unpackAlignment),t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL,d);let p=f(a.image,!1,s.maxTextureSize);p=k(a,p);const m=r.convert(a.format,a.colorSpace),v=r.convert(a.type);let S,M=_(a.internalFormat,m,v,a.colorSpace,a.isVideoTexture);N(l,a);const T=a.mipmaps,w=!0!==a.isVideoTexture,A=void 0===u.__version||!0===h,E=c.dataReady,C=b(a,p);if(a.isDepthTexture)M=y(a.format===gt,a.type),A&&(w?i.texStorage2D(t.TEXTURE_2D,1,M,p.width,p.height):i.texImage2D(t.TEXTURE_2D,0,M,p.width,p.height,0,m,v,null));else if(a.isDataTexture)if(T.length>0){w&&A&&i.texStorage2D(t.TEXTURE_2D,C,M,T[0].width,T[0].height);for(let e=0,n=T.length;e<n;e++)S=T[e],w?E&&i.texSubImage2D(t.TEXTURE_2D,e,0,0,S.width,S.height,m,v,S.data):i.texImage2D(t.TEXTURE_2D,e,M,S.width,S.height,0,m,v,S.data);a.generateMipmaps=!1}else w?(A&&i.texStorage2D(t.TEXTURE_2D,C,M,p.width,p.height),E&&i.texSubImage2D(t.TEXTURE_2D,0,0,0,p.width,p.height,m,v,p.data)):i.texImage2D(t.TEXTURE_2D,0,M,p.width,p.height,0,m,v,p.data);else if(a.isCompressedTexture)if(a.isCompressedArrayTexture){w&&A&&i.texStorage3D(t.TEXTURE_2D_ARRAY,C,M,T[0].width,T[0].height,p.depth);for(let e=0,n=T.length;e<n;e++)if(S=T[e],a.format!==mt){if(null!==m)if(w){if(E)if(a.layerUpdates.size>0){const n=po(S.width,S.height,a.format,a.type);for(const s of a.layerUpdates){const r=S.data.subarray(s*n/S.data.BYTES_PER_ELEMENT,(s+1)*n/S.data.BYTES_PER_ELEMENT);i.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY,e,0,0,s,S.width,S.height,1,m,r)}a.clearLayerUpdates()}else i.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY,e,0,0,0,S.width,S.height,p.depth,m,S.data)}else i.compressedTexImage3D(t.TEXTURE_2D_ARRAY,e,M,S.width,S.height,p.depth,0,S.data,0,0)}else w?E&&i.texSubImage3D(t.TEXTURE_2D_ARRAY,e,0,0,0,S.width,S.height,p.depth,m,v,S.data):i.texImage3D(t.TEXTURE_2D_ARRAY,e,M,S.width,S.height,p.depth,0,m,v,S.data)}else{w&&A&&i.texStorage2D(t.TEXTURE_2D,C,M,T[0].width,T[0].height);for(let e=0,n=T.length;e<n;e++)S=T[e],a.format!==mt?null!==m&&(w?E&&i.compressedTexSubImage2D(t.TEXTURE_2D,e,0,0,S.width,S.height,m,S.data):i.compressedTexImage2D(t.TEXTURE_2D,e,M,S.width,S.height,0,S.data)):w?E&&i.texSubImage2D(t.TEXTURE_2D,e,0,0,S.width,S.height,m,v,S.data):i.texImage2D(t.TEXTURE_2D,e,M,S.width,S.height,0,m,v,S.data)}else if(a.isDataArrayTexture)if(w){if(A&&i.texStorage3D(t.TEXTURE_2D_ARRAY,C,M,p.width,p.height,p.depth),E)if(a.layerUpdates.size>0){const e=po(p.width,p.height,a.format,a.type);for(const n of a.layerUpdates){const s=p.data.subarray(n*e/p.data.BYTES_PER_ELEMENT,(n+1)*e/p.data.BYTES_PER_ELEMENT);i.texSubImage3D(t.TEXTURE_2D_ARRAY,0,0,0,n,p.width,p.height,1,m,v,s)}a.clearLayerUpdates()}else i.texSubImage3D(t.TEXTURE_2D_ARRAY,0,0,0,0,p.width,p.height,p.depth,m,v,p.data)}else i.texImage3D(t.TEXTURE_2D_ARRAY,0,M,p.width,p.height,p.depth,0,m,v,p.data);else if(a.isData3DTexture)w?(A&&i.texStorage3D(t.TEXTURE_3D,C,M,p.width,p.height,p.depth),E&&i.texSubImage3D(t.TEXTURE_3D,0,0,0,0,p.width,p.height,p.depth,m,v,p.data)):i.texImage3D(t.TEXTURE_3D,0,M,p.width,p.height,p.depth,0,m,v,p.data);else if(a.isFramebufferTexture){if(A)if(w)i.texStorage2D(t.TEXTURE_2D,C,M,p.width,p.height);else{let e=p.width,n=p.height;for(let s=0;s<C;s++)i.texImage2D(t.TEXTURE_2D,s,M,e,n,0,m,v,null),e>>=1,n>>=1}}else if(T.length>0){if(w&&A){const e=V(T[0]);i.texStorage2D(t.TEXTURE_2D,C,M,e.width,e.height)}for(let e=0,n=T.length;e<n;e++)S=T[e],w?E&&i.texSubImage2D(t.TEXTURE_2D,e,0,0,m,v,S):i.texImage2D(t.TEXTURE_2D,e,M,m,v,S);a.generateMipmaps=!1}else if(w){if(A){const e=V(p);i.texStorage2D(t.TEXTURE_2D,C,M,e.width,e.height)}E&&i.texSubImage2D(t.TEXTURE_2D,0,0,0,m,v,p)}else i.texImage2D(t.TEXTURE_2D,0,M,m,v,p);g(a)&&x(l),u.__version=c.version,a.onUpdate&&a.onUpdate(a)}e.__version=a.version}function L(e,s,a,l,h,c){const u=r.convert(a.format,a.colorSpace),d=r.convert(a.type),p=_(a.internalFormat,u,d,a.colorSpace),m=n.get(s),f=n.get(a);if(f.__renderTarget=s,!m.__hasExternalTextures){const e=Math.max(1,s.width>>c),n=Math.max(1,s.height>>c);h===t.TEXTURE_3D||h===t.TEXTURE_2D_ARRAY?i.texImage3D(h,c,p,e,n,s.depth,0,u,d,null):i.texImage2D(h,c,p,e,n,0,u,d,null)}i.bindFramebuffer(t.FRAMEBUFFER,e),z(s)?o.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER,l,h,f.__webglTexture,0,O(s)):(h===t.TEXTURE_2D||h>=t.TEXTURE_CUBE_MAP_POSITIVE_X&&h<=t.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&t.framebufferTexture2D(t.FRAMEBUFFER,l,h,f.__webglTexture,c),i.bindFramebuffer(t.FRAMEBUFFER,null)}function D(e,i,n){if(t.bindRenderbuffer(t.RENDERBUFFER,e),i.depthBuffer){const s=i.depthTexture,r=s&&s.isDepthTexture?s.type:null,a=y(i.stencilBuffer,r),l=i.stencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT,h=O(i);z(i)?o.renderbufferStorageMultisampleEXT(t.RENDERBUFFER,h,a,i.width,i.height):n?t.renderbufferStorageMultisample(t.RENDERBUFFER,h,a,i.width,i.height):t.renderbufferStorage(t.RENDERBUFFER,a,i.width,i.height),t.framebufferRenderbuffer(t.FRAMEBUFFER,l,t.RENDERBUFFER,e)}else{const e=i.textures;for(let s=0;s<e.length;s++){const a=e[s],l=r.convert(a.format,a.colorSpace),h=r.convert(a.type),c=_(a.internalFormat,l,h,a.colorSpace),u=O(i);n&&!1===z(i)?t.renderbufferStorageMultisample(t.RENDERBUFFER,u,c,i.width,i.height):z(i)?o.renderbufferStorageMultisampleEXT(t.RENDERBUFFER,u,c,i.width,i.height):t.renderbufferStorage(t.RENDERBUFFER,c,i.width,i.height)}}t.bindRenderbuffer(t.RENDERBUFFER,null)}function U(e){const s=n.get(e),r=!0===e.isWebGLCubeRenderTarget;if(s.__boundDepthTexture!==e.depthTexture){const t=e.depthTexture;if(s.__depthDisposeCallback&&s.__depthDisposeCallback(),t){const e=()=>{delete s.__boundDepthTexture,delete s.__depthDisposeCallback,t.removeEventListener("dispose",e)};t.addEventListener("dispose",e),s.__depthDisposeCallback=e}s.__boundDepthTexture=t}if(e.depthTexture&&!s.__autoAllocateDepthBuffer){if(r)throw new Error("target.depthTexture not supported in Cube render targets");!function(e,s){if(s&&s.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(i.bindFramebuffer(t.FRAMEBUFFER,e),!s.depthTexture||!s.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");const r=n.get(s.depthTexture);r.__renderTarget=s,r.__webglTexture&&s.depthTexture.image.width===s.width&&s.depthTexture.image.height===s.height||(s.depthTexture.image.width=s.width,s.depthTexture.image.height=s.height,s.depthTexture.needsUpdate=!0),A(s.depthTexture,0);const a=r.__webglTexture,l=O(s);if(s.depthTexture.format===ft)z(s)?o.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.TEXTURE_2D,a,0,l):t.framebufferTexture2D(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.TEXTURE_2D,a,0);else{if(s.depthTexture.format!==gt)throw new Error("Unknown depthTexture format");z(s)?o.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,t.TEXTURE_2D,a,0,l):t.framebufferTexture2D(t.FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,t.TEXTURE_2D,a,0)}}(s.__webglFramebuffer,e)}else if(r){s.__webglDepthbuffer=[];for(let n=0;n<6;n++)if(i.bindFramebuffer(t.FRAMEBUFFER,s.__webglFramebuffer[n]),void 0===s.__webglDepthbuffer[n])s.__webglDepthbuffer[n]=t.createRenderbuffer(),D(s.__webglDepthbuffer[n],e,!1);else{const i=e.stencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT,r=s.__webglDepthbuffer[n];t.bindRenderbuffer(t.RENDERBUFFER,r),t.framebufferRenderbuffer(t.FRAMEBUFFER,i,t.RENDERBUFFER,r)}}else if(i.bindFramebuffer(t.FRAMEBUFFER,s.__webglFramebuffer),void 0===s.__webglDepthbuffer)s.__webglDepthbuffer=t.createRenderbuffer(),D(s.__webglDepthbuffer,e,!1);else{const i=e.stencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT,n=s.__webglDepthbuffer;t.bindRenderbuffer(t.RENDERBUFFER,n),t.framebufferRenderbuffer(t.FRAMEBUFFER,i,t.RENDERBUFFER,n)}i.bindFramebuffer(t.FRAMEBUFFER,null)}const F=[],B=[];function O(t){return Math.min(s.maxSamples,t.samples)}function z(t){const i=n.get(t);return t.samples>0&&!0===e.has("WEBGL_multisampled_render_to_texture")&&!1!==i.__useRenderToTexture}function k(t,e){const i=t.colorSpace;t.format,t.type;return!0===t.isCompressedTexture||!0===t.isVideoTexture||i!==le&&i!==ae&&We.getTransfer(i),e}function V(t){return"undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement?(h.width=t.naturalWidth||t.width,h.height=t.naturalHeight||t.height):"undefined"!=typeof VideoFrame&&t instanceof VideoFrame?(h.width=t.displayWidth,h.height=t.displayHeight):(h.width=t.width,h.height=t.height),h}this.allocateTextureUnit=function(){const t=w;return s.maxTextures,w+=1,t},this.resetTextureUnits=function(){w=0},this.setTexture2D=A,this.setTexture2DArray=function(e,s){const r=n.get(e);e.version>0&&r.__version!==e.version?I(r,e,s):i.bindTexture(t.TEXTURE_2D_ARRAY,r.__webglTexture,t.TEXTURE0+s)},this.setTexture3D=function(e,s){const r=n.get(e);e.version>0&&r.__version!==e.version?I(r,e,s):i.bindTexture(t.TEXTURE_3D,r.__webglTexture,t.TEXTURE0+s)},this.setTextureCube=function(e,a){const o=n.get(e);e.version>0&&o.__version!==e.version?function(e,a,o){if(6!==a.image.length)return;const l=P(e,a),h=a.source;i.bindTexture(t.TEXTURE_CUBE_MAP,e.__webglTexture,t.TEXTURE0+o);const c=n.get(h);if(h.version!==c.__version||!0===l){i.activeTexture(t.TEXTURE0+o);const e=We.getPrimaries(We.workingColorSpace),n=a.colorSpace===ae?null:We.getPrimaries(a.colorSpace),u=a.colorSpace===ae||e===n?t.NONE:t.BROWSER_DEFAULT_WEBGL;t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,a.flipY),t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,a.premultiplyAlpha),t.pixelStorei(t.UNPACK_ALIGNMENT,a.unpackAlignment),t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL,u);const d=a.isCompressedTexture||a.image[0].isCompressedTexture,p=a.image[0]&&a.image[0].isDataTexture,m=[];for(let t=0;t<6;t++)m[t]=d||p?p?a.image[t].image:a.image[t]:f(a.image[t],!0,s.maxCubemapSize),m[t]=k(a,m[t]);const v=m[0],y=r.convert(a.format,a.colorSpace),S=r.convert(a.type),M=_(a.internalFormat,y,S,a.colorSpace),T=!0!==a.isVideoTexture,w=void 0===c.__version||!0===l,A=h.dataReady;let E,C=b(a,v);if(N(t.TEXTURE_CUBE_MAP,a),d){T&&w&&i.texStorage2D(t.TEXTURE_CUBE_MAP,C,M,v.width,v.height);for(let e=0;e<6;e++){E=m[e].mipmaps;for(let n=0;n<E.length;n++){const s=E[n];a.format!==mt?null!==y&&(T?A&&i.compressedTexSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,0,0,s.width,s.height,y,s.data):i.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,M,s.width,s.height,0,s.data)):T?A&&i.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,0,0,s.width,s.height,y,S,s.data):i.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,M,s.width,s.height,0,y,S,s.data)}}}else{if(E=a.mipmaps,T&&w){E.length>0&&C++;const e=V(m[0]);i.texStorage2D(t.TEXTURE_CUBE_MAP,C,M,e.width,e.height)}for(let e=0;e<6;e++)if(p){T?A&&i.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,0,0,m[e].width,m[e].height,y,S,m[e].data):i.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,M,m[e].width,m[e].height,0,y,S,m[e].data);for(let n=0;n<E.length;n++){const s=E[n].image[e].image;T?A&&i.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,n+1,0,0,s.width,s.height,y,S,s.data):i.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,n+1,M,s.width,s.height,0,y,S,s.data)}}else{T?A&&i.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,0,0,y,S,m[e]):i.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,M,y,S,m[e]);for(let n=0;n<E.length;n++){const s=E[n];T?A&&i.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,n+1,0,0,y,S,s.image[e]):i.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,n+1,M,y,S,s.image[e])}}}g(a)&&x(t.TEXTURE_CUBE_MAP),c.__version=h.version,a.onUpdate&&a.onUpdate(a)}e.__version=a.version}(o,e,a):i.bindTexture(t.TEXTURE_CUBE_MAP,o.__webglTexture,t.TEXTURE0+a)},this.rebindTextures=function(e,i,s){const r=n.get(e);void 0!==i&&L(r.__webglFramebuffer,e,e.texture,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,0),void 0!==s&&U(e)},this.setupRenderTarget=function(e){const s=e.texture,o=n.get(e),l=n.get(s);e.addEventListener("dispose",M);const h=e.textures,c=!0===e.isWebGLCubeRenderTarget,u=h.length>1;if(u||(void 0===l.__webglTexture&&(l.__webglTexture=t.createTexture()),l.__version=s.version,a.memory.textures++),c){o.__webglFramebuffer=[];for(let e=0;e<6;e++)if(s.mipmaps&&s.mipmaps.length>0){o.__webglFramebuffer[e]=[];for(let i=0;i<s.mipmaps.length;i++)o.__webglFramebuffer[e][i]=t.createFramebuffer()}else o.__webglFramebuffer[e]=t.createFramebuffer()}else{if(s.mipmaps&&s.mipmaps.length>0){o.__webglFramebuffer=[];for(let e=0;e<s.mipmaps.length;e++)o.__webglFramebuffer[e]=t.createFramebuffer()}else o.__webglFramebuffer=t.createFramebuffer();if(u)for(let e=0,i=h.length;e<i;e++){const i=n.get(h[e]);void 0===i.__webglTexture&&(i.__webglTexture=t.createTexture(),a.memory.textures++)}if(e.samples>0&&!1===z(e)){o.__webglMultisampledFramebuffer=t.createFramebuffer(),o.__webglColorRenderbuffer=[],i.bindFramebuffer(t.FRAMEBUFFER,o.__webglMultisampledFramebuffer);for(let i=0;i<h.length;i++){const n=h[i];o.__webglColorRenderbuffer[i]=t.createRenderbuffer(),t.bindRenderbuffer(t.RENDERBUFFER,o.__webglColorRenderbuffer[i]);const s=r.convert(n.format,n.colorSpace),a=r.convert(n.type),l=_(n.internalFormat,s,a,n.colorSpace,!0===e.isXRRenderTarget),c=O(e);t.renderbufferStorageMultisample(t.RENDERBUFFER,c,l,e.width,e.height),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0+i,t.RENDERBUFFER,o.__webglColorRenderbuffer[i])}t.bindRenderbuffer(t.RENDERBUFFER,null),e.depthBuffer&&(o.__webglDepthRenderbuffer=t.createRenderbuffer(),D(o.__webglDepthRenderbuffer,e,!0)),i.bindFramebuffer(t.FRAMEBUFFER,null)}}if(c){i.bindTexture(t.TEXTURE_CUBE_MAP,l.__webglTexture),N(t.TEXTURE_CUBE_MAP,s);for(let i=0;i<6;i++)if(s.mipmaps&&s.mipmaps.length>0)for(let n=0;n<s.mipmaps.length;n++)L(o.__webglFramebuffer[i][n],e,s,t.COLOR_ATTACHMENT0,t.TEXTURE_CUBE_MAP_POSITIVE_X+i,n);else L(o.__webglFramebuffer[i],e,s,t.COLOR_ATTACHMENT0,t.TEXTURE_CUBE_MAP_POSITIVE_X+i,0);g(s)&&x(t.TEXTURE_CUBE_MAP),i.unbindTexture()}else if(u){for(let s=0,r=h.length;s<r;s++){const r=h[s],a=n.get(r);i.bindTexture(t.TEXTURE_2D,a.__webglTexture),N(t.TEXTURE_2D,r),L(o.__webglFramebuffer,e,r,t.COLOR_ATTACHMENT0+s,t.TEXTURE_2D,0),g(r)&&x(t.TEXTURE_2D)}i.unbindTexture()}else{let n=t.TEXTURE_2D;if((e.isWebGL3DRenderTarget||e.isWebGLArrayRenderTarget)&&(n=e.isWebGL3DRenderTarget?t.TEXTURE_3D:t.TEXTURE_2D_ARRAY),i.bindTexture(n,l.__webglTexture),N(n,s),s.mipmaps&&s.mipmaps.length>0)for(let i=0;i<s.mipmaps.length;i++)L(o.__webglFramebuffer[i],e,s,t.COLOR_ATTACHMENT0,n,i);else L(o.__webglFramebuffer,e,s,t.COLOR_ATTACHMENT0,n,0);g(s)&&x(n),i.unbindTexture()}e.depthBuffer&&U(e)},this.updateRenderTargetMipmap=function(t){const e=t.textures;for(let s=0,r=e.length;s<r;s++){const r=e[s];if(g(r)){const e=v(t),s=n.get(r).__webglTexture;i.bindTexture(e,s),x(e),i.unbindTexture()}}},this.updateMultisampleRenderTarget=function(e){if(e.samples>0)if(!1===z(e)){const s=e.textures,r=e.width,a=e.height;let o=t.COLOR_BUFFER_BIT;const h=e.stencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT,c=n.get(e),u=s.length>1;if(u)for(let e=0;e<s.length;e++)i.bindFramebuffer(t.FRAMEBUFFER,c.__webglMultisampledFramebuffer),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0+e,t.RENDERBUFFER,null),i.bindFramebuffer(t.FRAMEBUFFER,c.__webglFramebuffer),t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0+e,t.TEXTURE_2D,null,0);i.bindFramebuffer(t.READ_FRAMEBUFFER,c.__webglMultisampledFramebuffer),i.bindFramebuffer(t.DRAW_FRAMEBUFFER,c.__webglFramebuffer);for(let i=0;i<s.length;i++){if(e.resolveDepthBuffer&&(e.depthBuffer&&(o|=t.DEPTH_BUFFER_BIT),e.stencilBuffer&&e.resolveStencilBuffer&&(o|=t.STENCIL_BUFFER_BIT)),u){t.framebufferRenderbuffer(t.READ_FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.RENDERBUFFER,c.__webglColorRenderbuffer[i]);const e=n.get(s[i]).__webglTexture;t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0)}t.blitFramebuffer(0,0,r,a,0,0,r,a,o,t.NEAREST),!0===l&&(F.length=0,B.length=0,F.push(t.COLOR_ATTACHMENT0+i),e.depthBuffer&&!1===e.resolveDepthBuffer&&(F.push(h),B.push(h),t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER,B)),t.invalidateFramebuffer(t.READ_FRAMEBUFFER,F))}if(i.bindFramebuffer(t.READ_FRAMEBUFFER,null),i.bindFramebuffer(t.DRAW_FRAMEBUFFER,null),u)for(let e=0;e<s.length;e++){i.bindFramebuffer(t.FRAMEBUFFER,c.__webglMultisampledFramebuffer),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0+e,t.RENDERBUFFER,c.__webglColorRenderbuffer[e]);const r=n.get(s[e]).__webglTexture;i.bindFramebuffer(t.FRAMEBUFFER,c.__webglFramebuffer),t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0+e,t.TEXTURE_2D,r,0)}i.bindFramebuffer(t.DRAW_FRAMEBUFFER,c.__webglMultisampledFramebuffer)}else if(e.depthBuffer&&!1===e.resolveDepthBuffer&&l){const i=e.stencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT;t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER,[i])}},this.setupDepthRenderbuffer=U,this.setupFrameBufferTexture=L,this.useMultisampledRTT=z}function fo(t,e){return{convert:function(i,n=""){let s;const r=We.getTransfer(n);if(i===it)return t.UNSIGNED_BYTE;if(i===ct)return t.UNSIGNED_SHORT_4_4_4_4;if(i===ut)return t.UNSIGNED_SHORT_5_5_5_1;if(i===pt)return t.UNSIGNED_INT_5_9_9_9_REV;if(i===nt)return t.BYTE;if(i===st)return t.SHORT;if(i===rt)return t.UNSIGNED_SHORT;if(i===at)return t.INT;if(i===ot)return t.UNSIGNED_INT;if(i===lt)return t.FLOAT;if(i===ht)return t.HALF_FLOAT;if(1021===i)return t.ALPHA;if(1022===i)return t.RGB;if(i===mt)return t.RGBA;if(1024===i)return t.LUMINANCE;if(1025===i)return t.LUMINANCE_ALPHA;if(i===ft)return t.DEPTH_COMPONENT;if(i===gt)return t.DEPTH_STENCIL;if(i===xt)return t.RED;if(i===vt)return t.RED_INTEGER;if(1030===i)return t.RG;if(i===_t)return t.RG_INTEGER;if(i===yt)return t.RGBA_INTEGER;if(i===bt||i===St||i===Mt||i===Tt)if(r===ce){if(s=e.get("WEBGL_compressed_texture_s3tc_srgb"),null===s)return null;if(i===bt)return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(i===St)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(i===Mt)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(i===Tt)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(s=e.get("WEBGL_compressed_texture_s3tc"),null===s)return null;if(i===bt)return s.COMPRESSED_RGB_S3TC_DXT1_EXT;if(i===St)return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(i===Mt)return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(i===Tt)return s.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(i===wt||i===At||i===Et||i===Ct){if(s=e.get("WEBGL_compressed_texture_pvrtc"),null===s)return null;if(i===wt)return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(i===At)return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(i===Et)return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(i===Ct)return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(i===Rt||i===Nt||i===Pt){if(s=e.get("WEBGL_compressed_texture_etc"),null===s)return null;if(i===Rt||i===Nt)return r===ce?s.COMPRESSED_SRGB8_ETC2:s.COMPRESSED_RGB8_ETC2;if(i===Pt)return r===ce?s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:s.COMPRESSED_RGBA8_ETC2_EAC}if(i===It||i===Lt||i===Dt||i===Ut||i===Ft||i===Bt||i===Ot||i===zt||i===kt||i===Vt||i===Gt||i===Ht||i===Wt||i===jt){if(s=e.get("WEBGL_compressed_texture_astc"),null===s)return null;if(i===It)return r===ce?s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:s.COMPRESSED_RGBA_ASTC_4x4_KHR;if(i===Lt)return r===ce?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:s.COMPRESSED_RGBA_ASTC_5x4_KHR;if(i===Dt)return r===ce?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:s.COMPRESSED_RGBA_ASTC_5x5_KHR;if(i===Ut)return r===ce?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:s.COMPRESSED_RGBA_ASTC_6x5_KHR;if(i===Ft)return r===ce?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:s.COMPRESSED_RGBA_ASTC_6x6_KHR;if(i===Bt)return r===ce?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:s.COMPRESSED_RGBA_ASTC_8x5_KHR;if(i===Ot)return r===ce?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:s.COMPRESSED_RGBA_ASTC_8x6_KHR;if(i===zt)return r===ce?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:s.COMPRESSED_RGBA_ASTC_8x8_KHR;if(i===kt)return r===ce?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:s.COMPRESSED_RGBA_ASTC_10x5_KHR;if(i===Vt)return r===ce?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:s.COMPRESSED_RGBA_ASTC_10x6_KHR;if(i===Gt)return r===ce?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:s.COMPRESSED_RGBA_ASTC_10x8_KHR;if(i===Ht)return r===ce?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:s.COMPRESSED_RGBA_ASTC_10x10_KHR;if(i===Wt)return r===ce?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:s.COMPRESSED_RGBA_ASTC_12x10_KHR;if(i===jt)return r===ce?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:s.COMPRESSED_RGBA_ASTC_12x12_KHR}if(i===Xt||i===qt||i===$t){if(s=e.get("EXT_texture_compression_bptc"),null===s)return null;if(i===Xt)return r===ce?s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:s.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(i===qt)return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(i===$t)return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}if(36283===i||i===Yt||i===Zt||i===Kt){if(s=e.get("EXT_texture_compression_rgtc"),null===s)return null;if(i===Xt)return s.COMPRESSED_RED_RGTC1_EXT;if(i===Yt)return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(i===Zt)return s.COMPRESSED_RED_GREEN_RGTC2_EXT;if(i===Kt)return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}return i===dt?t.UNSIGNED_INT_24_8:void 0!==t[i]?t[i]:null}}}class go extends Ss{constructor(t=[]){super(),this.isArrayCamera=!0,this.cameras=t}}let xo=class extends fn{constructor(){super(),this.isGroup=!0,this.type="Group"}};const vo={type:"move"};class _o{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return null===this._hand&&(this._hand=new xo,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return null===this._targetRay&&(this._targetRay=new xo,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new ui,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new ui),this._targetRay}getGripSpace(){return null===this._grip&&(this._grip=new xo,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new ui,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new ui),this._grip}dispatchEvent(t){return null!==this._targetRay&&this._targetRay.dispatchEvent(t),null!==this._grip&&this._grip.dispatchEvent(t),null!==this._hand&&this._hand.dispatchEvent(t),this}connect(t){if(t&&t.hand){const e=this._hand;if(e)for(const i of t.hand.values())this._getHandJoint(e,i)}return this.dispatchEvent({type:"connected",data:t}),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this}update(t,e,i){let n=null,s=null,r=null;const a=this._targetRay,o=this._grip,l=this._hand;if(t&&"visible-blurred"!==e.session.visibilityState){if(l&&t.hand){r=!0;for(const r of t.hand.values()){const t=e.getJointPose(r,i),n=this._getHandJoint(l,r);null!==t&&(n.matrix.fromArray(t.transform.matrix),n.matrix.decompose(n.position,n.rotation,n.scale),n.matrixWorldNeedsUpdate=!0,n.jointRadius=t.radius),n.visible=null!==t}const n=l.joints["index-finger-tip"],s=l.joints["thumb-tip"],a=n.position.distanceTo(s.position),o=.02,h=.005;l.inputState.pinching&&a>o+h?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!l.inputState.pinching&&a<=o-h&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else null!==o&&t.gripSpace&&(s=e.getPose(t.gripSpace,i),null!==s&&(o.matrix.fromArray(s.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),o.matrixWorldNeedsUpdate=!0,s.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(s.linearVelocity)):o.hasLinearVelocity=!1,s.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(s.angularVelocity)):o.hasAngularVelocity=!1));null!==a&&(n=e.getPose(t.targetRaySpace,i),null===n&&null!==s&&(n=s),null!==n&&(a.matrix.fromArray(n.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),a.matrixWorldNeedsUpdate=!0,n.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(n.linearVelocity)):a.hasLinearVelocity=!1,n.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(n.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(vo)))}return null!==a&&(a.visible=null!==n),null!==o&&(o.visible=null!==s),null!==l&&(l.visible=null!==r),this}_getHandJoint(t,e){if(void 0===t.joints[e.jointName]){const i=new xo;i.matrixAutoUpdate=!1,i.visible=!1,t.joints[e.jointName]=i,t.add(i)}return t.joints[e.jointName]}}class yo{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(t,e,i){if(null===this.texture){const n=new si;t.properties.get(n).__webglTexture=e.texture,e.depthNear==i.depthNear&&e.depthFar==i.depthFar||(this.depthNear=e.depthNear,this.depthFar=e.depthFar),this.texture=n}}getMesh(t){if(null!==this.texture&&null===this.mesh){const e=t.cameras[0].viewport,i=new xs({vertexShader:"\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}",fragmentShader:"\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}",uniforms:{depthColor:{value:this.texture},depthWidth:{value:e.z},depthHeight:{value:e.w}}});this.mesh=new cs(new Fs(20,20),i)}return this.mesh}reset(){this.texture=null,this.mesh=null}getDepthTexture(){return this.texture}}class bo extends Te{constructor(t,e){super();const i=this;let n=null,s=1,r=null,a="local-floor",o=1,l=null,h=null,c=null,u=null,d=null,p=null;const m=new yo,f=e.getContextAttributes();let g=null,x=null;const v=[],_=[],y=new Fe;let b=null;const S=new Ss;S.viewport=new ri;const M=new Ss;M.viewport=new ri;const T=[S,M],w=new go;let A=null,E=null;function C(t){const e=_.indexOf(t.inputSource);if(-1===e)return;const i=v[e];void 0!==i&&(i.update(t.inputSource,t.frame,l||r),i.dispatchEvent({type:t.type,data:t.inputSource}))}function R(){n.removeEventListener("select",C),n.removeEventListener("selectstart",C),n.removeEventListener("selectend",C),n.removeEventListener("squeeze",C),n.removeEventListener("squeezestart",C),n.removeEventListener("squeezeend",C),n.removeEventListener("end",R),n.removeEventListener("inputsourceschange",N);for(let t=0;t<v.length;t++){const e=_[t];null!==e&&(_[t]=null,v[t].disconnect(e))}A=null,E=null,m.reset(),t.setRenderTarget(g),d=null,u=null,c=null,n=null,x=null,U.stop(),i.isPresenting=!1,t.setPixelRatio(b),t.setSize(y.width,y.height,!1),i.dispatchEvent({type:"sessionend"})}function N(t){for(let e=0;e<t.removed.length;e++){const i=t.removed[e],n=_.indexOf(i);n>=0&&(_[n]=null,v[n].disconnect(i))}for(let e=0;e<t.added.length;e++){const i=t.added[e];let n=_.indexOf(i);if(-1===n){for(let t=0;t<v.length;t++){if(t>=_.length){_.push(i),n=t;break}if(null===_[t]){_[t]=i,n=t;break}}if(-1===n)break}const s=v[n];s&&s.connect(i)}}this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(t){let e=v[t];return void 0===e&&(e=new _o,v[t]=e),e.getTargetRaySpace()},this.getControllerGrip=function(t){let e=v[t];return void 0===e&&(e=new _o,v[t]=e),e.getGripSpace()},this.getHand=function(t){let e=v[t];return void 0===e&&(e=new _o,v[t]=e),e.getHandSpace()},this.setFramebufferScaleFactor=function(t){s=t,i.isPresenting},this.setReferenceSpaceType=function(t){a=t,i.isPresenting},this.getReferenceSpace=function(){return l||r},this.setReferenceSpace=function(t){l=t},this.getBaseLayer=function(){return null!==u?u:d},this.getBinding=function(){return c},this.getFrame=function(){return p},this.getSession=function(){return n},this.setSession=async function(h){if(n=h,null!==n){if(g=t.getRenderTarget(),n.addEventListener("select",C),n.addEventListener("selectstart",C),n.addEventListener("selectend",C),n.addEventListener("squeeze",C),n.addEventListener("squeezestart",C),n.addEventListener("squeezeend",C),n.addEventListener("end",R),n.addEventListener("inputsourceschange",N),!0!==f.xrCompatible&&await e.makeXRCompatible(),b=t.getPixelRatio(),t.getSize(y),void 0===n.renderState.layers){const i={antialias:f.antialias,alpha:!0,depth:f.depth,stencil:f.stencil,framebufferScaleFactor:s};d=new XRWebGLLayer(n,e,i),n.updateRenderState({baseLayer:d}),t.setPixelRatio(1),t.setSize(d.framebufferWidth,d.framebufferHeight,!1),x=new oi(d.framebufferWidth,d.framebufferHeight,{format:mt,type:it,colorSpace:t.outputColorSpace,stencilBuffer:f.stencil})}else{let i=null,r=null,a=null;f.depth&&(a=f.stencil?e.DEPTH24_STENCIL8:e.DEPTH_COMPONENT24,i=f.stencil?gt:ft,r=f.stencil?dt:ot);const o={colorFormat:e.RGBA8,depthFormat:a,scaleFactor:s};c=new XRWebGLBinding(n,e),u=c.createProjectionLayer(o),n.updateRenderState({layers:[u]}),t.setPixelRatio(1),t.setSize(u.textureWidth,u.textureHeight,!1),x=new oi(u.textureWidth,u.textureHeight,{format:mt,type:it,depthTexture:new yr(u.textureWidth,u.textureHeight,r,void 0,void 0,void 0,void 0,void 0,void 0,i),stencilBuffer:f.stencil,colorSpace:t.outputColorSpace,samples:f.antialias?4:0,resolveDepthBuffer:!1===u.ignoreDepthValues})}x.isXRRenderTarget=!0,this.setFoveation(o),l=null,r=await n.requestReferenceSpace(a),U.setContext(n),U.start(),i.isPresenting=!0,i.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(null!==n)return n.environmentBlendMode},this.getDepthTexture=function(){return m.getDepthTexture()};const P=new ui,I=new ui;function L(t,e){null===e?t.matrixWorld.copy(t.matrix):t.matrixWorld.multiplyMatrices(e.matrixWorld,t.matrix),t.matrixWorldInverse.copy(t.matrixWorld).invert()}this.updateCamera=function(t){if(null===n)return;let e=t.near,i=t.far;null!==m.texture&&(m.depthNear>0&&(e=m.depthNear),m.depthFar>0&&(i=m.depthFar)),w.near=M.near=S.near=e,w.far=M.far=S.far=i,A===w.near&&E===w.far||(n.updateRenderState({depthNear:w.near,depthFar:w.far}),A=w.near,E=w.far),S.layers.mask=2|t.layers.mask,M.layers.mask=4|t.layers.mask,w.layers.mask=S.layers.mask|M.layers.mask;const s=t.parent,r=w.cameras;L(w,s);for(let n=0;n<r.length;n++)L(r[n],s);2===r.length?function(t,e,i){P.setFromMatrixPosition(e.matrixWorld),I.setFromMatrixPosition(i.matrixWorld);const n=P.distanceTo(I),s=e.projectionMatrix.elements,r=i.projectionMatrix.elements,a=s[14]/(s[10]-1),o=s[14]/(s[10]+1),l=(s[9]+1)/s[5],h=(s[9]-1)/s[5],c=(s[8]-1)/s[0],u=(r[8]+1)/r[0],d=a*c,p=a*u,m=n/(-c+u),f=m*-c;if(e.matrixWorld.decompose(t.position,t.quaternion,t.scale),t.translateX(f),t.translateZ(m),t.matrixWorld.compose(t.position,t.quaternion,t.scale),t.matrixWorldInverse.copy(t.matrixWorld).invert(),-1===s[10])t.projectionMatrix.copy(e.projectionMatrix),t.projectionMatrixInverse.copy(e.projectionMatrixInverse);else{const e=a+m,i=o+m,s=d-f,r=p+(n-f),c=l*o/i*e,u=h*o/i*e;t.projectionMatrix.makePerspective(s,r,c,u,e,i),t.projectionMatrixInverse.copy(t.projectionMatrix).invert()}}(w,S,M):w.projectionMatrix.copy(S.projectionMatrix),function(t,e,i){null===i?t.matrix.copy(e.matrixWorld):(t.matrix.copy(i.matrixWorld),t.matrix.invert(),t.matrix.multiply(e.matrixWorld));t.matrix.decompose(t.position,t.quaternion,t.scale),t.updateMatrixWorld(!0),t.projectionMatrix.copy(e.projectionMatrix),t.projectionMatrixInverse.copy(e.projectionMatrixInverse),t.isPerspectiveCamera&&(t.fov=2*Ce*Math.atan(1/t.projectionMatrix.elements[5]),t.zoom=1)}(t,w,s)},this.getCamera=function(){return w},this.getFoveation=function(){if(null!==u||null!==d)return o},this.setFoveation=function(t){o=t,null!==u&&(u.fixedFoveation=t),null!==d&&void 0!==d.fixedFoveation&&(d.fixedFoveation=t)},this.hasDepthSensing=function(){return null!==m.texture},this.getDepthSensingMesh=function(){return m.getMesh(w)};let D=null;const U=new Ds;U.setAnimationLoop((function(e,s){if(h=s.getViewerPose(l||r),p=s,null!==h){const e=h.views;null!==d&&(t.setRenderTargetFramebuffer(x,d.framebuffer),t.setRenderTarget(x));let i=!1;e.length!==w.cameras.length&&(w.cameras.length=0,i=!0);for(let n=0;n<e.length;n++){const s=e[n];let r=null;if(null!==d)r=d.getViewport(s);else{const e=c.getViewSubImage(u,s);r=e.viewport,0===n&&(t.setRenderTargetTextures(x,e.colorTexture,u.ignoreDepthValues?void 0:e.depthStencilTexture),t.setRenderTarget(x))}let a=T[n];void 0===a&&(a=new Ss,a.layers.enable(n),a.viewport=new ri,T[n]=a),a.matrix.fromArray(s.transform.matrix),a.matrix.decompose(a.position,a.quaternion,a.scale),a.projectionMatrix.fromArray(s.projectionMatrix),a.projectionMatrixInverse.copy(a.projectionMatrix).invert(),a.viewport.set(r.x,r.y,r.width,r.height),0===n&&(w.matrix.copy(a.matrix),w.matrix.decompose(w.position,w.quaternion,w.scale)),!0===i&&w.cameras.push(a)}const s=n.enabledFeatures;if(s&&s.includes("depth-sensing")){const i=c.getDepthInformation(e[0]);i&&i.isValid&&i.texture&&m.init(t,i,n.renderState)}}for(let t=0;t<v.length;t++){const e=_[t],i=v[t];null!==e&&void 0!==i&&i.update(e,s,l||r)}D&&D(e,s),s.detectedPlanes&&i.dispatchEvent({type:"planesdetected",data:s}),p=null})),this.setAnimationLoop=function(t){D=t},this.dispose=function(){}}}const So=new Ki,Mo=new Vi;function To(t,e){function i(t,e){!0===t.matrixAutoUpdate&&t.updateMatrix(),e.value.copy(t.matrix)}function n(t,n){t.opacity.value=n.opacity,n.color&&t.diffuse.value.copy(n.color),n.emissive&&t.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),n.map&&(t.map.value=n.map,i(n.map,t.mapTransform)),n.alphaMap&&(t.alphaMap.value=n.alphaMap,i(n.alphaMap,t.alphaMapTransform)),n.bumpMap&&(t.bumpMap.value=n.bumpMap,i(n.bumpMap,t.bumpMapTransform),t.bumpScale.value=n.bumpScale,1===n.side&&(t.bumpScale.value*=-1)),n.normalMap&&(t.normalMap.value=n.normalMap,i(n.normalMap,t.normalMapTransform),t.normalScale.value.copy(n.normalScale),1===n.side&&t.normalScale.value.negate()),n.displacementMap&&(t.displacementMap.value=n.displacementMap,i(n.displacementMap,t.displacementMapTransform),t.displacementScale.value=n.displacementScale,t.displacementBias.value=n.displacementBias),n.emissiveMap&&(t.emissiveMap.value=n.emissiveMap,i(n.emissiveMap,t.emissiveMapTransform)),n.specularMap&&(t.specularMap.value=n.specularMap,i(n.specularMap,t.specularMapTransform)),n.alphaTest>0&&(t.alphaTest.value=n.alphaTest);const s=e.get(n),r=s.envMap,a=s.envMapRotation;r&&(t.envMap.value=r,So.copy(a),So.x*=-1,So.y*=-1,So.z*=-1,r.isCubeTexture&&!1===r.isRenderTargetTexture&&(So.y*=-1,So.z*=-1),t.envMapRotation.value.setFromMatrix4(Mo.makeRotationFromEuler(So)),t.flipEnvMap.value=r.isCubeTexture&&!1===r.isRenderTargetTexture?-1:1,t.reflectivity.value=n.reflectivity,t.ior.value=n.ior,t.refractionRatio.value=n.refractionRatio),n.lightMap&&(t.lightMap.value=n.lightMap,t.lightMapIntensity.value=n.lightMapIntensity,i(n.lightMap,t.lightMapTransform)),n.aoMap&&(t.aoMap.value=n.aoMap,t.aoMapIntensity.value=n.aoMapIntensity,i(n.aoMap,t.aoMapTransform))}return{refreshFogUniforms:function(e,i){i.color.getRGB(e.fogColor.value,fs(t)),i.isFog?(e.fogNear.value=i.near,e.fogFar.value=i.far):i.isFogExp2&&(e.fogDensity.value=i.density)},refreshMaterialUniforms:function(t,s,r,a,o){s.isMeshBasicMaterial||s.isMeshLambertMaterial?n(t,s):s.isMeshToonMaterial?(n(t,s),function(t,e){e.gradientMap&&(t.gradientMap.value=e.gradientMap)}(t,s)):s.isMeshPhongMaterial?(n(t,s),function(t,e){t.specular.value.copy(e.specular),t.shininess.value=Math.max(e.shininess,1e-4)}(t,s)):s.isMeshStandardMaterial?(n(t,s),function(t,e){t.metalness.value=e.metalness,e.metalnessMap&&(t.metalnessMap.value=e.metalnessMap,i(e.metalnessMap,t.metalnessMapTransform));t.roughness.value=e.roughness,e.roughnessMap&&(t.roughnessMap.value=e.roughnessMap,i(e.roughnessMap,t.roughnessMapTransform));e.envMap&&(t.envMapIntensity.value=e.envMapIntensity)}(t,s),s.isMeshPhysicalMaterial&&function(t,e,n){t.ior.value=e.ior,e.sheen>0&&(t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen),t.sheenRoughness.value=e.sheenRoughness,e.sheenColorMap&&(t.sheenColorMap.value=e.sheenColorMap,i(e.sheenColorMap,t.sheenColorMapTransform)),e.sheenRoughnessMap&&(t.sheenRoughnessMap.value=e.sheenRoughnessMap,i(e.sheenRoughnessMap,t.sheenRoughnessMapTransform)));e.clearcoat>0&&(t.clearcoat.value=e.clearcoat,t.clearcoatRoughness.value=e.clearcoatRoughness,e.clearcoatMap&&(t.clearcoatMap.value=e.clearcoatMap,i(e.clearcoatMap,t.clearcoatMapTransform)),e.clearcoatRoughnessMap&&(t.clearcoatRoughnessMap.value=e.clearcoatRoughnessMap,i(e.clearcoatRoughnessMap,t.clearcoatRoughnessMapTransform)),e.clearcoatNormalMap&&(t.clearcoatNormalMap.value=e.clearcoatNormalMap,i(e.clearcoatNormalMap,t.clearcoatNormalMapTransform),t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),1===e.side&&t.clearcoatNormalScale.value.negate()));e.dispersion>0&&(t.dispersion.value=e.dispersion);e.iridescence>0&&(t.iridescence.value=e.iridescence,t.iridescenceIOR.value=e.iridescenceIOR,t.iridescenceThicknessMinimum.value=e.iridescenceThicknessRange[0],t.iridescenceThicknessMaximum.value=e.iridescenceThicknessRange[1],e.iridescenceMap&&(t.iridescenceMap.value=e.iridescenceMap,i(e.iridescenceMap,t.iridescenceMapTransform)),e.iridescenceThicknessMap&&(t.iridescenceThicknessMap.value=e.iridescenceThicknessMap,i(e.iridescenceThicknessMap,t.iridescenceThicknessMapTransform)));e.transmission>0&&(t.transmission.value=e.transmission,t.transmissionSamplerMap.value=n.texture,t.transmissionSamplerSize.value.set(n.width,n.height),e.transmissionMap&&(t.transmissionMap.value=e.transmissionMap,i(e.transmissionMap,t.transmissionMapTransform)),t.thickness.value=e.thickness,e.thicknessMap&&(t.thicknessMap.value=e.thicknessMap,i(e.thicknessMap,t.thicknessMapTransform)),t.attenuationDistance.value=e.attenuationDistance,t.attenuationColor.value.copy(e.attenuationColor));e.anisotropy>0&&(t.anisotropyVector.value.set(e.anisotropy*Math.cos(e.anisotropyRotation),e.anisotropy*Math.sin(e.anisotropyRotation)),e.anisotropyMap&&(t.anisotropyMap.value=e.anisotropyMap,i(e.anisotropyMap,t.anisotropyMapTransform)));t.specularIntensity.value=e.specularIntensity,t.specularColor.value.copy(e.specularColor),e.specularColorMap&&(t.specularColorMap.value=e.specularColorMap,i(e.specularColorMap,t.specularColorMapTransform));e.specularIntensityMap&&(t.specularIntensityMap.value=e.specularIntensityMap,i(e.specularIntensityMap,t.specularIntensityMapTransform))}(t,s,o)):s.isMeshMatcapMaterial?(n(t,s),function(t,e){e.matcap&&(t.matcap.value=e.matcap)}(t,s)):s.isMeshDepthMaterial?n(t,s):s.isMeshDistanceMaterial?(n(t,s),function(t,i){const n=e.get(i).light;t.referencePosition.value.setFromMatrixPosition(n.matrixWorld),t.nearDistance.value=n.shadow.camera.near,t.farDistance.value=n.shadow.camera.far}(t,s)):s.isMeshNormalMaterial?n(t,s):s.isLineBasicMaterial?(function(t,e){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,e.map&&(t.map.value=e.map,i(e.map,t.mapTransform))}(t,s),s.isLineDashedMaterial&&function(t,e){t.dashSize.value=e.dashSize,t.totalSize.value=e.dashSize+e.gapSize,t.scale.value=e.scale}(t,s)):s.isPointsMaterial?function(t,e,n,s){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.size.value=e.size*n,t.scale.value=.5*s,e.map&&(t.map.value=e.map,i(e.map,t.uvTransform));e.alphaMap&&(t.alphaMap.value=e.alphaMap,i(e.alphaMap,t.alphaMapTransform));e.alphaTest>0&&(t.alphaTest.value=e.alphaTest)}(t,s,r,a):s.isSpriteMaterial?function(t,e){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.rotation.value=e.rotation,e.map&&(t.map.value=e.map,i(e.map,t.mapTransform));e.alphaMap&&(t.alphaMap.value=e.alphaMap,i(e.alphaMap,t.alphaMapTransform));e.alphaTest>0&&(t.alphaTest.value=e.alphaTest)}(t,s):s.isShadowMaterial?(t.color.value.copy(s.color),t.opacity.value=s.opacity):s.isShaderMaterial&&(s.uniformsNeedUpdate=!1)}}}function wo(t,e,i,n){let s={},r={},a=[];const o=t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS);function l(t,e,i,n){const s=t.value,r=e+"_"+i;if(void 0===n[r])return n[r]="number"==typeof s||"boolean"==typeof s?s:s.clone(),!0;{const t=n[r];if("number"==typeof s||"boolean"==typeof s){if(t!==s)return n[r]=s,!0}else if(!1===t.equals(s))return t.copy(s),!0}return!1}function h(t){const e={boundary:0,storage:0};return"number"==typeof t||"boolean"==typeof t?(e.boundary=4,e.storage=4):t.isVector2?(e.boundary=8,e.storage=8):t.isVector3||t.isColor?(e.boundary=16,e.storage=12):t.isVector4?(e.boundary=16,e.storage=16):t.isMatrix3?(e.boundary=48,e.storage=48):t.isMatrix4?(e.boundary=64,e.storage=64):t.isTexture,e}function c(e){const i=e.target;i.removeEventListener("dispose",c);const n=a.indexOf(i.__bindingPointIndex);a.splice(n,1),t.deleteBuffer(s[i.id]),delete s[i.id],delete r[i.id]}return{bind:function(t,e){const i=e.program;n.uniformBlockBinding(t,i)},update:function(i,u){let d=s[i.id];void 0===d&&(!function(t){const e=t.uniforms;let i=0;const n=16;for(let r=0,a=e.length;r<a;r++){const t=Array.isArray(e[r])?e[r]:[e[r]];for(let e=0,s=t.length;e<s;e++){const s=t[e],r=Array.isArray(s.value)?s.value:[s.value];for(let t=0,e=r.length;t<e;t++){const e=h(r[t]),a=i%n,o=a%e.boundary,l=a+o;i+=o,0!==l&&n-l<e.storage&&(i+=n-l),s.__data=new Float32Array(e.storage/Float32Array.BYTES_PER_ELEMENT),s.__offset=i,i+=e.storage}}}const s=i%n;s>0&&(i+=n-s);t.__size=i,t.__cache={}}(i),d=function(e){const i=function(){for(let t=0;t<o;t++)if(-1===a.indexOf(t))return a.push(t),t;return 0}();e.__bindingPointIndex=i;const n=t.createBuffer(),s=e.__size,r=e.usage;return t.bindBuffer(t.UNIFORM_BUFFER,n),t.bufferData(t.UNIFORM_BUFFER,s,r),t.bindBuffer(t.UNIFORM_BUFFER,null),t.bindBufferBase(t.UNIFORM_BUFFER,i,n),n}(i),s[i.id]=d,i.addEventListener("dispose",c));const p=u.program;n.updateUBOMapping(i,p);const m=e.render.frame;r[i.id]!==m&&(!function(e){const i=s[e.id],n=e.uniforms,r=e.__cache;t.bindBuffer(t.UNIFORM_BUFFER,i);for(let s=0,a=n.length;s<a;s++){const e=Array.isArray(n[s])?n[s]:[n[s]];for(let i=0,n=e.length;i<n;i++){const n=e[i];if(!0===l(n,s,i,r)){const e=n.__offset,i=Array.isArray(n.value)?n.value:[n.value];let s=0;for(let r=0;r<i.length;r++){const a=i[r],o=h(a);"number"==typeof a||"boolean"==typeof a?(n.__data[0]=a,t.bufferSubData(t.UNIFORM_BUFFER,e+s,n.__data)):a.isMatrix3?(n.__data[0]=a.elements[0],n.__data[1]=a.elements[1],n.__data[2]=a.elements[2],n.__data[3]=0,n.__data[4]=a.elements[3],n.__data[5]=a.elements[4],n.__data[6]=a.elements[5],n.__data[7]=0,n.__data[8]=a.elements[6],n.__data[9]=a.elements[7],n.__data[10]=a.elements[8],n.__data[11]=0):(a.toArray(n.__data,s),s+=o.storage/Float32Array.BYTES_PER_ELEMENT)}t.bufferSubData(t.UNIFORM_BUFFER,e,n.__data)}}}t.bindBuffer(t.UNIFORM_BUFFER,null)}(i),r[i.id]=m)},dispose:function(){for(const e in s)t.deleteBuffer(s[e]);a=[],s={},r={}}}}class Ao{constructor(t={}){const{canvas:e=Ve(),context:n=null,depth:s=!0,stencil:r=!1,alpha:a=!1,antialias:o=!1,premultipliedAlpha:l=!0,preserveDrawingBuffer:h=!1,powerPreference:c="default",failIfMajorPerformanceCaveat:u=!1,reverseDepthBuffer:d=!1}=t;let p;if(this.isWebGLRenderer=!0,null!==n){if("undefined"!=typeof WebGLRenderingContext&&n instanceof WebGLRenderingContext)throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");p=n.getContextAttributes().alpha}else p=a;const m=new Uint32Array(4),f=new Int32Array(4);let g=null,x=null;const v=[],_=[];this.domElement=e,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this._outputColorSpace=oe,this.toneMapping=0,this.toneMappingExposure=1;const y=this;let b=!1,S=0,M=0,T=null,w=-1,A=null;const E=new ri,C=new ri;let R=null;const N=new Dn(0);let P=0,I=e.width,L=e.height,D=1,U=null,F=null;const B=new ri(0,0,I,L),O=new ri(0,0,I,L);let z=!1;const k=new Ls;let V=!1,G=!1;const H=new Vi,W=new Vi,j=new ui,X=new ri,q={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};let $=!1;function Y(){return null===T?D:1}let Z,K,J,Q,tt,nt,st,at,lt,pt,mt,ft,gt,xt,bt,St,Mt,Tt,wt,At,Et,Ct,Rt,Nt,Pt=n;function It(t,i){return e.getContext(t,i)}try{const t={alpha:!0,depth:s,stencil:r,antialias:o,premultipliedAlpha:l,preserveDrawingBuffer:h,powerPreference:c,failIfMajorPerformanceCaveat:u};if("setAttribute"in e&&e.setAttribute("data-engine",`three.js r${i}`),e.addEventListener("webglcontextlost",Ut,!1),e.addEventListener("webglcontextrestored",Ft,!1),e.addEventListener("webglcontextcreationerror",Bt,!1),null===Pt){const e="webgl2";if(Pt=It(e,t),null===Pt)throw It(e)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}}catch(Jt){throw Jt}function Lt(){Z=new mr(Pt),Z.init(),Ct=new fo(Pt,Z),K=new Xs(Pt,Z,t,Ct),J=new uo(Pt,Z),K.reverseDepthBuffer&&d&&J.buffers.depth.setReversed(!0),Q=new xr(Pt),tt=new Za,nt=new mo(Pt,Z,J,tt,K,Ct,Q),st=new $s(y),at=new pr(y),lt=new Us(Pt),Rt=new Ws(Pt,lt),pt=new fr(Pt,lt,Q,Rt),mt=new _r(Pt,pt,lt,Q),wt=new vr(Pt,K,nt),St=new qs(tt),ft=new Ya(y,st,at,Z,K,Rt,St),gt=new To(y,tt),xt=new to,bt=new ao(Z),Tt=new Hs(y,st,at,J,mt,p,l),Mt=new ho(y,mt,K),Nt=new wo(Pt,Q,K,J),At=new js(Pt,Z,Q),Et=new gr(Pt,Z,Q),Q.programs=ft.programs,y.capabilities=K,y.extensions=Z,y.properties=tt,y.renderLists=xt,y.shadowMap=Mt,y.state=J,y.info=Q}Lt();const Dt=new bo(y,Pt);function Ut(t){t.preventDefault(),b=!0}function Ft(){b=!1;const t=Q.autoReset,e=Mt.enabled,i=Mt.autoUpdate,n=Mt.needsUpdate,s=Mt.type;Lt(),Q.autoReset=t,Mt.enabled=e,Mt.autoUpdate=i,Mt.needsUpdate=n,Mt.type=s}function Bt(t){}function Ot(t){const e=t.target;e.removeEventListener("dispose",Ot),function(t){(function(t){const e=tt.get(t).programs;void 0!==e&&(e.forEach((function(t){ft.releaseProgram(t)})),t.isShaderMaterial&&ft.releaseShaderCache(t))})(t),tt.remove(t)}(e)}function zt(t,e,i){!0===t.transparent&&2===t.side&&!1===t.forceSinglePass?(t.side=1,t.needsUpdate=!0,Yt(t,e,i),t.side=0,t.needsUpdate=!0,Yt(t,e,i),t.side=2):Yt(t,e,i)}this.xr=Dt,this.getContext=function(){return Pt},this.getContextAttributes=function(){return Pt.getContextAttributes()},this.forceContextLoss=function(){const t=Z.get("WEBGL_lose_context");t&&t.loseContext()},this.forceContextRestore=function(){const t=Z.get("WEBGL_lose_context");t&&t.restoreContext()},this.getPixelRatio=function(){return D},this.setPixelRatio=function(t){void 0!==t&&(D=t,this.setSize(I,L,!1))},this.getSize=function(t){return t.set(I,L)},this.setSize=function(t,i,n=!0){Dt.isPresenting||(I=t,L=i,e.width=Math.floor(t*D),e.height=Math.floor(i*D),!0===n&&(e.style.width=t+"px",e.style.height=i+"px"),this.setViewport(0,0,t,i))},this.getDrawingBufferSize=function(t){return t.set(I*D,L*D).floor()},this.setDrawingBufferSize=function(t,i,n){I=t,L=i,D=n,e.width=Math.floor(t*n),e.height=Math.floor(i*n),this.setViewport(0,0,t,i)},this.getCurrentViewport=function(t){return t.copy(E)},this.getViewport=function(t){return t.copy(B)},this.setViewport=function(t,e,i,n){t.isVector4?B.set(t.x,t.y,t.z,t.w):B.set(t,e,i,n),J.viewport(E.copy(B).multiplyScalar(D).round())},this.getScissor=function(t){return t.copy(O)},this.setScissor=function(t,e,i,n){t.isVector4?O.set(t.x,t.y,t.z,t.w):O.set(t,e,i,n),J.scissor(C.copy(O).multiplyScalar(D).round())},this.getScissorTest=function(){return z},this.setScissorTest=function(t){J.setScissorTest(z=t)},this.setOpaqueSort=function(t){U=t},this.setTransparentSort=function(t){F=t},this.getClearColor=function(t){return t.copy(Tt.getClearColor())},this.setClearColor=function(){Tt.setClearColor.apply(Tt,arguments)},this.getClearAlpha=function(){return Tt.getClearAlpha()},this.setClearAlpha=function(){Tt.setClearAlpha.apply(Tt,arguments)},this.clear=function(t=!0,e=!0,i=!0){let n=0;if(t){let t=!1;if(null!==T){const e=T.texture.format;t=e===yt||e===_t||e===vt}if(t){const t=T.texture.type,e=t===it||t===ot||t===rt||t===dt||t===ct||t===ut,i=Tt.getClearColor(),n=Tt.getClearAlpha(),s=i.r,r=i.g,a=i.b;e?(m[0]=s,m[1]=r,m[2]=a,m[3]=n,Pt.clearBufferuiv(Pt.COLOR,0,m)):(f[0]=s,f[1]=r,f[2]=a,f[3]=n,Pt.clearBufferiv(Pt.COLOR,0,f))}else n|=Pt.COLOR_BUFFER_BIT}e&&(n|=Pt.DEPTH_BUFFER_BIT),i&&(n|=Pt.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),Pt.clear(n)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",Ut,!1),e.removeEventListener("webglcontextrestored",Ft,!1),e.removeEventListener("webglcontextcreationerror",Bt,!1),xt.dispose(),bt.dispose(),tt.dispose(),st.dispose(),at.dispose(),mt.dispose(),Rt.dispose(),Nt.dispose(),ft.dispose(),Dt.dispose(),Dt.removeEventListener("sessionstart",Vt),Dt.removeEventListener("sessionend",Gt),Ht.stop()},this.renderBufferDirect=function(t,e,i,n,s,r){null===e&&(e=q);const a=s.isMesh&&s.matrixWorld.determinant()<0,o=function(t,e,i,n,s){!0!==e.isScene&&(e=q);nt.resetTextureUnits();const r=e.fog,a=n.isMeshStandardMaterial?e.environment:null,o=null===T?y.outputColorSpace:!0===T.isXRRenderTarget?T.texture.colorSpace:le,l=(n.isMeshStandardMaterial?at:st).get(n.envMap||a),h=!0===n.vertexColors&&!!i.attributes.color&&4===i.attributes.color.itemSize,c=!!i.attributes.tangent&&(!!n.normalMap||n.anisotropy>0),u=!!i.morphAttributes.position,d=!!i.morphAttributes.normal,p=!!i.morphAttributes.color;let m=0;n.toneMapped&&(null!==T&&!0!==T.isXRRenderTarget||(m=y.toneMapping));const f=i.morphAttributes.position||i.morphAttributes.normal||i.morphAttributes.color,g=void 0!==f?f.length:0,v=tt.get(n),_=x.state.lights;if(!0===V&&(!0===G||t!==A)){const e=t===A&&n.id===w;St.setState(n,t,e)}let b=!1;n.version===v.__version?v.needsLights&&v.lightsStateVersion!==_.state.version||v.outputColorSpace!==o||s.isBatchedMesh&&!1===v.batching?b=!0:s.isBatchedMesh||!0!==v.batching?s.isBatchedMesh&&!0===v.batchingColor&&null===s.colorTexture||s.isBatchedMesh&&!1===v.batchingColor&&null!==s.colorTexture||s.isInstancedMesh&&!1===v.instancing?b=!0:s.isInstancedMesh||!0!==v.instancing?s.isSkinnedMesh&&!1===v.skinning?b=!0:s.isSkinnedMesh||!0!==v.skinning?s.isInstancedMesh&&!0===v.instancingColor&&null===s.instanceColor||s.isInstancedMesh&&!1===v.instancingColor&&null!==s.instanceColor||s.isInstancedMesh&&!0===v.instancingMorph&&null===s.morphTexture||s.isInstancedMesh&&!1===v.instancingMorph&&null!==s.morphTexture||v.envMap!==l||!0===n.fog&&v.fog!==r?b=!0:void 0===v.numClippingPlanes||v.numClippingPlanes===St.numPlanes&&v.numIntersection===St.numIntersection?(v.vertexAlphas!==h||v.vertexTangents!==c||v.morphTargets!==u||v.morphNormals!==d||v.morphColors!==p||v.toneMapping!==m||v.morphTargetsCount!==g)&&(b=!0):b=!0:b=!0:b=!0:b=!0:(b=!0,v.__version=n.version);let S=v.currentProgram;!0===b&&(S=Yt(n,e,s));let M=!1,E=!1,C=!1;const R=S.getUniforms(),N=v.uniforms;J.useProgram(S.program)&&(M=!0,E=!0,C=!0);n.id!==w&&(w=n.id,E=!0);if(M||A!==t){J.buffers.depth.getReversed()?(H.copy(t.projectionMatrix),function(t){const e=t.elements;e[2]=.5*e[2]+.5*e[3],e[6]=.5*e[6]+.5*e[7],e[10]=.5*e[10]+.5*e[11],e[14]=.5*e[14]+.5*e[15]}(H),function(t){const e=t.elements;-1===e[11]?(e[10]=-e[10]-1,e[14]=-e[14]):(e[10]=-e[10],e[14]=1-e[14])}(H),R.setValue(Pt,"projectionMatrix",H)):R.setValue(Pt,"projectionMatrix",t.projectionMatrix),R.setValue(Pt,"viewMatrix",t.matrixWorldInverse);const e=R.map.cameraPosition;void 0!==e&&e.setValue(Pt,j.setFromMatrixPosition(t.matrixWorld)),K.logarithmicDepthBuffer&&R.setValue(Pt,"logDepthBufFC",2/(Math.log(t.far+1)/Math.LN2)),(n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshLambertMaterial||n.isMeshBasicMaterial||n.isMeshStandardMaterial||n.isShaderMaterial)&&R.setValue(Pt,"isOrthographic",!0===t.isOrthographicCamera),A!==t&&(A=t,E=!0,C=!0)}if(s.isSkinnedMesh){R.setOptional(Pt,s,"bindMatrix"),R.setOptional(Pt,s,"bindMatrixInverse");const t=s.skeleton;t&&(null===t.boneTexture&&t.computeBoneTexture(),R.setValue(Pt,"boneTexture",t.boneTexture,nt))}s.isBatchedMesh&&(R.setOptional(Pt,s,"batchingTexture"),R.setValue(Pt,"batchingTexture",s._matricesTexture,nt),R.setOptional(Pt,s,"batchingIdTexture"),R.setValue(Pt,"batchingIdTexture",s._indirectTexture,nt),R.setOptional(Pt,s,"batchingColorTexture"),null!==s._colorsTexture&&R.setValue(Pt,"batchingColorTexture",s._colorsTexture,nt));const P=i.morphAttributes;void 0===P.position&&void 0===P.normal&&void 0===P.color||wt.update(s,i,S);(E||v.receiveShadow!==s.receiveShadow)&&(v.receiveShadow=s.receiveShadow,R.setValue(Pt,"receiveShadow",s.receiveShadow));n.isMeshGouraudMaterial&&null!==n.envMap&&(N.envMap.value=l,N.flipEnvMap.value=l.isCubeTexture&&!1===l.isRenderTargetTexture?-1:1);n.isMeshStandardMaterial&&null===n.envMap&&null!==e.environment&&(N.envMapIntensity.value=e.environmentIntensity);E&&(R.setValue(Pt,"toneMappingExposure",y.toneMappingExposure),v.needsLights&&(U=C,(I=N).ambientLightColor.needsUpdate=U,I.lightProbe.needsUpdate=U,I.directionalLights.needsUpdate=U,I.directionalLightShadows.needsUpdate=U,I.pointLights.needsUpdate=U,I.pointLightShadows.needsUpdate=U,I.spotLights.needsUpdate=U,I.spotLightShadows.needsUpdate=U,I.rectAreaLights.needsUpdate=U,I.hemisphereLights.needsUpdate=U),r&&!0===n.fog&&gt.refreshFogUniforms(N,r),gt.refreshMaterialUniforms(N,n,D,L,x.state.transmissionRenderTarget[t.id]),wa.upload(Pt,Zt(v),N,nt));var I,U;n.isShaderMaterial&&!0===n.uniformsNeedUpdate&&(wa.upload(Pt,Zt(v),N,nt),n.uniformsNeedUpdate=!1);n.isSpriteMaterial&&R.setValue(Pt,"center",s.center);if(R.setValue(Pt,"modelViewMatrix",s.modelViewMatrix),R.setValue(Pt,"normalMatrix",s.normalMatrix),R.setValue(Pt,"modelMatrix",s.matrixWorld),n.isShaderMaterial||n.isRawShaderMaterial){const t=n.uniformsGroups;for(let e=0,i=t.length;e<i;e++){const i=t[e];Nt.update(i,S),Nt.bind(i,S)}}return S}(t,e,i,n,s);J.setMaterial(n,a);let l=i.index,h=1;if(!0===n.wireframe){if(l=pt.getWireframeAttribute(i),void 0===l)return;h=2}const c=i.drawRange,u=i.attributes.position;let d=c.start*h,p=(c.start+c.count)*h;null!==r&&(d=Math.max(d,r.start*h),p=Math.min(p,(r.start+r.count)*h)),null!==l?(d=Math.max(d,0),p=Math.min(p,l.count)):null!=u&&(d=Math.max(d,0),p=Math.min(p,u.count));const m=p-d;if(m<0||m===1/0)return;let f;Rt.setup(s,n,o,i,l);let g=At;if(null!==l&&(f=lt.get(l),g=Et,g.setIndex(f)),s.isMesh)!0===n.wireframe?(J.setLineWidth(n.wireframeLinewidth*Y()),g.setMode(Pt.LINES)):g.setMode(Pt.TRIANGLES);else if(s.isLine){let t=n.linewidth;void 0===t&&(t=1),J.setLineWidth(t*Y()),s.isLineSegments?g.setMode(Pt.LINES):s.isLineLoop?g.setMode(Pt.LINE_LOOP):g.setMode(Pt.LINE_STRIP)}else s.isPoints?g.setMode(Pt.POINTS):s.isSprite&&g.setMode(Pt.TRIANGLES);if(s.isBatchedMesh)if(null!==s._multiDrawInstances)g.renderMultiDrawInstances(s._multiDrawStarts,s._multiDrawCounts,s._multiDrawCount,s._multiDrawInstances);else if(Z.get("WEBGL_multi_draw"))g.renderMultiDraw(s._multiDrawStarts,s._multiDrawCounts,s._multiDrawCount);else{const t=s._multiDrawStarts,e=s._multiDrawCounts,i=s._multiDrawCount,r=l?lt.get(l).bytesPerElement:1,a=tt.get(n).currentProgram.getUniforms();for(let n=0;n<i;n++)a.setValue(Pt,"_gl_DrawID",n),g.render(t[n]/r,e[n])}else if(s.isInstancedMesh)g.renderInstances(d,m,s.count);else if(i.isInstancedBufferGeometry){const t=void 0!==i._maxInstanceCount?i._maxInstanceCount:1/0,e=Math.min(i.instanceCount,t);g.renderInstances(d,m,e)}else g.render(d,m)},this.compile=function(t,e,i=null){null===i&&(i=t),x=bt.get(i),x.init(e),_.push(x),i.traverseVisible((function(t){t.isLight&&t.layers.test(e.layers)&&(x.pushLight(t),t.castShadow&&x.pushShadow(t))})),t!==i&&t.traverseVisible((function(t){t.isLight&&t.layers.test(e.layers)&&(x.pushLight(t),t.castShadow&&x.pushShadow(t))})),x.setupLights();const n=new Set;return t.traverse((function(t){if(!(t.isMesh||t.isPoints||t.isLine||t.isSprite))return;const e=t.material;if(e)if(Array.isArray(e))for(let s=0;s<e.length;s++){const r=e[s];zt(r,i,t),n.add(r)}else zt(e,i,t),n.add(e)})),_.pop(),x=null,n},this.compileAsync=function(t,e,i=null){const n=this.compile(t,e,i);return new Promise((e=>{function i(){n.forEach((function(t){tt.get(t).currentProgram.isReady()&&n.delete(t)})),0!==n.size?setTimeout(i,10):e(t)}null!==Z.get("KHR_parallel_shader_compile")?i():setTimeout(i,10)}))};let kt=null;function Vt(){Ht.stop()}function Gt(){Ht.start()}const Ht=new Ds;function Wt(t,e,i,n){if(!1===t.visible)return;if(t.layers.test(e.layers))if(t.isGroup)i=t.renderOrder;else if(t.isLOD)!0===t.autoUpdate&&t.update(e);else if(t.isLight)x.pushLight(t),t.castShadow&&x.pushShadow(t);else if(t.isSprite){if(!t.frustumCulled||k.intersectsSprite(t)){n&&X.setFromMatrixPosition(t.matrixWorld).applyMatrix4(W);const e=mt.update(t),s=t.material;s.visible&&g.push(t,e,s,i,X.z,null)}}else if((t.isMesh||t.isLine||t.isPoints)&&(!t.frustumCulled||k.intersectsObject(t))){const e=mt.update(t),s=t.material;if(n&&(void 0!==t.boundingSphere?(null===t.boundingSphere&&t.computeBoundingSphere(),X.copy(t.boundingSphere.center)):(null===e.boundingSphere&&e.computeBoundingSphere(),X.copy(e.boundingSphere.center)),X.applyMatrix4(t.matrixWorld).applyMatrix4(W)),Array.isArray(s)){const n=e.groups;for(let r=0,a=n.length;r<a;r++){const a=n[r],o=s[a.materialIndex];o&&o.visible&&g.push(t,e,o,i,X.z,a)}}else s.visible&&g.push(t,e,s,i,X.z,null)}const s=t.children;for(let r=0,a=s.length;r<a;r++)Wt(s[r],e,i,n)}function jt(t,e,i,n){const s=t.opaque,r=t.transmissive,a=t.transparent;x.setupLightsView(i),!0===V&&St.setGlobalState(y.clippingPlanes,i),n&&J.viewport(E.copy(n)),s.length>0&&qt(s,e,i),r.length>0&&qt(r,e,i),a.length>0&&qt(a,e,i),J.buffers.depth.setTest(!0),J.buffers.depth.setMask(!0),J.buffers.color.setMask(!0),J.setPolygonOffset(!1)}function Xt(t,e,i,n){if(null!==(!0===i.isScene?i.overrideMaterial:null))return;void 0===x.state.transmissionRenderTarget[n.id]&&(x.state.transmissionRenderTarget[n.id]=new oi(1,1,{generateMipmaps:!0,type:Z.has("EXT_color_buffer_half_float")||Z.has("EXT_color_buffer_float")?ht:it,minFilter:et,samples:4,stencilBuffer:r,resolveDepthBuffer:!1,resolveStencilBuffer:!1,colorSpace:We.workingColorSpace}));const s=x.state.transmissionRenderTarget[n.id],a=n.viewport||E;s.setSize(a.z,a.w);const o=y.getRenderTarget();y.setRenderTarget(s),y.getClearColor(N),P=y.getClearAlpha(),P<1&&y.setClearColor(16777215,.5),y.clear(),$&&Tt.render(i);const l=y.toneMapping;y.toneMapping=0;const h=n.viewport;if(void 0!==n.viewport&&(n.viewport=void 0),x.setupLightsView(n),!0===V&&St.setGlobalState(y.clippingPlanes,n),qt(t,i,n),nt.updateMultisampleRenderTarget(s),nt.updateRenderTargetMipmap(s),!1===Z.has("WEBGL_multisampled_render_to_texture")){let t=!1;for(let s=0,r=e.length;s<r;s++){const r=e[s],a=r.object,o=r.geometry,l=r.material,h=r.group;if(2===l.side&&a.layers.test(n.layers)){const e=l.side;l.side=1,l.needsUpdate=!0,$t(a,i,n,o,l,h),l.side=e,l.needsUpdate=!0,t=!0}}!0===t&&(nt.updateMultisampleRenderTarget(s),nt.updateRenderTargetMipmap(s))}y.setRenderTarget(o),y.setClearColor(N,P),void 0!==h&&(n.viewport=h),y.toneMapping=l}function qt(t,e,i){const n=!0===e.isScene?e.overrideMaterial:null;for(let s=0,r=t.length;s<r;s++){const r=t[s],a=r.object,o=r.geometry,l=null===n?r.material:n,h=r.group;a.layers.test(i.layers)&&$t(a,e,i,o,l,h)}}function $t(t,e,i,n,s,r){t.onBeforeRender(y,e,i,n,s,r),t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse,t.matrixWorld),t.normalMatrix.getNormalMatrix(t.modelViewMatrix),s.onBeforeRender(y,e,i,n,t,r),!0===s.transparent&&2===s.side&&!1===s.forceSinglePass?(s.side=1,s.needsUpdate=!0,y.renderBufferDirect(i,e,n,s,t,r),s.side=0,s.needsUpdate=!0,y.renderBufferDirect(i,e,n,s,t,r),s.side=2):y.renderBufferDirect(i,e,n,s,t,r),t.onAfterRender(y,e,i,n,s,r)}function Yt(t,e,i){!0!==e.isScene&&(e=q);const n=tt.get(t),s=x.state.lights,r=x.state.shadowsArray,a=s.state.version,o=ft.getParameters(t,s.state,r,e,i),l=ft.getProgramCacheKey(o);let h=n.programs;n.environment=t.isMeshStandardMaterial?e.environment:null,n.fog=e.fog,n.envMap=(t.isMeshStandardMaterial?at:st).get(t.envMap||n.environment),n.envMapRotation=null!==n.environment&&null===t.envMap?e.environmentRotation:t.envMapRotation,void 0===h&&(t.addEventListener("dispose",Ot),h=new Map,n.programs=h);let c=h.get(l);if(void 0!==c){if(n.currentProgram===c&&n.lightsStateVersion===a)return Kt(t,o),c}else o.uniforms=ft.getUniforms(t),t.onBeforeCompile(o,y),c=ft.acquireProgram(o,l),h.set(l,c),n.uniforms=o.uniforms;const u=n.uniforms;return(t.isShaderMaterial||t.isRawShaderMaterial)&&!0!==t.clipping||(u.clippingPlanes=St.uniform),Kt(t,o),n.needsLights=function(t){return t.isMeshLambertMaterial||t.isMeshToonMaterial||t.isMeshPhongMaterial||t.isMeshStandardMaterial||t.isShadowMaterial||t.isShaderMaterial&&!0===t.lights}(t),n.lightsStateVersion=a,n.needsLights&&(u.ambientLightColor.value=s.state.ambient,u.lightProbe.value=s.state.probe,u.directionalLights.value=s.state.directional,u.directionalLightShadows.value=s.state.directionalShadow,u.spotLights.value=s.state.spot,u.spotLightShadows.value=s.state.spotShadow,u.rectAreaLights.value=s.state.rectArea,u.ltc_1.value=s.state.rectAreaLTC1,u.ltc_2.value=s.state.rectAreaLTC2,u.pointLights.value=s.state.point,u.pointLightShadows.value=s.state.pointShadow,u.hemisphereLights.value=s.state.hemi,u.directionalShadowMap.value=s.state.directionalShadowMap,u.directionalShadowMatrix.value=s.state.directionalShadowMatrix,u.spotShadowMap.value=s.state.spotShadowMap,u.spotLightMatrix.value=s.state.spotLightMatrix,u.spotLightMap.value=s.state.spotLightMap,u.pointShadowMap.value=s.state.pointShadowMap,u.pointShadowMatrix.value=s.state.pointShadowMatrix),n.currentProgram=c,n.uniformsList=null,c}function Zt(t){if(null===t.uniformsList){const e=t.currentProgram.getUniforms();t.uniformsList=wa.seqWithValue(e.seq,t.uniforms)}return t.uniformsList}function Kt(t,e){const i=tt.get(t);i.outputColorSpace=e.outputColorSpace,i.batching=e.batching,i.batchingColor=e.batchingColor,i.instancing=e.instancing,i.instancingColor=e.instancingColor,i.instancingMorph=e.instancingMorph,i.skinning=e.skinning,i.morphTargets=e.morphTargets,i.morphNormals=e.morphNormals,i.morphColors=e.morphColors,i.morphTargetsCount=e.morphTargetsCount,i.numClippingPlanes=e.numClippingPlanes,i.numIntersection=e.numClipIntersection,i.vertexAlphas=e.vertexAlphas,i.vertexTangents=e.vertexTangents,i.toneMapping=e.toneMapping}Ht.setAnimationLoop((function(t){kt&&kt(t)})),"undefined"!=typeof self&&Ht.setContext(self),this.setAnimationLoop=function(t){kt=t,Dt.setAnimationLoop(t),null===t?Ht.stop():Ht.start()},Dt.addEventListener("sessionstart",Vt),Dt.addEventListener("sessionend",Gt),this.render=function(t,e){if(void 0!==e&&!0!==e.isCamera)return;if(!0===b)return;if(!0===t.matrixWorldAutoUpdate&&t.updateMatrixWorld(),null===e.parent&&!0===e.matrixWorldAutoUpdate&&e.updateMatrixWorld(),!0===Dt.enabled&&!0===Dt.isPresenting&&(!0===Dt.cameraAutoUpdate&&Dt.updateCamera(e),e=Dt.getCamera()),!0===t.isScene&&t.onBeforeRender(y,t,e,T),x=bt.get(t,_.length),x.init(e),_.push(x),W.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),k.setFromProjectionMatrix(W),G=this.localClippingEnabled,V=St.init(this.clippingPlanes,G),g=xt.get(t,v.length),g.init(),v.push(g),!0===Dt.enabled&&!0===Dt.isPresenting){const t=y.xr.getDepthSensingMesh();null!==t&&Wt(t,e,-1/0,y.sortObjects)}Wt(t,e,0,y.sortObjects),g.finish(),!0===y.sortObjects&&g.sort(U,F),$=!1===Dt.enabled||!1===Dt.isPresenting||!1===Dt.hasDepthSensing(),$&&Tt.addToRenderList(g,t),this.info.render.frame++,!0===V&&St.beginShadows();const i=x.state.shadowsArray;Mt.render(i,t,e),!0===V&&St.endShadows(),!0===this.info.autoReset&&this.info.reset();const n=g.opaque,s=g.transmissive;if(x.setupLights(),e.isArrayCamera){const i=e.cameras;if(s.length>0)for(let e=0,r=i.length;e<r;e++){Xt(n,s,t,i[e])}$&&Tt.render(t);for(let e=0,n=i.length;e<n;e++){const n=i[e];jt(g,t,n,n.viewport)}}else s.length>0&&Xt(n,s,t,e),$&&Tt.render(t),jt(g,t,e);null!==T&&(nt.updateMultisampleRenderTarget(T),nt.updateRenderTargetMipmap(T)),!0===t.isScene&&t.onAfterRender(y,t,e),Rt.resetDefaultState(),w=-1,A=null,_.pop(),_.length>0?(x=_[_.length-1],!0===V&&St.setGlobalState(y.clippingPlanes,x.state.camera)):x=null,v.pop(),g=v.length>0?v[v.length-1]:null},this.getActiveCubeFace=function(){return S},this.getActiveMipmapLevel=function(){return M},this.getRenderTarget=function(){return T},this.setRenderTargetTextures=function(t,e,i){tt.get(t.texture).__webglTexture=e,tt.get(t.depthTexture).__webglTexture=i;const n=tt.get(t);n.__hasExternalTextures=!0,n.__autoAllocateDepthBuffer=void 0===i,n.__autoAllocateDepthBuffer||!0===Z.has("WEBGL_multisampled_render_to_texture")&&(n.__useRenderToTexture=!1)},this.setRenderTargetFramebuffer=function(t,e){const i=tt.get(t);i.__webglFramebuffer=e,i.__useDefaultFramebuffer=void 0===e},this.setRenderTarget=function(t,e=0,i=0){T=t,S=e,M=i;let n=!0,s=null,r=!1,a=!1;if(t){const o=tt.get(t);if(void 0!==o.__useDefaultFramebuffer)J.bindFramebuffer(Pt.FRAMEBUFFER,null),n=!1;else if(void 0===o.__webglFramebuffer)nt.setupRenderTarget(t);else if(o.__hasExternalTextures)nt.rebindTextures(t,tt.get(t.texture).__webglTexture,tt.get(t.depthTexture).__webglTexture);else if(t.depthBuffer){const e=t.depthTexture;if(o.__boundDepthTexture!==e){if(null!==e&&tt.has(e)&&(t.width!==e.image.width||t.height!==e.image.height))throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");nt.setupDepthRenderbuffer(t)}}const l=t.texture;(l.isData3DTexture||l.isDataArrayTexture||l.isCompressedArrayTexture)&&(a=!0);const h=tt.get(t).__webglFramebuffer;t.isWebGLCubeRenderTarget?(s=Array.isArray(h[e])?h[e][i]:h[e],r=!0):s=t.samples>0&&!1===nt.useMultisampledRTT(t)?tt.get(t).__webglMultisampledFramebuffer:Array.isArray(h)?h[i]:h,E.copy(t.viewport),C.copy(t.scissor),R=t.scissorTest}else E.copy(B).multiplyScalar(D).floor(),C.copy(O).multiplyScalar(D).floor(),R=z;if(J.bindFramebuffer(Pt.FRAMEBUFFER,s)&&n&&J.drawBuffers(t,s),J.viewport(E),J.scissor(C),J.setScissorTest(R),r){const n=tt.get(t.texture);Pt.framebufferTexture2D(Pt.FRAMEBUFFER,Pt.COLOR_ATTACHMENT0,Pt.TEXTURE_CUBE_MAP_POSITIVE_X+e,n.__webglTexture,i)}else if(a){const n=tt.get(t.texture),s=e||0;Pt.framebufferTextureLayer(Pt.FRAMEBUFFER,Pt.COLOR_ATTACHMENT0,n.__webglTexture,i||0,s)}w=-1},this.readRenderTargetPixels=function(t,e,i,n,s,r,a){if(!t||!t.isWebGLRenderTarget)return;let o=tt.get(t).__webglFramebuffer;if(t.isWebGLCubeRenderTarget&&void 0!==a&&(o=o[a]),o){J.bindFramebuffer(Pt.FRAMEBUFFER,o);try{const a=t.texture,o=a.format,l=a.type;if(!K.textureFormatReadable(o))return;if(!K.textureTypeReadable(l))return;e>=0&&e<=t.width-n&&i>=0&&i<=t.height-s&&Pt.readPixels(e,i,n,s,Ct.convert(o),Ct.convert(l),r)}finally{const t=null!==T?tt.get(T).__webglFramebuffer:null;J.bindFramebuffer(Pt.FRAMEBUFFER,t)}}},this.readRenderTargetPixelsAsync=async function(t,e,i,n,s,r,a){if(!t||!t.isWebGLRenderTarget)throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let o=tt.get(t).__webglFramebuffer;if(t.isWebGLCubeRenderTarget&&void 0!==a&&(o=o[a]),o){const a=t.texture,l=a.format,h=a.type;if(!K.textureFormatReadable(l))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");if(!K.textureTypeReadable(h))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");if(e>=0&&e<=t.width-n&&i>=0&&i<=t.height-s){J.bindFramebuffer(Pt.FRAMEBUFFER,o);const t=Pt.createBuffer();Pt.bindBuffer(Pt.PIXEL_PACK_BUFFER,t),Pt.bufferData(Pt.PIXEL_PACK_BUFFER,r.byteLength,Pt.STREAM_READ),Pt.readPixels(e,i,n,s,Ct.convert(l),Ct.convert(h),0);const a=null!==T?tt.get(T).__webglFramebuffer:null;J.bindFramebuffer(Pt.FRAMEBUFFER,a);const c=Pt.fenceSync(Pt.SYNC_GPU_COMMANDS_COMPLETE,0);return Pt.flush(),await function(t,e,i){return new Promise((function(n,s){setTimeout((function r(){switch(t.clientWaitSync(e,t.SYNC_FLUSH_COMMANDS_BIT,0)){case t.WAIT_FAILED:s();break;case t.TIMEOUT_EXPIRED:setTimeout(r,i);break;default:n()}}),i)}))}(Pt,c,4),Pt.bindBuffer(Pt.PIXEL_PACK_BUFFER,t),Pt.getBufferSubData(Pt.PIXEL_PACK_BUFFER,0,r),Pt.deleteBuffer(t),Pt.deleteSync(c),r}throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")}},this.copyFramebufferToTexture=function(t,e=null,i=0){!0!==t.isTexture&&(He("WebGLRenderer: copyFramebufferToTexture function signature has changed."),e=arguments[0]||null,t=arguments[1]);const n=Math.pow(2,-i),s=Math.floor(t.image.width*n),r=Math.floor(t.image.height*n),a=null!==e?e.x:0,o=null!==e?e.y:0;nt.setTexture2D(t,0),Pt.copyTexSubImage2D(Pt.TEXTURE_2D,i,0,0,a,o,s,r),J.unbindTexture()},this.copyTextureToTexture=function(t,e,i=null,n=null,s=0){let r,a,o,l,h,c,u,d,p;!0!==t.isTexture&&(He("WebGLRenderer: copyTextureToTexture function signature has changed."),n=arguments[0]||null,t=arguments[1],e=arguments[2],s=arguments[3]||0,i=null);const m=t.isCompressedTexture?t.mipmaps[s]:t.image;null!==i?(r=i.max.x-i.min.x,a=i.max.y-i.min.y,o=i.isBox3?i.max.z-i.min.z:1,l=i.min.x,h=i.min.y,c=i.isBox3?i.min.z:0):(r=m.width,a=m.height,o=m.depth||1,l=0,h=0,c=0),null!==n?(u=n.x,d=n.y,p=n.z):(u=0,d=0,p=0);const f=Ct.convert(e.format),g=Ct.convert(e.type);let x;e.isData3DTexture?(nt.setTexture3D(e,0),x=Pt.TEXTURE_3D):e.isDataArrayTexture||e.isCompressedArrayTexture?(nt.setTexture2DArray(e,0),x=Pt.TEXTURE_2D_ARRAY):(nt.setTexture2D(e,0),x=Pt.TEXTURE_2D),Pt.pixelStorei(Pt.UNPACK_FLIP_Y_WEBGL,e.flipY),Pt.pixelStorei(Pt.UNPACK_PREMULTIPLY_ALPHA_WEBGL,e.premultiplyAlpha),Pt.pixelStorei(Pt.UNPACK_ALIGNMENT,e.unpackAlignment);const v=Pt.getParameter(Pt.UNPACK_ROW_LENGTH),_=Pt.getParameter(Pt.UNPACK_IMAGE_HEIGHT),y=Pt.getParameter(Pt.UNPACK_SKIP_PIXELS),b=Pt.getParameter(Pt.UNPACK_SKIP_ROWS),S=Pt.getParameter(Pt.UNPACK_SKIP_IMAGES);Pt.pixelStorei(Pt.UNPACK_ROW_LENGTH,m.width),Pt.pixelStorei(Pt.UNPACK_IMAGE_HEIGHT,m.height),Pt.pixelStorei(Pt.UNPACK_SKIP_PIXELS,l),Pt.pixelStorei(Pt.UNPACK_SKIP_ROWS,h),Pt.pixelStorei(Pt.UNPACK_SKIP_IMAGES,c);const M=t.isDataArrayTexture||t.isData3DTexture,T=e.isDataArrayTexture||e.isData3DTexture;if(t.isRenderTargetTexture||t.isDepthTexture){const i=tt.get(t),n=tt.get(e),m=tt.get(i.__renderTarget),f=tt.get(n.__renderTarget);J.bindFramebuffer(Pt.READ_FRAMEBUFFER,m.__webglFramebuffer),J.bindFramebuffer(Pt.DRAW_FRAMEBUFFER,f.__webglFramebuffer);for(let g=0;g<o;g++)M&&Pt.framebufferTextureLayer(Pt.READ_FRAMEBUFFER,Pt.COLOR_ATTACHMENT0,tt.get(t).__webglTexture,s,c+g),t.isDepthTexture?(T&&Pt.framebufferTextureLayer(Pt.DRAW_FRAMEBUFFER,Pt.COLOR_ATTACHMENT0,tt.get(e).__webglTexture,s,p+g),Pt.blitFramebuffer(l,h,r,a,u,d,r,a,Pt.DEPTH_BUFFER_BIT,Pt.NEAREST)):T?Pt.copyTexSubImage3D(x,s,u,d,p+g,l,h,r,a):Pt.copyTexSubImage2D(x,s,u,d,p+g,l,h,r,a);J.bindFramebuffer(Pt.READ_FRAMEBUFFER,null),J.bindFramebuffer(Pt.DRAW_FRAMEBUFFER,null)}else T?t.isDataTexture||t.isData3DTexture?Pt.texSubImage3D(x,s,u,d,p,r,a,o,f,g,m.data):e.isCompressedArrayTexture?Pt.compressedTexSubImage3D(x,s,u,d,p,r,a,o,f,m.data):Pt.texSubImage3D(x,s,u,d,p,r,a,o,f,g,m):t.isDataTexture?Pt.texSubImage2D(Pt.TEXTURE_2D,s,u,d,r,a,f,g,m.data):t.isCompressedTexture?Pt.compressedTexSubImage2D(Pt.TEXTURE_2D,s,u,d,m.width,m.height,f,m.data):Pt.texSubImage2D(Pt.TEXTURE_2D,s,u,d,r,a,f,g,m);Pt.pixelStorei(Pt.UNPACK_ROW_LENGTH,v),Pt.pixelStorei(Pt.UNPACK_IMAGE_HEIGHT,_),Pt.pixelStorei(Pt.UNPACK_SKIP_PIXELS,y),Pt.pixelStorei(Pt.UNPACK_SKIP_ROWS,b),Pt.pixelStorei(Pt.UNPACK_SKIP_IMAGES,S),0===s&&e.generateMipmaps&&Pt.generateMipmap(x),J.unbindTexture()},this.copyTextureToTexture3D=function(t,e,i=null,n=null,s=0){return!0!==t.isTexture&&(He("WebGLRenderer: copyTextureToTexture3D function signature has changed."),i=arguments[0]||null,n=arguments[1]||null,t=arguments[2],e=arguments[3],s=arguments[4]||0),He('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'),this.copyTextureToTexture(t,e,i,n,s)},this.initRenderTarget=function(t){void 0===tt.get(t).__webglFramebuffer&&nt.setupRenderTarget(t)},this.initTexture=function(t){t.isCubeTexture?nt.setTextureCube(t,0):t.isData3DTexture?nt.setTexture3D(t,0):t.isDataArrayTexture||t.isCompressedArrayTexture?nt.setTexture2DArray(t,0):nt.setTexture2D(t,0),J.unbindTexture()},this.resetState=function(){S=0,M=0,T=null,J.reset(),Rt.reset()},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return Se}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(t){this._outputColorSpace=t;const e=this.getContext();e.drawingBufferColorspace=We._getDrawingBufferColorSpace(t),e.unpackColorSpace=We._getUnpackColorSpace()}}class Eo{constructor(t,e=1,i=1e3){this.isFog=!0,this.name="",this.color=new Dn(t),this.near=e,this.far=i}clone(){return new Eo(this.color,this.near,this.far)}toJSON(){return{type:"Fog",name:this.name,color:this.color.getHex(),near:this.near,far:this.far}}}let Co=class extends fn{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new Ki,this.environmentIntensity=1,this.environmentRotation=new Ki,this.overrideMaterial=null,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),null!==t.background&&(this.background=t.background.clone()),null!==t.environment&&(this.environment=t.environment.clone()),null!==t.fog&&(this.fog=t.fog.clone()),this.backgroundBlurriness=t.backgroundBlurriness,this.backgroundIntensity=t.backgroundIntensity,this.backgroundRotation.copy(t.backgroundRotation),this.environmentIntensity=t.environmentIntensity,this.environmentRotation.copy(t.environmentRotation),null!==t.overrideMaterial&&(this.overrideMaterial=t.overrideMaterial.clone()),this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return null!==this.fog&&(e.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(e.object.backgroundBlurriness=this.backgroundBlurriness),1!==this.backgroundIntensity&&(e.object.backgroundIntensity=this.backgroundIntensity),e.object.backgroundRotation=this.backgroundRotation.toArray(),1!==this.environmentIntensity&&(e.object.environmentIntensity=this.environmentIntensity),e.object.environmentRotation=this.environmentRotation.toArray(),e}},Ro=class{constructor(t,e){this.isInterleavedBuffer=!0,this.array=t,this.stride=e,this.count=void 0!==t?t.length/e:0,this.usage=ye,this.updateRanges=[],this.version=0,this.uuid=Re()}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,i){t*=this.stride,i*=e.stride;for(let n=0,s=this.stride;n<s;n++)this.array[t+n]=e.array[i+n];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=Re()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),i=new this.constructor(e,this.stride);return i.setUsage(this.usage),i}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=Re()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}};const No=new ui;let Po,Io=class t{constructor(t,e,i,n=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=t,this.itemSize=e,this.offset=i,this.normalized=n}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,i=this.data.count;e<i;e++)No.fromBufferAttribute(this,e),No.applyMatrix4(t),this.setXYZ(e,No.x,No.y,No.z);return this}applyNormalMatrix(t){for(let e=0,i=this.count;e<i;e++)No.fromBufferAttribute(this,e),No.applyNormalMatrix(t),this.setXYZ(e,No.x,No.y,No.z);return this}transformDirection(t){for(let e=0,i=this.count;e<i;e++)No.fromBufferAttribute(this,e),No.transformDirection(t),this.setXYZ(e,No.x,No.y,No.z);return this}getComponent(t,e){let i=this.array[t*this.data.stride+this.offset+e];return this.normalized&&(i=Le(i,this.array)),i}setComponent(t,e,i){return this.normalized&&(i=De(i,this.array)),this.data.array[t*this.data.stride+this.offset+e]=i,this}setX(t,e){return this.normalized&&(e=De(e,this.array)),this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.normalized&&(e=De(e,this.array)),this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.normalized&&(e=De(e,this.array)),this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.normalized&&(e=De(e,this.array)),this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){let e=this.data.array[t*this.data.stride+this.offset];return this.normalized&&(e=Le(e,this.array)),e}getY(t){let e=this.data.array[t*this.data.stride+this.offset+1];return this.normalized&&(e=Le(e,this.array)),e}getZ(t){let e=this.data.array[t*this.data.stride+this.offset+2];return this.normalized&&(e=Le(e,this.array)),e}getW(t){let e=this.data.array[t*this.data.stride+this.offset+3];return this.normalized&&(e=Le(e,this.array)),e}setXY(t,e,i){return t=t*this.data.stride+this.offset,this.normalized&&(e=De(e,this.array),i=De(i,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=i,this}setXYZ(t,e,i,n){return t=t*this.data.stride+this.offset,this.normalized&&(e=De(e,this.array),i=De(i,this.array),n=De(n,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=i,this.data.array[t+2]=n,this}setXYZW(t,e,i,n,s){return t=t*this.data.stride+this.offset,this.normalized&&(e=De(e,this.array),i=De(i,this.array),n=De(n,this.array),s=De(s,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=i,this.data.array[t+2]=n,this.data.array[t+3]=s,this}clone(e){if(void 0===e){const t=[];for(let e=0;e<this.count;e++){const i=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[i+e])}return new Vn(new this.array.constructor(t),this.itemSize,this.normalized)}return void 0===e.interleavedBuffers&&(e.interleavedBuffers={}),void 0===e.interleavedBuffers[this.data.uuid]&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new t(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(void 0===t){const t=[];for(let e=0;e<this.count;e++){const i=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[i+e])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}},Lo=class extends Bn{static get type(){return"SpriteMaterial"}constructor(t){super(),this.isSpriteMaterial=!0,this.color=new Dn(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}};const Do=new ui,Uo=new ui,Fo=new ui,Bo=new Fe,Oo=new Fe,zo=new Vi,ko=new ui,Vo=new ui,Go=new ui,Ho=new Fe,Wo=new Fe,jo=new Fe;class Xo extends fn{constructor(t=new Lo){if(super(),this.isSprite=!0,this.type="Sprite",void 0===Po){Po=new Jn;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),e=new Ro(t,5);Po.setIndex([0,1,2,0,2,3]),Po.setAttribute("position",new Io(e,3,0,!1)),Po.setAttribute("uv",new Io(e,2,3,!1))}this.geometry=Po,this.material=t,this.center=new Fe(.5,.5)}raycast(t,e){t.camera,Uo.setFromMatrixScale(this.matrixWorld),zo.copy(t.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse,this.matrixWorld),Fo.setFromMatrixPosition(this.modelViewMatrix),t.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&Uo.multiplyScalar(-Fo.z);const i=this.material.rotation;let n,s;0!==i&&(s=Math.cos(i),n=Math.sin(i));const r=this.center;qo(ko.set(-.5,-.5,0),Fo,r,Uo,n,s),qo(Vo.set(.5,-.5,0),Fo,r,Uo,n,s),qo(Go.set(.5,.5,0),Fo,r,Uo,n,s),Ho.set(0,0),Wo.set(1,0),jo.set(1,1);let a=t.ray.intersectTriangle(ko,Vo,Go,!1,Do);if(null===a&&(qo(Vo.set(-.5,.5,0),Fo,r,Uo,n,s),Wo.set(0,1),a=t.ray.intersectTriangle(ko,Go,Vo,!1,Do),null===a))return;const o=t.ray.origin.distanceTo(Do);o<t.near||o>t.far||e.push({distance:o,point:Do.clone(),uv:Rn.getInterpolation(Do,ko,Vo,Go,Ho,Wo,jo,new Fe),face:null,object:this})}copy(t,e){return super.copy(t,e),void 0!==t.center&&this.center.copy(t.center),this.material=t.material,this}}function qo(t,e,i,n,s,r){Bo.subVectors(t,i).addScalar(.5).multiply(n),void 0!==s?(Oo.x=r*Bo.x-s*Bo.y,Oo.y=s*Bo.x+r*Bo.y):Oo.copy(Bo),t.copy(e),t.x+=Oo.x,t.y+=Oo.y,t.applyMatrix4(zo)}const $o=new ui,Yo=new ri,Zo=new ri,Ko=new ui,Jo=new Vi,Qo=new ui,tl=new Ii,el=new Vi,il=new ki;class nl extends cs{constructor(t,e){super(t,e),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=G,this.bindMatrix=new Vi,this.bindMatrixInverse=new Vi,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const t=this.geometry;null===this.boundingBox&&(this.boundingBox=new mi),this.boundingBox.makeEmpty();const e=t.getAttribute("position");for(let i=0;i<e.count;i++)this.getVertexPosition(i,Qo),this.boundingBox.expandByPoint(Qo)}computeBoundingSphere(){const t=this.geometry;null===this.boundingSphere&&(this.boundingSphere=new Ii),this.boundingSphere.makeEmpty();const e=t.getAttribute("position");for(let i=0;i<e.count;i++)this.getVertexPosition(i,Qo),this.boundingSphere.expandByPoint(Qo)}copy(t,e){return super.copy(t,e),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,null!==t.boundingBox&&(this.boundingBox=t.boundingBox.clone()),null!==t.boundingSphere&&(this.boundingSphere=t.boundingSphere.clone()),this}raycast(t,e){const i=this.material,n=this.matrixWorld;void 0!==i&&(null===this.boundingSphere&&this.computeBoundingSphere(),tl.copy(this.boundingSphere),tl.applyMatrix4(n),!1!==t.ray.intersectsSphere(tl)&&(el.copy(n).invert(),il.copy(t.ray).applyMatrix4(el),null!==this.boundingBox&&!1===il.intersectsBox(this.boundingBox)||this._computeIntersections(t,e,il)))}getVertexPosition(t,e){return super.getVertexPosition(t,e),this.applyBoneTransform(t,e),e}bind(t,e){this.skeleton=t,void 0===e&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const t=new ri,e=this.geometry.attributes.skinWeight;for(let i=0,n=e.count;i<n;i++){t.fromBufferAttribute(e,i);const n=1/t.manhattanLength();n!==1/0?t.multiplyScalar(n):t.set(1,0,0,0),e.setXYZW(i,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),this.bindMode===G?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode&&this.bindMatrixInverse.copy(this.bindMatrix).invert()}applyBoneTransform(t,e){const i=this.skeleton,n=this.geometry;Yo.fromBufferAttribute(n.attributes.skinIndex,t),Zo.fromBufferAttribute(n.attributes.skinWeight,t),$o.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let s=0;s<4;s++){const t=Zo.getComponent(s);if(0!==t){const n=Yo.getComponent(s);Jo.multiplyMatrices(i.bones[n].matrixWorld,i.boneInverses[n]),e.addScaledVector(Ko.copy($o).applyMatrix4(Jo),t)}}return e.applyMatrix4(this.bindMatrixInverse)}}class sl extends fn{constructor(){super(),this.isBone=!0,this.type="Bone"}}let rl=class extends si{constructor(t=null,e=1,i=1,n,s,r,a,o,l=1003,h=1003,c,u){super(null,r,a,o,l,h,n,s,c,u),this.isDataTexture=!0,this.image={data:t,width:e,height:i},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}};const al=new Vi,ol=new Vi;class ll{constructor(t=[],e=[]){this.uuid=Re(),this.bones=t.slice(0),this.boneInverses=e,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const t=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(16*t.length),0===e.length)this.calculateInverses();else if(t.length!==e.length){this.boneInverses=[];for(let t=0,e=this.bones.length;t<e;t++)this.boneInverses.push(new Vi)}}calculateInverses(){this.boneInverses.length=0;for(let t=0,e=this.bones.length;t<e;t++){const e=new Vi;this.bones[t]&&e.copy(this.bones[t].matrixWorld).invert(),this.boneInverses.push(e)}}pose(){for(let t=0,e=this.bones.length;t<e;t++){const e=this.bones[t];e&&e.matrixWorld.copy(this.boneInverses[t]).invert()}for(let t=0,e=this.bones.length;t<e;t++){const e=this.bones[t];e&&(e.parent&&e.parent.isBone?(e.matrix.copy(e.parent.matrixWorld).invert(),e.matrix.multiply(e.matrixWorld)):e.matrix.copy(e.matrixWorld),e.matrix.decompose(e.position,e.quaternion,e.scale))}}update(){const t=this.bones,e=this.boneInverses,i=this.boneMatrices,n=this.boneTexture;for(let s=0,r=t.length;s<r;s++){const n=t[s]?t[s].matrixWorld:ol;al.multiplyMatrices(n,e[s]),al.toArray(i,16*s)}null!==n&&(n.needsUpdate=!0)}clone(){return new ll(this.bones,this.boneInverses)}computeBoneTexture(){let t=Math.sqrt(4*this.bones.length);t=4*Math.ceil(t/4),t=Math.max(t,4);const e=new Float32Array(t*t*4);e.set(this.boneMatrices);const i=new rl(e,t,t,mt,lt);return i.needsUpdate=!0,this.boneMatrices=e,this.boneTexture=i,this}getBoneByName(t){for(let e=0,i=this.bones.length;e<i;e++){const i=this.bones[e];if(i.name===t)return i}}dispose(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(t,e){this.uuid=t.uuid;for(let i=0,n=t.bones.length;i<n;i++){let n=e[t.bones[i]];void 0===n&&(n=new sl),this.bones.push(n),this.boneInverses.push((new Vi).fromArray(t.boneInverses[i]))}return this.init(),this}toJSON(){const t={metadata:{version:4.6,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};t.uuid=this.uuid;const e=this.bones,i=this.boneInverses;for(let n=0,s=e.length;n<s;n++){const s=e[n];t.bones.push(s.uuid);const r=i[n];t.boneInverses.push(r.toArray())}return t}}let hl=class extends Vn{constructor(t,e,i,n=1){super(t,e,i),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=n}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}};const cl=new Vi,ul=new Vi,dl=[],pl=new mi,ml=new Vi,fl=new cs,gl=new Ii;let xl=class extends cs{constructor(t,e,i){super(t,e),this.isInstancedMesh=!0,this.instanceMatrix=new hl(new Float32Array(16*i),16),this.instanceColor=null,this.morphTexture=null,this.count=i,this.boundingBox=null,this.boundingSphere=null;for(let n=0;n<i;n++)this.setMatrixAt(n,ml)}computeBoundingBox(){const t=this.geometry,e=this.count;null===this.boundingBox&&(this.boundingBox=new mi),null===t.boundingBox&&t.computeBoundingBox(),this.boundingBox.makeEmpty();for(let i=0;i<e;i++)this.getMatrixAt(i,cl),pl.copy(t.boundingBox).applyMatrix4(cl),this.boundingBox.union(pl)}computeBoundingSphere(){const t=this.geometry,e=this.count;null===this.boundingSphere&&(this.boundingSphere=new Ii),null===t.boundingSphere&&t.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let i=0;i<e;i++)this.getMatrixAt(i,cl),gl.copy(t.boundingSphere).applyMatrix4(cl),this.boundingSphere.union(gl)}copy(t,e){return super.copy(t,e),this.instanceMatrix.copy(t.instanceMatrix),null!==t.morphTexture&&(this.morphTexture=t.morphTexture.clone()),null!==t.instanceColor&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,null!==t.boundingBox&&(this.boundingBox=t.boundingBox.clone()),null!==t.boundingSphere&&(this.boundingSphere=t.boundingSphere.clone()),this}getColorAt(t,e){e.fromArray(this.instanceColor.array,3*t)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,16*t)}getMorphAt(t,e){const i=e.morphTargetInfluences,n=this.morphTexture.source.data.data,s=t*(i.length+1)+1;for(let r=0;r<i.length;r++)i[r]=n[s+r]}raycast(t,e){const i=this.matrixWorld,n=this.count;if(fl.geometry=this.geometry,fl.material=this.material,void 0!==fl.material&&(null===this.boundingSphere&&this.computeBoundingSphere(),gl.copy(this.boundingSphere),gl.applyMatrix4(i),!1!==t.ray.intersectsSphere(gl)))for(let s=0;s<n;s++){this.getMatrixAt(s,cl),ul.multiplyMatrices(i,cl),fl.matrixWorld=ul,fl.raycast(t,dl);for(let t=0,i=dl.length;t<i;t++){const i=dl[t];i.instanceId=s,i.object=this,e.push(i)}dl.length=0}}setColorAt(t,e){null===this.instanceColor&&(this.instanceColor=new hl(new Float32Array(3*this.instanceMatrix.count).fill(1),3)),e.toArray(this.instanceColor.array,3*t)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,16*t)}setMorphAt(t,e){const i=e.morphTargetInfluences,n=i.length+1;null===this.morphTexture&&(this.morphTexture=new rl(new Float32Array(n*this.count),n,this.count,xt,lt));const s=this.morphTexture.source.data.data;let r=0;for(let l=0;l<i.length;l++)r+=i[l];const a=this.geometry.morphTargetsRelative?1:1-r,o=n*t;s[o]=a,s.set(i,o+1)}updateMorphTargets(){}dispose(){return this.dispatchEvent({type:"dispose"}),null!==this.morphTexture&&(this.morphTexture.dispose(),this.morphTexture=null),this}},vl=class extends Bn{static get type(){return"LineBasicMaterial"}constructor(t){super(),this.isLineBasicMaterial=!0,this.color=new Dn(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this.fog=t.fog,this}};const _l=new ui,yl=new ui,bl=new Vi,Sl=new ki,Ml=new Ii,Tl=new ui,wl=new ui;let Al=class extends fn{constructor(t=new Jn,e=new vl){super(),this.isLine=!0,this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(null===t.index){const e=t.attributes.position,i=[0];for(let t=1,n=e.count;t<n;t++)_l.fromBufferAttribute(e,t-1),yl.fromBufferAttribute(e,t),i[t]=i[t-1],i[t]+=_l.distanceTo(yl);t.setAttribute("lineDistance",new Wn(i,1))}return this}raycast(t,e){const i=this.geometry,n=this.matrixWorld,s=t.params.Line.threshold,r=i.drawRange;if(null===i.boundingSphere&&i.computeBoundingSphere(),Ml.copy(i.boundingSphere),Ml.applyMatrix4(n),Ml.radius+=s,!1===t.ray.intersectsSphere(Ml))return;bl.copy(n).invert(),Sl.copy(t.ray).applyMatrix4(bl);const a=s/((this.scale.x+this.scale.y+this.scale.z)/3),o=a*a,l=this.isLineSegments?2:1,h=i.index,c=i.attributes.position;if(null!==h){const i=Math.max(0,r.start),n=Math.min(h.count,r.start+r.count);for(let s=i,r=n-1;s<r;s+=l){const i=h.getX(s),n=h.getX(s+1),r=El(this,t,Sl,o,i,n);r&&e.push(r)}if(this.isLineLoop){const s=h.getX(n-1),r=h.getX(i),a=El(this,t,Sl,o,s,r);a&&e.push(a)}}else{const i=Math.max(0,r.start),n=Math.min(c.count,r.start+r.count);for(let s=i,r=n-1;s<r;s+=l){const i=El(this,t,Sl,o,s,s+1);i&&e.push(i)}if(this.isLineLoop){const s=El(this,t,Sl,o,n-1,i);s&&e.push(s)}}}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const i=t[e[0]];if(void 0!==i){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,e=i.length;t<e;t++){const e=i[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[e]=t}}}}};function El(t,e,i,n,s,r){const a=t.geometry.attributes.position;_l.fromBufferAttribute(a,s),yl.fromBufferAttribute(a,r);if(i.distanceSqToSegment(_l,yl,Tl,wl)>n)return;Tl.applyMatrix4(t.matrixWorld);const o=e.ray.origin.distanceTo(Tl);return o<e.near||o>e.far?void 0:{distance:o,point:wl.clone().applyMatrix4(t.matrixWorld),index:s,face:null,faceIndex:null,barycoord:null,object:t}}const Cl=new ui,Rl=new ui;let Nl=class extends Al{constructor(t,e){super(t,e),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(null===t.index){const e=t.attributes.position,i=[];for(let t=0,n=e.count;t<n;t+=2)Cl.fromBufferAttribute(e,t),Rl.fromBufferAttribute(e,t+1),i[t]=0===t?0:i[t-1],i[t+1]=i[t]+Cl.distanceTo(Rl);t.setAttribute("lineDistance",new Wn(i,1))}return this}};class Pl extends Al{constructor(t,e){super(t,e),this.isLineLoop=!0,this.type="LineLoop"}}let Il=class extends Bn{static get type(){return"PointsMaterial"}constructor(t){super(),this.isPointsMaterial=!0,this.color=new Dn(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}};const Ll=new Vi,Dl=new ki,Ul=new Ii,Fl=new ui;class Bl extends fn{constructor(t=new Jn,e=new Il){super(),this.isPoints=!0,this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}raycast(t,e){const i=this.geometry,n=this.matrixWorld,s=t.params.Points.threshold,r=i.drawRange;if(null===i.boundingSphere&&i.computeBoundingSphere(),Ul.copy(i.boundingSphere),Ul.applyMatrix4(n),Ul.radius+=s,!1===t.ray.intersectsSphere(Ul))return;Ll.copy(n).invert(),Dl.copy(t.ray).applyMatrix4(Ll);const a=s/((this.scale.x+this.scale.y+this.scale.z)/3),o=a*a,l=i.index,h=i.attributes.position;if(null!==l){for(let i=Math.max(0,r.start),s=Math.min(l.count,r.start+r.count);i<s;i++){const s=l.getX(i);Fl.fromBufferAttribute(h,s),Ol(Fl,s,o,n,t,e,this)}}else{for(let i=Math.max(0,r.start),s=Math.min(h.count,r.start+r.count);i<s;i++)Fl.fromBufferAttribute(h,i),Ol(Fl,i,o,n,t,e,this)}}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const i=t[e[0]];if(void 0!==i){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,e=i.length;t<e;t++){const e=i[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[e]=t}}}}}function Ol(t,e,i,n,s,r,a){const o=Dl.distanceSqToPoint(t);if(o<i){const i=new ui;Dl.closestPointToPoint(t,i),i.applyMatrix4(n);const l=s.ray.origin.distanceTo(i);if(l<s.near||l>s.far)return;r.push({distance:l,distanceToRay:Math.sqrt(o),point:i,index:e,face:null,faceIndex:null,barycoord:null,object:a})}}let zl=class extends si{constructor(t,e,i,n,s,r,a,o,l){super(t,e,i,n,s,r,a,o,l),this.isVideoTexture=!0,this.minFilter=void 0!==r?r:Q,this.magFilter=void 0!==s?s:Q,this.generateMipmaps=!1;const h=this;"requestVideoFrameCallback"in t&&t.requestVideoFrameCallback((function e(){h.needsUpdate=!0,t.requestVideoFrameCallback(e)}))}clone(){return new this.constructor(this.image).copy(this)}update(){const t=this.image;!1==="requestVideoFrameCallback"in t&&t.readyState>=t.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}},kl=class extends si{constructor(t,e,i,n,s,r,a,o,l){super(t,e,i,n,s,r,a,o,l),this.isCanvasTexture=!0,this.needsUpdate=!0}};class Vl{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return null}getPointAt(t,e){const i=this.getUtoTmapping(t);return this.getPoint(i,e)}getPoints(t=5){const e=[];for(let i=0;i<=t;i++)e.push(this.getPoint(i/t));return e}getSpacedPoints(t=5){const e=[];for(let i=0;i<=t;i++)e.push(this.getPointAt(i/t));return e}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let i,n=this.getPoint(0),s=0;e.push(0);for(let r=1;r<=t;r++)i=this.getPoint(r/t),s+=i.distanceTo(n),e.push(s),n=i;return this.cacheArcLengths=e,e}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,e){const i=this.getLengths();let n=0;const s=i.length;let r;r=e||t*i[s-1];let a,o=0,l=s-1;for(;o<=l;)if(n=Math.floor(o+(l-o)/2),a=i[n]-r,a<0)o=n+1;else{if(!(a>0)){l=n;break}l=n-1}if(n=l,i[n]===r)return n/(s-1);const h=i[n];return(n+(r-h)/(i[n+1]-h))/(s-1)}getTangent(t,e){const i=1e-4;let n=t-i,s=t+i;n<0&&(n=0),s>1&&(s=1);const r=this.getPoint(n),a=this.getPoint(s),o=e||(r.isVector2?new Fe:new ui);return o.copy(a).sub(r).normalize(),o}getTangentAt(t,e){const i=this.getUtoTmapping(t);return this.getTangent(i,e)}computeFrenetFrames(t,e){const i=new ui,n=[],s=[],r=[],a=new ui,o=new Vi;for(let d=0;d<=t;d++){const e=d/t;n[d]=this.getTangentAt(e,new ui)}s[0]=new ui,r[0]=new ui;let l=Number.MAX_VALUE;const h=Math.abs(n[0].x),c=Math.abs(n[0].y),u=Math.abs(n[0].z);h<=l&&(l=h,i.set(1,0,0)),c<=l&&(l=c,i.set(0,1,0)),u<=l&&i.set(0,0,1),a.crossVectors(n[0],i).normalize(),s[0].crossVectors(n[0],a),r[0].crossVectors(n[0],s[0]);for(let d=1;d<=t;d++){if(s[d]=s[d-1].clone(),r[d]=r[d-1].clone(),a.crossVectors(n[d-1],n[d]),a.length()>Number.EPSILON){a.normalize();const t=Math.acos(Ne(n[d-1].dot(n[d]),-1,1));s[d].applyMatrix4(o.makeRotationAxis(a,t))}r[d].crossVectors(n[d],s[d])}if(!0===e){let e=Math.acos(Ne(s[0].dot(s[t]),-1,1));e/=t,n[0].dot(a.crossVectors(s[0],s[t]))>0&&(e=-e);for(let i=1;i<=t;i++)s[i].applyMatrix4(o.makeRotationAxis(n[i],e*i)),r[i].crossVectors(n[i],s[i])}return{tangents:n,normals:s,binormals:r}}clone(){return(new this.constructor).copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){const t={metadata:{version:4.6,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}class Gl extends Vl{constructor(t=0,e=0,i=1,n=1,s=0,r=2*Math.PI,a=!1,o=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=t,this.aY=e,this.xRadius=i,this.yRadius=n,this.aStartAngle=s,this.aEndAngle=r,this.aClockwise=a,this.aRotation=o}getPoint(t,e=new Fe){const i=e,n=2*Math.PI;let s=this.aEndAngle-this.aStartAngle;const r=Math.abs(s)<Number.EPSILON;for(;s<0;)s+=n;for(;s>n;)s-=n;s<Number.EPSILON&&(s=r?0:n),!0!==this.aClockwise||r||(s===n?s=-n:s-=n);const a=this.aStartAngle+t*s;let o=this.aX+this.xRadius*Math.cos(a),l=this.aY+this.yRadius*Math.sin(a);if(0!==this.aRotation){const t=Math.cos(this.aRotation),e=Math.sin(this.aRotation),i=o-this.aX,n=l-this.aY;o=i*t-n*e+this.aX,l=i*e+n*t+this.aY}return i.set(o,l)}copy(t){return super.copy(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}toJSON(){const t=super.toJSON();return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t}fromJSON(t){return super.fromJSON(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}}function Hl(){let t=0,e=0,i=0,n=0;function s(s,r,a,o){t=s,e=a,i=-3*s+3*r-2*a-o,n=2*s-2*r+a+o}return{initCatmullRom:function(t,e,i,n,r){s(e,i,r*(i-t),r*(n-e))},initNonuniformCatmullRom:function(t,e,i,n,r,a,o){let l=(e-t)/r-(i-t)/(r+a)+(i-e)/a,h=(i-e)/a-(n-e)/(a+o)+(n-i)/o;l*=a,h*=a,s(e,i,l,h)},calc:function(s){const r=s*s;return t+e*s+i*r+n*(r*s)}}}const Wl=new ui,jl=new Hl,Xl=new Hl,ql=new Hl;class $l extends Vl{constructor(t=[],e=!1,i="centripetal",n=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=i,this.tension=n}getPoint(t,e=new ui){const i=e,n=this.points,s=n.length,r=(s-(this.closed?0:1))*t;let a,o,l=Math.floor(r),h=r-l;this.closed?l+=l>0?0:(Math.floor(Math.abs(l)/s)+1)*s:0===h&&l===s-1&&(l=s-2,h=1),this.closed||l>0?a=n[(l-1)%s]:(Wl.subVectors(n[0],n[1]).add(n[0]),a=Wl);const c=n[l%s],u=n[(l+1)%s];if(this.closed||l+2<s?o=n[(l+2)%s]:(Wl.subVectors(n[s-1],n[s-2]).add(n[s-1]),o=Wl),"centripetal"===this.curveType||"chordal"===this.curveType){const t="chordal"===this.curveType?.5:.25;let e=Math.pow(a.distanceToSquared(c),t),i=Math.pow(c.distanceToSquared(u),t),n=Math.pow(u.distanceToSquared(o),t);i<1e-4&&(i=1),e<1e-4&&(e=i),n<1e-4&&(n=i),jl.initNonuniformCatmullRom(a.x,c.x,u.x,o.x,e,i,n),Xl.initNonuniformCatmullRom(a.y,c.y,u.y,o.y,e,i,n),ql.initNonuniformCatmullRom(a.z,c.z,u.z,o.z,e,i,n)}else"catmullrom"===this.curveType&&(jl.initCatmullRom(a.x,c.x,u.x,o.x,this.tension),Xl.initCatmullRom(a.y,c.y,u.y,o.y,this.tension),ql.initCatmullRom(a.z,c.z,u.z,o.z,this.tension));return i.set(jl.calc(h),Xl.calc(h),ql.calc(h)),i}copy(t){super.copy(t),this.points=[];for(let e=0,i=t.points.length;e<i;e++){const i=t.points[e];this.points.push(i.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,i=this.points.length;e<i;e++){const i=this.points[e];t.points.push(i.toArray())}return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,i=t.points.length;e<i;e++){const i=t.points[e];this.points.push((new ui).fromArray(i))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}}function Yl(t,e,i,n,s){const r=.5*(n-e),a=.5*(s-i),o=t*t;return(2*i-2*n+r+a)*(t*o)+(-3*i+3*n-2*r-a)*o+r*t+i}function Zl(t,e,i,n){return function(t,e){const i=1-t;return i*i*e}(t,e)+function(t,e){return 2*(1-t)*t*e}(t,i)+function(t,e){return t*t*e}(t,n)}function Kl(t,e,i,n,s){return function(t,e){const i=1-t;return i*i*i*e}(t,e)+function(t,e){const i=1-t;return 3*i*i*t*e}(t,i)+function(t,e){return 3*(1-t)*t*t*e}(t,n)+function(t,e){return t*t*t*e}(t,s)}class Jl extends Vl{constructor(t=new Fe,e=new Fe,i=new Fe,n=new Fe){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=i,this.v3=n}getPoint(t,e=new Fe){const i=e,n=this.v0,s=this.v1,r=this.v2,a=this.v3;return i.set(Kl(t,n.x,s.x,r.x,a.x),Kl(t,n.y,s.y,r.y,a.y)),i}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}class Ql extends Vl{constructor(t=new Fe,e=new Fe){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=t,this.v2=e}getPoint(t,e=new Fe){const i=e;return 1===t?i.copy(this.v2):(i.copy(this.v2).sub(this.v1),i.multiplyScalar(t).add(this.v1)),i}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e=new Fe){return e.subVectors(this.v2,this.v1).normalize()}getTangentAt(t,e){return this.getTangent(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class th extends Vl{constructor(t=new ui,e=new ui){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=t,this.v2=e}getPoint(t,e=new ui){const i=e;return 1===t?i.copy(this.v2):(i.copy(this.v2).sub(this.v1),i.multiplyScalar(t).add(this.v1)),i}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e=new ui){return e.subVectors(this.v2,this.v1).normalize()}getTangentAt(t,e){return this.getTangent(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class eh extends Vl{constructor(t=new Fe,e=new Fe,i=new Fe){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=i}getPoint(t,e=new Fe){const i=e,n=this.v0,s=this.v1,r=this.v2;return i.set(Zl(t,n.x,s.x,r.x),Zl(t,n.y,s.y,r.y)),i}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class ih extends Vl{constructor(t=new ui,e=new ui,i=new ui){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=i}getPoint(t,e=new ui){const i=e,n=this.v0,s=this.v1,r=this.v2;return i.set(Zl(t,n.x,s.x,r.x),Zl(t,n.y,s.y,r.y),Zl(t,n.z,s.z,r.z)),i}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class nh extends Vl{constructor(t=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=t}getPoint(t,e=new Fe){const i=e,n=this.points,s=(n.length-1)*t,r=Math.floor(s),a=s-r,o=n[0===r?r:r-1],l=n[r],h=n[r>n.length-2?n.length-1:r+1],c=n[r>n.length-3?n.length-1:r+2];return i.set(Yl(a,o.x,l.x,h.x,c.x),Yl(a,o.y,l.y,h.y,c.y)),i}copy(t){super.copy(t),this.points=[];for(let e=0,i=t.points.length;e<i;e++){const i=t.points[e];this.points.push(i.clone())}return this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,i=this.points.length;e<i;e++){const i=this.points[e];t.points.push(i.toArray())}return t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,i=t.points.length;e<i;e++){const i=t.points[e];this.points.push((new Fe).fromArray(i))}return this}}var sh=Object.freeze({__proto__:null,ArcCurve:class extends Gl{constructor(t,e,i,n,s,r){super(t,e,i,i,n,s,r),this.isArcCurve=!0,this.type="ArcCurve"}},CatmullRomCurve3:$l,CubicBezierCurve:Jl,CubicBezierCurve3:class extends Vl{constructor(t=new ui,e=new ui,i=new ui,n=new ui){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=i,this.v3=n}getPoint(t,e=new ui){const i=e,n=this.v0,s=this.v1,r=this.v2,a=this.v3;return i.set(Kl(t,n.x,s.x,r.x,a.x),Kl(t,n.y,s.y,r.y,a.y),Kl(t,n.z,s.z,r.z,a.z)),i}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}},EllipseCurve:Gl,LineCurve:Ql,LineCurve3:th,QuadraticBezierCurve:eh,QuadraticBezierCurve3:ih,SplineCurve:nh});class rh extends Vl{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(t){this.curves.push(t)}closePath(){const t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);if(!t.equals(e)){const i=!0===t.isVector2?"LineCurve":"LineCurve3";this.curves.push(new sh[i](e,t))}return this}getPoint(t,e){const i=t*this.getLength(),n=this.getCurveLengths();let s=0;for(;s<n.length;){if(n[s]>=i){const t=n[s]-i,r=this.curves[s],a=r.getLength(),o=0===a?0:1-t/a;return r.getPointAt(o,e)}s++}return null}getLength(){const t=this.getCurveLengths();return t[t.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const t=[];let e=0;for(let i=0,n=this.curves.length;i<n;i++)e+=this.curves[i].getLength(),t.push(e);return this.cacheLengths=t,t}getSpacedPoints(t=40){const e=[];for(let i=0;i<=t;i++)e.push(this.getPoint(i/t));return this.autoClose&&e.push(e[0]),e}getPoints(t=12){const e=[];let i;for(let n=0,s=this.curves;n<s.length;n++){const r=s[n],a=r.isEllipseCurve?2*t:r.isLineCurve||r.isLineCurve3?1:r.isSplineCurve?t*r.points.length:t,o=r.getPoints(a);for(let t=0;t<o.length;t++){const n=o[t];i&&i.equals(n)||(e.push(n),i=n)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e}copy(t){super.copy(t),this.curves=[];for(let e=0,i=t.curves.length;e<i;e++){const i=t.curves[e];this.curves.push(i.clone())}return this.autoClose=t.autoClose,this}toJSON(){const t=super.toJSON();t.autoClose=this.autoClose,t.curves=[];for(let e=0,i=this.curves.length;e<i;e++){const i=this.curves[e];t.curves.push(i.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.autoClose=t.autoClose,this.curves=[];for(let e=0,i=t.curves.length;e<i;e++){const i=t.curves[e];this.curves.push((new sh[i.type]).fromJSON(i))}return this}}class ah extends rh{constructor(t){super(),this.type="Path",this.currentPoint=new Fe,t&&this.setFromPoints(t)}setFromPoints(t){this.moveTo(t[0].x,t[0].y);for(let e=1,i=t.length;e<i;e++)this.lineTo(t[e].x,t[e].y);return this}moveTo(t,e){return this.currentPoint.set(t,e),this}lineTo(t,e){const i=new Ql(this.currentPoint.clone(),new Fe(t,e));return this.curves.push(i),this.currentPoint.set(t,e),this}quadraticCurveTo(t,e,i,n){const s=new eh(this.currentPoint.clone(),new Fe(t,e),new Fe(i,n));return this.curves.push(s),this.currentPoint.set(i,n),this}bezierCurveTo(t,e,i,n,s,r){const a=new Jl(this.currentPoint.clone(),new Fe(t,e),new Fe(i,n),new Fe(s,r));return this.curves.push(a),this.currentPoint.set(s,r),this}splineThru(t){const e=[this.currentPoint.clone()].concat(t),i=new nh(e);return this.curves.push(i),this.currentPoint.copy(t[t.length-1]),this}arc(t,e,i,n,s,r){const a=this.currentPoint.x,o=this.currentPoint.y;return this.absarc(t+a,e+o,i,n,s,r),this}absarc(t,e,i,n,s,r){return this.absellipse(t,e,i,i,n,s,r),this}ellipse(t,e,i,n,s,r,a,o){const l=this.currentPoint.x,h=this.currentPoint.y;return this.absellipse(t+l,e+h,i,n,s,r,a,o),this}absellipse(t,e,i,n,s,r,a,o){const l=new Gl(t,e,i,n,s,r,a,o);if(this.curves.length>0){const t=l.getPoint(0);t.equals(this.currentPoint)||this.lineTo(t.x,t.y)}this.curves.push(l);const h=l.getPoint(1);return this.currentPoint.copy(h),this}copy(t){return super.copy(t),this.currentPoint.copy(t.currentPoint),this}toJSON(){const t=super.toJSON();return t.currentPoint=this.currentPoint.toArray(),t}fromJSON(t){return super.fromJSON(t),this.currentPoint.fromArray(t.currentPoint),this}}class oh extends Jn{constructor(t=[new Fe(0,-.5),new Fe(.5,0),new Fe(0,.5)],e=12,i=0,n=2*Math.PI){super(),this.type="LatheGeometry",this.parameters={points:t,segments:e,phiStart:i,phiLength:n},e=Math.floor(e),n=Ne(n,0,2*Math.PI);const s=[],r=[],a=[],o=[],l=[],h=1/e,c=new ui,u=new Fe,d=new ui,p=new ui,m=new ui;let f=0,g=0;for(let x=0;x<=t.length-1;x++)switch(x){case 0:f=t[x+1].x-t[x].x,g=t[x+1].y-t[x].y,d.x=1*g,d.y=-f,d.z=0*g,m.copy(d),d.normalize(),o.push(d.x,d.y,d.z);break;case t.length-1:o.push(m.x,m.y,m.z);break;default:f=t[x+1].x-t[x].x,g=t[x+1].y-t[x].y,d.x=1*g,d.y=-f,d.z=0*g,p.copy(d),d.x+=m.x,d.y+=m.y,d.z+=m.z,d.normalize(),o.push(d.x,d.y,d.z),m.copy(p)}for(let x=0;x<=e;x++){const s=i+x*h*n,d=Math.sin(s),p=Math.cos(s);for(let i=0;i<=t.length-1;i++){c.x=t[i].x*d,c.y=t[i].y,c.z=t[i].x*p,r.push(c.x,c.y,c.z),u.x=x/e,u.y=i/(t.length-1),a.push(u.x,u.y);const n=o[3*i+0]*d,s=o[3*i+1],h=o[3*i+0]*p;l.push(n,s,h)}}for(let x=0;x<e;x++)for(let e=0;e<t.length-1;e++){const i=e+x*t.length,n=i,r=i+t.length,a=i+t.length+1,o=i+1;s.push(n,r,o),s.push(a,o,r)}this.setIndex(s),this.setAttribute("position",new Wn(r,3)),this.setAttribute("uv",new Wn(a,2)),this.setAttribute("normal",new Wn(l,3))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new oh(t.points,t.segments,t.phiStart,t.phiLength)}}class lh extends oh{constructor(t=1,e=1,i=4,n=8){const s=new ah;s.absarc(0,-e/2,t,1.5*Math.PI,0),s.absarc(0,e/2,t,0,.5*Math.PI),super(s.getPoints(i),n),this.type="CapsuleGeometry",this.parameters={radius:t,length:e,capSegments:i,radialSegments:n}}static fromJSON(t){return new lh(t.radius,t.length,t.capSegments,t.radialSegments)}}class hh extends Jn{constructor(t=1,e=32,i=0,n=2*Math.PI){super(),this.type="CircleGeometry",this.parameters={radius:t,segments:e,thetaStart:i,thetaLength:n},e=Math.max(3,e);const s=[],r=[],a=[],o=[],l=new ui,h=new Fe;r.push(0,0,0),a.push(0,0,1),o.push(.5,.5);for(let c=0,u=3;c<=e;c++,u+=3){const s=i+c/e*n;l.x=t*Math.cos(s),l.y=t*Math.sin(s),r.push(l.x,l.y,l.z),a.push(0,0,1),h.x=(r[u]/t+1)/2,h.y=(r[u+1]/t+1)/2,o.push(h.x,h.y)}for(let c=1;c<=e;c++)s.push(c,c+1,0);this.setIndex(s),this.setAttribute("position",new Wn(r,3)),this.setAttribute("normal",new Wn(a,3)),this.setAttribute("uv",new Wn(o,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new hh(t.radius,t.segments,t.thetaStart,t.thetaLength)}}class ch extends Jn{constructor(t=1,e=1,i=1,n=32,s=1,r=!1,a=0,o=2*Math.PI){super(),this.type="CylinderGeometry",this.parameters={radiusTop:t,radiusBottom:e,height:i,radialSegments:n,heightSegments:s,openEnded:r,thetaStart:a,thetaLength:o};const l=this;n=Math.floor(n),s=Math.floor(s);const h=[],c=[],u=[],d=[];let p=0;const m=[],f=i/2;let g=0;function x(i){const s=p,r=new Fe,m=new ui;let x=0;const v=!0===i?t:e,_=!0===i?1:-1;for(let t=1;t<=n;t++)c.push(0,f*_,0),u.push(0,_,0),d.push(.5,.5),p++;const y=p;for(let t=0;t<=n;t++){const e=t/n*o+a,i=Math.cos(e),s=Math.sin(e);m.x=v*s,m.y=f*_,m.z=v*i,c.push(m.x,m.y,m.z),u.push(0,_,0),r.x=.5*i+.5,r.y=.5*s*_+.5,d.push(r.x,r.y),p++}for(let t=0;t<n;t++){const e=s+t,n=y+t;!0===i?h.push(n,n+1,e):h.push(n+1,n,e),x+=3}l.addGroup(g,x,!0===i?1:2),g+=x}!function(){const r=new ui,x=new ui;let v=0;const _=(e-t)/i;for(let l=0;l<=s;l++){const h=[],g=l/s,v=g*(e-t)+t;for(let t=0;t<=n;t++){const e=t/n,s=e*o+a,l=Math.sin(s),m=Math.cos(s);x.x=v*l,x.y=-g*i+f,x.z=v*m,c.push(x.x,x.y,x.z),r.set(l,_,m).normalize(),u.push(r.x,r.y,r.z),d.push(e,1-g),h.push(p++)}m.push(h)}for(let i=0;i<n;i++)for(let n=0;n<s;n++){const r=m[n][i],a=m[n+1][i],o=m[n+1][i+1],l=m[n][i+1];(t>0||0!==n)&&(h.push(r,a,l),v+=3),(e>0||n!==s-1)&&(h.push(a,o,l),v+=3)}l.addGroup(g,v,0),g+=v}(),!1===r&&(t>0&&x(!0),e>0&&x(!1)),this.setIndex(h),this.setAttribute("position",new Wn(c,3)),this.setAttribute("normal",new Wn(u,3)),this.setAttribute("uv",new Wn(d,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new ch(t.radiusTop,t.radiusBottom,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class uh extends ch{constructor(t=1,e=1,i=32,n=1,s=!1,r=0,a=2*Math.PI){super(0,t,e,i,n,s,r,a),this.type="ConeGeometry",this.parameters={radius:t,height:e,radialSegments:i,heightSegments:n,openEnded:s,thetaStart:r,thetaLength:a}}static fromJSON(t){return new uh(t.radius,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class dh extends Jn{constructor(t=[],e=[],i=1,n=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:t,indices:e,radius:i,detail:n};const s=[],r=[];function a(t,e,i,n){const s=n+1,r=[];for(let a=0;a<=s;a++){r[a]=[];const n=t.clone().lerp(i,a/s),o=e.clone().lerp(i,a/s),l=s-a;for(let t=0;t<=l;t++)r[a][t]=0===t&&a===s?n:n.clone().lerp(o,t/l)}for(let a=0;a<s;a++)for(let t=0;t<2*(s-a)-1;t++){const e=Math.floor(t/2);t%2==0?(o(r[a][e+1]),o(r[a+1][e]),o(r[a][e])):(o(r[a][e+1]),o(r[a+1][e+1]),o(r[a+1][e]))}}function o(t){s.push(t.x,t.y,t.z)}function l(e,i){const n=3*e;i.x=t[n+0],i.y=t[n+1],i.z=t[n+2]}function h(t,e,i,n){n<0&&1===t.x&&(r[e]=t.x-1),0===i.x&&0===i.z&&(r[e]=n/2/Math.PI+.5)}function c(t){return Math.atan2(t.z,-t.x)}!function(t){const i=new ui,n=new ui,s=new ui;for(let r=0;r<e.length;r+=3)l(e[r+0],i),l(e[r+1],n),l(e[r+2],s),a(i,n,s,t)}(n),function(t){const e=new ui;for(let i=0;i<s.length;i+=3)e.x=s[i+0],e.y=s[i+1],e.z=s[i+2],e.normalize().multiplyScalar(t),s[i+0]=e.x,s[i+1]=e.y,s[i+2]=e.z}(i),function(){const t=new ui;for(let i=0;i<s.length;i+=3){t.x=s[i+0],t.y=s[i+1],t.z=s[i+2];const n=c(t)/2/Math.PI+.5,a=(e=t,Math.atan2(-e.y,Math.sqrt(e.x*e.x+e.z*e.z))/Math.PI+.5);r.push(n,1-a)}var e;(function(){const t=new ui,e=new ui,i=new ui,n=new ui,a=new Fe,o=new Fe,l=new Fe;for(let u=0,d=0;u<s.length;u+=9,d+=6){t.set(s[u+0],s[u+1],s[u+2]),e.set(s[u+3],s[u+4],s[u+5]),i.set(s[u+6],s[u+7],s[u+8]),a.set(r[d+0],r[d+1]),o.set(r[d+2],r[d+3]),l.set(r[d+4],r[d+5]),n.copy(t).add(e).add(i).divideScalar(3);const p=c(n);h(a,d+0,t,p),h(o,d+2,e,p),h(l,d+4,i,p)}})(),function(){for(let t=0;t<r.length;t+=6){const e=r[t+0],i=r[t+2],n=r[t+4],s=Math.max(e,i,n),a=Math.min(e,i,n);s>.9&&a<.1&&(e<.2&&(r[t+0]+=1),i<.2&&(r[t+2]+=1),n<.2&&(r[t+4]+=1))}}()}(),this.setAttribute("position",new Wn(s,3)),this.setAttribute("normal",new Wn(s.slice(),3)),this.setAttribute("uv",new Wn(r,2)),0===n?this.computeVertexNormals():this.normalizeNormals()}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new dh(t.vertices,t.indices,t.radius,t.details)}}const ph=new ui,mh=new ui,fh=new ui,gh=new Rn;class xh extends Jn{constructor(t=null,e=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:t,thresholdAngle:e},null!==t){const i=4,n=Math.pow(10,i),s=Math.cos(Ee*e),r=t.getIndex(),a=t.getAttribute("position"),o=r?r.count:a.count,l=[0,0,0],h=["a","b","c"],c=new Array(3),u={},d=[];for(let t=0;t<o;t+=3){r?(l[0]=r.getX(t),l[1]=r.getX(t+1),l[2]=r.getX(t+2)):(l[0]=t,l[1]=t+1,l[2]=t+2);const{a:e,b:i,c:o}=gh;if(e.fromBufferAttribute(a,l[0]),i.fromBufferAttribute(a,l[1]),o.fromBufferAttribute(a,l[2]),gh.getNormal(fh),c[0]=`${Math.round(e.x*n)},${Math.round(e.y*n)},${Math.round(e.z*n)}`,c[1]=`${Math.round(i.x*n)},${Math.round(i.y*n)},${Math.round(i.z*n)}`,c[2]=`${Math.round(o.x*n)},${Math.round(o.y*n)},${Math.round(o.z*n)}`,c[0]!==c[1]&&c[1]!==c[2]&&c[2]!==c[0])for(let t=0;t<3;t++){const e=(t+1)%3,i=c[t],n=c[e],r=gh[h[t]],a=gh[h[e]],o=`${i}_${n}`,p=`${n}_${i}`;p in u&&u[p]?(fh.dot(u[p].normal)<=s&&(d.push(r.x,r.y,r.z),d.push(a.x,a.y,a.z)),u[p]=null):o in u||(u[o]={index0:l[t],index1:l[e],normal:fh.clone()})}}for(const t in u)if(u[t]){const{index0:e,index1:i}=u[t];ph.fromBufferAttribute(a,e),mh.fromBufferAttribute(a,i),d.push(ph.x,ph.y,ph.z),d.push(mh.x,mh.y,mh.z)}this.setAttribute("position",new Wn(d,3))}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}}class vh extends ah{constructor(t){super(t),this.uuid=Re(),this.type="Shape",this.holes=[]}getPointsHoles(t){const e=[];for(let i=0,n=this.holes.length;i<n;i++)e[i]=this.holes[i].getPoints(t);return e}extractPoints(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}}copy(t){super.copy(t),this.holes=[];for(let e=0,i=t.holes.length;e<i;e++){const i=t.holes[e];this.holes.push(i.clone())}return this}toJSON(){const t=super.toJSON();t.uuid=this.uuid,t.holes=[];for(let e=0,i=this.holes.length;e<i;e++){const i=this.holes[e];t.holes.push(i.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.uuid=t.uuid,this.holes=[];for(let e=0,i=t.holes.length;e<i;e++){const i=t.holes[e];this.holes.push((new ah).fromJSON(i))}return this}}const _h=function(t,e,i=2){const n=e&&e.length,s=n?e[0]*i:t.length;let r=yh(t,0,s,i,!0);const a=[];if(!r||r.next===r.prev)return a;let o,l,h,c,u,d,p;if(n&&(r=function(t,e,i,n){const s=[];let r,a,o,l,h;for(r=0,a=e.length;r<a;r++)o=e[r]*n,l=r<a-1?e[r+1]*n:t.length,h=yh(t,o,l,n,!1),h===h.next&&(h.steiner=!0),s.push(Ph(h));for(s.sort(Eh),r=0;r<s.length;r++)i=Ch(s[r],i);return i}(t,e,r,i)),t.length>80*i){o=h=t[0],l=c=t[1];for(let e=i;e<s;e+=i)u=t[e],d=t[e+1],u<o&&(o=u),d<l&&(l=d),u>h&&(h=u),d>c&&(c=d);p=Math.max(h-o,c-l),p=0!==p?32767/p:0}return Sh(r,a,i,o,l,p,0),a};function yh(t,e,i,n,s){let r,a;if(s===function(t,e,i,n){let s=0;for(let r=e,a=i-n;r<i;r+=n)s+=(t[a]-t[r])*(t[r+1]+t[a+1]),a=r;return s}(t,e,i,n)>0)for(r=e;r<i;r+=n)a=Vh(r,t[r],t[r+1],a);else for(r=i-n;r>=e;r-=n)a=Vh(r,t[r],t[r+1],a);return a&&Uh(a,a.next)&&(Gh(a),a=a.next),a}function bh(t,e){if(!t)return t;e||(e=t);let i,n=t;do{if(i=!1,n.steiner||!Uh(n,n.next)&&0!==Dh(n.prev,n,n.next))n=n.next;else{if(Gh(n),n=e=n.prev,n===n.next)break;i=!0}}while(i||n!==e);return e}function Sh(t,e,i,n,s,r,a){if(!t)return;!a&&r&&function(t,e,i,n){let s=t;do{0===s.z&&(s.z=Nh(s.x,s.y,e,i,n)),s.prevZ=s.prev,s.nextZ=s.next,s=s.next}while(s!==t);s.prevZ.nextZ=null,s.prevZ=null,function(t){let e,i,n,s,r,a,o,l,h=1;do{for(i=t,t=null,r=null,a=0;i;){for(a++,n=i,o=0,e=0;e<h&&(o++,n=n.nextZ,n);e++);for(l=h;o>0||l>0&&n;)0!==o&&(0===l||!n||i.z<=n.z)?(s=i,i=i.nextZ,o--):(s=n,n=n.nextZ,l--),r?r.nextZ=s:t=s,s.prevZ=r,r=s;i=n}r.nextZ=null,h*=2}while(a>1)}(s)}(t,n,s,r);let o,l,h=t;for(;t.prev!==t.next;)if(o=t.prev,l=t.next,r?Th(t,n,s,r):Mh(t))e.push(o.i/i|0),e.push(t.i/i|0),e.push(l.i/i|0),Gh(t),t=l.next,h=l.next;else if((t=l)===h){a?1===a?Sh(t=wh(bh(t),e,i),e,i,n,s,r,2):2===a&&Ah(t,e,i,n,s,r):Sh(bh(t),e,i,n,s,r,1);break}}function Mh(t){const e=t.prev,i=t,n=t.next;if(Dh(e,i,n)>=0)return!1;const s=e.x,r=i.x,a=n.x,o=e.y,l=i.y,h=n.y,c=s<r?s<a?s:a:r<a?r:a,u=o<l?o<h?o:h:l<h?l:h,d=s>r?s>a?s:a:r>a?r:a,p=o>l?o>h?o:h:l>h?l:h;let m=n.next;for(;m!==e;){if(m.x>=c&&m.x<=d&&m.y>=u&&m.y<=p&&Ih(s,o,r,l,a,h,m.x,m.y)&&Dh(m.prev,m,m.next)>=0)return!1;m=m.next}return!0}function Th(t,e,i,n){const s=t.prev,r=t,a=t.next;if(Dh(s,r,a)>=0)return!1;const o=s.x,l=r.x,h=a.x,c=s.y,u=r.y,d=a.y,p=o<l?o<h?o:h:l<h?l:h,m=c<u?c<d?c:d:u<d?u:d,f=o>l?o>h?o:h:l>h?l:h,g=c>u?c>d?c:d:u>d?u:d,x=Nh(p,m,e,i,n),v=Nh(f,g,e,i,n);let _=t.prevZ,y=t.nextZ;for(;_&&_.z>=x&&y&&y.z<=v;){if(_.x>=p&&_.x<=f&&_.y>=m&&_.y<=g&&_!==s&&_!==a&&Ih(o,c,l,u,h,d,_.x,_.y)&&Dh(_.prev,_,_.next)>=0)return!1;if(_=_.prevZ,y.x>=p&&y.x<=f&&y.y>=m&&y.y<=g&&y!==s&&y!==a&&Ih(o,c,l,u,h,d,y.x,y.y)&&Dh(y.prev,y,y.next)>=0)return!1;y=y.nextZ}for(;_&&_.z>=x;){if(_.x>=p&&_.x<=f&&_.y>=m&&_.y<=g&&_!==s&&_!==a&&Ih(o,c,l,u,h,d,_.x,_.y)&&Dh(_.prev,_,_.next)>=0)return!1;_=_.prevZ}for(;y&&y.z<=v;){if(y.x>=p&&y.x<=f&&y.y>=m&&y.y<=g&&y!==s&&y!==a&&Ih(o,c,l,u,h,d,y.x,y.y)&&Dh(y.prev,y,y.next)>=0)return!1;y=y.nextZ}return!0}function wh(t,e,i){let n=t;do{const s=n.prev,r=n.next.next;!Uh(s,r)&&Fh(s,n,n.next,r)&&zh(s,r)&&zh(r,s)&&(e.push(s.i/i|0),e.push(n.i/i|0),e.push(r.i/i|0),Gh(n),Gh(n.next),n=t=r),n=n.next}while(n!==t);return bh(n)}function Ah(t,e,i,n,s,r){let a=t;do{let t=a.next.next;for(;t!==a.prev;){if(a.i!==t.i&&Lh(a,t)){let o=kh(a,t);return a=bh(a,a.next),o=bh(o,o.next),Sh(a,e,i,n,s,r,0),void Sh(o,e,i,n,s,r,0)}t=t.next}a=a.next}while(a!==t)}function Eh(t,e){return t.x-e.x}function Ch(t,e){const i=function(t,e){let i,n=e,s=-1/0;const r=t.x,a=t.y;do{if(a<=n.y&&a>=n.next.y&&n.next.y!==n.y){const t=n.x+(a-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(t<=r&&t>s&&(s=t,i=n.x<n.next.x?n:n.next,t===r))return i}n=n.next}while(n!==e);if(!i)return null;const o=i,l=i.x,h=i.y;let c,u=1/0;n=i;do{r>=n.x&&n.x>=l&&r!==n.x&&Ih(a<h?r:s,a,l,h,a<h?s:r,a,n.x,n.y)&&(c=Math.abs(a-n.y)/(r-n.x),zh(n,t)&&(c<u||c===u&&(n.x>i.x||n.x===i.x&&Rh(i,n)))&&(i=n,u=c)),n=n.next}while(n!==o);return i}(t,e);if(!i)return e;const n=kh(i,t);return bh(n,n.next),bh(i,i.next)}function Rh(t,e){return Dh(t.prev,t,e.prev)<0&&Dh(e.next,t,t.next)<0}function Nh(t,e,i,n,s){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-i)*s|0)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-n)*s|0)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function Ph(t){let e=t,i=t;do{(e.x<i.x||e.x===i.x&&e.y<i.y)&&(i=e),e=e.next}while(e!==t);return i}function Ih(t,e,i,n,s,r,a,o){return(s-a)*(e-o)>=(t-a)*(r-o)&&(t-a)*(n-o)>=(i-a)*(e-o)&&(i-a)*(r-o)>=(s-a)*(n-o)}function Lh(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){let i=t;do{if(i.i!==t.i&&i.next.i!==t.i&&i.i!==e.i&&i.next.i!==e.i&&Fh(i,i.next,t,e))return!0;i=i.next}while(i!==t);return!1}(t,e)&&(zh(t,e)&&zh(e,t)&&function(t,e){let i=t,n=!1;const s=(t.x+e.x)/2,r=(t.y+e.y)/2;do{i.y>r!=i.next.y>r&&i.next.y!==i.y&&s<(i.next.x-i.x)*(r-i.y)/(i.next.y-i.y)+i.x&&(n=!n),i=i.next}while(i!==t);return n}(t,e)&&(Dh(t.prev,t,e.prev)||Dh(t,e.prev,e))||Uh(t,e)&&Dh(t.prev,t,t.next)>0&&Dh(e.prev,e,e.next)>0)}function Dh(t,e,i){return(e.y-t.y)*(i.x-e.x)-(e.x-t.x)*(i.y-e.y)}function Uh(t,e){return t.x===e.x&&t.y===e.y}function Fh(t,e,i,n){const s=Oh(Dh(t,e,i)),r=Oh(Dh(t,e,n)),a=Oh(Dh(i,n,t)),o=Oh(Dh(i,n,e));return s!==r&&a!==o||(!(0!==s||!Bh(t,i,e))||(!(0!==r||!Bh(t,n,e))||(!(0!==a||!Bh(i,t,n))||!(0!==o||!Bh(i,e,n)))))}function Bh(t,e,i){return e.x<=Math.max(t.x,i.x)&&e.x>=Math.min(t.x,i.x)&&e.y<=Math.max(t.y,i.y)&&e.y>=Math.min(t.y,i.y)}function Oh(t){return t>0?1:t<0?-1:0}function zh(t,e){return Dh(t.prev,t,t.next)<0?Dh(t,e,t.next)>=0&&Dh(t,t.prev,e)>=0:Dh(t,e,t.prev)<0||Dh(t,t.next,e)<0}function kh(t,e){const i=new Hh(t.i,t.x,t.y),n=new Hh(e.i,e.x,e.y),s=t.next,r=e.prev;return t.next=e,e.prev=t,i.next=s,s.prev=i,n.next=i,i.prev=n,r.next=n,n.prev=r,n}function Vh(t,e,i,n){const s=new Hh(t,e,i);return n?(s.next=n.next,s.prev=n,n.next.prev=s,n.next=s):(s.prev=s,s.next=s),s}function Gh(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function Hh(t,e,i){this.i=t,this.x=e,this.y=i,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}class Wh{static area(t){const e=t.length;let i=0;for(let n=e-1,s=0;s<e;n=s++)i+=t[n].x*t[s].y-t[s].x*t[n].y;return.5*i}static isClockWise(t){return Wh.area(t)<0}static triangulateShape(t,e){const i=[],n=[],s=[];jh(t),Xh(i,t);let r=t.length;e.forEach(jh);for(let o=0;o<e.length;o++)n.push(r),r+=e[o].length,Xh(i,e[o]);const a=_h(i,n);for(let o=0;o<a.length;o+=3)s.push(a.slice(o,o+3));return s}}function jh(t){const e=t.length;e>2&&t[e-1].equals(t[0])&&t.pop()}function Xh(t,e){for(let i=0;i<e.length;i++)t.push(e[i].x),t.push(e[i].y)}class qh extends Jn{constructor(t=new vh([new Fe(.5,.5),new Fe(-.5,.5),new Fe(-.5,-.5),new Fe(.5,-.5)]),e={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];const i=this,n=[],s=[];for(let a=0,o=t.length;a<o;a++){r(t[a])}function r(t){const r=[],a=void 0!==e.curveSegments?e.curveSegments:12,o=void 0!==e.steps?e.steps:1,l=void 0!==e.depth?e.depth:1;let h=void 0===e.bevelEnabled||e.bevelEnabled,c=void 0!==e.bevelThickness?e.bevelThickness:.2,u=void 0!==e.bevelSize?e.bevelSize:c-.1,d=void 0!==e.bevelOffset?e.bevelOffset:0,p=void 0!==e.bevelSegments?e.bevelSegments:3;const m=e.extrudePath,f=void 0!==e.UVGenerator?e.UVGenerator:$h;let g,x,v,_,y,b=!1;m&&(g=m.getSpacedPoints(o),b=!0,h=!1,x=m.computeFrenetFrames(o,!1),v=new ui,_=new ui,y=new ui),h||(p=0,c=0,u=0,d=0);const S=t.extractPoints(a);let M=S.shape;const T=S.holes;if(!Wh.isClockWise(M)){M=M.reverse();for(let t=0,e=T.length;t<e;t++){const e=T[t];Wh.isClockWise(e)&&(T[t]=e.reverse())}}const w=Wh.triangulateShape(M,T),A=M;for(let e=0,i=T.length;e<i;e++){const t=T[e];M=M.concat(t)}function E(t,e,i){return t.clone().addScaledVector(e,i)}const C=M.length,R=w.length;function N(t,e,i){let n,s,r;const a=t.x-e.x,o=t.y-e.y,l=i.x-t.x,h=i.y-t.y,c=a*a+o*o,u=a*h-o*l;if(Math.abs(u)>Number.EPSILON){const u=Math.sqrt(c),d=Math.sqrt(l*l+h*h),p=e.x-o/u,m=e.y+a/u,f=((i.x-h/d-p)*h-(i.y+l/d-m)*l)/(a*h-o*l);n=p+a*f-t.x,s=m+o*f-t.y;const g=n*n+s*s;if(g<=2)return new Fe(n,s);r=Math.sqrt(g/2)}else{let t=!1;a>Number.EPSILON?l>Number.EPSILON&&(t=!0):a<-Number.EPSILON?l<-Number.EPSILON&&(t=!0):Math.sign(o)===Math.sign(h)&&(t=!0),t?(n=-o,s=a,r=Math.sqrt(c)):(n=a,s=o,r=Math.sqrt(c/2))}return new Fe(n/r,s/r)}const P=[];for(let e=0,i=A.length,n=i-1,s=e+1;e<i;e++,n++,s++)n===i&&(n=0),s===i&&(s=0),P[e]=N(A[e],A[n],A[s]);const I=[];let L,D=P.concat();for(let e=0,i=T.length;e<i;e++){const t=T[e];L=[];for(let e=0,i=t.length,n=i-1,s=e+1;e<i;e++,n++,s++)n===i&&(n=0),s===i&&(s=0),L[e]=N(t[e],t[n],t[s]);I.push(L),D=D.concat(L)}for(let e=0;e<p;e++){const t=e/p,i=c*Math.cos(t*Math.PI/2),n=u*Math.sin(t*Math.PI/2)+d;for(let e=0,s=A.length;e<s;e++){const t=E(A[e],P[e],n);B(t.x,t.y,-i)}for(let e=0,s=T.length;e<s;e++){const t=T[e];L=I[e];for(let e=0,s=t.length;e<s;e++){const s=E(t[e],L[e],n);B(s.x,s.y,-i)}}}const U=u+d;for(let e=0;e<C;e++){const t=h?E(M[e],D[e],U):M[e];b?(_.copy(x.normals[0]).multiplyScalar(t.x),v.copy(x.binormals[0]).multiplyScalar(t.y),y.copy(g[0]).add(_).add(v),B(y.x,y.y,y.z)):B(t.x,t.y,0)}for(let e=1;e<=o;e++)for(let t=0;t<C;t++){const i=h?E(M[t],D[t],U):M[t];b?(_.copy(x.normals[e]).multiplyScalar(i.x),v.copy(x.binormals[e]).multiplyScalar(i.y),y.copy(g[e]).add(_).add(v),B(y.x,y.y,y.z)):B(i.x,i.y,l/o*e)}for(let e=p-1;e>=0;e--){const t=e/p,i=c*Math.cos(t*Math.PI/2),n=u*Math.sin(t*Math.PI/2)+d;for(let e=0,s=A.length;e<s;e++){const t=E(A[e],P[e],n);B(t.x,t.y,l+i)}for(let e=0,s=T.length;e<s;e++){const t=T[e];L=I[e];for(let e=0,s=t.length;e<s;e++){const s=E(t[e],L[e],n);b?B(s.x,s.y+g[o-1].y,g[o-1].x+i):B(s.x,s.y,l+i)}}}function F(t,e){let i=t.length;for(;--i>=0;){const n=i;let s=i-1;s<0&&(s=t.length-1);for(let t=0,i=o+2*p;t<i;t++){const i=C*t,r=C*(t+1);z(e+n+i,e+s+i,e+s+r,e+n+r)}}}function B(t,e,i){r.push(t),r.push(e),r.push(i)}function O(t,e,s){k(t),k(e),k(s);const r=n.length/3,a=f.generateTopUV(i,n,r-3,r-2,r-1);V(a[0]),V(a[1]),V(a[2])}function z(t,e,s,r){k(t),k(e),k(r),k(e),k(s),k(r);const a=n.length/3,o=f.generateSideWallUV(i,n,a-6,a-3,a-2,a-1);V(o[0]),V(o[1]),V(o[3]),V(o[1]),V(o[2]),V(o[3])}function k(t){n.push(r[3*t+0]),n.push(r[3*t+1]),n.push(r[3*t+2])}function V(t){s.push(t.x),s.push(t.y)}!function(){const t=n.length/3;if(h){let t=0,e=C*t;for(let i=0;i<R;i++){const t=w[i];O(t[2]+e,t[1]+e,t[0]+e)}t=o+2*p,e=C*t;for(let i=0;i<R;i++){const t=w[i];O(t[0]+e,t[1]+e,t[2]+e)}}else{for(let t=0;t<R;t++){const e=w[t];O(e[2],e[1],e[0])}for(let t=0;t<R;t++){const e=w[t];O(e[0]+C*o,e[1]+C*o,e[2]+C*o)}}i.addGroup(t,n.length/3-t,0)}(),function(){const t=n.length/3;let e=0;F(A,e),e+=A.length;for(let i=0,n=T.length;i<n;i++){const t=T[i];F(t,e),e+=t.length}i.addGroup(t,n.length/3-t,1)}()}this.setAttribute("position",new Wn(n,3)),this.setAttribute("uv",new Wn(s,2)),this.computeVertexNormals()}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){const t=super.toJSON();return function(t,e,i){if(i.shapes=[],Array.isArray(t))for(let n=0,s=t.length;n<s;n++){const e=t[n];i.shapes.push(e.uuid)}else i.shapes.push(t.uuid);i.options=Object.assign({},e),void 0!==e.extrudePath&&(i.options.extrudePath=e.extrudePath.toJSON());return i}(this.parameters.shapes,this.parameters.options,t)}static fromJSON(t,e){const i=[];for(let s=0,r=t.shapes.length;s<r;s++){const n=e[t.shapes[s]];i.push(n)}const n=t.options.extrudePath;return void 0!==n&&(t.options.extrudePath=(new sh[n.type]).fromJSON(n)),new qh(i,t.options)}}const $h={generateTopUV:function(t,e,i,n,s){const r=e[3*i],a=e[3*i+1],o=e[3*n],l=e[3*n+1],h=e[3*s],c=e[3*s+1];return[new Fe(r,a),new Fe(o,l),new Fe(h,c)]},generateSideWallUV:function(t,e,i,n,s,r){const a=e[3*i],o=e[3*i+1],l=e[3*i+2],h=e[3*n],c=e[3*n+1],u=e[3*n+2],d=e[3*s],p=e[3*s+1],m=e[3*s+2],f=e[3*r],g=e[3*r+1],x=e[3*r+2];return Math.abs(o-c)<Math.abs(a-h)?[new Fe(a,1-l),new Fe(h,1-u),new Fe(d,1-m),new Fe(f,1-x)]:[new Fe(o,1-l),new Fe(c,1-u),new Fe(p,1-m),new Fe(g,1-x)]}};class Yh extends dh{constructor(t=1,e=0){const i=(1+Math.sqrt(5))/2;super([-1,i,0,1,i,0,-1,-i,0,1,-i,0,0,-1,i,0,1,i,0,-1,-i,0,1,-i,i,0,-1,i,0,1,-i,0,-1,-i,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],t,e),this.type="IcosahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new Yh(t.radius,t.detail)}}class Zh extends Jn{constructor(t=new vh([new Fe(0,.5),new Fe(-.5,-.5),new Fe(.5,-.5)]),e=12){super(),this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:e};const i=[],n=[],s=[],r=[];let a=0,o=0;if(!1===Array.isArray(t))l(t);else for(let h=0;h<t.length;h++)l(t[h]),this.addGroup(a,o,h),a+=o,o=0;function l(t){const a=n.length/3,l=t.extractPoints(e);let h=l.shape;const c=l.holes;!1===Wh.isClockWise(h)&&(h=h.reverse());for(let e=0,i=c.length;e<i;e++){const t=c[e];!0===Wh.isClockWise(t)&&(c[e]=t.reverse())}const u=Wh.triangulateShape(h,c);for(let e=0,i=c.length;e<i;e++){const t=c[e];h=h.concat(t)}for(let e=0,i=h.length;e<i;e++){const t=h[e];n.push(t.x,t.y,0),s.push(0,0,1),r.push(t.x,t.y)}for(let e=0,n=u.length;e<n;e++){const t=u[e],n=t[0]+a,s=t[1]+a,r=t[2]+a;i.push(n,s,r),o+=3}}this.setIndex(i),this.setAttribute("position",new Wn(n,3)),this.setAttribute("normal",new Wn(s,3)),this.setAttribute("uv",new Wn(r,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){const t=super.toJSON();return function(t,e){if(e.shapes=[],Array.isArray(t))for(let i=0,n=t.length;i<n;i++){const n=t[i];e.shapes.push(n.uuid)}else e.shapes.push(t.uuid);return e}(this.parameters.shapes,t)}static fromJSON(t,e){const i=[];for(let n=0,s=t.shapes.length;n<s;n++){const s=e[t.shapes[n]];i.push(s)}return new Zh(i,t.curveSegments)}}let Kh=class t extends Jn{constructor(t=1,e=32,i=16,n=0,s=2*Math.PI,r=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:e,heightSegments:i,phiStart:n,phiLength:s,thetaStart:r,thetaLength:a},e=Math.max(3,Math.floor(e)),i=Math.max(2,Math.floor(i));const o=Math.min(r+a,Math.PI);let l=0;const h=[],c=new ui,u=new ui,d=[],p=[],m=[],f=[];for(let g=0;g<=i;g++){const d=[],x=g/i;let v=0;0===g&&0===r?v=.5/e:g===i&&o===Math.PI&&(v=-.5/e);for(let i=0;i<=e;i++){const o=i/e;c.x=-t*Math.cos(n+o*s)*Math.sin(r+x*a),c.y=t*Math.cos(r+x*a),c.z=t*Math.sin(n+o*s)*Math.sin(r+x*a),p.push(c.x,c.y,c.z),u.copy(c).normalize(),m.push(u.x,u.y,u.z),f.push(o+v,1-x),d.push(l++)}h.push(d)}for(let g=0;g<i;g++)for(let t=0;t<e;t++){const e=h[g][t+1],n=h[g][t],s=h[g+1][t],a=h[g+1][t+1];(0!==g||r>0)&&d.push(e,n,a),(g!==i-1||o<Math.PI)&&d.push(n,s,a)}this.setIndex(d),this.setAttribute("position",new Wn(p,3)),this.setAttribute("normal",new Wn(m,3)),this.setAttribute("uv",new Wn(f,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(e){return new t(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}};class Jh extends dh{constructor(t=1,e=0){super([1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],t,e),this.type="TetrahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new Jh(t.radius,t.detail)}}class Qh extends Jn{constructor(t=1,e=.4,i=12,n=48,s=2*Math.PI){super(),this.type="TorusGeometry",this.parameters={radius:t,tube:e,radialSegments:i,tubularSegments:n,arc:s},i=Math.floor(i),n=Math.floor(n);const r=[],a=[],o=[],l=[],h=new ui,c=new ui,u=new ui;for(let d=0;d<=i;d++)for(let r=0;r<=n;r++){const p=r/n*s,m=d/i*Math.PI*2;c.x=(t+e*Math.cos(m))*Math.cos(p),c.y=(t+e*Math.cos(m))*Math.sin(p),c.z=e*Math.sin(m),a.push(c.x,c.y,c.z),h.x=t*Math.cos(p),h.y=t*Math.sin(p),u.subVectors(c,h).normalize(),o.push(u.x,u.y,u.z),l.push(r/n),l.push(d/i)}for(let d=1;d<=i;d++)for(let t=1;t<=n;t++){const e=(n+1)*d+t-1,i=(n+1)*(d-1)+t-1,s=(n+1)*(d-1)+t,a=(n+1)*d+t;r.push(e,i,a),r.push(i,s,a)}this.setIndex(r),this.setAttribute("position",new Wn(a,3)),this.setAttribute("normal",new Wn(o,3)),this.setAttribute("uv",new Wn(l,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Qh(t.radius,t.tube,t.radialSegments,t.tubularSegments,t.arc)}}class tc extends Jn{constructor(t=new ih(new ui(-1,-1,0),new ui(-1,1,0),new ui(1,1,0)),e=64,i=1,n=8,s=!1){super(),this.type="TubeGeometry",this.parameters={path:t,tubularSegments:e,radius:i,radialSegments:n,closed:s};const r=t.computeFrenetFrames(e,s);this.tangents=r.tangents,this.normals=r.normals,this.binormals=r.binormals;const a=new ui,o=new ui,l=new Fe;let h=new ui;const c=[],u=[],d=[],p=[];function m(s){h=t.getPointAt(s/e,h);const l=r.normals[s],d=r.binormals[s];for(let t=0;t<=n;t++){const e=t/n*Math.PI*2,s=Math.sin(e),r=-Math.cos(e);o.x=r*l.x+s*d.x,o.y=r*l.y+s*d.y,o.z=r*l.z+s*d.z,o.normalize(),u.push(o.x,o.y,o.z),a.x=h.x+i*o.x,a.y=h.y+i*o.y,a.z=h.z+i*o.z,c.push(a.x,a.y,a.z)}}!function(){for(let t=0;t<e;t++)m(t);m(!1===s?e:0),function(){for(let t=0;t<=e;t++)for(let i=0;i<=n;i++)l.x=t/e,l.y=i/n,d.push(l.x,l.y)}(),function(){for(let t=1;t<=e;t++)for(let e=1;e<=n;e++){const i=(n+1)*(t-1)+(e-1),s=(n+1)*t+(e-1),r=(n+1)*t+e,a=(n+1)*(t-1)+e;p.push(i,s,a),p.push(s,r,a)}}()}(),this.setIndex(p),this.setAttribute("position",new Wn(c,3)),this.setAttribute("normal",new Wn(u,3)),this.setAttribute("uv",new Wn(d,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){const t=super.toJSON();return t.path=this.parameters.path.toJSON(),t}static fromJSON(t){return new tc((new sh[t.path.type]).fromJSON(t.path),t.tubularSegments,t.radius,t.radialSegments,t.closed)}}class ec extends xs{static get type(){return"RawShaderMaterial"}constructor(t){super(t),this.isRawShaderMaterial=!0}}let ic=class extends Bn{static get type(){return"MeshStandardMaterial"}constructor(t){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.color=new Dn(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Dn(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Fe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Ki,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.envMapIntensity=t.envMapIntensity,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}},nc=class extends ic{static get type(){return"MeshPhysicalMaterial"}constructor(t){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Fe(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return Ne(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new Dn(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new Dn(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Dn(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._dispersion=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(t)}get anisotropy(){return this._anisotropy}set anisotropy(t){this._anisotropy>0!=t>0&&this.version++,this._anisotropy=t}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get iridescence(){return this._iridescence}set iridescence(t){this._iridescence>0!=t>0&&this.version++,this._iridescence=t}get dispersion(){return this._dispersion}set dispersion(t){this._dispersion>0!=t>0&&this.version++,this._dispersion=t}get sheen(){return this._sheen}set sheen(t){this._sheen>0!=t>0&&this.version++,this._sheen=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=t.anisotropy,this.anisotropyRotation=t.anisotropyRotation,this.anisotropyMap=t.anisotropyMap,this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.dispersion=t.dispersion,this.ior=t.ior,this.iridescence=t.iridescence,this.iridescenceMap=t.iridescenceMap,this.iridescenceIOR=t.iridescenceIOR,this.iridescenceThicknessRange=[...t.iridescenceThicknessRange],this.iridescenceThicknessMap=t.iridescenceThicknessMap,this.sheen=t.sheen,this.sheenColor.copy(t.sheenColor),this.sheenColorMap=t.sheenColorMap,this.sheenRoughness=t.sheenRoughness,this.sheenRoughnessMap=t.sheenRoughnessMap,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationColor.copy(t.attenuationColor),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularColor.copy(t.specularColor),this.specularColorMap=t.specularColorMap,this}},sc=class extends Bn{static get type(){return"MeshPhongMaterial"}constructor(t){super(),this.isMeshPhongMaterial=!0,this.color=new Dn(16777215),this.specular=new Dn(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Dn(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Fe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Ki,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}},rc=class extends Bn{static get type(){return"MeshNormalMaterial"}constructor(t){super(),this.isMeshNormalMaterial=!0,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Fe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this}},ac=class extends Bn{static get type(){return"MeshLambertMaterial"}constructor(t){super(),this.isMeshLambertMaterial=!0,this.color=new Dn(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Dn(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Fe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Ki,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}};function oc(t,e,i){return!t||!i&&t.constructor===e?t:"number"==typeof e.BYTES_PER_ELEMENT?new e(t):Array.prototype.slice.call(t)}function lc(t){const e=t.length,i=new Array(e);for(let n=0;n!==e;++n)i[n]=n;return i.sort((function(e,i){return t[e]-t[i]})),i}function hc(t,e,i){const n=t.length,s=new t.constructor(n);for(let r=0,a=0;a!==n;++r){const n=i[r]*e;for(let i=0;i!==e;++i)s[a++]=t[n+i]}return s}function cc(t,e,i,n){let s=1,r=t[0];for(;void 0!==r&&void 0===r[n];)r=t[s++];if(void 0===r)return;let a=r[n];if(void 0!==a)if(Array.isArray(a))do{a=r[n],void 0!==a&&(e.push(r.time),i.push.apply(i,a)),r=t[s++]}while(void 0!==r);else if(void 0!==a.toArray)do{a=r[n],void 0!==a&&(e.push(r.time),a.toArray(i,i.length)),r=t[s++]}while(void 0!==r);else do{a=r[n],void 0!==a&&(e.push(r.time),i.push(a)),r=t[s++]}while(void 0!==r)}class uc{constructor(t,e,i,n){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=void 0!==n?n:new e.constructor(i),this.sampleValues=e,this.valueSize=i,this.settings=null,this.DefaultSettings_={}}evaluate(t){const e=this.parameterPositions;let i=this._cachedIndex,n=e[i],s=e[i-1];t:{e:{let r;i:{n:if(!(t<n)){for(let r=i+2;;){if(void 0===n){if(t<s)break n;return i=e.length,this._cachedIndex=i,this.copySampleValue_(i-1)}if(i===r)break;if(s=n,n=e[++i],t<n)break e}r=e.length;break i}if(t>=s)break t;{const a=e[1];t<a&&(i=2,s=a);for(let r=i-2;;){if(void 0===s)return this._cachedIndex=0,this.copySampleValue_(0);if(i===r)break;if(n=s,s=e[--i-1],t>=s)break e}r=i,i=0}}for(;i<r;){const n=i+r>>>1;t<e[n]?r=n:i=n+1}if(n=e[i],s=e[i-1],void 0===s)return this._cachedIndex=0,this.copySampleValue_(0);if(void 0===n)return i=e.length,this._cachedIndex=i,this.copySampleValue_(i-1)}this._cachedIndex=i,this.intervalChanged_(i,s,n)}return this.interpolate_(i,s,t,n)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){const e=this.resultBuffer,i=this.sampleValues,n=this.valueSize,s=t*n;for(let r=0;r!==n;++r)e[r]=i[s+r];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class dc extends uc{constructor(t,e,i,n){super(t,e,i,n),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:ie,endingEnd:ie}}intervalChanged_(t,e,i){const n=this.parameterPositions;let s=t-2,r=t+1,a=n[s],o=n[r];if(void 0===a)switch(this.getSettings_().endingStart){case ne:s=t,a=2*e-i;break;case se:s=n.length-2,a=e+n[s]-n[s+1];break;default:s=t,a=i}if(void 0===o)switch(this.getSettings_().endingEnd){case ne:r=t,o=2*i-e;break;case se:r=1,o=i+n[1]-n[0];break;default:r=t-1,o=e}const l=.5*(i-e),h=this.valueSize;this._weightPrev=l/(e-a),this._weightNext=l/(o-i),this._offsetPrev=s*h,this._offsetNext=r*h}interpolate_(t,e,i,n){const s=this.resultBuffer,r=this.sampleValues,a=this.valueSize,o=t*a,l=o-a,h=this._offsetPrev,c=this._offsetNext,u=this._weightPrev,d=this._weightNext,p=(i-e)/(n-e),m=p*p,f=m*p,g=-u*f+2*u*m-u*p,x=(1+u)*f+(-1.5-2*u)*m+(-.5+u)*p+1,v=(-1-d)*f+(1.5+d)*m+.5*p,_=d*f-d*m;for(let y=0;y!==a;++y)s[y]=g*r[h+y]+x*r[l+y]+v*r[o+y]+_*r[c+y];return s}}class pc extends uc{constructor(t,e,i,n){super(t,e,i,n)}interpolate_(t,e,i,n){const s=this.resultBuffer,r=this.sampleValues,a=this.valueSize,o=t*a,l=o-a,h=(i-e)/(n-e),c=1-h;for(let u=0;u!==a;++u)s[u]=r[l+u]*c+r[o+u]*h;return s}}class mc extends uc{constructor(t,e,i,n){super(t,e,i,n)}interpolate_(t){return this.copySampleValue_(t-1)}}class fc{constructor(t,e,i,n){if(void 0===t)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===e||0===e.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=oc(e,this.TimeBufferType),this.values=oc(i,this.ValueBufferType),this.setInterpolation(n||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let i;if(e.toJSON!==this.toJSON)i=e.toJSON(t);else{i={name:t.name,times:oc(t.times,Array),values:oc(t.values,Array)};const e=t.getInterpolation();e!==t.DefaultInterpolation&&(i.interpolation=e)}return i.type=t.ValueTypeName,i}InterpolantFactoryMethodDiscrete(t){return new mc(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new pc(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new dc(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case Qt:e=this.InterpolantFactoryMethodDiscrete;break;case te:e=this.InterpolantFactoryMethodLinear;break;case ee:e=this.InterpolantFactoryMethodSmooth}if(void 0===e){const e="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(t===this.DefaultInterpolation)throw new Error(e);this.setInterpolation(this.DefaultInterpolation)}return this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Qt;case this.InterpolantFactoryMethodLinear:return te;case this.InterpolantFactoryMethodSmooth:return ee}}getValueSize(){return this.values.length/this.times.length}shift(t){if(0!==t){const e=this.times;for(let i=0,n=e.length;i!==n;++i)e[i]+=t}return this}scale(t){if(1!==t){const e=this.times;for(let i=0,n=e.length;i!==n;++i)e[i]*=t}return this}trim(t,e){const i=this.times,n=i.length;let s=0,r=n-1;for(;s!==n&&i[s]<t;)++s;for(;-1!==r&&i[r]>e;)--r;if(++r,0!==s||r!==n){s>=r&&(r=Math.max(r,1),s=r-1);const t=this.getValueSize();this.times=i.slice(s,r),this.values=this.values.slice(s*t,r*t)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!=0&&(t=!1);const i=this.times,n=this.values,s=i.length;0===s&&(t=!1);let r=null;for(let o=0;o!==s;o++){const e=i[o];if("number"==typeof e&&isNaN(e)){t=!1;break}if(null!==r&&r>e){t=!1;break}r=e}if(void 0!==n&&(a=n,ArrayBuffer.isView(a)&&!(a instanceof DataView)))for(let o=0,l=n.length;o!==l;++o){const e=n[o];if(isNaN(e)){t=!1;break}}var a;return t}optimize(){const t=this.times.slice(),e=this.values.slice(),i=this.getValueSize(),n=this.getInterpolation()===ee,s=t.length-1;let r=1;for(let a=1;a<s;++a){let s=!1;const o=t[a];if(o!==t[a+1]&&(1!==a||o!==t[0]))if(n)s=!0;else{const t=a*i,n=t-i,r=t+i;for(let a=0;a!==i;++a){const i=e[t+a];if(i!==e[n+a]||i!==e[r+a]){s=!0;break}}}if(s){if(a!==r){t[r]=t[a];const n=a*i,s=r*i;for(let t=0;t!==i;++t)e[s+t]=e[n+t]}++r}}if(s>0){t[r]=t[s];for(let t=s*i,n=r*i,a=0;a!==i;++a)e[n+a]=e[t+a];++r}return r!==t.length?(this.times=t.slice(0,r),this.values=e.slice(0,r*i)):(this.times=t,this.values=e),this}clone(){const t=this.times.slice(),e=this.values.slice(),i=new(0,this.constructor)(this.name,t,e);return i.createInterpolant=this.createInterpolant,i}}fc.prototype.TimeBufferType=Float32Array,fc.prototype.ValueBufferType=Float32Array,fc.prototype.DefaultInterpolation=te;class gc extends fc{constructor(t,e,i){super(t,e,i)}}gc.prototype.ValueTypeName="bool",gc.prototype.ValueBufferType=Array,gc.prototype.DefaultInterpolation=Qt,gc.prototype.InterpolantFactoryMethodLinear=void 0,gc.prototype.InterpolantFactoryMethodSmooth=void 0;class xc extends fc{}xc.prototype.ValueTypeName="color";class vc extends fc{}vc.prototype.ValueTypeName="number";class _c extends uc{constructor(t,e,i,n){super(t,e,i,n)}interpolate_(t,e,i,n){const s=this.resultBuffer,r=this.sampleValues,a=this.valueSize,o=(i-e)/(n-e);let l=t*a;for(let h=l+a;l!==h;l+=4)ci.slerpFlat(s,0,r,l-a,r,l,o);return s}}class yc extends fc{InterpolantFactoryMethodLinear(t){return new _c(this.times,this.values,this.getValueSize(),t)}}yc.prototype.ValueTypeName="quaternion",yc.prototype.InterpolantFactoryMethodSmooth=void 0;class bc extends fc{constructor(t,e,i){super(t,e,i)}}bc.prototype.ValueTypeName="string",bc.prototype.ValueBufferType=Array,bc.prototype.DefaultInterpolation=Qt,bc.prototype.InterpolantFactoryMethodLinear=void 0,bc.prototype.InterpolantFactoryMethodSmooth=void 0;class Sc extends fc{}Sc.prototype.ValueTypeName="vector";class Mc{constructor(t="",e=-1,i=[],n=2500){this.name=t,this.tracks=i,this.duration=e,this.blendMode=n,this.uuid=Re(),this.duration<0&&this.resetDuration()}static parse(t){const e=[],i=t.tracks,n=1/(t.fps||1);for(let r=0,a=i.length;r!==a;++r)e.push(Tc(i[r]).scale(n));const s=new this(t.name,t.duration,e,t.blendMode);return s.uuid=t.uuid,s}static toJSON(t){const e=[],i=t.tracks,n={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let s=0,r=i.length;s!==r;++s)e.push(fc.toJSON(i[s]));return n}static CreateFromMorphTargetSequence(t,e,i,n){const s=e.length,r=[];for(let a=0;a<s;a++){let t=[],o=[];t.push((a+s-1)%s,a,(a+1)%s),o.push(0,1,0);const l=lc(t);t=hc(t,1,l),o=hc(o,1,l),n||0!==t[0]||(t.push(s),o.push(o[0])),r.push(new vc(".morphTargetInfluences["+e[a].name+"]",t,o).scale(1/i))}return new this(t,-1,r)}static findByName(t,e){let i=t;if(!Array.isArray(t)){const e=t;i=e.geometry&&e.geometry.animations||e.animations}for(let n=0;n<i.length;n++)if(i[n].name===e)return i[n];return null}static CreateClipsFromMorphTargetSequences(t,e,i){const n={},s=/^([\w-]*?)([\d]+)$/;for(let a=0,o=t.length;a<o;a++){const e=t[a],i=e.name.match(s);if(i&&i.length>1){const t=i[1];let s=n[t];s||(n[t]=s=[]),s.push(e)}}const r=[];for(const a in n)r.push(this.CreateFromMorphTargetSequence(a,n[a],e,i));return r}static parseAnimation(t,e){if(!t)return null;const i=function(t,e,i,n,s){if(0!==i.length){const r=[],a=[];cc(i,r,a,n),0!==r.length&&s.push(new t(e,r,a))}},n=[],s=t.name||"default",r=t.fps||30,a=t.blendMode;let o=t.length||-1;const l=t.hierarchy||[];for(let h=0;h<l.length;h++){const t=l[h].keys;if(t&&0!==t.length)if(t[0].morphTargets){const e={};let i;for(i=0;i<t.length;i++)if(t[i].morphTargets)for(let n=0;n<t[i].morphTargets.length;n++)e[t[i].morphTargets[n]]=-1;for(const s in e){const e=[],r=[];for(let n=0;n!==t[i].morphTargets.length;++n){const n=t[i];e.push(n.time),r.push(n.morphTarget===s?1:0)}n.push(new vc(".morphTargetInfluence["+s+"]",e,r))}o=e.length*r}else{const s=".bones["+e[h].name+"]";i(Sc,s+".position",t,"pos",n),i(yc,s+".quaternion",t,"rot",n),i(Sc,s+".scale",t,"scl",n)}}if(0===n.length)return null;return new this(s,o,n,a)}resetDuration(){let t=0;for(let e=0,i=this.tracks.length;e!==i;++e){const i=this.tracks[e];t=Math.max(t,i.times[i.times.length-1])}return this.duration=t,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,t,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function Tc(t){if(void 0===t.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=function(t){switch(t.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return vc;case"vector":case"vector2":case"vector3":case"vector4":return Sc;case"color":return xc;case"quaternion":return yc;case"bool":case"boolean":return gc;case"string":return bc}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+t)}(t.type);if(void 0===t.times){const e=[],i=[];cc(t.keys,e,i,"value"),t.times=e,t.values=i}return void 0!==e.parse?e.parse(t):new e(t.name,t.times,t.values,t.interpolation)}const wc={enabled:!1,files:{},add:function(t,e){!1!==this.enabled&&(this.files[t]=e)},get:function(t){if(!1!==this.enabled)return this.files[t]},remove:function(t){delete this.files[t]},clear:function(){this.files={}}};const Ac=new class{constructor(t,e,i){const n=this;let s,r=!1,a=0,o=0;const l=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=i,this.itemStart=function(t){o++,!1===r&&void 0!==n.onStart&&n.onStart(t,a,o),r=!0},this.itemEnd=function(t){a++,void 0!==n.onProgress&&n.onProgress(t,a,o),a===o&&(r=!1,void 0!==n.onLoad&&n.onLoad())},this.itemError=function(t){void 0!==n.onError&&n.onError(t)},this.resolveURL=function(t){return s?s(t):t},this.setURLModifier=function(t){return s=t,this},this.addHandler=function(t,e){return l.push(t,e),this},this.removeHandler=function(t){const e=l.indexOf(t);return-1!==e&&l.splice(e,2),this},this.getHandler=function(t){for(let e=0,i=l.length;e<i;e+=2){const i=l[e],n=l[e+1];if(i.global&&(i.lastIndex=0),i.test(t))return n}return null}}};let Ec=class{constructor(t){this.manager=void 0!==t?t:Ac,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const i=this;return new Promise((function(n,s){i.load(t,n,e,s)}))}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}};Ec.DEFAULT_MATERIAL_NAME="__DEFAULT";const Cc={};class Rc extends Error{constructor(t,e){super(t),this.response=e}}class Nc extends Ec{constructor(t){super(t)}load(t,e,i,n){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const s=wc.get(t);if(void 0!==s)return this.manager.itemStart(t),setTimeout((()=>{e&&e(s),this.manager.itemEnd(t)}),0),s;if(void 0!==Cc[t])return void Cc[t].push({onLoad:e,onProgress:i,onError:n});Cc[t]=[],Cc[t].push({onLoad:e,onProgress:i,onError:n});const r=new Request(t,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),a=this.mimeType,o=this.responseType;fetch(r).then((e=>{if(200===e.status||0===e.status){if(e.status,"undefined"==typeof ReadableStream||void 0===e.body||void 0===e.body.getReader)return e;const i=Cc[t],n=e.body.getReader(),s=e.headers.get("X-File-Size")||e.headers.get("Content-Length"),r=s?parseInt(s):0,a=0!==r;let o=0;const l=new ReadableStream({start(t){!function e(){n.read().then((({done:n,value:s})=>{if(n)t.close();else{o+=s.byteLength;const n=new ProgressEvent("progress",{lengthComputable:a,loaded:o,total:r});for(let t=0,e=i.length;t<e;t++){const e=i[t];e.onProgress&&e.onProgress(n)}t.enqueue(s),e()}}),(e=>{t.error(e)}))}()}});return new Response(l)}throw new Rc(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`,e)})).then((t=>{switch(o){case"arraybuffer":return t.arrayBuffer();case"blob":return t.blob();case"document":return t.text().then((t=>(new DOMParser).parseFromString(t,a)));case"json":return t.json();default:if(void 0===a)return t.text();{const e=/charset="?([^;"\s]*)"?/i.exec(a),i=e&&e[1]?e[1].toLowerCase():void 0,n=new TextDecoder(i);return t.arrayBuffer().then((t=>n.decode(t)))}}})).then((e=>{wc.add(t,e);const i=Cc[t];delete Cc[t];for(let t=0,n=i.length;t<n;t++){const n=i[t];n.onLoad&&n.onLoad(e)}})).catch((e=>{const i=Cc[t];if(void 0===i)throw this.manager.itemError(t),e;delete Cc[t];for(let t=0,n=i.length;t<n;t++){const n=i[t];n.onError&&n.onError(e)}this.manager.itemError(t)})).finally((()=>{this.manager.itemEnd(t)})),this.manager.itemStart(t)}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}}let Pc=class extends Ec{constructor(t){super(t)}load(t,e,i,n){void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const s=this,r=wc.get(t);if(void 0!==r)return s.manager.itemStart(t),setTimeout((function(){e&&e(r),s.manager.itemEnd(t)}),0),r;const a=ke("img");function o(){h(),wc.add(t,this),e&&e(this),s.manager.itemEnd(t)}function l(e){h(),n&&n(e),s.manager.itemError(t),s.manager.itemEnd(t)}function h(){a.removeEventListener("load",o,!1),a.removeEventListener("error",l,!1)}return a.addEventListener("load",o,!1),a.addEventListener("error",l,!1),"data:"!==t.slice(0,5)&&void 0!==this.crossOrigin&&(a.crossOrigin=this.crossOrigin),s.manager.itemStart(t),a.src=t,a}},Ic=class extends Ec{constructor(t){super(t)}load(t,e,i,n){const s=new si,r=new Pc(this.manager);return r.setCrossOrigin(this.crossOrigin),r.setPath(this.path),r.load(t,(function(t){s.image=t,s.needsUpdate=!0,void 0!==e&&e(s)}),i,n),s}},Lc=class extends fn{constructor(t,e=1){super(),this.isLight=!0,this.type="Light",this.color=new Dn(t),this.intensity=e}dispose(){}copy(t,e){return super.copy(t,e),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,void 0!==this.groundColor&&(e.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(e.object.distance=this.distance),void 0!==this.angle&&(e.object.angle=this.angle),void 0!==this.decay&&(e.object.decay=this.decay),void 0!==this.penumbra&&(e.object.penumbra=this.penumbra),void 0!==this.shadow&&(e.object.shadow=this.shadow.toJSON()),void 0!==this.target&&(e.object.target=this.target.uuid),e}},Dc=class extends Lc{constructor(t,e,i){super(t,i),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(fn.DEFAULT_UP),this.updateMatrix(),this.groundColor=new Dn(e)}copy(t,e){return super.copy(t,e),this.groundColor.copy(t.groundColor),this}};const Uc=new Vi,Fc=new ui,Bc=new ui;let Oc=class{constructor(t){this.camera=t,this.intensity=1,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Fe(512,512),this.map=null,this.mapPass=null,this.matrix=new Vi,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Ls,this._frameExtents=new Fe(1,1),this._viewportCount=1,this._viewports=[new ri(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,i=this.matrix;Fc.setFromMatrixPosition(t.matrixWorld),e.position.copy(Fc),Bc.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(Bc),e.updateMatrixWorld(),Uc.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Uc),i.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),i.multiply(Uc)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.intensity=t.intensity,this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return(new this.constructor).copy(this)}toJSON(){const t={};return 1!==this.intensity&&(t.intensity=this.intensity),0!==this.bias&&(t.bias=this.bias),0!==this.normalBias&&(t.normalBias=this.normalBias),1!==this.radius&&(t.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}},zc=class extends Oc{constructor(){super(new Ss(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(t){const e=this.camera,i=2*Ce*t.angle*this.focus,n=this.mapSize.width/this.mapSize.height,s=t.distance||e.far;i===e.fov&&n===e.aspect&&s===e.far||(e.fov=i,e.aspect=n,e.far=s,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}},kc=class extends Lc{constructor(t,e,i=0,n=Math.PI/3,s=0,r=2){super(t,e),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(fn.DEFAULT_UP),this.updateMatrix(),this.target=new fn,this.distance=i,this.angle=n,this.penumbra=s,this.decay=r,this.map=null,this.shadow=new zc}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}};const Vc=new Vi,Gc=new ui,Hc=new ui;let Wc,jc=class extends Oc{constructor(){super(new Ss(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new Fe(4,2),this._viewportCount=6,this._viewports=[new ri(2,1,1,1),new ri(0,1,1,1),new ri(3,1,1,1),new ri(1,1,1,1),new ri(3,0,1,1),new ri(1,0,1,1)],this._cubeDirections=[new ui(1,0,0),new ui(-1,0,0),new ui(0,0,1),new ui(0,0,-1),new ui(0,1,0),new ui(0,-1,0)],this._cubeUps=[new ui(0,1,0),new ui(0,1,0),new ui(0,1,0),new ui(0,1,0),new ui(0,0,1),new ui(0,0,-1)]}updateMatrices(t,e=0){const i=this.camera,n=this.matrix,s=t.distance||i.far;s!==i.far&&(i.far=s,i.updateProjectionMatrix()),Gc.setFromMatrixPosition(t.matrixWorld),i.position.copy(Gc),Hc.copy(i.position),Hc.add(this._cubeDirections[e]),i.up.copy(this._cubeUps[e]),i.lookAt(Hc),i.updateMatrixWorld(),n.makeTranslation(-Gc.x,-Gc.y,-Gc.z),Vc.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Vc)}},Xc=class extends Lc{constructor(t,e,i=0,n=2){super(t,e),this.isPointLight=!0,this.type="PointLight",this.distance=i,this.decay=n,this.shadow=new jc}get power(){return 4*this.intensity*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}},qc=class extends Oc{constructor(){super(new Ys(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}},$c=class extends Lc{constructor(t,e){super(t,e),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(fn.DEFAULT_UP),this.updateMatrix(),this.target=new fn,this.shadow=new qc}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}},Yc=class extends Lc{constructor(t,e){super(t,e),this.isAmbientLight=!0,this.type="AmbientLight"}},Zc=class extends Lc{constructor(t,e,i=10,n=10){super(t,e),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=i,this.height=n}get power(){return this.intensity*this.width*this.height*Math.PI}set power(t){this.intensity=t/(this.width*this.height*Math.PI)}copy(t){return super.copy(t),this.width=t.width,this.height=t.height,this}toJSON(t){const e=super.toJSON(t);return e.object.width=this.width,e.object.height=this.height,e}};class Kc{static decodeText(t){if("undefined"!=typeof TextDecoder)return(new TextDecoder).decode(t);let e="";for(let n=0,s=t.length;n<s;n++)e+=String.fromCharCode(t[n]);try{return decodeURIComponent(escape(e))}catch(i){return e}}static extractUrlBase(t){const e=t.lastIndexOf("/");return-1===e?"./":t.slice(0,e+1)}static resolveURL(t,e){return"string"!=typeof t||""===t?"":(/^https?:\/\//i.test(e)&&/^\//.test(t)&&(e=e.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(t)||/^data:.*,.*$/i.test(t)||/^blob:.*$/i.test(t)?t:e+t)}}class Jc extends Ec{constructor(t){super(t),this.isImageBitmapLoader=!0,this.options={premultiplyAlpha:"none"}}setOptions(t){return this.options=t,this}load(t,e,i,n){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const s=this,r=wc.get(t);if(void 0!==r)return s.manager.itemStart(t),r.then?void r.then((i=>{e&&e(i),s.manager.itemEnd(t)})).catch((t=>{n&&n(t)})):(setTimeout((function(){e&&e(r),s.manager.itemEnd(t)}),0),r);const a={};a.credentials="anonymous"===this.crossOrigin?"same-origin":"include",a.headers=this.requestHeader;const o=fetch(t,a).then((function(t){return t.blob()})).then((function(t){return createImageBitmap(t,Object.assign(s.options,{colorSpaceConversion:"none"}))})).then((function(i){return wc.add(t,i),e&&e(i),s.manager.itemEnd(t),i})).catch((function(e){n&&n(e),wc.remove(t),s.manager.itemError(t),s.manager.itemEnd(t)}));wc.add(t,o),s.manager.itemStart(t)}}class Qc{static getContext(){return void 0===Wc&&(Wc=new(window.AudioContext||window.webkitAudioContext)),Wc}static setContext(t){Wc=t}}class tu extends Ec{constructor(t){super(t)}load(t,e,i,n){const s=this,r=new Nc(this.manager);function a(e){n&&n(e),s.manager.itemError(t)}r.setResponseType("arraybuffer"),r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(t,(function(t){try{const i=t.slice(0);Qc.getContext().decodeAudioData(i,(function(t){e(t)})).catch(a)}catch(i){a(i)}}),i,n)}}let eu=class{constructor(t=!0){this.autoStart=t,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=iu(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let t=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const e=iu();t=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=t}return t}};function iu(){return performance.now()}const nu=new ui,su=new ci,ru=new ui,au=new ui;class ou extends fn{constructor(){super(),this.type="AudioListener",this.context=Qc.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new eu}getInput(){return this.gain}removeFilter(){return null!==this.filter&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(t){return null!==this.filter?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=t,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}updateMatrixWorld(t){super.updateMatrixWorld(t);const e=this.context.listener,i=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(nu,su,ru),au.set(0,0,-1).applyQuaternion(su),e.positionX){const t=this.context.currentTime+this.timeDelta;e.positionX.linearRampToValueAtTime(nu.x,t),e.positionY.linearRampToValueAtTime(nu.y,t),e.positionZ.linearRampToValueAtTime(nu.z,t),e.forwardX.linearRampToValueAtTime(au.x,t),e.forwardY.linearRampToValueAtTime(au.y,t),e.forwardZ.linearRampToValueAtTime(au.z,t),e.upX.linearRampToValueAtTime(i.x,t),e.upY.linearRampToValueAtTime(i.y,t),e.upZ.linearRampToValueAtTime(i.z,t)}else e.setPosition(nu.x,nu.y,nu.z),e.setOrientation(au.x,au.y,au.z,i.x,i.y,i.z)}}class lu extends fn{constructor(t){super(),this.type="Audio",this.listener=t,this.context=t.context,this.gain=this.context.createGain(),this.gain.connect(t.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(t){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=t,this.connect(),this}setMediaElementSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(t),this.connect(),this}setMediaStreamSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(t),this.connect(),this}setBuffer(t){return this.buffer=t,this.sourceType="buffer",this.autoplay&&this.play(),this}play(t=0){if(!0===this.isPlaying)return;if(!1===this.hasPlaybackControl)return;this._startedAt=this.context.currentTime+t;const e=this.context.createBufferSource();return e.buffer=this.buffer,e.loop=this.loop,e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.onended=this.onEnded.bind(this),e.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=e,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(!1!==this.hasPlaybackControl)return!0===this.isPlaying&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(t=0){if(!1!==this.hasPlaybackControl)return this._progress=0,null!==this.source&&(this.source.stop(this.context.currentTime+t),this.source.onended=null),this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].connect(this.filters[t]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(!1!==this._connected){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].disconnect(this.filters[t]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}}getFilters(){return this.filters}setFilters(t){return t||(t=[]),!0===this._connected?(this.disconnect(),this.filters=t.slice(),this.connect()):this.filters=t.slice(),this}setDetune(t){return this.detune=t,!0===this.isPlaying&&void 0!==this.source.detune&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(t){return this.setFilters(t?[t]:[])}setPlaybackRate(t){if(!1!==this.hasPlaybackControl)return this.playbackRate=t,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return!1!==this.hasPlaybackControl&&this.loop}setLoop(t){if(!1!==this.hasPlaybackControl)return this.loop=t,!0===this.isPlaying&&(this.source.loop=this.loop),this}setLoopStart(t){return this.loopStart=t,this}setLoopEnd(t){return this.loopEnd=t,this}getVolume(){return this.gain.gain.value}setVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}}class hu{constructor(t,e=2048){this.analyser=t.context.createAnalyser(),this.analyser.fftSize=e,this.data=new Uint8Array(this.analyser.frequencyBinCount),t.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let t=0;const e=this.getFrequencyData();for(let i=0;i<e.length;i++)t+=e[i];return t/e.length}}class cu{constructor(t,e,i){let n,s,r;switch(this.binding=t,this.valueSize=i,e){case"quaternion":n=this._slerp,s=this._slerpAdditive,r=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*i),this._workIndex=5;break;case"string":case"bool":n=this._select,s=this._select,r=this._setAdditiveIdentityOther,this.buffer=new Array(5*i);break;default:n=this._lerp,s=this._lerpAdditive,r=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*i)}this._mixBufferRegion=n,this._mixBufferRegionAdditive=s,this._setIdentity=r,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(t,e){const i=this.buffer,n=this.valueSize,s=t*n+n;let r=this.cumulativeWeight;if(0===r){for(let t=0;t!==n;++t)i[s+t]=i[t];r=e}else{r+=e;const t=e/r;this._mixBufferRegion(i,s,0,t,n)}this.cumulativeWeight=r}accumulateAdditive(t){const e=this.buffer,i=this.valueSize,n=i*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),this._mixBufferRegionAdditive(e,n,0,t,i),this.cumulativeWeightAdditive+=t}apply(t){const e=this.valueSize,i=this.buffer,n=t*e+e,s=this.cumulativeWeight,r=this.cumulativeWeightAdditive,a=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,s<1){const t=e*this._origIndex;this._mixBufferRegion(i,n,t,1-s,e)}r>0&&this._mixBufferRegionAdditive(i,n,this._addIndex*e,1,e);for(let o=e,l=e+e;o!==l;++o)if(i[o]!==i[o+e]){a.setValue(i,n);break}}saveOriginalState(){const t=this.binding,e=this.buffer,i=this.valueSize,n=i*this._origIndex;t.getValue(e,n);for(let s=i,r=n;s!==r;++s)e[s]=e[n+s%i];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const t=3*this.valueSize;this.binding.setValue(this.buffer,t)}_setAdditiveIdentityNumeric(){const t=this._addIndex*this.valueSize,e=t+this.valueSize;for(let i=t;i<e;i++)this.buffer[i]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const t=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let i=0;i<this.valueSize;i++)this.buffer[e+i]=this.buffer[t+i]}_select(t,e,i,n,s){if(n>=.5)for(let r=0;r!==s;++r)t[e+r]=t[i+r]}_slerp(t,e,i,n){ci.slerpFlat(t,e,t,e,t,i,n)}_slerpAdditive(t,e,i,n,s){const r=this._workIndex*s;ci.multiplyQuaternionsFlat(t,r,t,e,t,i),ci.slerpFlat(t,e,t,e,t,r,n)}_lerp(t,e,i,n,s){const r=1-n;for(let a=0;a!==s;++a){const s=e+a;t[s]=t[s]*r+t[i+a]*n}}_lerpAdditive(t,e,i,n,s){for(let r=0;r!==s;++r){const s=e+r;t[s]=t[s]+t[i+r]*n}}}const uu="\\[\\]\\.:\\/",du=new RegExp("["+uu+"]","g"),pu="[^"+uu+"]",mu="[^"+uu.replace("\\.","")+"]",fu=new RegExp("^"+/((?:WC+[\/:])*)/.source.replace("WC",pu)+/(WCOD+)?/.source.replace("WCOD",mu)+/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",pu)+/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",pu)+"$"),gu=["material","materials","bones","map"];class xu{constructor(t,e,i){this.path=e,this.parsedPath=i||xu.parseTrackName(e),this.node=xu.findNode(t,this.parsedPath.nodeName),this.rootNode=t,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,e,i){return t&&t.isAnimationObjectGroup?new xu.Composite(t,e,i):new xu(t,e,i)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(du,"")}static parseTrackName(t){const e=fu.exec(t);if(null===e)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const i={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},n=i.nodeName&&i.nodeName.lastIndexOf(".");if(void 0!==n&&-1!==n){const t=i.nodeName.substring(n+1);-1!==gu.indexOf(t)&&(i.nodeName=i.nodeName.substring(0,n),i.objectName=t)}if(null===i.propertyName||0===i.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return i}static findNode(t,e){if(void 0===e||""===e||"."===e||-1===e||e===t.name||e===t.uuid)return t;if(t.skeleton){const i=t.skeleton.getBoneByName(e);if(void 0!==i)return i}if(t.children){const i=function(t){for(let n=0;n<t.length;n++){const s=t[n];if(s.name===e||s.uuid===e)return s;const r=i(s.children);if(r)return r}return null},n=i(t.children);if(n)return n}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(t,e){t[e]=this.targetObject[this.propertyName]}_getValue_array(t,e){const i=this.resolvedProperty;for(let n=0,s=i.length;n!==s;++n)t[e++]=i[n]}_getValue_arrayElement(t,e){t[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,e){this.resolvedProperty.toArray(t,e)}_setValue_direct(t,e){this.targetObject[this.propertyName]=t[e]}_setValue_direct_setNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(t,e){const i=this.resolvedProperty;for(let n=0,s=i.length;n!==s;++n)i[n]=t[e++]}_setValue_array_setNeedsUpdate(t,e){const i=this.resolvedProperty;for(let n=0,s=i.length;n!==s;++n)i[n]=t[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,e){const i=this.resolvedProperty;for(let n=0,s=i.length;n!==s;++n)i[n]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(t,e){this.resolvedProperty[this.propertyIndex]=t[e]}_setValue_arrayElement_setNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(t,e){this.resolvedProperty.fromArray(t,e)}_setValue_fromArray_setNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,e){this.bind(),this.getValue(t,e)}_setValue_unbound(t,e){this.bind(),this.setValue(t,e)}bind(){let t=this.node;const e=this.parsedPath,i=e.objectName,n=e.propertyName;let s=e.propertyIndex;if(t||(t=xu.findNode(this.rootNode,e.nodeName),this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t)return;if(i){let n=e.objectIndex;switch(i){case"materials":if(!t.material)return;if(!t.material.materials)return;t=t.material.materials;break;case"bones":if(!t.skeleton)return;t=t.skeleton.bones;for(let e=0;e<t.length;e++)if(t[e].name===n){n=e;break}break;case"map":if("map"in t){t=t.map;break}if(!t.material)return;if(!t.material.map)return;t=t.material.map;break;default:if(void 0===t[i])return;t=t[i]}if(void 0!==n){if(void 0===t[n])return;t=t[n]}}const r=t[n];if(void 0===r){e.nodeName;return}let a=this.Versioning.None;this.targetObject=t,void 0!==t.needsUpdate?a=this.Versioning.NeedsUpdate:void 0!==t.matrixWorldNeedsUpdate&&(a=this.Versioning.MatrixWorldNeedsUpdate);let o=this.BindingType.Direct;if(void 0!==s){if("morphTargetInfluences"===n){if(!t.geometry)return;if(!t.geometry.morphAttributes)return;void 0!==t.morphTargetDictionary[s]&&(s=t.morphTargetDictionary[s])}o=this.BindingType.ArrayElement,this.resolvedProperty=r,this.propertyIndex=s}else void 0!==r.fromArray&&void 0!==r.toArray?(o=this.BindingType.HasFromToArray,this.resolvedProperty=r):Array.isArray(r)?(o=this.BindingType.EntireArray,this.resolvedProperty=r):this.propertyName=n;this.getValue=this.GetterByBindingType[o],this.setValue=this.SetterByBindingTypeAndVersioning[o][a]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}xu.Composite=class{constructor(t,e,i){const n=i||xu.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,n)}getValue(t,e){this.bind();const i=this._targetGroup.nCachedObjects_,n=this._bindings[i];void 0!==n&&n.getValue(t,e)}setValue(t,e){const i=this._bindings;for(let n=this._targetGroup.nCachedObjects_,s=i.length;n!==s;++n)i[n].setValue(t,e)}bind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,i=t.length;e!==i;++e)t[e].bind()}unbind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,i=t.length;e!==i;++e)t[e].unbind()}},xu.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},xu.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},xu.prototype.GetterByBindingType=[xu.prototype._getValue_direct,xu.prototype._getValue_array,xu.prototype._getValue_arrayElement,xu.prototype._getValue_toArray],xu.prototype.SetterByBindingTypeAndVersioning=[[xu.prototype._setValue_direct,xu.prototype._setValue_direct_setNeedsUpdate,xu.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[xu.prototype._setValue_array,xu.prototype._setValue_array_setNeedsUpdate,xu.prototype._setValue_array_setMatrixWorldNeedsUpdate],[xu.prototype._setValue_arrayElement,xu.prototype._setValue_arrayElement_setNeedsUpdate,xu.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[xu.prototype._setValue_fromArray,xu.prototype._setValue_fromArray_setNeedsUpdate,xu.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class vu{constructor(t,e,i=null,n=e.blendMode){this._mixer=t,this._clip=e,this._localRoot=i,this.blendMode=n;const s=e.tracks,r=s.length,a=new Array(r),o={endingStart:ie,endingEnd:ie};for(let l=0;l!==r;++l){const t=s[l].createInterpolant(null);a[l]=t,t.settings=o}this._interpolantSettings=o,this._interpolants=a,this._propertyBindings=new Array(r),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=2201,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,e){return this.loop=t,this.repetitions=e,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,e,i){if(t.fadeOut(e),this.fadeIn(e),i){const i=this._clip.duration,n=t._clip.duration,s=n/i,r=i/n;t.warp(1,s,e),this.warp(r,1,e)}return this}crossFadeTo(t,e,i){return t.crossFadeFrom(this,e,i)}stopFading(){const t=this._weightInterpolant;return null!==t&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,e,i){const n=this._mixer,s=n.time,r=this.timeScale;let a=this._timeScaleInterpolant;null===a&&(a=n._lendControlInterpolant(),this._timeScaleInterpolant=a);const o=a.parameterPositions,l=a.sampleValues;return o[0]=s,o[1]=s+i,l[0]=t/r,l[1]=e/r,this}stopWarping(){const t=this._timeScaleInterpolant;return null!==t&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,e,i,n){if(!this.enabled)return void this._updateWeight(t);const s=this._startTime;if(null!==s){const n=(t-s)*i;n<0||0===i?e=0:(this._startTime=null,e=i*n)}e*=this._updateTimeScale(t);const r=this._updateTime(e),a=this._updateWeight(t);if(a>0){const t=this._interpolants,e=this._propertyBindings;if(2501===this.blendMode)for(let i=0,n=t.length;i!==n;++i)t[i].evaluate(r),e[i].accumulateAdditive(a);else for(let i=0,s=t.length;i!==s;++i)t[i].evaluate(r),e[i].accumulate(n,a)}}_updateWeight(t){let e=0;if(this.enabled){e=this.weight;const i=this._weightInterpolant;if(null!==i){const n=i.evaluate(t)[0];e*=n,t>i.parameterPositions[1]&&(this.stopFading(),0===n&&(this.enabled=!1))}}return this._effectiveWeight=e,e}_updateTimeScale(t){let e=0;if(!this.paused){e=this.timeScale;const i=this._timeScaleInterpolant;if(null!==i){e*=i.evaluate(t)[0],t>i.parameterPositions[1]&&(this.stopWarping(),0===e?this.paused=!0:this.timeScale=e)}}return this._effectiveTimeScale=e,e}_updateTime(t){const e=this._clip.duration,i=this.loop;let n=this.time+t,s=this._loopCount;const r=2202===i;if(0===t)return-1===s||!r||1&~s?n:e-n;if(2200===i){-1===s&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(n>=e)n=e;else{if(!(n<0)){this.time=n;break t}n=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=n,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(-1===s&&(t>=0?(s=0,this._setEndings(!0,0===this.repetitions,r)):this._setEndings(0===this.repetitions,!0,r)),n>=e||n<0){const i=Math.floor(n/e);n-=e*i,s+=Math.abs(i);const a=this.repetitions-s;if(a<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,n=t>0?e:0,this.time=n,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(1===a){const e=t<0;this._setEndings(e,!e,r)}else this._setEndings(!1,!1,r);this._loopCount=s,this.time=n,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:i})}}else this.time=n;if(r&&!(1&~s))return e-n}return n}_setEndings(t,e,i){const n=this._interpolantSettings;i?(n.endingStart=ne,n.endingEnd=ne):(n.endingStart=t?this.zeroSlopeAtStart?ne:ie:se,n.endingEnd=e?this.zeroSlopeAtEnd?ne:ie:se)}_scheduleFading(t,e,i){const n=this._mixer,s=n.time;let r=this._weightInterpolant;null===r&&(r=n._lendControlInterpolant(),this._weightInterpolant=r);const a=r.parameterPositions,o=r.sampleValues;return a[0]=s,o[0]=e,a[1]=s+t,o[1]=i,this}}const _u=new Float32Array(1);class yu extends Te{constructor(t){super(),this._root=t,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(t,e){const i=t._localRoot||this._root,n=t._clip.tracks,s=n.length,r=t._propertyBindings,a=t._interpolants,o=i.uuid,l=this._bindingsByRootAndName;let h=l[o];void 0===h&&(h={},l[o]=h);for(let c=0;c!==s;++c){const t=n[c],s=t.name;let l=h[s];if(void 0!==l)++l.referenceCount,r[c]=l;else{if(l=r[c],void 0!==l){null===l._cacheIndex&&(++l.referenceCount,this._addInactiveBinding(l,o,s));continue}const n=e&&e._propertyBindings[c].binding.parsedPath;l=new cu(xu.create(i,s,n),t.ValueTypeName,t.getValueSize()),++l.referenceCount,this._addInactiveBinding(l,o,s),r[c]=l}a[c].resultBuffer=l.buffer}}_activateAction(t){if(!this._isActiveAction(t)){if(null===t._cacheIndex){const e=(t._localRoot||this._root).uuid,i=t._clip.uuid,n=this._actionsByClip[i];this._bindAction(t,n&&n.knownActions[0]),this._addInactiveAction(t,i,e)}const e=t._propertyBindings;for(let t=0,i=e.length;t!==i;++t){const i=e[t];0==i.useCount++&&(this._lendBinding(i),i.saveOriginalState())}this._lendAction(t)}}_deactivateAction(t){if(this._isActiveAction(t)){const e=t._propertyBindings;for(let t=0,i=e.length;t!==i;++t){const i=e[t];0==--i.useCount&&(i.restoreOriginalState(),this._takeBackBinding(i))}this._takeBackAction(t)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const t=this;this.stats={actions:{get total(){return t._actions.length},get inUse(){return t._nActiveActions}},bindings:{get total(){return t._bindings.length},get inUse(){return t._nActiveBindings}},controlInterpolants:{get total(){return t._controlInterpolants.length},get inUse(){return t._nActiveControlInterpolants}}}}_isActiveAction(t){const e=t._cacheIndex;return null!==e&&e<this._nActiveActions}_addInactiveAction(t,e,i){const n=this._actions,s=this._actionsByClip;let r=s[e];if(void 0===r)r={knownActions:[t],actionByRoot:{}},t._byClipCacheIndex=0,s[e]=r;else{const e=r.knownActions;t._byClipCacheIndex=e.length,e.push(t)}t._cacheIndex=n.length,n.push(t),r.actionByRoot[i]=t}_removeInactiveAction(t){const e=this._actions,i=e[e.length-1],n=t._cacheIndex;i._cacheIndex=n,e[n]=i,e.pop(),t._cacheIndex=null;const s=t._clip.uuid,r=this._actionsByClip,a=r[s],o=a.knownActions,l=o[o.length-1],h=t._byClipCacheIndex;l._byClipCacheIndex=h,o[h]=l,o.pop(),t._byClipCacheIndex=null;delete a.actionByRoot[(t._localRoot||this._root).uuid],0===o.length&&delete r[s],this._removeInactiveBindingsForAction(t)}_removeInactiveBindingsForAction(t){const e=t._propertyBindings;for(let i=0,n=e.length;i!==n;++i){const t=e[i];0==--t.referenceCount&&this._removeInactiveBinding(t)}}_lendAction(t){const e=this._actions,i=t._cacheIndex,n=this._nActiveActions++,s=e[n];t._cacheIndex=n,e[n]=t,s._cacheIndex=i,e[i]=s}_takeBackAction(t){const e=this._actions,i=t._cacheIndex,n=--this._nActiveActions,s=e[n];t._cacheIndex=n,e[n]=t,s._cacheIndex=i,e[i]=s}_addInactiveBinding(t,e,i){const n=this._bindingsByRootAndName,s=this._bindings;let r=n[e];void 0===r&&(r={},n[e]=r),r[i]=t,t._cacheIndex=s.length,s.push(t)}_removeInactiveBinding(t){const e=this._bindings,i=t.binding,n=i.rootNode.uuid,s=i.path,r=this._bindingsByRootAndName,a=r[n],o=e[e.length-1],l=t._cacheIndex;o._cacheIndex=l,e[l]=o,e.pop(),delete a[s],0===Object.keys(a).length&&delete r[n]}_lendBinding(t){const e=this._bindings,i=t._cacheIndex,n=this._nActiveBindings++,s=e[n];t._cacheIndex=n,e[n]=t,s._cacheIndex=i,e[i]=s}_takeBackBinding(t){const e=this._bindings,i=t._cacheIndex,n=--this._nActiveBindings,s=e[n];t._cacheIndex=n,e[n]=t,s._cacheIndex=i,e[i]=s}_lendControlInterpolant(){const t=this._controlInterpolants,e=this._nActiveControlInterpolants++;let i=t[e];return void 0===i&&(i=new pc(new Float32Array(2),new Float32Array(2),1,_u),i.__cacheIndex=e,t[e]=i),i}_takeBackControlInterpolant(t){const e=this._controlInterpolants,i=t.__cacheIndex,n=--this._nActiveControlInterpolants,s=e[n];t.__cacheIndex=n,e[n]=t,s.__cacheIndex=i,e[i]=s}clipAction(t,e,i){const n=e||this._root,s=n.uuid;let r="string"==typeof t?Mc.findByName(n,t):t;const a=null!==r?r.uuid:t,o=this._actionsByClip[a];let l=null;if(void 0===i&&(i=null!==r?r.blendMode:re),void 0!==o){const t=o.actionByRoot[s];if(void 0!==t&&t.blendMode===i)return t;l=o.knownActions[0],null===r&&(r=l._clip)}if(null===r)return null;const h=new vu(this,r,e,i);return this._bindAction(h,l),this._addInactiveAction(h,a,s),h}existingAction(t,e){const i=e||this._root,n=i.uuid,s="string"==typeof t?Mc.findByName(i,t):t,r=s?s.uuid:t,a=this._actionsByClip[r];return void 0!==a&&a.actionByRoot[n]||null}stopAllAction(){const t=this._actions;for(let e=this._nActiveActions-1;e>=0;--e)t[e].stop();return this}update(t){t*=this.timeScale;const e=this._actions,i=this._nActiveActions,n=this.time+=t,s=Math.sign(t),r=this._accuIndex^=1;for(let l=0;l!==i;++l){e[l]._update(n,t,s,r)}const a=this._bindings,o=this._nActiveBindings;for(let l=0;l!==o;++l)a[l].apply(r);return this}setTime(t){this.time=0;for(let e=0;e<this._actions.length;e++)this._actions[e].time=0;return this.update(t)}getRoot(){return this._root}uncacheClip(t){const e=this._actions,i=t.uuid,n=this._actionsByClip,s=n[i];if(void 0!==s){const t=s.knownActions;for(let i=0,n=t.length;i!==n;++i){const n=t[i];this._deactivateAction(n);const s=n._cacheIndex,r=e[e.length-1];n._cacheIndex=null,n._byClipCacheIndex=null,r._cacheIndex=s,e[s]=r,e.pop(),this._removeInactiveBindingsForAction(n)}delete n[i]}}uncacheRoot(t){const e=t.uuid,i=this._actionsByClip;for(const s in i){const t=i[s].actionByRoot[e];void 0!==t&&(this._deactivateAction(t),this._removeInactiveAction(t))}const n=this._bindingsByRootAndName[e];if(void 0!==n)for(const s in n){const t=n[s];t.restoreOriginalState(),this._removeInactiveBinding(t)}}uncacheAction(t,e){const i=this.existingAction(t,e);null!==i&&(this._deactivateAction(i),this._removeInactiveAction(i))}}const bu=new Vi;class Su{constructor(t,e,i=0,n=1/0){this.ray=new ki(t,e),this.near=i,this.far=n,this.camera=null,this.layers=new Ji,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(t,e){this.ray.set(t,e)}setFromCamera(t,e){e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(t.x,t.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e.isOrthographicCamera&&(this.ray.origin.set(t.x,t.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e)}setFromXRController(t){return bu.identity().extractRotation(t.matrixWorld),this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(0,0,-1).applyMatrix4(bu),this}intersectObject(t,e=!0,i=[]){return Tu(t,this,i,e),i.sort(Mu),i}intersectObjects(t,e=!0,i=[]){for(let n=0,s=t.length;n<s;n++)Tu(t[n],this,i,e);return i.sort(Mu),i}}function Mu(t,e){return t.distance-e.distance}function Tu(t,e,i,n){let s=!0;if(t.layers.test(e.layers)){!1===t.raycast(e,i)&&(s=!1)}if(!0===s&&!0===n){const n=t.children;for(let t=0,s=n.length;t<s;t++)Tu(n[t],e,i,!0)}}class wu{constructor(t=1,e=0,i=0){return this.radius=t,this.phi=e,this.theta=i,this}set(t,e,i){return this.radius=t,this.phi=e,this.theta=i,this}copy(t){return this.radius=t.radius,this.phi=t.phi,this.theta=t.theta,this}makeSafe(){const t=1e-6;return this.phi=Math.max(t,Math.min(Math.PI-t,this.phi)),this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,i){return this.radius=Math.sqrt(t*t+e*e+i*i),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(t,i),this.phi=Math.acos(Ne(e/this.radius,-1,1))),this}clone(){return(new this.constructor).copy(this)}}const Au=new ui,Eu=new ui;class Cu{constructor(t=new ui,e=new ui){this.start=t,this.end=e}set(t,e){return this.start.copy(t),this.end.copy(e),this}copy(t){return this.start.copy(t.start),this.end.copy(t.end),this}getCenter(t){return t.addVectors(this.start,this.end).multiplyScalar(.5)}delta(t){return t.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(t,e){return this.delta(e).multiplyScalar(t).add(this.start)}closestPointToPointParameter(t,e){Au.subVectors(t,this.start),Eu.subVectors(this.end,this.start);const i=Eu.dot(Eu);let n=Eu.dot(Au)/i;return e&&(n=Ne(n,0,1)),n}closestPointToPoint(t,e,i){const n=this.closestPointToPointParameter(t,e);return this.delta(i).multiplyScalar(n).add(this.start)}applyMatrix4(t){return this.start.applyMatrix4(t),this.end.applyMatrix4(t),this}equals(t){return t.start.equals(this.start)&&t.end.equals(this.end)}clone(){return(new this.constructor).copy(this)}}let Ru=class extends cs{constructor(t,e,i){super(new Kh(e,4,2),new On({wireframe:!0,fog:!1,toneMapped:!1})),this.light=t,this.color=i,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),void 0!==this.color?this.material.color.set(this.color):this.material.color.copy(this.light.color)}},Nu=class extends Nl{constructor(t=10,e=10,i=4473924,n=8947848){i=new Dn(i),n=new Dn(n);const s=e/2,r=t/e,a=t/2,o=[],l=[];for(let c=0,u=0,d=-a;c<=e;c++,d+=r){o.push(-a,0,d,a,0,d),o.push(d,0,-a,d,0,a);const t=c===s?i:n;t.toArray(l,u),u+=3,t.toArray(l,u),u+=3,t.toArray(l,u),u+=3,t.toArray(l,u),u+=3}const h=new Jn;h.setAttribute("position",new Wn(o,3)),h.setAttribute("color",new Wn(l,3));super(h,new vl({vertexColors:!0,toneMapped:!1})),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}};const Pu=new ui,Iu=new ui,Lu=new ui;let Du=class extends fn{constructor(t,e,i){super(),this.light=t,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=i,this.type="DirectionalLightHelper",void 0===e&&(e=1);let n=new Jn;n.setAttribute("position",new Wn([-e,e,0,e,e,0,e,-e,0,-e,-e,0,-e,e,0],3));const s=new vl({fog:!1,toneMapped:!1});this.lightPlane=new Al(n,s),this.add(this.lightPlane),n=new Jn,n.setAttribute("position",new Wn([0,0,0,0,0,1],3)),this.targetLine=new Al(n,s),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),Pu.setFromMatrixPosition(this.light.matrixWorld),Iu.setFromMatrixPosition(this.light.target.matrixWorld),Lu.subVectors(Iu,Pu),this.lightPlane.lookAt(Iu),void 0!==this.color?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(Iu),this.targetLine.scale.z=Lu.length()}};const Uu=new ui,Fu=new vs;class Bu extends Nl{constructor(t){const e=new Jn,i=new vl({color:16777215,vertexColors:!0,toneMapped:!1}),n=[],s=[],r={};function a(t,e){o(t),o(e)}function o(t){n.push(0,0,0),s.push(0,0,0),void 0===r[t]&&(r[t]=[]),r[t].push(n.length/3-1)}a("n1","n2"),a("n2","n4"),a("n4","n3"),a("n3","n1"),a("f1","f2"),a("f2","f4"),a("f4","f3"),a("f3","f1"),a("n1","f1"),a("n2","f2"),a("n3","f3"),a("n4","f4"),a("p","n1"),a("p","n2"),a("p","n3"),a("p","n4"),a("u1","u2"),a("u2","u3"),a("u3","u1"),a("c","t"),a("p","c"),a("cn1","cn2"),a("cn3","cn4"),a("cf1","cf2"),a("cf3","cf4"),e.setAttribute("position",new Wn(n,3)),e.setAttribute("color",new Wn(s,3)),super(e,i),this.type="CameraHelper",this.camera=t,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=r,this.update();const l=new Dn(16755200),h=new Dn(16711680),c=new Dn(43775),u=new Dn(16777215),d=new Dn(3355443);this.setColors(l,h,c,u,d)}setColors(t,e,i,n,s){const r=this.geometry.getAttribute("color");r.setXYZ(0,t.r,t.g,t.b),r.setXYZ(1,t.r,t.g,t.b),r.setXYZ(2,t.r,t.g,t.b),r.setXYZ(3,t.r,t.g,t.b),r.setXYZ(4,t.r,t.g,t.b),r.setXYZ(5,t.r,t.g,t.b),r.setXYZ(6,t.r,t.g,t.b),r.setXYZ(7,t.r,t.g,t.b),r.setXYZ(8,t.r,t.g,t.b),r.setXYZ(9,t.r,t.g,t.b),r.setXYZ(10,t.r,t.g,t.b),r.setXYZ(11,t.r,t.g,t.b),r.setXYZ(12,t.r,t.g,t.b),r.setXYZ(13,t.r,t.g,t.b),r.setXYZ(14,t.r,t.g,t.b),r.setXYZ(15,t.r,t.g,t.b),r.setXYZ(16,t.r,t.g,t.b),r.setXYZ(17,t.r,t.g,t.b),r.setXYZ(18,t.r,t.g,t.b),r.setXYZ(19,t.r,t.g,t.b),r.setXYZ(20,t.r,t.g,t.b),r.setXYZ(21,t.r,t.g,t.b),r.setXYZ(22,t.r,t.g,t.b),r.setXYZ(23,t.r,t.g,t.b),r.setXYZ(24,e.r,e.g,e.b),r.setXYZ(25,e.r,e.g,e.b),r.setXYZ(26,e.r,e.g,e.b),r.setXYZ(27,e.r,e.g,e.b),r.setXYZ(28,e.r,e.g,e.b),r.setXYZ(29,e.r,e.g,e.b),r.setXYZ(30,e.r,e.g,e.b),r.setXYZ(31,e.r,e.g,e.b),r.setXYZ(32,i.r,i.g,i.b),r.setXYZ(33,i.r,i.g,i.b),r.setXYZ(34,i.r,i.g,i.b),r.setXYZ(35,i.r,i.g,i.b),r.setXYZ(36,i.r,i.g,i.b),r.setXYZ(37,i.r,i.g,i.b),r.setXYZ(38,n.r,n.g,n.b),r.setXYZ(39,n.r,n.g,n.b),r.setXYZ(40,s.r,s.g,s.b),r.setXYZ(41,s.r,s.g,s.b),r.setXYZ(42,s.r,s.g,s.b),r.setXYZ(43,s.r,s.g,s.b),r.setXYZ(44,s.r,s.g,s.b),r.setXYZ(45,s.r,s.g,s.b),r.setXYZ(46,s.r,s.g,s.b),r.setXYZ(47,s.r,s.g,s.b),r.setXYZ(48,s.r,s.g,s.b),r.setXYZ(49,s.r,s.g,s.b),r.needsUpdate=!0}update(){const t=this.geometry,e=this.pointMap;Fu.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),Ou("c",e,t,Fu,0,0,-1),Ou("t",e,t,Fu,0,0,1),Ou("n1",e,t,Fu,-1,-1,-1),Ou("n2",e,t,Fu,1,-1,-1),Ou("n3",e,t,Fu,-1,1,-1),Ou("n4",e,t,Fu,1,1,-1),Ou("f1",e,t,Fu,-1,-1,1),Ou("f2",e,t,Fu,1,-1,1),Ou("f3",e,t,Fu,-1,1,1),Ou("f4",e,t,Fu,1,1,1),Ou("u1",e,t,Fu,.7,1.1,-1),Ou("u2",e,t,Fu,-.7,1.1,-1),Ou("u3",e,t,Fu,0,2,-1),Ou("cf1",e,t,Fu,-1,0,1),Ou("cf2",e,t,Fu,1,0,1),Ou("cf3",e,t,Fu,0,-1,1),Ou("cf4",e,t,Fu,0,1,1),Ou("cn1",e,t,Fu,-1,0,-1),Ou("cn2",e,t,Fu,1,0,-1),Ou("cn3",e,t,Fu,0,-1,-1),Ou("cn4",e,t,Fu,0,1,-1),t.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function Ou(t,e,i,n,s,r,a){Uu.set(s,r,a).unproject(n);const o=e[t];if(void 0!==o){const t=i.getAttribute("position");for(let e=0,i=o.length;e<i;e++)t.setXYZ(o[e],Uu.x,Uu.y,Uu.z)}}class zu extends Al{constructor(t,e=1,i=16776960){const n=i,s=new Jn;s.setAttribute("position",new Wn([1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],3)),s.computeBoundingSphere(),super(s,new vl({color:n,toneMapped:!1})),this.type="PlaneHelper",this.plane=t,this.size=e;const r=new Jn;r.setAttribute("position",new Wn([1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],3)),r.computeBoundingSphere(),this.add(new cs(r,new On({color:n,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(t){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(t)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}let ku=class extends Nl{constructor(t=1){const e=[0,0,0,t,0,0,0,0,0,0,t,0,0,0,0,0,0,t],i=new Jn;i.setAttribute("position",new Wn(e,3)),i.setAttribute("color",new Wn([1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],3));super(i,new vl({vertexColors:!0,toneMapped:!1})),this.type="AxesHelper"}setColors(t,e,i){const n=new Dn,s=this.geometry.attributes.color.array;return n.set(t),n.toArray(s,0),n.toArray(s,3),n.set(e),n.toArray(s,6),n.toArray(s,9),n.set(i),n.toArray(s,12),n.toArray(s,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}};class Vu{constructor(){this.type="ShapePath",this.color=new Dn,this.subPaths=[],this.currentPath=null}moveTo(t,e){return this.currentPath=new ah,this.subPaths.push(this.currentPath),this.currentPath.moveTo(t,e),this}lineTo(t,e){return this.currentPath.lineTo(t,e),this}quadraticCurveTo(t,e,i,n){return this.currentPath.quadraticCurveTo(t,e,i,n),this}bezierCurveTo(t,e,i,n,s,r){return this.currentPath.bezierCurveTo(t,e,i,n,s,r),this}splineThru(t){return this.currentPath.splineThru(t),this}toShapes(t){function e(t,e){const i=e.length;let n=!1;for(let s=i-1,r=0;r<i;s=r++){let i=e[s],a=e[r],o=a.x-i.x,l=a.y-i.y;if(Math.abs(l)>Number.EPSILON){if(l<0&&(i=e[r],o=-o,a=e[s],l=-l),t.y<i.y||t.y>a.y)continue;if(t.y===i.y){if(t.x===i.x)return!0}else{const e=l*(t.x-i.x)-o*(t.y-i.y);if(0===e)return!0;if(e<0)continue;n=!n}}else{if(t.y!==i.y)continue;if(a.x<=t.x&&t.x<=i.x||i.x<=t.x&&t.x<=a.x)return!0}}return n}const i=Wh.isClockWise,n=this.subPaths;if(0===n.length)return[];let s,r,a;const o=[];if(1===n.length)return r=n[0],a=new vh,a.curves=r.curves,o.push(a),o;let l=!i(n[0].getPoints());l=t?!l:l;const h=[],c=[];let u,d,p=[],m=0;c[m]=void 0,p[m]=[];for(let f=0,g=n.length;f<g;f++)r=n[f],u=r.getPoints(),s=i(u),s=t?!s:s,s?(!l&&c[m]&&m++,c[m]={s:new vh,p:u},c[m].s.curves=r.curves,l&&m++,p[m]=[]):p[m].push({h:r,p:u[0]});if(!c[0])return function(t){const e=[];for(let i=0,n=t.length;i<n;i++){const n=t[i],s=new vh;s.curves=n.curves,e.push(s)}return e}(n);if(c.length>1){let t=!1,i=0;for(let e=0,n=c.length;e<n;e++)h[e]=[];for(let n=0,s=c.length;n<s;n++){const s=p[n];for(let r=0;r<s.length;r++){const a=s[r];let o=!0;for(let s=0;s<c.length;s++)e(a.p,c[s].p)&&(n!==s&&i++,o?(o=!1,h[s].push(a)):t=!0);o&&h[n].push(a)}}i>0&&!1===t&&(p=h)}for(let f=0,g=c.length;f<g;f++){a=c[f].s,o.push(a),d=p[f];for(let t=0,e=d.length;t<e;t++)a.holes.push(d[t].h)}return o}}class Gu extends Te{constructor(t,e=null){super(),this.object=t,this.domElement=e,this.enabled=!0,this.state=-1,this.keys={},this.mouseButtons={LEFT:null,MIDDLE:null,RIGHT:null},this.touches={ONE:null,TWO:null}}connect(){}disconnect(){}dispose(){}update(){}}"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:i}})),"undefined"!=typeof window&&(window.__THREE__||(window.__THREE__=i));const Hu={type:"change"},Wu={type:"start"},ju={type:"end"},Xu=new ki,qu=new Ns,$u=Math.cos(70*Ue.DEG2RAD),Yu=new ui,Zu=2*Math.PI,Ku=-1,Ju=0,Qu=1,td=2,ed=3,id=4,nd=5,sd=6,rd=1e-6;class ad extends Gu{constructor(t,e=null){super(t,e),this.state=Ku,this.enabled=!0,this.target=new ui,this.cursor=new ui,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minTargetRadius=0,this.maxTargetRadius=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.zoomToCursor=!1,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:n,MIDDLE:s,RIGHT:r},this.touches={ONE:a,TWO:l},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this._lastPosition=new ui,this._lastQuaternion=new ci,this._lastTargetPosition=new ui,this._quat=(new ci).setFromUnitVectors(t.up,new ui(0,1,0)),this._quatInverse=this._quat.clone().invert(),this._spherical=new wu,this._sphericalDelta=new wu,this._scale=1,this._panOffset=new ui,this._rotateStart=new Fe,this._rotateEnd=new Fe,this._rotateDelta=new Fe,this._panStart=new Fe,this._panEnd=new Fe,this._panDelta=new Fe,this._dollyStart=new Fe,this._dollyEnd=new Fe,this._dollyDelta=new Fe,this._dollyDirection=new ui,this._mouse=new Fe,this._performCursorZoom=!1,this._pointers=[],this._pointerPositions={},this._controlActive=!1,this._onPointerMove=ld.bind(this),this._onPointerDown=od.bind(this),this._onPointerUp=hd.bind(this),this._onContextMenu=gd.bind(this),this._onMouseWheel=dd.bind(this),this._onKeyDown=pd.bind(this),this._onTouchStart=md.bind(this),this._onTouchMove=fd.bind(this),this._onMouseDown=cd.bind(this),this._onMouseMove=ud.bind(this),this._interceptControlDown=xd.bind(this),this._interceptControlUp=vd.bind(this),null!==this.domElement&&this.connect(),this.update()}connect(){this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointercancel",this._onPointerUp),this.domElement.addEventListener("contextmenu",this._onContextMenu),this.domElement.addEventListener("wheel",this._onMouseWheel,{passive:!1});this.domElement.getRootNode().addEventListener("keydown",this._interceptControlDown,{passive:!0,capture:!0}),this.domElement.style.touchAction="none"}disconnect(){this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.domElement.removeEventListener("pointercancel",this._onPointerUp),this.domElement.removeEventListener("wheel",this._onMouseWheel),this.domElement.removeEventListener("contextmenu",this._onContextMenu),this.stopListenToKeyEvents();this.domElement.getRootNode().removeEventListener("keydown",this._interceptControlDown,{capture:!0}),this.domElement.style.touchAction="auto"}dispose(){this.disconnect()}getPolarAngle(){return this._spherical.phi}getAzimuthalAngle(){return this._spherical.theta}getDistance(){return this.object.position.distanceTo(this.target)}listenToKeyEvents(t){t.addEventListener("keydown",this._onKeyDown),this._domElementKeyEvents=t}stopListenToKeyEvents(){null!==this._domElementKeyEvents&&(this._domElementKeyEvents.removeEventListener("keydown",this._onKeyDown),this._domElementKeyEvents=null)}saveState(){this.target0.copy(this.target),this.position0.copy(this.object.position),this.zoom0=this.object.zoom}reset(){this.target.copy(this.target0),this.object.position.copy(this.position0),this.object.zoom=this.zoom0,this.object.updateProjectionMatrix(),this.dispatchEvent(Hu),this.update(),this.state=Ku}update(t=null){const e=this.object.position;Yu.copy(e).sub(this.target),Yu.applyQuaternion(this._quat),this._spherical.setFromVector3(Yu),this.autoRotate&&this.state===Ku&&this._rotateLeft(this._getAutoRotationAngle(t)),this.enableDamping?(this._spherical.theta+=this._sphericalDelta.theta*this.dampingFactor,this._spherical.phi+=this._sphericalDelta.phi*this.dampingFactor):(this._spherical.theta+=this._sphericalDelta.theta,this._spherical.phi+=this._sphericalDelta.phi);let i=this.minAzimuthAngle,n=this.maxAzimuthAngle;isFinite(i)&&isFinite(n)&&(i<-Math.PI?i+=Zu:i>Math.PI&&(i-=Zu),n<-Math.PI?n+=Zu:n>Math.PI&&(n-=Zu),this._spherical.theta=i<=n?Math.max(i,Math.min(n,this._spherical.theta)):this._spherical.theta>(i+n)/2?Math.max(i,this._spherical.theta):Math.min(n,this._spherical.theta)),this._spherical.phi=Math.max(this.minPolarAngle,Math.min(this.maxPolarAngle,this._spherical.phi)),this._spherical.makeSafe(),!0===this.enableDamping?this.target.addScaledVector(this._panOffset,this.dampingFactor):this.target.add(this._panOffset),this.target.sub(this.cursor),this.target.clampLength(this.minTargetRadius,this.maxTargetRadius),this.target.add(this.cursor);let s=!1;if(this.zoomToCursor&&this._performCursorZoom||this.object.isOrthographicCamera)this._spherical.radius=this._clampDistance(this._spherical.radius);else{const t=this._spherical.radius;this._spherical.radius=this._clampDistance(this._spherical.radius*this._scale),s=t!=this._spherical.radius}if(Yu.setFromSpherical(this._spherical),Yu.applyQuaternion(this._quatInverse),e.copy(this.target).add(Yu),this.object.lookAt(this.target),!0===this.enableDamping?(this._sphericalDelta.theta*=1-this.dampingFactor,this._sphericalDelta.phi*=1-this.dampingFactor,this._panOffset.multiplyScalar(1-this.dampingFactor)):(this._sphericalDelta.set(0,0,0),this._panOffset.set(0,0,0)),this.zoomToCursor&&this._performCursorZoom){let t=null;if(this.object.isPerspectiveCamera){const e=Yu.length();t=this._clampDistance(e*this._scale);const i=e-t;this.object.position.addScaledVector(this._dollyDirection,i),this.object.updateMatrixWorld(),s=!!i}else if(this.object.isOrthographicCamera){const e=new ui(this._mouse.x,this._mouse.y,0);e.unproject(this.object);const i=this.object.zoom;this.object.zoom=Math.max(this.minZoom,Math.min(this.maxZoom,this.object.zoom/this._scale)),this.object.updateProjectionMatrix(),s=i!==this.object.zoom;const n=new ui(this._mouse.x,this._mouse.y,0);n.unproject(this.object),this.object.position.sub(n).add(e),this.object.updateMatrixWorld(),t=Yu.length()}else this.zoomToCursor=!1;null!==t&&(this.screenSpacePanning?this.target.set(0,0,-1).transformDirection(this.object.matrix).multiplyScalar(t).add(this.object.position):(Xu.origin.copy(this.object.position),Xu.direction.set(0,0,-1).transformDirection(this.object.matrix),Math.abs(this.object.up.dot(Xu.direction))<$u?this.object.lookAt(this.target):(qu.setFromNormalAndCoplanarPoint(this.object.up,this.target),Xu.intersectPlane(qu,this.target))))}else if(this.object.isOrthographicCamera){const t=this.object.zoom;this.object.zoom=Math.max(this.minZoom,Math.min(this.maxZoom,this.object.zoom/this._scale)),t!==this.object.zoom&&(this.object.updateProjectionMatrix(),s=!0)}return this._scale=1,this._performCursorZoom=!1,!!(s||this._lastPosition.distanceToSquared(this.object.position)>rd||8*(1-this._lastQuaternion.dot(this.object.quaternion))>rd||this._lastTargetPosition.distanceToSquared(this.target)>rd)&&(this.dispatchEvent(Hu),this._lastPosition.copy(this.object.position),this._lastQuaternion.copy(this.object.quaternion),this._lastTargetPosition.copy(this.target),!0)}_getAutoRotationAngle(t){return null!==t?Zu/60*this.autoRotateSpeed*t:Zu/60/60*this.autoRotateSpeed}_getZoomScale(t){const e=Math.abs(.01*t);return Math.pow(.95,this.zoomSpeed*e)}_rotateLeft(t){this._sphericalDelta.theta-=t}_rotateUp(t){this._sphericalDelta.phi-=t}_panLeft(t,e){Yu.setFromMatrixColumn(e,0),Yu.multiplyScalar(-t),this._panOffset.add(Yu)}_panUp(t,e){!0===this.screenSpacePanning?Yu.setFromMatrixColumn(e,1):(Yu.setFromMatrixColumn(e,0),Yu.crossVectors(this.object.up,Yu)),Yu.multiplyScalar(t),this._panOffset.add(Yu)}_pan(t,e){const i=this.domElement;if(this.object.isPerspectiveCamera){const n=this.object.position;Yu.copy(n).sub(this.target);let s=Yu.length();s*=Math.tan(this.object.fov/2*Math.PI/180),this._panLeft(2*t*s/i.clientHeight,this.object.matrix),this._panUp(2*e*s/i.clientHeight,this.object.matrix)}else this.object.isOrthographicCamera?(this._panLeft(t*(this.object.right-this.object.left)/this.object.zoom/i.clientWidth,this.object.matrix),this._panUp(e*(this.object.top-this.object.bottom)/this.object.zoom/i.clientHeight,this.object.matrix)):this.enablePan=!1}_dollyOut(t){this.object.isPerspectiveCamera||this.object.isOrthographicCamera?this._scale/=t:this.enableZoom=!1}_dollyIn(t){this.object.isPerspectiveCamera||this.object.isOrthographicCamera?this._scale*=t:this.enableZoom=!1}_updateZoomParameters(t,e){if(!this.zoomToCursor)return;this._performCursorZoom=!0;const i=this.domElement.getBoundingClientRect(),n=t-i.left,s=e-i.top,r=i.width,a=i.height;this._mouse.x=n/r*2-1,this._mouse.y=-s/a*2+1,this._dollyDirection.set(this._mouse.x,this._mouse.y,1).unproject(this.object).sub(this.object.position).normalize()}_clampDistance(t){return Math.max(this.minDistance,Math.min(this.maxDistance,t))}_handleMouseDownRotate(t){this._rotateStart.set(t.clientX,t.clientY)}_handleMouseDownDolly(t){this._updateZoomParameters(t.clientX,t.clientX),this._dollyStart.set(t.clientX,t.clientY)}_handleMouseDownPan(t){this._panStart.set(t.clientX,t.clientY)}_handleMouseMoveRotate(t){this._rotateEnd.set(t.clientX,t.clientY),this._rotateDelta.subVectors(this._rotateEnd,this._rotateStart).multiplyScalar(this.rotateSpeed);const e=this.domElement;this._rotateLeft(Zu*this._rotateDelta.x/e.clientHeight),this._rotateUp(Zu*this._rotateDelta.y/e.clientHeight),this._rotateStart.copy(this._rotateEnd),this.update()}_handleMouseMoveDolly(t){this._dollyEnd.set(t.clientX,t.clientY),this._dollyDelta.subVectors(this._dollyEnd,this._dollyStart),this._dollyDelta.y>0?this._dollyOut(this._getZoomScale(this._dollyDelta.y)):this._dollyDelta.y<0&&this._dollyIn(this._getZoomScale(this._dollyDelta.y)),this._dollyStart.copy(this._dollyEnd),this.update()}_handleMouseMovePan(t){this._panEnd.set(t.clientX,t.clientY),this._panDelta.subVectors(this._panEnd,this._panStart).multiplyScalar(this.panSpeed),this._pan(this._panDelta.x,this._panDelta.y),this._panStart.copy(this._panEnd),this.update()}_handleMouseWheel(t){this._updateZoomParameters(t.clientX,t.clientY),t.deltaY<0?this._dollyIn(this._getZoomScale(t.deltaY)):t.deltaY>0&&this._dollyOut(this._getZoomScale(t.deltaY)),this.update()}_handleKeyDown(t){let e=!1;switch(t.code){case this.keys.UP:t.ctrlKey||t.metaKey||t.shiftKey?this._rotateUp(Zu*this.rotateSpeed/this.domElement.clientHeight):this._pan(0,this.keyPanSpeed),e=!0;break;case this.keys.BOTTOM:t.ctrlKey||t.metaKey||t.shiftKey?this._rotateUp(-Zu*this.rotateSpeed/this.domElement.clientHeight):this._pan(0,-this.keyPanSpeed),e=!0;break;case this.keys.LEFT:t.ctrlKey||t.metaKey||t.shiftKey?this._rotateLeft(Zu*this.rotateSpeed/this.domElement.clientHeight):this._pan(this.keyPanSpeed,0),e=!0;break;case this.keys.RIGHT:t.ctrlKey||t.metaKey||t.shiftKey?this._rotateLeft(-Zu*this.rotateSpeed/this.domElement.clientHeight):this._pan(-this.keyPanSpeed,0),e=!0}e&&(t.preventDefault(),this.update())}_handleTouchStartRotate(t){if(1===this._pointers.length)this._rotateStart.set(t.pageX,t.pageY);else{const e=this._getSecondPointerPosition(t),i=.5*(t.pageX+e.x),n=.5*(t.pageY+e.y);this._rotateStart.set(i,n)}}_handleTouchStartPan(t){if(1===this._pointers.length)this._panStart.set(t.pageX,t.pageY);else{const e=this._getSecondPointerPosition(t),i=.5*(t.pageX+e.x),n=.5*(t.pageY+e.y);this._panStart.set(i,n)}}_handleTouchStartDolly(t){const e=this._getSecondPointerPosition(t),i=t.pageX-e.x,n=t.pageY-e.y,s=Math.sqrt(i*i+n*n);this._dollyStart.set(0,s)}_handleTouchStartDollyPan(t){this.enableZoom&&this._handleTouchStartDolly(t),this.enablePan&&this._handleTouchStartPan(t)}_handleTouchStartDollyRotate(t){this.enableZoom&&this._handleTouchStartDolly(t),this.enableRotate&&this._handleTouchStartRotate(t)}_handleTouchMoveRotate(t){if(1==this._pointers.length)this._rotateEnd.set(t.pageX,t.pageY);else{const e=this._getSecondPointerPosition(t),i=.5*(t.pageX+e.x),n=.5*(t.pageY+e.y);this._rotateEnd.set(i,n)}this._rotateDelta.subVectors(this._rotateEnd,this._rotateStart).multiplyScalar(this.rotateSpeed);const e=this.domElement;this._rotateLeft(Zu*this._rotateDelta.x/e.clientHeight),this._rotateUp(Zu*this._rotateDelta.y/e.clientHeight),this._rotateStart.copy(this._rotateEnd)}_handleTouchMovePan(t){if(1===this._pointers.length)this._panEnd.set(t.pageX,t.pageY);else{const e=this._getSecondPointerPosition(t),i=.5*(t.pageX+e.x),n=.5*(t.pageY+e.y);this._panEnd.set(i,n)}this._panDelta.subVectors(this._panEnd,this._panStart).multiplyScalar(this.panSpeed),this._pan(this._panDelta.x,this._panDelta.y),this._panStart.copy(this._panEnd)}_handleTouchMoveDolly(t){const e=this._getSecondPointerPosition(t),i=t.pageX-e.x,n=t.pageY-e.y,s=Math.sqrt(i*i+n*n);this._dollyEnd.set(0,s),this._dollyDelta.set(0,Math.pow(this._dollyEnd.y/this._dollyStart.y,this.zoomSpeed)),this._dollyOut(this._dollyDelta.y),this._dollyStart.copy(this._dollyEnd);const r=.5*(t.pageX+e.x),a=.5*(t.pageY+e.y);this._updateZoomParameters(r,a)}_handleTouchMoveDollyPan(t){this.enableZoom&&this._handleTouchMoveDolly(t),this.enablePan&&this._handleTouchMovePan(t)}_handleTouchMoveDollyRotate(t){this.enableZoom&&this._handleTouchMoveDolly(t),this.enableRotate&&this._handleTouchMoveRotate(t)}_addPointer(t){this._pointers.push(t.pointerId)}_removePointer(t){delete this._pointerPositions[t.pointerId];for(let e=0;e<this._pointers.length;e++)if(this._pointers[e]==t.pointerId)return void this._pointers.splice(e,1)}_isTrackingPointer(t){for(let e=0;e<this._pointers.length;e++)if(this._pointers[e]==t.pointerId)return!0;return!1}_trackPointer(t){let e=this._pointerPositions[t.pointerId];void 0===e&&(e=new Fe,this._pointerPositions[t.pointerId]=e),e.set(t.pageX,t.pageY)}_getSecondPointerPosition(t){const e=t.pointerId===this._pointers[0]?this._pointers[1]:this._pointers[0];return this._pointerPositions[e]}_customWheelEvent(t){const e=t.deltaMode,i={clientX:t.clientX,clientY:t.clientY,deltaY:t.deltaY};switch(e){case 1:i.deltaY*=16;break;case 2:i.deltaY*=100}return t.ctrlKey&&!this._controlActive&&(i.deltaY*=10),i}}function od(t){!1!==this.enabled&&(0===this._pointers.length&&(this.domElement.setPointerCapture(t.pointerId),this.domElement.addEventListener("pointermove",this._onPointerMove),this.domElement.addEventListener("pointerup",this._onPointerUp)),this._isTrackingPointer(t)||(this._addPointer(t),"touch"===t.pointerType?this._onTouchStart(t):this._onMouseDown(t)))}function ld(t){!1!==this.enabled&&("touch"===t.pointerType?this._onTouchMove(t):this._onMouseMove(t))}function hd(t){switch(this._removePointer(t),this._pointers.length){case 0:this.domElement.releasePointerCapture(t.pointerId),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.dispatchEvent(ju),this.state=Ku;break;case 1:const e=this._pointers[0],i=this._pointerPositions[e];this._onTouchStart({pointerId:e,pageX:i.x,pageY:i.y})}}function cd(t){let e;switch(t.button){case 0:e=this.mouseButtons.LEFT;break;case 1:e=this.mouseButtons.MIDDLE;break;case 2:e=this.mouseButtons.RIGHT;break;default:e=-1}switch(e){case s:if(!1===this.enableZoom)return;this._handleMouseDownDolly(t),this.state=Qu;break;case n:if(t.ctrlKey||t.metaKey||t.shiftKey){if(!1===this.enablePan)return;this._handleMouseDownPan(t),this.state=td}else{if(!1===this.enableRotate)return;this._handleMouseDownRotate(t),this.state=Ju}break;case r:if(t.ctrlKey||t.metaKey||t.shiftKey){if(!1===this.enableRotate)return;this._handleMouseDownRotate(t),this.state=Ju}else{if(!1===this.enablePan)return;this._handleMouseDownPan(t),this.state=td}break;default:this.state=Ku}this.state!==Ku&&this.dispatchEvent(Wu)}function ud(t){switch(this.state){case Ju:if(!1===this.enableRotate)return;this._handleMouseMoveRotate(t);break;case Qu:if(!1===this.enableZoom)return;this._handleMouseMoveDolly(t);break;case td:if(!1===this.enablePan)return;this._handleMouseMovePan(t)}}function dd(t){!1!==this.enabled&&!1!==this.enableZoom&&this.state===Ku&&(t.preventDefault(),this.dispatchEvent(Wu),this._handleMouseWheel(this._customWheelEvent(t)),this.dispatchEvent(ju))}function pd(t){!1!==this.enabled&&!1!==this.enablePan&&this._handleKeyDown(t)}function md(t){switch(this._trackPointer(t),this._pointers.length){case 1:switch(this.touches.ONE){case a:if(!1===this.enableRotate)return;this._handleTouchStartRotate(t),this.state=ed;break;case o:if(!1===this.enablePan)return;this._handleTouchStartPan(t),this.state=id;break;default:this.state=Ku}break;case 2:switch(this.touches.TWO){case l:if(!1===this.enableZoom&&!1===this.enablePan)return;this._handleTouchStartDollyPan(t),this.state=nd;break;case h:if(!1===this.enableZoom&&!1===this.enableRotate)return;this._handleTouchStartDollyRotate(t),this.state=sd;break;default:this.state=Ku}break;default:this.state=Ku}this.state!==Ku&&this.dispatchEvent(Wu)}function fd(t){switch(this._trackPointer(t),this.state){case ed:if(!1===this.enableRotate)return;this._handleTouchMoveRotate(t),this.update();break;case id:if(!1===this.enablePan)return;this._handleTouchMovePan(t),this.update();break;case nd:if(!1===this.enableZoom&&!1===this.enablePan)return;this._handleTouchMoveDollyPan(t),this.update();break;case sd:if(!1===this.enableZoom&&!1===this.enableRotate)return;this._handleTouchMoveDollyRotate(t),this.update();break;default:this.state=Ku}}function gd(t){!1!==this.enabled&&t.preventDefault()}function xd(t){if("Control"===t.key){this._controlActive=!0;this.domElement.getRootNode().addEventListener("keyup",this._interceptControlUp,{passive:!0,capture:!0})}}function vd(t){if("Control"===t.key){this._controlActive=!1;this.domElement.getRootNode().removeEventListener("keyup",this._interceptControlUp,{passive:!0,capture:!0})}}var _d=function(){var t=0,e=document.createElement("div");function i(t){return e.appendChild(t.dom),t}function n(i){for(var n=0;n<e.children.length;n++)e.children[n].style.display=n===i?"block":"none";t=i}e.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",e.addEventListener("click",(function(i){i.preventDefault(),n(++t%e.children.length)}),!1);var s=(performance||Date).now(),r=s,a=0,o=i(new _d.Panel("FPS","#0ff","#002")),l=i(new _d.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var h=i(new _d.Panel("MB","#f08","#201"));return n(0),{REVISION:16,dom:e,addPanel:i,showPanel:n,begin:function(){s=(performance||Date).now()},end:function(){a++;var t=(performance||Date).now();if(l.update(t-s,200),t>=r+1e3&&(o.update(1e3*a/(t-r),100),r=t,a=0,h)){var e=performance.memory;h.update(e.usedJSHeapSize/1048576,e.jsHeapSizeLimit/1048576)}return t},update:function(){s=this.end()},domElement:e,setMode:n}};_d.Panel=function(t,e,i){var n=1/0,s=0,r=Math.round,a=r(window.devicePixelRatio||1),o=80*a,l=48*a,h=3*a,c=2*a,u=3*a,d=15*a,p=74*a,m=30*a,f=document.createElement("canvas");f.width=o,f.height=l,f.style.cssText="width:80px;height:48px";var g=f.getContext("2d");return g.font="bold "+9*a+"px Helvetica,Arial,sans-serif",g.textBaseline="top",g.fillStyle=i,g.fillRect(0,0,o,l),g.fillStyle=e,g.fillText(t,h,c),g.fillRect(u,d,p,m),g.fillStyle=i,g.globalAlpha=.9,g.fillRect(u,d,p,m),{dom:f,update:function(l,x){n=Math.min(n,l),s=Math.max(s,l),g.fillStyle=i,g.globalAlpha=1,g.fillRect(0,0,o,d),g.fillStyle=e,g.fillText(r(l)+" "+t+" ("+r(n)+"-"+r(s)+")",h,c),g.drawImage(f,u+a,d,p-a,m,u,d,p-a,m),g.fillRect(u+p-a,d,a,m),g.fillStyle=i,g.globalAlpha=.9,g.fillRect(u+p-a,d,a,r((1-l/x)*m))}}};
/**
 * lil-gui
 * https://lil-gui.georgealways.com
 * @version 0.17.0
 * @author George Michael Brower
 * @license MIT
 */
class yd{constructor(t,e,i,n,s="div"){this.parent=t,this.object=e,this.property=i,this._disabled=!1,this._hidden=!1,this.initialValue=this.getValue(),this.domElement=document.createElement("div"),this.domElement.classList.add("controller"),this.domElement.classList.add(n),this.$name=document.createElement("div"),this.$name.classList.add("name"),yd.nextNameID=yd.nextNameID||0,this.$name.id="lil-gui-name-"+ ++yd.nextNameID,this.$widget=document.createElement(s),this.$widget.classList.add("widget"),this.$disable=this.$widget,this.domElement.appendChild(this.$name),this.domElement.appendChild(this.$widget),this.parent.children.push(this),this.parent.controllers.push(this),this.parent.$children.appendChild(this.domElement),this._listenCallback=this._listenCallback.bind(this),this.name(i)}name(t){return this._name=t,this.$name.innerHTML=t,this}onChange(t){return this._onChange=t,this}_callOnChange(){this.parent._callOnChange(this),void 0!==this._onChange&&this._onChange.call(this,this.getValue()),this._changed=!0}onFinishChange(t){return this._onFinishChange=t,this}_callOnFinishChange(){this._changed&&(this.parent._callOnFinishChange(this),void 0!==this._onFinishChange&&this._onFinishChange.call(this,this.getValue())),this._changed=!1}reset(){return this.setValue(this.initialValue),this._callOnFinishChange(),this}enable(t=!0){return this.disable(!t)}disable(t=!0){return t===this._disabled||(this._disabled=t,this.domElement.classList.toggle("disabled",t),this.$disable.toggleAttribute("disabled",t)),this}show(t=!0){return this._hidden=!t,this.domElement.style.display=this._hidden?"none":"",this}hide(){return this.show(!1)}options(t){const e=this.parent.add(this.object,this.property,t);return e.name(this._name),this.destroy(),e}min(t){return this}max(t){return this}step(t){return this}decimals(t){return this}listen(t=!0){return this._listening=t,void 0!==this._listenCallbackID&&(cancelAnimationFrame(this._listenCallbackID),this._listenCallbackID=void 0),this._listening&&this._listenCallback(),this}_listenCallback(){this._listenCallbackID=requestAnimationFrame(this._listenCallback);const t=this.save();t!==this._listenPrevValue&&this.updateDisplay(),this._listenPrevValue=t}getValue(){return this.object[this.property]}setValue(t){return this.object[this.property]=t,this._callOnChange(),this.updateDisplay(),this}updateDisplay(){return this}load(t){return this.setValue(t),this._callOnFinishChange(),this}save(){return this.getValue()}destroy(){this.listen(!1),this.parent.children.splice(this.parent.children.indexOf(this),1),this.parent.controllers.splice(this.parent.controllers.indexOf(this),1),this.parent.$children.removeChild(this.domElement)}}class bd extends yd{constructor(t,e,i){super(t,e,i,"boolean","label"),this.$input=document.createElement("input"),this.$input.setAttribute("type","checkbox"),this.$input.setAttribute("aria-labelledby",this.$name.id),this.$widget.appendChild(this.$input),this.$input.addEventListener("change",(()=>{this.setValue(this.$input.checked),this._callOnFinishChange()})),this.$disable=this.$input,this.updateDisplay()}updateDisplay(){return this.$input.checked=this.getValue(),this}}function Sd(t){let e,i;return(e=t.match(/(#|0x)?([a-f0-9]{6})/i))?i=e[2]:(e=t.match(/rgb\(\s*(\d*)\s*,\s*(\d*)\s*,\s*(\d*)\s*\)/))?i=parseInt(e[1]).toString(16).padStart(2,0)+parseInt(e[2]).toString(16).padStart(2,0)+parseInt(e[3]).toString(16).padStart(2,0):(e=t.match(/^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i))&&(i=e[1]+e[1]+e[2]+e[2]+e[3]+e[3]),!!i&&"#"+i}const Md={isPrimitive:!0,match:t=>"string"==typeof t,fromHexString:Sd,toHexString:Sd},Td={isPrimitive:!0,match:t=>"number"==typeof t,fromHexString:t=>parseInt(t.substring(1),16),toHexString:t=>"#"+t.toString(16).padStart(6,0)},wd={isPrimitive:!1,match:Array.isArray,fromHexString(t,e,i=1){const n=Td.fromHexString(t);e[0]=(n>>16&255)/255*i,e[1]=(n>>8&255)/255*i,e[2]=(255&n)/255*i},toHexString:([t,e,i],n=1)=>Td.toHexString(t*(n=255/n)<<16^e*n<<8^i*n)},Ad={isPrimitive:!1,match:t=>Object(t)===t,fromHexString(t,e,i=1){const n=Td.fromHexString(t);e.r=(n>>16&255)/255*i,e.g=(n>>8&255)/255*i,e.b=(255&n)/255*i},toHexString:({r:t,g:e,b:i},n=1)=>Td.toHexString(t*(n=255/n)<<16^e*n<<8^i*n)},Ed=[Md,Td,wd,Ad];class Cd extends yd{constructor(t,e,i,n){var s;super(t,e,i,"color"),this.$input=document.createElement("input"),this.$input.setAttribute("type","color"),this.$input.setAttribute("tabindex",-1),this.$input.setAttribute("aria-labelledby",this.$name.id),this.$text=document.createElement("input"),this.$text.setAttribute("type","text"),this.$text.setAttribute("spellcheck","false"),this.$text.setAttribute("aria-labelledby",this.$name.id),this.$display=document.createElement("div"),this.$display.classList.add("display"),this.$display.appendChild(this.$input),this.$widget.appendChild(this.$display),this.$widget.appendChild(this.$text),this._format=(s=this.initialValue,Ed.find((t=>t.match(s)))),this._rgbScale=n,this._initialValueHexString=this.save(),this._textFocused=!1,this.$input.addEventListener("input",(()=>{this._setValueFromHexString(this.$input.value)})),this.$input.addEventListener("blur",(()=>{this._callOnFinishChange()})),this.$text.addEventListener("input",(()=>{const t=Sd(this.$text.value);t&&this._setValueFromHexString(t)})),this.$text.addEventListener("focus",(()=>{this._textFocused=!0,this.$text.select()})),this.$text.addEventListener("blur",(()=>{this._textFocused=!1,this.updateDisplay(),this._callOnFinishChange()})),this.$disable=this.$text,this.updateDisplay()}reset(){return this._setValueFromHexString(this._initialValueHexString),this}_setValueFromHexString(t){if(this._format.isPrimitive){const e=this._format.fromHexString(t);this.setValue(e)}else this._format.fromHexString(t,this.getValue(),this._rgbScale),this._callOnChange(),this.updateDisplay()}save(){return this._format.toHexString(this.getValue(),this._rgbScale)}load(t){return this._setValueFromHexString(t),this._callOnFinishChange(),this}updateDisplay(){return this.$input.value=this._format.toHexString(this.getValue(),this._rgbScale),this._textFocused||(this.$text.value=this.$input.value.substring(1)),this.$display.style.backgroundColor=this.$input.value,this}}class Rd extends yd{constructor(t,e,i){super(t,e,i,"function"),this.$button=document.createElement("button"),this.$button.appendChild(this.$name),this.$widget.appendChild(this.$button),this.$button.addEventListener("click",(t=>{t.preventDefault(),this.getValue().call(this.object)})),this.$button.addEventListener("touchstart",(()=>{}),{passive:!0}),this.$disable=this.$button}}class Nd extends yd{constructor(t,e,i,n,s,r){super(t,e,i,"number"),this._initInput(),this.min(n),this.max(s);const a=void 0!==r;this.step(a?r:this._getImplicitStep(),a),this.updateDisplay()}decimals(t){return this._decimals=t,this.updateDisplay(),this}min(t){return this._min=t,this._onUpdateMinMax(),this}max(t){return this._max=t,this._onUpdateMinMax(),this}step(t,e=!0){return this._step=t,this._stepExplicit=e,this}updateDisplay(){const t=this.getValue();if(this._hasSlider){let e=(t-this._min)/(this._max-this._min);e=Math.max(0,Math.min(e,1)),this.$fill.style.width=100*e+"%"}return this._inputFocused||(this.$input.value=void 0===this._decimals?t:t.toFixed(this._decimals)),this}_initInput(){this.$input=document.createElement("input"),this.$input.setAttribute("type","number"),this.$input.setAttribute("step","any"),this.$input.setAttribute("aria-labelledby",this.$name.id),this.$widget.appendChild(this.$input),this.$disable=this.$input;const t=t=>{const e=parseFloat(this.$input.value);isNaN(e)||(this._snapClampSetValue(e+t),this.$input.value=this.getValue())};let e,i,n,s,r,a=!1;const o=t=>{if(a){const n=t.clientX-e,s=t.clientY-i;Math.abs(s)>5?(t.preventDefault(),this.$input.blur(),a=!1,this._setDraggingStyle(!0,"vertical")):Math.abs(n)>5&&l()}if(!a){const e=t.clientY-n;r-=e*this._step*this._arrowKeyMultiplier(t),s+r>this._max?r=this._max-s:s+r<this._min&&(r=this._min-s),this._snapClampSetValue(s+r)}n=t.clientY},l=()=>{this._setDraggingStyle(!1,"vertical"),this._callOnFinishChange(),window.removeEventListener("mousemove",o),window.removeEventListener("mouseup",l)};this.$input.addEventListener("input",(()=>{let t=parseFloat(this.$input.value);isNaN(t)||(this._stepExplicit&&(t=this._snap(t)),this.setValue(this._clamp(t)))})),this.$input.addEventListener("keydown",(e=>{"Enter"===e.code&&this.$input.blur(),"ArrowUp"===e.code&&(e.preventDefault(),t(this._step*this._arrowKeyMultiplier(e))),"ArrowDown"===e.code&&(e.preventDefault(),t(this._step*this._arrowKeyMultiplier(e)*-1))})),this.$input.addEventListener("wheel",(e=>{this._inputFocused&&(e.preventDefault(),t(this._step*this._normalizeMouseWheel(e)))}),{passive:!1}),this.$input.addEventListener("mousedown",(t=>{e=t.clientX,i=n=t.clientY,a=!0,s=this.getValue(),r=0,window.addEventListener("mousemove",o),window.addEventListener("mouseup",l)})),this.$input.addEventListener("focus",(()=>{this._inputFocused=!0})),this.$input.addEventListener("blur",(()=>{this._inputFocused=!1,this.updateDisplay(),this._callOnFinishChange()}))}_initSlider(){this._hasSlider=!0,this.$slider=document.createElement("div"),this.$slider.classList.add("slider"),this.$fill=document.createElement("div"),this.$fill.classList.add("fill"),this.$slider.appendChild(this.$fill),this.$widget.insertBefore(this.$slider,this.$input),this.domElement.classList.add("hasSlider");const t=t=>{const e=this.$slider.getBoundingClientRect();let i=(n=t,s=e.left,r=e.right,a=this._min,(n-s)/(r-s)*(this._max-a)+a);var n,s,r,a;this._snapClampSetValue(i)},e=e=>{t(e.clientX)},i=()=>{this._callOnFinishChange(),this._setDraggingStyle(!1),window.removeEventListener("mousemove",e),window.removeEventListener("mouseup",i)};let n,s,r=!1;const a=e=>{e.preventDefault(),this._setDraggingStyle(!0),t(e.touches[0].clientX),r=!1},o=e=>{if(r){const t=e.touches[0].clientX-n,i=e.touches[0].clientY-s;Math.abs(t)>Math.abs(i)?a(e):(window.removeEventListener("touchmove",o),window.removeEventListener("touchend",l))}else e.preventDefault(),t(e.touches[0].clientX)},l=()=>{this._callOnFinishChange(),this._setDraggingStyle(!1),window.removeEventListener("touchmove",o),window.removeEventListener("touchend",l)},h=this._callOnFinishChange.bind(this);let c;this.$slider.addEventListener("mousedown",(n=>{this._setDraggingStyle(!0),t(n.clientX),window.addEventListener("mousemove",e),window.addEventListener("mouseup",i)})),this.$slider.addEventListener("touchstart",(t=>{t.touches.length>1||(this._hasScrollBar?(n=t.touches[0].clientX,s=t.touches[0].clientY,r=!0):a(t),window.addEventListener("touchmove",o,{passive:!1}),window.addEventListener("touchend",l))}),{passive:!1}),this.$slider.addEventListener("wheel",(t=>{if(Math.abs(t.deltaX)<Math.abs(t.deltaY)&&this._hasScrollBar)return;t.preventDefault();const e=this._normalizeMouseWheel(t)*this._step;this._snapClampSetValue(this.getValue()+e),this.$input.value=this.getValue(),clearTimeout(c),c=setTimeout(h,400)}),{passive:!1})}_setDraggingStyle(t,e="horizontal"){this.$slider&&this.$slider.classList.toggle("active",t),document.body.classList.toggle("lil-gui-dragging",t),document.body.classList.toggle("lil-gui-"+e,t)}_getImplicitStep(){return this._hasMin&&this._hasMax?(this._max-this._min)/1e3:.1}_onUpdateMinMax(){!this._hasSlider&&this._hasMin&&this._hasMax&&(this._stepExplicit||this.step(this._getImplicitStep(),!1),this._initSlider(),this.updateDisplay())}_normalizeMouseWheel(t){let{deltaX:e,deltaY:i}=t;return Math.floor(t.deltaY)!==t.deltaY&&t.wheelDelta&&(e=0,i=-t.wheelDelta/120,i*=this._stepExplicit?1:10),e+-i}_arrowKeyMultiplier(t){let e=this._stepExplicit?1:10;return t.shiftKey?e*=10:t.altKey&&(e/=10),e}_snap(t){const e=Math.round(t/this._step)*this._step;return parseFloat(e.toPrecision(15))}_clamp(t){return t<this._min&&(t=this._min),t>this._max&&(t=this._max),t}_snapClampSetValue(t){this.setValue(this._clamp(this._snap(t)))}get _hasScrollBar(){const t=this.parent.root.$children;return t.scrollHeight>t.clientHeight}get _hasMin(){return void 0!==this._min}get _hasMax(){return void 0!==this._max}}class Pd extends yd{constructor(t,e,i,n){super(t,e,i,"option"),this.$select=document.createElement("select"),this.$select.setAttribute("aria-labelledby",this.$name.id),this.$display=document.createElement("div"),this.$display.classList.add("display"),this._values=Array.isArray(n)?n:Object.values(n),this._names=Array.isArray(n)?n:Object.keys(n),this._names.forEach((t=>{const e=document.createElement("option");e.innerHTML=t,this.$select.appendChild(e)})),this.$select.addEventListener("change",(()=>{this.setValue(this._values[this.$select.selectedIndex]),this._callOnFinishChange()})),this.$select.addEventListener("focus",(()=>{this.$display.classList.add("focus")})),this.$select.addEventListener("blur",(()=>{this.$display.classList.remove("focus")})),this.$widget.appendChild(this.$select),this.$widget.appendChild(this.$display),this.$disable=this.$select,this.updateDisplay()}updateDisplay(){const t=this.getValue(),e=this._values.indexOf(t);return this.$select.selectedIndex=e,this.$display.innerHTML=-1===e?t:this._names[e],this}}class Id extends yd{constructor(t,e,i){super(t,e,i,"string"),this.$input=document.createElement("input"),this.$input.setAttribute("type","text"),this.$input.setAttribute("aria-labelledby",this.$name.id),this.$input.addEventListener("input",(()=>{this.setValue(this.$input.value)})),this.$input.addEventListener("keydown",(t=>{"Enter"===t.code&&this.$input.blur()})),this.$input.addEventListener("blur",(()=>{this._callOnFinishChange()})),this.$widget.appendChild(this.$input),this.$disable=this.$input,this.updateDisplay()}updateDisplay(){return this.$input.value=this.getValue(),this}}let Ld=!1;class Dd{constructor({parent:t,autoPlace:e=void 0===t,container:i,width:n,title:s="Controls",injectStyles:r=!0,touchStyles:a=!0}={}){if(this.parent=t,this.root=t?t.root:this,this.children=[],this.controllers=[],this.folders=[],this._closed=!1,this._hidden=!1,this.domElement=document.createElement("div"),this.domElement.classList.add("lil-gui"),this.$title=document.createElement("div"),this.$title.classList.add("title"),this.$title.setAttribute("role","button"),this.$title.setAttribute("aria-expanded",!0),this.$title.setAttribute("tabindex",0),this.$title.addEventListener("click",(()=>this.openAnimated(this._closed))),this.$title.addEventListener("keydown",(t=>{"Enter"!==t.code&&"Space"!==t.code||(t.preventDefault(),this.$title.click())})),this.$title.addEventListener("touchstart",(()=>{}),{passive:!0}),this.$children=document.createElement("div"),this.$children.classList.add("children"),this.domElement.appendChild(this.$title),this.domElement.appendChild(this.$children),this.title(s),a&&this.domElement.classList.add("allow-touch-styles"),this.parent)return this.parent.children.push(this),this.parent.folders.push(this),void this.parent.$children.appendChild(this.domElement);this.domElement.classList.add("root"),!Ld&&r&&(function(){const t=document.createElement("style");t.innerHTML='.lil-gui{--background-color:#1f1f1f;--text-color:#ebebeb;--title-background-color:#111;--title-text-color:#ebebeb;--widget-color:#424242;--hover-color:#4f4f4f;--focus-color:#595959;--number-color:#2cc9ff;--string-color:#a2db3c;--font-size:11px;--input-font-size:11px;--font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;--font-family-mono:Menlo,Monaco,Consolas,"Droid Sans Mono",monospace;--padding:4px;--spacing:4px;--widget-height:20px;--name-width:45%;--slider-knob-width:2px;--slider-input-width:27%;--color-input-width:27%;--slider-input-min-width:45px;--color-input-min-width:45px;--folder-indent:7px;--widget-padding:0 0 0 3px;--widget-border-radius:2px;--checkbox-size:calc(var(--widget-height)*0.75);--scrollbar-width:5px;background-color:var(--background-color);color:var(--text-color);font-family:var(--font-family);font-size:var(--font-size);font-style:normal;font-weight:400;line-height:1;text-align:left;touch-action:manipulation;user-select:none;-webkit-user-select:none}.lil-gui,.lil-gui *{box-sizing:border-box;margin:0;padding:0}.lil-gui.root{display:flex;flex-direction:column;width:var(--width,245px)}.lil-gui.root>.title{background:var(--title-background-color);color:var(--title-text-color)}.lil-gui.root>.children{overflow-x:hidden;overflow-y:auto}.lil-gui.root>.children::-webkit-scrollbar{background:var(--background-color);height:var(--scrollbar-width);width:var(--scrollbar-width)}.lil-gui.root>.children::-webkit-scrollbar-thumb{background:var(--focus-color);border-radius:var(--scrollbar-width)}.lil-gui.force-touch-styles{--widget-height:28px;--padding:6px;--spacing:6px;--font-size:13px;--input-font-size:16px;--folder-indent:10px;--scrollbar-width:7px;--slider-input-min-width:50px;--color-input-min-width:65px}.lil-gui.autoPlace{max-height:100%;position:fixed;right:15px;top:0;z-index:1001}.lil-gui .controller{align-items:center;display:flex;margin:var(--spacing) 0;padding:0 var(--padding)}.lil-gui .controller.disabled{opacity:.5}.lil-gui .controller.disabled,.lil-gui .controller.disabled *{pointer-events:none!important}.lil-gui .controller>.name{flex-shrink:0;line-height:var(--widget-height);min-width:var(--name-width);padding-right:var(--spacing);white-space:pre}.lil-gui .controller .widget{align-items:center;display:flex;min-height:var(--widget-height);position:relative;width:100%}.lil-gui .controller.string input{color:var(--string-color)}.lil-gui .controller.boolean .widget{cursor:pointer}.lil-gui .controller.color .display{border-radius:var(--widget-border-radius);height:var(--widget-height);position:relative;width:100%}.lil-gui .controller.color input[type=color]{cursor:pointer;height:100%;opacity:0;width:100%}.lil-gui .controller.color input[type=text]{flex-shrink:0;font-family:var(--font-family-mono);margin-left:var(--spacing);min-width:var(--color-input-min-width);width:var(--color-input-width)}.lil-gui .controller.option select{max-width:100%;opacity:0;position:absolute;width:100%}.lil-gui .controller.option .display{background:var(--widget-color);border-radius:var(--widget-border-radius);height:var(--widget-height);line-height:var(--widget-height);max-width:100%;overflow:hidden;padding-left:.55em;padding-right:1.75em;pointer-events:none;position:relative;word-break:break-all}.lil-gui .controller.option .display.active{background:var(--focus-color)}.lil-gui .controller.option .display:after{bottom:0;content:"↕";font-family:lil-gui;padding-right:.375em;position:absolute;right:0;top:0}.lil-gui .controller.option .widget,.lil-gui .controller.option select{cursor:pointer}.lil-gui .controller.number input{color:var(--number-color)}.lil-gui .controller.number.hasSlider input{flex-shrink:0;margin-left:var(--spacing);min-width:var(--slider-input-min-width);width:var(--slider-input-width)}.lil-gui .controller.number .slider{background-color:var(--widget-color);border-radius:var(--widget-border-radius);cursor:ew-resize;height:var(--widget-height);overflow:hidden;padding-right:var(--slider-knob-width);touch-action:pan-y;width:100%}.lil-gui .controller.number .slider.active{background-color:var(--focus-color)}.lil-gui .controller.number .slider.active .fill{opacity:.95}.lil-gui .controller.number .fill{border-right:var(--slider-knob-width) solid var(--number-color);box-sizing:content-box;height:100%}.lil-gui-dragging .lil-gui{--hover-color:var(--widget-color)}.lil-gui-dragging *{cursor:ew-resize!important}.lil-gui-dragging.lil-gui-vertical *{cursor:ns-resize!important}.lil-gui .title{--title-height:calc(var(--widget-height) + var(--spacing)*1.25);-webkit-tap-highlight-color:transparent;text-decoration-skip:objects;cursor:pointer;font-weight:600;height:var(--title-height);line-height:calc(var(--title-height) - 4px);outline:none;padding:0 var(--padding)}.lil-gui .title:before{content:"▾";display:inline-block;font-family:lil-gui;padding-right:2px}.lil-gui .title:active{background:var(--title-background-color);opacity:.75}.lil-gui.root>.title:focus{text-decoration:none!important}.lil-gui.closed>.title:before{content:"▸"}.lil-gui.closed>.children{opacity:0;transform:translateY(-7px)}.lil-gui.closed:not(.transition)>.children{display:none}.lil-gui.transition>.children{overflow:hidden;pointer-events:none;transition-duration:.3s;transition-property:height,opacity,transform;transition-timing-function:cubic-bezier(.2,.6,.35,1)}.lil-gui .children:empty:before{content:"Empty";display:block;font-style:italic;height:var(--widget-height);line-height:var(--widget-height);margin:var(--spacing) 0;opacity:.5;padding:0 var(--padding)}.lil-gui.root>.children>.lil-gui>.title{border-width:0;border-bottom:1px solid var(--widget-color);border-left:0 solid var(--widget-color);border-right:0 solid var(--widget-color);border-top:1px solid var(--widget-color);transition:border-color .3s}.lil-gui.root>.children>.lil-gui.closed>.title{border-bottom-color:transparent}.lil-gui+.controller{border-top:1px solid var(--widget-color);margin-top:0;padding-top:var(--spacing)}.lil-gui .lil-gui .lil-gui>.title{border:none}.lil-gui .lil-gui .lil-gui>.children{border:none;border-left:2px solid var(--widget-color);margin-left:var(--folder-indent)}.lil-gui .lil-gui .controller{border:none}.lil-gui input{-webkit-tap-highlight-color:transparent;background:var(--widget-color);border:0;border-radius:var(--widget-border-radius);color:var(--text-color);font-family:var(--font-family);font-size:var(--input-font-size);height:var(--widget-height);outline:none;width:100%}.lil-gui input:disabled{opacity:1}.lil-gui input[type=number],.lil-gui input[type=text]{padding:var(--widget-padding)}.lil-gui input[type=number]:focus,.lil-gui input[type=text]:focus{background:var(--focus-color)}.lil-gui input::-webkit-inner-spin-button,.lil-gui input::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.lil-gui input[type=number]{-moz-appearance:textfield}.lil-gui input[type=checkbox]{appearance:none;-webkit-appearance:none;border-radius:var(--widget-border-radius);cursor:pointer;height:var(--checkbox-size);text-align:center;width:var(--checkbox-size)}.lil-gui input[type=checkbox]:checked:before{content:"✓";font-family:lil-gui;font-size:var(--checkbox-size);line-height:var(--checkbox-size)}.lil-gui button{-webkit-tap-highlight-color:transparent;background:var(--widget-color);border:1px solid var(--widget-color);border-radius:var(--widget-border-radius);color:var(--text-color);cursor:pointer;font-family:var(--font-family);font-size:var(--font-size);height:var(--widget-height);line-height:calc(var(--widget-height) - 4px);outline:none;text-align:center;text-transform:none;width:100%}.lil-gui button:active{background:var(--focus-color)}@font-face{font-family:lil-gui;src:url("data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZpWH2hlYWQAAAMcAAAAJwAAADZfcj2zaGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhiAGJgZWBgZ7RnFRdnVJELCQlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB4WwoqAHicY2BkYGAA4sk1sR/j+W2+MnAzpDBgAyEMQUCSg4EJxAEAwUgFHgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==") format("woff")}@media (pointer:coarse){.lil-gui.allow-touch-styles{--widget-height:28px;--padding:6px;--spacing:6px;--font-size:13px;--input-font-size:16px;--folder-indent:10px;--scrollbar-width:7px;--slider-input-min-width:50px;--color-input-min-width:65px}}@media (hover:hover){.lil-gui .controller.color .display:hover:before{border:1px solid #fff9;border-radius:var(--widget-border-radius);bottom:0;content:" ";display:block;left:0;position:absolute;right:0;top:0}.lil-gui .controller.option .display.focus{background:var(--focus-color)}.lil-gui .controller.option .widget:hover .display{background:var(--hover-color)}.lil-gui .controller.number .slider:hover{background-color:var(--hover-color)}body:not(.lil-gui-dragging) .lil-gui .title:hover{background:var(--title-background-color);opacity:.85}.lil-gui .title:focus{text-decoration:underline var(--focus-color)}.lil-gui input:hover{background:var(--hover-color)}.lil-gui input:active{background:var(--focus-color)}.lil-gui input[type=checkbox]:focus{box-shadow:inset 0 0 0 1px var(--focus-color)}.lil-gui button:hover{background:var(--hover-color);border-color:var(--hover-color)}.lil-gui button:focus{border-color:var(--focus-color)}}';const e=document.querySelector("head link[rel=stylesheet], head style");e?document.head.insertBefore(t,e):document.head.appendChild(t)}(),Ld=!0),i?i.appendChild(this.domElement):e&&(this.domElement.classList.add("autoPlace"),document.body.appendChild(this.domElement)),n&&this.domElement.style.setProperty("--width",n+"px"),this.domElement.addEventListener("keydown",(t=>t.stopPropagation())),this.domElement.addEventListener("keyup",(t=>t.stopPropagation()))}add(t,e,i,n,s){if(Object(i)===i)return new Pd(this,t,e,i);switch(typeof t[e]){case"number":return new Nd(this,t,e,i,n,s);case"boolean":return new bd(this,t,e);case"string":return new Id(this,t,e);case"function":return new Rd(this,t,e)}}addColor(t,e,i=1){return new Cd(this,t,e,i)}addFolder(t){return new Dd({parent:this,title:t})}load(t,e=!0){return t.controllers&&this.controllers.forEach((e=>{e instanceof Rd||e._name in t.controllers&&e.load(t.controllers[e._name])})),e&&t.folders&&this.folders.forEach((e=>{e._title in t.folders&&e.load(t.folders[e._title])})),this}save(t=!0){const e={controllers:{},folders:{}};return this.controllers.forEach((t=>{if(!(t instanceof Rd)){if(t._name in e.controllers)throw new Error(`Cannot save GUI with duplicate property "${t._name}"`);e.controllers[t._name]=t.save()}})),t&&this.folders.forEach((t=>{if(t._title in e.folders)throw new Error(`Cannot save GUI with duplicate folder "${t._title}"`);e.folders[t._title]=t.save()})),e}open(t=!0){return this._closed=!t,this.$title.setAttribute("aria-expanded",!this._closed),this.domElement.classList.toggle("closed",this._closed),this}close(){return this.open(!1)}show(t=!0){return this._hidden=!t,this.domElement.style.display=this._hidden?"none":"",this}hide(){return this.show(!1)}openAnimated(t=!0){return this._closed=!t,this.$title.setAttribute("aria-expanded",!this._closed),requestAnimationFrame((()=>{const e=this.$children.clientHeight;this.$children.style.height=e+"px",this.domElement.classList.add("transition");const i=t=>{t.target===this.$children&&(this.$children.style.height="",this.domElement.classList.remove("transition"),this.$children.removeEventListener("transitionend",i))};this.$children.addEventListener("transitionend",i);const n=t?this.$children.scrollHeight:0;this.domElement.classList.toggle("closed",!t),requestAnimationFrame((()=>{this.$children.style.height=n+"px"}))})),this}title(t){return this._title=t,this.$title.innerHTML=t,this}reset(t=!0){return(t?this.controllersRecursive():this.controllers).forEach((t=>t.reset())),this}onChange(t){return this._onChange=t,this}_callOnChange(t){this.parent&&this.parent._callOnChange(t),void 0!==this._onChange&&this._onChange.call(this,{object:t.object,property:t.property,value:t.getValue(),controller:t})}onFinishChange(t){return this._onFinishChange=t,this}_callOnFinishChange(t){this.parent&&this.parent._callOnFinishChange(t),void 0!==this._onFinishChange&&this._onFinishChange.call(this,{object:t.object,property:t.property,value:t.getValue(),controller:t})}destroy(){this.parent&&(this.parent.children.splice(this.parent.children.indexOf(this),1),this.parent.folders.splice(this.parent.folders.indexOf(this),1)),this.domElement.parentElement&&this.domElement.parentElement.removeChild(this.domElement),Array.from(this.children).forEach((t=>t.destroy()))}controllersRecursive(){let t=Array.from(this.controllers);return this.folders.forEach((e=>{t=t.concat(e.controllersRecursive())})),t}foldersRecursive(){let t=Array.from(this.folders);return this.folders.forEach((e=>{t=t.concat(e.foldersRecursive())})),t}}const Ud=/^[og]\s*(.+)?/,Fd=/^mtllib /,Bd=/^usemtl /,Od=/^usemap /,zd=/\s+/,kd=new ui,Vd=new ui,Gd=new ui,Hd=new ui,Wd=new ui,jd=new Dn;function Xd(){const t={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(t,e){if(this.object&&!1===this.object.fromDeclaration)return this.object.name=t,void(this.object.fromDeclaration=!1!==e);const i=this.object&&"function"==typeof this.object.currentMaterial?this.object.currentMaterial():void 0;if(this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0),this.object={name:t||"",fromDeclaration:!1!==e,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(t,e){const i=this._finalize(!1);i&&(i.inherited||i.groupCount<=0)&&this.materials.splice(i.index,1);const n={index:this.materials.length,name:t||"",mtllib:Array.isArray(e)&&e.length>0?e[e.length-1]:"",smooth:void 0!==i?i.smooth:this.smooth,groupStart:void 0!==i?i.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(t){const e={index:"number"==typeof t?t:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return e.clone=this.clone.bind(e),e}};return this.materials.push(n),n},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(t){const e=this.currentMaterial();if(e&&-1===e.groupEnd&&(e.groupEnd=this.geometry.vertices.length/3,e.groupCount=e.groupEnd-e.groupStart,e.inherited=!1),t&&this.materials.length>1)for(let i=this.materials.length-1;i>=0;i--)this.materials[i].groupCount<=0&&this.materials.splice(i,1);return t&&0===this.materials.length&&this.materials.push({name:"",smooth:this.smooth}),e}},i&&i.name&&"function"==typeof i.clone){const t=i.clone(0);t.inherited=!0,this.object.materials.push(t)}this.objects.push(this.object)},finalize:function(){this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0)},parseVertexIndex:function(t,e){const i=parseInt(t,10);return 3*(i>=0?i-1:i+e/3)},parseNormalIndex:function(t,e){const i=parseInt(t,10);return 3*(i>=0?i-1:i+e/3)},parseUVIndex:function(t,e){const i=parseInt(t,10);return 2*(i>=0?i-1:i+e/2)},addVertex:function(t,e,i){const n=this.vertices,s=this.object.geometry.vertices;s.push(n[t+0],n[t+1],n[t+2]),s.push(n[e+0],n[e+1],n[e+2]),s.push(n[i+0],n[i+1],n[i+2])},addVertexPoint:function(t){const e=this.vertices;this.object.geometry.vertices.push(e[t+0],e[t+1],e[t+2])},addVertexLine:function(t){const e=this.vertices;this.object.geometry.vertices.push(e[t+0],e[t+1],e[t+2])},addNormal:function(t,e,i){const n=this.normals,s=this.object.geometry.normals;s.push(n[t+0],n[t+1],n[t+2]),s.push(n[e+0],n[e+1],n[e+2]),s.push(n[i+0],n[i+1],n[i+2])},addFaceNormal:function(t,e,i){const n=this.vertices,s=this.object.geometry.normals;kd.fromArray(n,t),Vd.fromArray(n,e),Gd.fromArray(n,i),Wd.subVectors(Gd,Vd),Hd.subVectors(kd,Vd),Wd.cross(Hd),Wd.normalize(),s.push(Wd.x,Wd.y,Wd.z),s.push(Wd.x,Wd.y,Wd.z),s.push(Wd.x,Wd.y,Wd.z)},addColor:function(t,e,i){const n=this.colors,s=this.object.geometry.colors;void 0!==n[t]&&s.push(n[t+0],n[t+1],n[t+2]),void 0!==n[e]&&s.push(n[e+0],n[e+1],n[e+2]),void 0!==n[i]&&s.push(n[i+0],n[i+1],n[i+2])},addUV:function(t,e,i){const n=this.uvs,s=this.object.geometry.uvs;s.push(n[t+0],n[t+1]),s.push(n[e+0],n[e+1]),s.push(n[i+0],n[i+1])},addDefaultUV:function(){const t=this.object.geometry.uvs;t.push(0,0),t.push(0,0),t.push(0,0)},addUVLine:function(t){const e=this.uvs;this.object.geometry.uvs.push(e[t+0],e[t+1])},addFace:function(t,e,i,n,s,r,a,o,l){const h=this.vertices.length;let c=this.parseVertexIndex(t,h),u=this.parseVertexIndex(e,h),d=this.parseVertexIndex(i,h);if(this.addVertex(c,u,d),this.addColor(c,u,d),void 0!==a&&""!==a){const t=this.normals.length;c=this.parseNormalIndex(a,t),u=this.parseNormalIndex(o,t),d=this.parseNormalIndex(l,t),this.addNormal(c,u,d)}else this.addFaceNormal(c,u,d);if(void 0!==n&&""!==n){const t=this.uvs.length;c=this.parseUVIndex(n,t),u=this.parseUVIndex(s,t),d=this.parseUVIndex(r,t),this.addUV(c,u,d),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(t){this.object.geometry.type="Points";const e=this.vertices.length;for(let i=0,n=t.length;i<n;i++){const n=this.parseVertexIndex(t[i],e);this.addVertexPoint(n),this.addColor(n)}},addLineGeometry:function(t,e){this.object.geometry.type="Line";const i=this.vertices.length,n=this.uvs.length;for(let s=0,r=t.length;s<r;s++)this.addVertexLine(this.parseVertexIndex(t[s],i));for(let s=0,r=e.length;s<r;s++)this.addUVLine(this.parseUVIndex(e[s],n))}};return t.startObject("",!1),t}class qd extends Ec{constructor(t){super(t),this.materials=null}load(t,e,i,n){const s=this,r=new Nc(this.manager);r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(t,(function(i){try{e(s.parse(i))}catch(r){n&&n(r),s.manager.itemError(t)}}),i,n)}setMaterials(t){return this.materials=t,this}parse(t){const e=new Xd;-1!==t.indexOf("\r\n")&&(t=t.replace(/\r\n/g,"\n")),-1!==t.indexOf("\\\n")&&(t=t.replace(/\\\n/g,""));const i=t.split("\n");let n=[];for(let r=0,a=i.length;r<a;r++){const t=i[r].trimStart();if(0===t.length)continue;const s=t.charAt(0);if("#"!==s)if("v"===s){const i=t.split(zd);switch(i[0]){case"v":e.vertices.push(parseFloat(i[1]),parseFloat(i[2]),parseFloat(i[3])),i.length>=7?(jd.setRGB(parseFloat(i[4]),parseFloat(i[5]),parseFloat(i[6]),oe),e.colors.push(jd.r,jd.g,jd.b)):e.colors.push(void 0,void 0,void 0);break;case"vn":e.normals.push(parseFloat(i[1]),parseFloat(i[2]),parseFloat(i[3]));break;case"vt":e.uvs.push(parseFloat(i[1]),parseFloat(i[2]))}}else if("f"===s){const i=t.slice(1).trim().split(zd),n=[];for(let t=0,e=i.length;t<e;t++){const e=i[t];if(e.length>0){const t=e.split("/");n.push(t)}}const s=n[0];for(let t=1,r=n.length-1;t<r;t++){const i=n[t],r=n[t+1];e.addFace(s[0],i[0],r[0],s[1],i[1],r[1],s[2],i[2],r[2])}}else if("l"===s){const i=t.substring(1).trim().split(" ");let n=[];const s=[];if(-1===t.indexOf("/"))n=i;else for(let t=0,e=i.length;t<e;t++){const e=i[t].split("/");""!==e[0]&&n.push(e[0]),""!==e[1]&&s.push(e[1])}e.addLineGeometry(n,s)}else if("p"===s){const i=t.slice(1).trim().split(" ");e.addPointGeometry(i)}else if(null!==(n=Ud.exec(t))){const t=(" "+n[0].slice(1).trim()).slice(1);e.startObject(t)}else if(Bd.test(t))e.object.startMaterial(t.substring(7).trim(),e.materialLibraries);else if(Fd.test(t))e.materialLibraries.push(t.substring(7).trim());else if(Od.test(t));else if("s"===s){if(n=t.split(" "),n.length>1){const t=n[1].trim().toLowerCase();e.object.smooth="0"!==t&&"off"!==t}else e.object.smooth=!0;const i=e.object.currentMaterial();i&&(i.smooth=e.object.smooth)}else if("\0"===t)continue}e.finalize();const s=new xo;s.materialLibraries=[].concat(e.materialLibraries);if(!0===!(1===e.objects.length&&0===e.objects[0].geometry.vertices.length))for(let r=0,a=e.objects.length;r<a;r++){const t=e.objects[r],i=t.geometry,n=t.materials,a="Line"===i.type,o="Points"===i.type;let l=!1;if(0===i.vertices.length)continue;const h=new Jn;h.setAttribute("position",new Wn(i.vertices,3)),i.normals.length>0&&h.setAttribute("normal",new Wn(i.normals,3)),i.colors.length>0&&(l=!0,h.setAttribute("color",new Wn(i.colors,3))),!0===i.hasUVIndices&&h.setAttribute("uv",new Wn(i.uvs,2));const c=[];for(let s=0,r=n.length;s<r;s++){const t=n[s],i=t.name+"_"+t.smooth+"_"+l;let r=e.materials[i];if(null!==this.materials)if(r=this.materials.create(t.name),!a||!r||r instanceof vl){if(o&&r&&!(r instanceof Il)){const t=new Il({size:10,sizeAttenuation:!1});Bn.prototype.copy.call(t,r),t.color.copy(r.color),t.map=r.map,r=t}}else{const t=new vl;Bn.prototype.copy.call(t,r),t.color.copy(r.color),r=t}void 0===r&&(r=a?new vl:o?new Il({size:1,sizeAttenuation:!1}):new sc,r.name=t.name,r.flatShading=!t.smooth,r.vertexColors=l,e.materials[i]=r),c.push(r)}let u;if(c.length>1){for(let t=0,e=n.length;t<e;t++){const e=n[t];h.addGroup(e.groupStart,e.groupCount,t)}u=a?new Nl(h,c):o?new Bl(h,c):new cs(h,c)}else u=a?new Nl(h,c[0]):o?new Bl(h,c[0]):new cs(h,c[0]);u.name=t.name,s.add(u)}else if(e.vertices.length>0){const t=new Il({size:1,sizeAttenuation:!1}),i=new Jn;i.setAttribute("position",new Wn(e.vertices,3)),e.colors.length>0&&void 0!==e.colors[0]&&(i.setAttribute("color",new Wn(e.colors,3)),t.vertexColors=!0);const n=new Bl(i,t);s.add(n)}return s}}function $d(t,e=!1){const i=null!==t[0].index,n=new Set(Object.keys(t[0].attributes)),s=new Set(Object.keys(t[0].morphAttributes)),r={},a={},o=t[0].morphTargetsRelative,l=new Jn;let h=0;for(let c=0;c<t.length;++c){const u=t[c];let d=0;if(i!==(null!==u.index))return null;for(const t in u.attributes){if(!n.has(t))return null;void 0===r[t]&&(r[t]=[]),r[t].push(u.attributes[t]),d++}if(d!==n.size)return null;if(o!==u.morphTargetsRelative)return null;for(const t in u.morphAttributes){if(!s.has(t))return null;void 0===a[t]&&(a[t]=[]),a[t].push(u.morphAttributes[t])}if(e){let t;if(i)t=u.index.count;else{if(void 0===u.attributes.position)return null;t=u.attributes.position.count}l.addGroup(h,t,c),h+=t}}if(i){let e=0;const i=[];for(let n=0;n<t.length;++n){const s=t[n].index;for(let t=0;t<s.count;++t)i.push(s.getX(t)+e);e+=t[n].attributes.position.count}l.setIndex(i)}for(const c in r){const t=Yd(r[c]);if(!t)return null;l.setAttribute(c,t)}for(const c in a){const t=a[c][0].length;if(0===t)break;l.morphAttributes=l.morphAttributes||{},l.morphAttributes[c]=[];for(let e=0;e<t;++e){const t=[];for(let n=0;n<a[c].length;++n)t.push(a[c][n][e]);const i=Yd(t);if(!i)return null;l.morphAttributes[c].push(i)}}return l}function Yd(t){let e,i,n,s=-1,r=0;for(let h=0;h<t.length;++h){const a=t[h];if(void 0===e&&(e=a.array.constructor),e!==a.array.constructor)return null;if(void 0===i&&(i=a.itemSize),i!==a.itemSize)return null;if(void 0===n&&(n=a.normalized),n!==a.normalized)return null;if(-1===s&&(s=a.gpuType),s!==a.gpuType)return null;r+=a.count*i}const a=new e(r),o=new Vn(a,i,n);let l=0;for(let h=0;h<t.length;++h){const e=t[h];if(e.isInterleavedBufferAttribute){const t=l/i;for(let n=0,s=e.count;n<s;n++)for(let r=0;r<i;r++){const i=e.getComponent(n,r);o.setComponent(n+t,r,i)}}else a.set(e.array,l);l+=e.count*i}return void 0!==s&&(o.gpuType=s),o}function Zd(t,e){if(0===e)return t;if(2===e||1===e){let i=t.getIndex();if(null===i){const e=[],n=t.getAttribute("position");if(void 0===n)return t;for(let t=0;t<n.count;t++)e.push(t);t.setIndex(e),i=t.getIndex()}const n=i.count-2,s=[];if(2===e)for(let t=1;t<=n;t++)s.push(i.getX(0)),s.push(i.getX(t)),s.push(i.getX(t+1));else for(let t=0;t<n;t++)t%2==0?(s.push(i.getX(t)),s.push(i.getX(t+1)),s.push(i.getX(t+2))):(s.push(i.getX(t+2)),s.push(i.getX(t+1)),s.push(i.getX(t)));s.length;const r=t.clone();return r.setIndex(s),r.clearGroups(),r}return t}class Kd extends Ec{constructor(t){super(t),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register((function(t){return new np(t)})),this.register((function(t){return new sp(t)})),this.register((function(t){return new pp(t)})),this.register((function(t){return new mp(t)})),this.register((function(t){return new fp(t)})),this.register((function(t){return new ap(t)})),this.register((function(t){return new op(t)})),this.register((function(t){return new lp(t)})),this.register((function(t){return new hp(t)})),this.register((function(t){return new ip(t)})),this.register((function(t){return new cp(t)})),this.register((function(t){return new rp(t)})),this.register((function(t){return new dp(t)})),this.register((function(t){return new up(t)})),this.register((function(t){return new tp(t)})),this.register((function(t){return new gp(t)})),this.register((function(t){return new xp(t)}))}load(t,e,i,n){const s=this;let r;if(""!==this.resourcePath)r=this.resourcePath;else if(""!==this.path){const e=Kc.extractUrlBase(t);r=Kc.resolveURL(e,this.path)}else r=Kc.extractUrlBase(t);this.manager.itemStart(t);const a=function(e){n&&n(e),s.manager.itemError(t),s.manager.itemEnd(t)},o=new Nc(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(t,(function(i){try{s.parse(i,r,(function(i){e(i),s.manager.itemEnd(t)}),a)}catch(n){a(n)}}),i,a)}setDRACOLoader(t){return this.dracoLoader=t,this}setKTX2Loader(t){return this.ktx2Loader=t,this}setMeshoptDecoder(t){return this.meshoptDecoder=t,this}register(t){return-1===this.pluginCallbacks.indexOf(t)&&this.pluginCallbacks.push(t),this}unregister(t){return-1!==this.pluginCallbacks.indexOf(t)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t),1),this}parse(t,e,i,n){let s;const r={},a={},o=new TextDecoder;if("string"==typeof t)s=JSON.parse(t);else if(t instanceof ArrayBuffer){if(o.decode(new Uint8Array(t,0,4))===vp){try{r[Qd.KHR_BINARY_GLTF]=new bp(t)}catch(h){return void(n&&n(h))}s=JSON.parse(r[Qd.KHR_BINARY_GLTF].content)}else s=JSON.parse(o.decode(t))}else s=t;if(void 0===s.asset||s.asset.version[0]<2)return void(n&&n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));const l=new Xp(s,{path:e||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});l.fileLoader.setRequestHeader(this.requestHeader);for(let c=0;c<this.pluginCallbacks.length;c++){const t=this.pluginCallbacks[c](l);t.name,a[t.name]=t,r[t.name]=!0}if(s.extensionsUsed)for(let c=0;c<s.extensionsUsed.length;++c){const t=s.extensionsUsed[c],e=s.extensionsRequired||[];switch(t){case Qd.KHR_MATERIALS_UNLIT:r[t]=new ep;break;case Qd.KHR_DRACO_MESH_COMPRESSION:r[t]=new Sp(s,this.dracoLoader);break;case Qd.KHR_TEXTURE_TRANSFORM:r[t]=new Mp;break;case Qd.KHR_MESH_QUANTIZATION:r[t]=new Tp;break;default:e.indexOf(t)>=0&&a[t]}}l.setExtensions(r),l.setPlugins(a),l.parse(i,n)}parseAsync(t,e){const i=this;return new Promise((function(n,s){i.parse(t,e,n,s)}))}}function Jd(){let t={};return{get:function(e){return t[e]},add:function(e,i){t[e]=i},remove:function(e){delete t[e]},removeAll:function(){t={}}}}const Qd={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class tp{constructor(t){this.parser=t,this.name=Qd.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const t=this.parser,e=this.parser.json.nodes||[];for(let i=0,n=e.length;i<n;i++){const n=e[i];n.extensions&&n.extensions[this.name]&&void 0!==n.extensions[this.name].light&&t._addNodeRef(this.cache,n.extensions[this.name].light)}}_loadLight(t){const e=this.parser,i="light:"+t;let n=e.cache.get(i);if(n)return n;const s=e.json,r=((s.extensions&&s.extensions[this.name]||{}).lights||[])[t];let a;const o=new Dn(16777215);void 0!==r.color&&o.setRGB(r.color[0],r.color[1],r.color[2],le);const l=void 0!==r.range?r.range:0;switch(r.type){case"directional":a=new $c(o),a.target.position.set(0,0,-1),a.add(a.target);break;case"point":a=new Xc(o),a.distance=l;break;case"spot":a=new kc(o),a.distance=l,r.spot=r.spot||{},r.spot.innerConeAngle=void 0!==r.spot.innerConeAngle?r.spot.innerConeAngle:0,r.spot.outerConeAngle=void 0!==r.spot.outerConeAngle?r.spot.outerConeAngle:Math.PI/4,a.angle=r.spot.outerConeAngle,a.penumbra=1-r.spot.innerConeAngle/r.spot.outerConeAngle,a.target.position.set(0,0,-1),a.add(a.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+r.type)}return a.position.set(0,0,0),a.decay=2,kp(a,r),void 0!==r.intensity&&(a.intensity=r.intensity),a.name=e.createUniqueName(r.name||"light_"+t),n=Promise.resolve(a),e.cache.add(i,n),n}getDependency(t,e){if("light"===t)return this._loadLight(e)}createNodeAttachment(t){const e=this,i=this.parser,n=i.json.nodes[t],s=(n.extensions&&n.extensions[this.name]||{}).light;return void 0===s?null:this._loadLight(s).then((function(t){return i._getNodeRef(e.cache,s,t)}))}}class ep{constructor(){this.name=Qd.KHR_MATERIALS_UNLIT}getMaterialType(){return On}extendParams(t,e,i){const n=[];t.color=new Dn(1,1,1),t.opacity=1;const s=e.pbrMetallicRoughness;if(s){if(Array.isArray(s.baseColorFactor)){const e=s.baseColorFactor;t.color.setRGB(e[0],e[1],e[2],le),t.opacity=e[3]}void 0!==s.baseColorTexture&&n.push(i.assignTexture(t,"map",s.baseColorTexture,oe))}return Promise.all(n)}}class ip{constructor(t){this.parser=t,this.name=Qd.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(t,e){const i=this.parser.json.materials[t];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const n=i.extensions[this.name].emissiveStrength;return void 0!==n&&(e.emissiveIntensity=n),Promise.resolve()}}class np{constructor(t){this.parser=t,this.name=Qd.KHR_MATERIALS_CLEARCOAT}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?nc:null}extendMaterialParams(t,e){const i=this.parser,n=i.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const s=[],r=n.extensions[this.name];if(void 0!==r.clearcoatFactor&&(e.clearcoat=r.clearcoatFactor),void 0!==r.clearcoatTexture&&s.push(i.assignTexture(e,"clearcoatMap",r.clearcoatTexture)),void 0!==r.clearcoatRoughnessFactor&&(e.clearcoatRoughness=r.clearcoatRoughnessFactor),void 0!==r.clearcoatRoughnessTexture&&s.push(i.assignTexture(e,"clearcoatRoughnessMap",r.clearcoatRoughnessTexture)),void 0!==r.clearcoatNormalTexture&&(s.push(i.assignTexture(e,"clearcoatNormalMap",r.clearcoatNormalTexture)),void 0!==r.clearcoatNormalTexture.scale)){const t=r.clearcoatNormalTexture.scale;e.clearcoatNormalScale=new Fe(t,t)}return Promise.all(s)}}class sp{constructor(t){this.parser=t,this.name=Qd.KHR_MATERIALS_DISPERSION}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?nc:null}extendMaterialParams(t,e){const i=this.parser.json.materials[t];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const n=i.extensions[this.name];return e.dispersion=void 0!==n.dispersion?n.dispersion:0,Promise.resolve()}}class rp{constructor(t){this.parser=t,this.name=Qd.KHR_MATERIALS_IRIDESCENCE}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?nc:null}extendMaterialParams(t,e){const i=this.parser,n=i.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const s=[],r=n.extensions[this.name];return void 0!==r.iridescenceFactor&&(e.iridescence=r.iridescenceFactor),void 0!==r.iridescenceTexture&&s.push(i.assignTexture(e,"iridescenceMap",r.iridescenceTexture)),void 0!==r.iridescenceIor&&(e.iridescenceIOR=r.iridescenceIor),void 0===e.iridescenceThicknessRange&&(e.iridescenceThicknessRange=[100,400]),void 0!==r.iridescenceThicknessMinimum&&(e.iridescenceThicknessRange[0]=r.iridescenceThicknessMinimum),void 0!==r.iridescenceThicknessMaximum&&(e.iridescenceThicknessRange[1]=r.iridescenceThicknessMaximum),void 0!==r.iridescenceThicknessTexture&&s.push(i.assignTexture(e,"iridescenceThicknessMap",r.iridescenceThicknessTexture)),Promise.all(s)}}class ap{constructor(t){this.parser=t,this.name=Qd.KHR_MATERIALS_SHEEN}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?nc:null}extendMaterialParams(t,e){const i=this.parser,n=i.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const s=[];e.sheenColor=new Dn(0,0,0),e.sheenRoughness=0,e.sheen=1;const r=n.extensions[this.name];if(void 0!==r.sheenColorFactor){const t=r.sheenColorFactor;e.sheenColor.setRGB(t[0],t[1],t[2],le)}return void 0!==r.sheenRoughnessFactor&&(e.sheenRoughness=r.sheenRoughnessFactor),void 0!==r.sheenColorTexture&&s.push(i.assignTexture(e,"sheenColorMap",r.sheenColorTexture,oe)),void 0!==r.sheenRoughnessTexture&&s.push(i.assignTexture(e,"sheenRoughnessMap",r.sheenRoughnessTexture)),Promise.all(s)}}class op{constructor(t){this.parser=t,this.name=Qd.KHR_MATERIALS_TRANSMISSION}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?nc:null}extendMaterialParams(t,e){const i=this.parser,n=i.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const s=[],r=n.extensions[this.name];return void 0!==r.transmissionFactor&&(e.transmission=r.transmissionFactor),void 0!==r.transmissionTexture&&s.push(i.assignTexture(e,"transmissionMap",r.transmissionTexture)),Promise.all(s)}}class lp{constructor(t){this.parser=t,this.name=Qd.KHR_MATERIALS_VOLUME}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?nc:null}extendMaterialParams(t,e){const i=this.parser,n=i.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const s=[],r=n.extensions[this.name];e.thickness=void 0!==r.thicknessFactor?r.thicknessFactor:0,void 0!==r.thicknessTexture&&s.push(i.assignTexture(e,"thicknessMap",r.thicknessTexture)),e.attenuationDistance=r.attenuationDistance||1/0;const a=r.attenuationColor||[1,1,1];return e.attenuationColor=(new Dn).setRGB(a[0],a[1],a[2],le),Promise.all(s)}}class hp{constructor(t){this.parser=t,this.name=Qd.KHR_MATERIALS_IOR}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?nc:null}extendMaterialParams(t,e){const i=this.parser.json.materials[t];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const n=i.extensions[this.name];return e.ior=void 0!==n.ior?n.ior:1.5,Promise.resolve()}}class cp{constructor(t){this.parser=t,this.name=Qd.KHR_MATERIALS_SPECULAR}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?nc:null}extendMaterialParams(t,e){const i=this.parser,n=i.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const s=[],r=n.extensions[this.name];e.specularIntensity=void 0!==r.specularFactor?r.specularFactor:1,void 0!==r.specularTexture&&s.push(i.assignTexture(e,"specularIntensityMap",r.specularTexture));const a=r.specularColorFactor||[1,1,1];return e.specularColor=(new Dn).setRGB(a[0],a[1],a[2],le),void 0!==r.specularColorTexture&&s.push(i.assignTexture(e,"specularColorMap",r.specularColorTexture,oe)),Promise.all(s)}}class up{constructor(t){this.parser=t,this.name=Qd.EXT_MATERIALS_BUMP}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?nc:null}extendMaterialParams(t,e){const i=this.parser,n=i.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const s=[],r=n.extensions[this.name];return e.bumpScale=void 0!==r.bumpFactor?r.bumpFactor:1,void 0!==r.bumpTexture&&s.push(i.assignTexture(e,"bumpMap",r.bumpTexture)),Promise.all(s)}}class dp{constructor(t){this.parser=t,this.name=Qd.KHR_MATERIALS_ANISOTROPY}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?nc:null}extendMaterialParams(t,e){const i=this.parser,n=i.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const s=[],r=n.extensions[this.name];return void 0!==r.anisotropyStrength&&(e.anisotropy=r.anisotropyStrength),void 0!==r.anisotropyRotation&&(e.anisotropyRotation=r.anisotropyRotation),void 0!==r.anisotropyTexture&&s.push(i.assignTexture(e,"anisotropyMap",r.anisotropyTexture)),Promise.all(s)}}class pp{constructor(t){this.parser=t,this.name=Qd.KHR_TEXTURE_BASISU}loadTexture(t){const e=this.parser,i=e.json,n=i.textures[t];if(!n.extensions||!n.extensions[this.name])return null;const s=n.extensions[this.name],r=e.options.ktx2Loader;if(!r){if(i.extensionsRequired&&i.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return e.loadTextureImage(t,s.source,r)}}class mp{constructor(t){this.parser=t,this.name=Qd.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(t){const e=this.name,i=this.parser,n=i.json,s=n.textures[t];if(!s.extensions||!s.extensions[e])return null;const r=s.extensions[e],a=n.images[r.source];let o=i.textureLoader;if(a.uri){const t=i.options.manager.getHandler(a.uri);null!==t&&(o=t)}return this.detectSupport().then((function(s){if(s)return i.loadTextureImage(t,r.source,o);if(n.extensionsRequired&&n.extensionsRequired.indexOf(e)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return i.loadTexture(t)}))}detectSupport(){return this.isSupported||(this.isSupported=new Promise((function(t){const e=new Image;e.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",e.onload=e.onerror=function(){t(1===e.height)}}))),this.isSupported}}class fp{constructor(t){this.parser=t,this.name=Qd.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(t){const e=this.name,i=this.parser,n=i.json,s=n.textures[t];if(!s.extensions||!s.extensions[e])return null;const r=s.extensions[e],a=n.images[r.source];let o=i.textureLoader;if(a.uri){const t=i.options.manager.getHandler(a.uri);null!==t&&(o=t)}return this.detectSupport().then((function(s){if(s)return i.loadTextureImage(t,r.source,o);if(n.extensionsRequired&&n.extensionsRequired.indexOf(e)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return i.loadTexture(t)}))}detectSupport(){return this.isSupported||(this.isSupported=new Promise((function(t){const e=new Image;e.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",e.onload=e.onerror=function(){t(1===e.height)}}))),this.isSupported}}class gp{constructor(t){this.name=Qd.EXT_MESHOPT_COMPRESSION,this.parser=t}loadBufferView(t){const e=this.parser.json,i=e.bufferViews[t];if(i.extensions&&i.extensions[this.name]){const t=i.extensions[this.name],n=this.parser.getDependency("buffer",t.buffer),s=this.parser.options.meshoptDecoder;if(!s||!s.supported){if(e.extensionsRequired&&e.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return n.then((function(e){const i=t.byteOffset||0,n=t.byteLength||0,r=t.count,a=t.byteStride,o=new Uint8Array(e,i,n);return s.decodeGltfBufferAsync?s.decodeGltfBufferAsync(r,a,o,t.mode,t.filter).then((function(t){return t.buffer})):s.ready.then((function(){const e=new ArrayBuffer(r*a);return s.decodeGltfBuffer(new Uint8Array(e),r,a,o,t.mode,t.filter),e}))}))}return null}}class xp{constructor(t){this.name=Qd.EXT_MESH_GPU_INSTANCING,this.parser=t}createNodeMesh(t){const e=this.parser.json,i=e.nodes[t];if(!i.extensions||!i.extensions[this.name]||void 0===i.mesh)return null;const n=e.meshes[i.mesh];for(const o of n.primitives)if(o.mode!==Cp.TRIANGLES&&o.mode!==Cp.TRIANGLE_STRIP&&o.mode!==Cp.TRIANGLE_FAN&&void 0!==o.mode)return null;const s=i.extensions[this.name].attributes,r=[],a={};for(const o in s)r.push(this.parser.getDependency("accessor",s[o]).then((t=>(a[o]=t,a[o]))));return r.length<1?null:(r.push(this.parser.createNodeMesh(t)),Promise.all(r).then((t=>{const e=t.pop(),i=e.isGroup?e.children:[e],n=t[0].count,s=[];for(const r of i){const t=new Vi,e=new ui,i=new ci,o=new ui(1,1,1),l=new xl(r.geometry,r.material,n);for(let s=0;s<n;s++)a.TRANSLATION&&e.fromBufferAttribute(a.TRANSLATION,s),a.ROTATION&&i.fromBufferAttribute(a.ROTATION,s),a.SCALE&&o.fromBufferAttribute(a.SCALE,s),l.setMatrixAt(s,t.compose(e,i,o));for(const n in a)if("_COLOR_0"===n){const t=a[n];l.instanceColor=new hl(t.array,t.itemSize,t.normalized)}else"TRANSLATION"!==n&&"ROTATION"!==n&&"SCALE"!==n&&r.geometry.setAttribute(n,a[n]);fn.prototype.copy.call(l,r),this.parser.assignFinalMaterial(l),s.push(l)}return e.isGroup?(e.clear(),e.add(...s),e):s[0]})))}}const vp="glTF",_p=1313821514,yp=5130562;class bp{constructor(t){this.name=Qd.KHR_BINARY_GLTF,this.content=null,this.body=null;const e=new DataView(t,0,12),i=new TextDecoder;if(this.header={magic:i.decode(new Uint8Array(t.slice(0,4))),version:e.getUint32(4,!0),length:e.getUint32(8,!0)},this.header.magic!==vp)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const n=this.header.length-12,s=new DataView(t,12);let r=0;for(;r<n;){const e=s.getUint32(r,!0);r+=4;const n=s.getUint32(r,!0);if(r+=4,n===_p){const n=new Uint8Array(t,12+r,e);this.content=i.decode(n)}else if(n===yp){const i=12+r;this.body=t.slice(i,i+e)}r+=e}if(null===this.content)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class Sp{constructor(t,e){if(!e)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=Qd.KHR_DRACO_MESH_COMPRESSION,this.json=t,this.dracoLoader=e,this.dracoLoader.preload()}decodePrimitive(t,e){const i=this.json,n=this.dracoLoader,s=t.extensions[this.name].bufferView,r=t.extensions[this.name].attributes,a={},o={},l={};for(const h in r){const t=Lp[h]||h.toLowerCase();a[t]=r[h]}for(const h in t.attributes){const e=Lp[h]||h.toLowerCase();if(void 0!==r[h]){const n=i.accessors[t.attributes[h]],s=Rp[n.componentType];l[e]=s.name,o[e]=!0===n.normalized}}return e.getDependency("bufferView",s).then((function(t){return new Promise((function(e,i){n.decodeDracoFile(t,(function(t){for(const e in t.attributes){const i=t.attributes[e],n=o[e];void 0!==n&&(i.normalized=n)}e(t)}),a,l,le,i)}))}))}}class Mp{constructor(){this.name=Qd.KHR_TEXTURE_TRANSFORM}extendTexture(t,e){return void 0!==e.texCoord&&e.texCoord!==t.channel||void 0!==e.offset||void 0!==e.rotation||void 0!==e.scale?(t=t.clone(),void 0!==e.texCoord&&(t.channel=e.texCoord),void 0!==e.offset&&t.offset.fromArray(e.offset),void 0!==e.rotation&&(t.rotation=e.rotation),void 0!==e.scale&&t.repeat.fromArray(e.scale),t.needsUpdate=!0,t):t}}class Tp{constructor(){this.name=Qd.KHR_MESH_QUANTIZATION}}class wp extends uc{constructor(t,e,i,n){super(t,e,i,n)}copySampleValue_(t){const e=this.resultBuffer,i=this.sampleValues,n=this.valueSize,s=t*n*3+n;for(let r=0;r!==n;r++)e[r]=i[s+r];return e}interpolate_(t,e,i,n){const s=this.resultBuffer,r=this.sampleValues,a=this.valueSize,o=2*a,l=3*a,h=n-e,c=(i-e)/h,u=c*c,d=u*c,p=t*l,m=p-l,f=-2*d+3*u,g=d-u,x=1-f,v=g-u+c;for(let _=0;_!==a;_++){const t=r[m+_+a],e=r[m+_+o]*h,i=r[p+_+a],n=r[p+_]*h;s[_]=x*t+v*e+f*i+g*n}return s}}const Ap=new ci;class Ep extends wp{interpolate_(t,e,i,n){const s=super.interpolate_(t,e,i,n);return Ap.fromArray(s).normalize().toArray(s),s}}const Cp={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},Rp={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},Np={9728:Z,9729:Q,9984:1004,9985:tt,9986:J,9987:et},Pp={33071:$,33648:Y,10497:q},Ip={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Lp={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},Dp={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},Up={CUBICSPLINE:void 0,LINEAR:te,STEP:Qt},Fp="OPAQUE",Bp="MASK",Op="BLEND";function zp(t,e,i){for(const n in i.extensions)void 0===t[n]&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[n]=i.extensions[n])}function kp(t,e){void 0!==e.extras&&"object"==typeof e.extras&&Object.assign(t.userData,e.extras)}function Vp(t,e){if(t.updateMorphTargets(),void 0!==e.weights)for(let i=0,n=e.weights.length;i<n;i++)t.morphTargetInfluences[i]=e.weights[i];if(e.extras&&Array.isArray(e.extras.targetNames)){const i=e.extras.targetNames;if(t.morphTargetInfluences.length===i.length){t.morphTargetDictionary={};for(let e=0,n=i.length;e<n;e++)t.morphTargetDictionary[i[e]]=e}}}function Gp(t){let e;const i=t.extensions&&t.extensions[Qd.KHR_DRACO_MESH_COMPRESSION];if(e=i?"draco:"+i.bufferView+":"+i.indices+":"+Hp(i.attributes):t.indices+":"+Hp(t.attributes)+":"+t.mode,void 0!==t.targets)for(let n=0,s=t.targets.length;n<s;n++)e+=":"+Hp(t.targets[n]);return e}function Hp(t){let e="";const i=Object.keys(t).sort();for(let n=0,s=i.length;n<s;n++)e+=i[n]+":"+t[i[n]]+";";return e}function Wp(t){switch(t){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}const jp=new Vi;class Xp{constructor(t={},e={}){this.json=t,this.extensions={},this.plugins={},this.options=e,this.cache=new Jd,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let i=!1,n=-1,s=!1,r=-1;if("undefined"!=typeof navigator){const t=navigator.userAgent;i=!0===/^((?!chrome|android).)*safari/i.test(t);const e=t.match(/Version\/(\d+)/);n=i&&e?parseInt(e[1],10):-1,s=t.indexOf("Firefox")>-1,r=s?t.match(/Firefox\/([0-9]+)\./)[1]:-1}"undefined"==typeof createImageBitmap||i&&n<17||s&&r<98?this.textureLoader=new Ic(this.options.manager):this.textureLoader=new Jc(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new Nc(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),"use-credentials"===this.options.crossOrigin&&this.fileLoader.setWithCredentials(!0)}setExtensions(t){this.extensions=t}setPlugins(t){this.plugins=t}parse(t,e){const i=this,n=this.json,s=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll((function(t){return t._markDefs&&t._markDefs()})),Promise.all(this._invokeAll((function(t){return t.beforeRoot&&t.beforeRoot()}))).then((function(){return Promise.all([i.getDependencies("scene"),i.getDependencies("animation"),i.getDependencies("camera")])})).then((function(e){const r={scene:e[0][n.scene||0],scenes:e[0],animations:e[1],cameras:e[2],asset:n.asset,parser:i,userData:{}};return zp(s,r,n),kp(r,n),Promise.all(i._invokeAll((function(t){return t.afterRoot&&t.afterRoot(r)}))).then((function(){for(const t of r.scenes)t.updateMatrixWorld();t(r)}))})).catch(e)}_markDefs(){const t=this.json.nodes||[],e=this.json.skins||[],i=this.json.meshes||[];for(let n=0,s=e.length;n<s;n++){const i=e[n].joints;for(let e=0,n=i.length;e<n;e++)t[i[e]].isBone=!0}for(let n=0,s=t.length;n<s;n++){const e=t[n];void 0!==e.mesh&&(this._addNodeRef(this.meshCache,e.mesh),void 0!==e.skin&&(i[e.mesh].isSkinnedMesh=!0)),void 0!==e.camera&&this._addNodeRef(this.cameraCache,e.camera)}}_addNodeRef(t,e){void 0!==e&&(void 0===t.refs[e]&&(t.refs[e]=t.uses[e]=0),t.refs[e]++)}_getNodeRef(t,e,i){if(t.refs[e]<=1)return i;const n=i.clone(),s=(t,e)=>{const i=this.associations.get(t);null!=i&&this.associations.set(e,i);for(const[n,r]of t.children.entries())s(r,e.children[n])};return s(i,n),n.name+="_instance_"+t.uses[e]++,n}_invokeOne(t){const e=Object.values(this.plugins);e.push(this);for(let i=0;i<e.length;i++){const n=t(e[i]);if(n)return n}return null}_invokeAll(t){const e=Object.values(this.plugins);e.unshift(this);const i=[];for(let n=0;n<e.length;n++){const s=t(e[n]);s&&i.push(s)}return i}getDependency(t,e){const i=t+":"+e;let n=this.cache.get(i);if(!n){switch(t){case"scene":n=this.loadScene(e);break;case"node":n=this._invokeOne((function(t){return t.loadNode&&t.loadNode(e)}));break;case"mesh":n=this._invokeOne((function(t){return t.loadMesh&&t.loadMesh(e)}));break;case"accessor":n=this.loadAccessor(e);break;case"bufferView":n=this._invokeOne((function(t){return t.loadBufferView&&t.loadBufferView(e)}));break;case"buffer":n=this.loadBuffer(e);break;case"material":n=this._invokeOne((function(t){return t.loadMaterial&&t.loadMaterial(e)}));break;case"texture":n=this._invokeOne((function(t){return t.loadTexture&&t.loadTexture(e)}));break;case"skin":n=this.loadSkin(e);break;case"animation":n=this._invokeOne((function(t){return t.loadAnimation&&t.loadAnimation(e)}));break;case"camera":n=this.loadCamera(e);break;default:if(n=this._invokeOne((function(i){return i!=this&&i.getDependency&&i.getDependency(t,e)})),!n)throw new Error("Unknown type: "+t)}this.cache.add(i,n)}return n}getDependencies(t){let e=this.cache.get(t);if(!e){const i=this,n=this.json[t+("mesh"===t?"es":"s")]||[];e=Promise.all(n.map((function(e,n){return i.getDependency(t,n)}))),this.cache.add(t,e)}return e}loadBuffer(t){const e=this.json.buffers[t],i=this.fileLoader;if(e.type&&"arraybuffer"!==e.type)throw new Error("THREE.GLTFLoader: "+e.type+" buffer type is not supported.");if(void 0===e.uri&&0===t)return Promise.resolve(this.extensions[Qd.KHR_BINARY_GLTF].body);const n=this.options;return new Promise((function(t,s){i.load(Kc.resolveURL(e.uri,n.path),t,void 0,(function(){s(new Error('THREE.GLTFLoader: Failed to load buffer "'+e.uri+'".'))}))}))}loadBufferView(t){const e=this.json.bufferViews[t];return this.getDependency("buffer",e.buffer).then((function(t){const i=e.byteLength||0,n=e.byteOffset||0;return t.slice(n,n+i)}))}loadAccessor(t){const e=this,i=this.json,n=this.json.accessors[t];if(void 0===n.bufferView&&void 0===n.sparse){const t=Ip[n.type],e=Rp[n.componentType],i=!0===n.normalized,s=new e(n.count*t);return Promise.resolve(new Vn(s,t,i))}const s=[];return void 0!==n.bufferView?s.push(this.getDependency("bufferView",n.bufferView)):s.push(null),void 0!==n.sparse&&(s.push(this.getDependency("bufferView",n.sparse.indices.bufferView)),s.push(this.getDependency("bufferView",n.sparse.values.bufferView))),Promise.all(s).then((function(t){const s=t[0],r=Ip[n.type],a=Rp[n.componentType],o=a.BYTES_PER_ELEMENT,l=o*r,h=n.byteOffset||0,c=void 0!==n.bufferView?i.bufferViews[n.bufferView].byteStride:void 0,u=!0===n.normalized;let d,p;if(c&&c!==l){const t=Math.floor(h/c),i="InterleavedBuffer:"+n.bufferView+":"+n.componentType+":"+t+":"+n.count;let l=e.cache.get(i);l||(d=new a(s,t*c,n.count*c/o),l=new Ro(d,c/o),e.cache.add(i,l)),p=new Io(l,r,h%c/o,u)}else d=null===s?new a(n.count*r):new a(s,h,n.count*r),p=new Vn(d,r,u);if(void 0!==n.sparse){const e=Ip.SCALAR,i=Rp[n.sparse.indices.componentType],o=n.sparse.indices.byteOffset||0,l=n.sparse.values.byteOffset||0,h=new i(t[1],o,n.sparse.count*e),c=new a(t[2],l,n.sparse.count*r);null!==s&&(p=new Vn(p.array.slice(),p.itemSize,p.normalized)),p.normalized=!1;for(let t=0,n=h.length;t<n;t++){const e=h[t];if(p.setX(e,c[t*r]),r>=2&&p.setY(e,c[t*r+1]),r>=3&&p.setZ(e,c[t*r+2]),r>=4&&p.setW(e,c[t*r+3]),r>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}p.normalized=u}return p}))}loadTexture(t){const e=this.json,i=this.options,n=e.textures[t].source,s=e.images[n];let r=this.textureLoader;if(s.uri){const t=i.manager.getHandler(s.uri);null!==t&&(r=t)}return this.loadTextureImage(t,n,r)}loadTextureImage(t,e,i){const n=this,s=this.json,r=s.textures[t],a=s.images[e],o=(a.uri||a.bufferView)+":"+r.sampler;if(this.textureCache[o])return this.textureCache[o];const l=this.loadImageSource(e,i).then((function(e){e.flipY=!1,e.name=r.name||a.name||"",""===e.name&&"string"==typeof a.uri&&!1===a.uri.startsWith("data:image/")&&(e.name=a.uri);const i=(s.samplers||{})[r.sampler]||{};return e.magFilter=Np[i.magFilter]||Q,e.minFilter=Np[i.minFilter]||et,e.wrapS=Pp[i.wrapS]||q,e.wrapT=Pp[i.wrapT]||q,e.generateMipmaps=!e.isCompressedTexture&&e.minFilter!==Z&&e.minFilter!==Q,n.associations.set(e,{textures:t}),e})).catch((function(){return null}));return this.textureCache[o]=l,l}loadImageSource(t,e){const i=this,n=this.json,s=this.options;if(void 0!==this.sourceCache[t])return this.sourceCache[t].then((t=>t.clone()));const r=n.images[t],a=self.URL||self.webkitURL;let o=r.uri||"",l=!1;if(void 0!==r.bufferView)o=i.getDependency("bufferView",r.bufferView).then((function(t){l=!0;const e=new Blob([t],{type:r.mimeType});return o=a.createObjectURL(e),o}));else if(void 0===r.uri)throw new Error("THREE.GLTFLoader: Image "+t+" is missing URI and bufferView");const h=Promise.resolve(o).then((function(t){return new Promise((function(i,n){let r=i;!0===e.isImageBitmapLoader&&(r=function(t){const e=new si(t);e.needsUpdate=!0,i(e)}),e.load(Kc.resolveURL(t,s.path),r,void 0,n)}))})).then((function(t){var e;return!0===l&&a.revokeObjectURL(o),kp(t,r),t.userData.mimeType=r.mimeType||((e=r.uri).search(/\.jpe?g($|\?)/i)>0||0===e.search(/^data\:image\/jpeg/)?"image/jpeg":e.search(/\.webp($|\?)/i)>0||0===e.search(/^data\:image\/webp/)?"image/webp":e.search(/\.ktx2($|\?)/i)>0||0===e.search(/^data\:image\/ktx2/)?"image/ktx2":"image/png"),t})).catch((function(t){throw t}));return this.sourceCache[t]=h,h}assignTexture(t,e,i,n){const s=this;return this.getDependency("texture",i.index).then((function(r){if(!r)return null;if(void 0!==i.texCoord&&i.texCoord>0&&((r=r.clone()).channel=i.texCoord),s.extensions[Qd.KHR_TEXTURE_TRANSFORM]){const t=void 0!==i.extensions?i.extensions[Qd.KHR_TEXTURE_TRANSFORM]:void 0;if(t){const e=s.associations.get(r);r=s.extensions[Qd.KHR_TEXTURE_TRANSFORM].extendTexture(r,t),s.associations.set(r,e)}}return void 0!==n&&(r.colorSpace=n),t[e]=r,r}))}assignFinalMaterial(t){const e=t.geometry;let i=t.material;const n=void 0===e.attributes.tangent,s=void 0!==e.attributes.color,r=void 0===e.attributes.normal;if(t.isPoints){const t="PointsMaterial:"+i.uuid;let e=this.cache.get(t);e||(e=new Il,Bn.prototype.copy.call(e,i),e.color.copy(i.color),e.map=i.map,e.sizeAttenuation=!1,this.cache.add(t,e)),i=e}else if(t.isLine){const t="LineBasicMaterial:"+i.uuid;let e=this.cache.get(t);e||(e=new vl,Bn.prototype.copy.call(e,i),e.color.copy(i.color),e.map=i.map,this.cache.add(t,e)),i=e}if(n||s||r){let t="ClonedMaterial:"+i.uuid+":";n&&(t+="derivative-tangents:"),s&&(t+="vertex-colors:"),r&&(t+="flat-shading:");let e=this.cache.get(t);e||(e=i.clone(),s&&(e.vertexColors=!0),r&&(e.flatShading=!0),n&&(e.normalScale&&(e.normalScale.y*=-1),e.clearcoatNormalScale&&(e.clearcoatNormalScale.y*=-1)),this.cache.add(t,e),this.associations.set(e,this.associations.get(i))),i=e}t.material=i}getMaterialType(){return ic}loadMaterial(t){const e=this,i=this.json,n=this.extensions,s=i.materials[t];let r;const a={},o=[];if((s.extensions||{})[Qd.KHR_MATERIALS_UNLIT]){const t=n[Qd.KHR_MATERIALS_UNLIT];r=t.getMaterialType(),o.push(t.extendParams(a,s,e))}else{const i=s.pbrMetallicRoughness||{};if(a.color=new Dn(1,1,1),a.opacity=1,Array.isArray(i.baseColorFactor)){const t=i.baseColorFactor;a.color.setRGB(t[0],t[1],t[2],le),a.opacity=t[3]}void 0!==i.baseColorTexture&&o.push(e.assignTexture(a,"map",i.baseColorTexture,oe)),a.metalness=void 0!==i.metallicFactor?i.metallicFactor:1,a.roughness=void 0!==i.roughnessFactor?i.roughnessFactor:1,void 0!==i.metallicRoughnessTexture&&(o.push(e.assignTexture(a,"metalnessMap",i.metallicRoughnessTexture)),o.push(e.assignTexture(a,"roughnessMap",i.metallicRoughnessTexture))),r=this._invokeOne((function(e){return e.getMaterialType&&e.getMaterialType(t)})),o.push(Promise.all(this._invokeAll((function(e){return e.extendMaterialParams&&e.extendMaterialParams(t,a)}))))}!0===s.doubleSided&&(a.side=2);const l=s.alphaMode||Fp;if(l===Op?(a.transparent=!0,a.depthWrite=!1):(a.transparent=!1,l===Bp&&(a.alphaTest=void 0!==s.alphaCutoff?s.alphaCutoff:.5)),void 0!==s.normalTexture&&r!==On&&(o.push(e.assignTexture(a,"normalMap",s.normalTexture)),a.normalScale=new Fe(1,1),void 0!==s.normalTexture.scale)){const t=s.normalTexture.scale;a.normalScale.set(t,t)}if(void 0!==s.occlusionTexture&&r!==On&&(o.push(e.assignTexture(a,"aoMap",s.occlusionTexture)),void 0!==s.occlusionTexture.strength&&(a.aoMapIntensity=s.occlusionTexture.strength)),void 0!==s.emissiveFactor&&r!==On){const t=s.emissiveFactor;a.emissive=(new Dn).setRGB(t[0],t[1],t[2],le)}return void 0!==s.emissiveTexture&&r!==On&&o.push(e.assignTexture(a,"emissiveMap",s.emissiveTexture,oe)),Promise.all(o).then((function(){const i=new r(a);return s.name&&(i.name=s.name),kp(i,s),e.associations.set(i,{materials:t}),s.extensions&&zp(n,i,s),i}))}createUniqueName(t){const e=xu.sanitizeNodeName(t||"");return e in this.nodeNamesUsed?e+"_"+ ++this.nodeNamesUsed[e]:(this.nodeNamesUsed[e]=0,e)}loadGeometries(t){const e=this,i=this.extensions,n=this.primitiveCache;function s(t){return i[Qd.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t,e).then((function(i){return qp(i,t,e)}))}const r=[];for(let a=0,o=t.length;a<o;a++){const i=t[a],o=Gp(i),l=n[o];if(l)r.push(l.promise);else{let t;t=i.extensions&&i.extensions[Qd.KHR_DRACO_MESH_COMPRESSION]?s(i):qp(new Jn,i,e),n[o]={primitive:i,promise:t},r.push(t)}}return Promise.all(r)}loadMesh(t){const e=this,i=this.json,n=this.extensions,s=i.meshes[t],r=s.primitives,a=[];for(let l=0,h=r.length;l<h;l++){const t=void 0===r[l].material?(void 0===(o=this.cache).DefaultMaterial&&(o.DefaultMaterial=new ic({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:0})),o.DefaultMaterial):this.getDependency("material",r[l].material);a.push(t)}var o;return a.push(e.loadGeometries(r)),Promise.all(a).then((function(i){const a=i.slice(0,i.length-1),o=i[i.length-1],l=[];for(let c=0,u=o.length;c<u;c++){const i=o[c],h=r[c];let u;const d=a[c];if(h.mode===Cp.TRIANGLES||h.mode===Cp.TRIANGLE_STRIP||h.mode===Cp.TRIANGLE_FAN||void 0===h.mode)u=!0===s.isSkinnedMesh?new nl(i,d):new cs(i,d),!0===u.isSkinnedMesh&&u.normalizeSkinWeights(),h.mode===Cp.TRIANGLE_STRIP?u.geometry=Zd(u.geometry,1):h.mode===Cp.TRIANGLE_FAN&&(u.geometry=Zd(u.geometry,2));else if(h.mode===Cp.LINES)u=new Nl(i,d);else if(h.mode===Cp.LINE_STRIP)u=new Al(i,d);else if(h.mode===Cp.LINE_LOOP)u=new Pl(i,d);else{if(h.mode!==Cp.POINTS)throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+h.mode);u=new Bl(i,d)}Object.keys(u.geometry.morphAttributes).length>0&&Vp(u,s),u.name=e.createUniqueName(s.name||"mesh_"+t),kp(u,s),h.extensions&&zp(n,u,h),e.assignFinalMaterial(u),l.push(u)}for(let n=0,s=l.length;n<s;n++)e.associations.set(l[n],{meshes:t,primitives:n});if(1===l.length)return s.extensions&&zp(n,l[0],s),l[0];const h=new xo;s.extensions&&zp(n,h,s),e.associations.set(h,{meshes:t});for(let t=0,e=l.length;t<e;t++)h.add(l[t]);return h}))}loadCamera(t){let e;const i=this.json.cameras[t],n=i[i.type];if(n)return"perspective"===i.type?e=new Ss(Ue.radToDeg(n.yfov),n.aspectRatio||1,n.znear||1,n.zfar||2e6):"orthographic"===i.type&&(e=new Ys(-n.xmag,n.xmag,n.ymag,-n.ymag,n.znear,n.zfar)),i.name&&(e.name=this.createUniqueName(i.name)),kp(e,i),Promise.resolve(e)}loadSkin(t){const e=this.json.skins[t],i=[];for(let n=0,s=e.joints.length;n<s;n++)i.push(this._loadNodeShallow(e.joints[n]));return void 0!==e.inverseBindMatrices?i.push(this.getDependency("accessor",e.inverseBindMatrices)):i.push(null),Promise.all(i).then((function(t){const e=t.pop(),i=t,n=[],s=[];for(let r=0,a=i.length;r<a;r++){const t=i[r];if(t){n.push(t);const i=new Vi;null!==e&&i.fromArray(e.array,16*r),s.push(i)}}return new ll(n,s)}))}loadAnimation(t){const e=this.json,i=this,n=e.animations[t],s=n.name?n.name:"animation_"+t,r=[],a=[],o=[],l=[],h=[];for(let c=0,u=n.channels.length;c<u;c++){const t=n.channels[c],e=n.samplers[t.sampler],i=t.target,s=i.node,u=void 0!==n.parameters?n.parameters[e.input]:e.input,d=void 0!==n.parameters?n.parameters[e.output]:e.output;void 0!==i.node&&(r.push(this.getDependency("node",s)),a.push(this.getDependency("accessor",u)),o.push(this.getDependency("accessor",d)),l.push(e),h.push(i))}return Promise.all([Promise.all(r),Promise.all(a),Promise.all(o),Promise.all(l),Promise.all(h)]).then((function(t){const e=t[0],n=t[1],r=t[2],a=t[3],o=t[4],l=[];for(let s=0,h=e.length;s<h;s++){const t=e[s],h=n[s],c=r[s],u=a[s],d=o[s];if(void 0===t)continue;t.updateMatrix&&t.updateMatrix();const p=i._createAnimationTracks(t,h,c,u,d);if(p)for(let e=0;e<p.length;e++)l.push(p[e])}return new Mc(s,void 0,l)}))}createNodeMesh(t){const e=this.json,i=this,n=e.nodes[t];return void 0===n.mesh?null:i.getDependency("mesh",n.mesh).then((function(t){const e=i._getNodeRef(i.meshCache,n.mesh,t);return void 0!==n.weights&&e.traverse((function(t){if(t.isMesh)for(let e=0,i=n.weights.length;e<i;e++)t.morphTargetInfluences[e]=n.weights[e]})),e}))}loadNode(t){const e=this,i=this.json.nodes[t],n=e._loadNodeShallow(t),s=[],r=i.children||[];for(let o=0,l=r.length;o<l;o++)s.push(e.getDependency("node",r[o]));const a=void 0===i.skin?Promise.resolve(null):e.getDependency("skin",i.skin);return Promise.all([n,Promise.all(s),a]).then((function(t){const e=t[0],i=t[1],n=t[2];null!==n&&e.traverse((function(t){t.isSkinnedMesh&&t.bind(n,jp)}));for(let s=0,r=i.length;s<r;s++)e.add(i[s]);return e}))}_loadNodeShallow(t){const e=this.json,i=this.extensions,n=this;if(void 0!==this.nodeCache[t])return this.nodeCache[t];const s=e.nodes[t],r=s.name?n.createUniqueName(s.name):"",a=[],o=n._invokeOne((function(e){return e.createNodeMesh&&e.createNodeMesh(t)}));return o&&a.push(o),void 0!==s.camera&&a.push(n.getDependency("camera",s.camera).then((function(t){return n._getNodeRef(n.cameraCache,s.camera,t)}))),n._invokeAll((function(e){return e.createNodeAttachment&&e.createNodeAttachment(t)})).forEach((function(t){a.push(t)})),this.nodeCache[t]=Promise.all(a).then((function(e){let a;if(a=!0===s.isBone?new sl:e.length>1?new xo:1===e.length?e[0]:new fn,a!==e[0])for(let t=0,i=e.length;t<i;t++)a.add(e[t]);if(s.name&&(a.userData.name=s.name,a.name=r),kp(a,s),s.extensions&&zp(i,a,s),void 0!==s.matrix){const t=new Vi;t.fromArray(s.matrix),a.applyMatrix4(t)}else void 0!==s.translation&&a.position.fromArray(s.translation),void 0!==s.rotation&&a.quaternion.fromArray(s.rotation),void 0!==s.scale&&a.scale.fromArray(s.scale);return n.associations.has(a)||n.associations.set(a,{}),n.associations.get(a).nodes=t,a})),this.nodeCache[t]}loadScene(t){const e=this.extensions,i=this.json.scenes[t],n=this,s=new xo;i.name&&(s.name=n.createUniqueName(i.name)),kp(s,i),i.extensions&&zp(e,s,i);const r=i.nodes||[],a=[];for(let o=0,l=r.length;o<l;o++)a.push(n.getDependency("node",r[o]));return Promise.all(a).then((function(t){for(let e=0,i=t.length;e<i;e++)s.add(t[e]);return n.associations=(t=>{const e=new Map;for(const[i,s]of n.associations)(i instanceof Bn||i instanceof si)&&e.set(i,s);return t.traverse((t=>{const i=n.associations.get(t);null!=i&&e.set(t,i)})),e})(s),s}))}_createAnimationTracks(t,e,i,n,s){const r=[],a=t.name?t.name:t.uuid,o=[];let l;switch(Dp[s.path]===Dp.weights?t.traverse((function(t){t.morphTargetInfluences&&o.push(t.name?t.name:t.uuid)})):o.push(a),Dp[s.path]){case Dp.weights:l=vc;break;case Dp.rotation:l=yc;break;case Dp.position:case Dp.scale:l=Sc;break;default:if(1===i.itemSize)l=vc;else l=Sc}const h=void 0!==n.interpolation?Up[n.interpolation]:te,c=this._getArrayFromAccessor(i);for(let u=0,d=o.length;u<d;u++){const t=new l(o[u]+"."+Dp[s.path],e.array,c,h);"CUBICSPLINE"===n.interpolation&&this._createCubicSplineTrackInterpolant(t),r.push(t)}return r}_getArrayFromAccessor(t){let e=t.array;if(t.normalized){const t=Wp(e.constructor),i=new Float32Array(e.length);for(let n=0,s=e.length;n<s;n++)i[n]=e[n]*t;e=i}return e}_createCubicSplineTrackInterpolant(t){t.createInterpolant=function(t){return new(this instanceof yc?Ep:wp)(this.times,this.values,this.getValueSize()/3,t)},t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function qp(t,e,i){const n=e.attributes,s=[];function r(e,n){return i.getDependency("accessor",e).then((function(e){t.setAttribute(n,e)}))}for(const a in n){const e=Lp[a]||a.toLowerCase();e in t.attributes||s.push(r(n[a],e))}if(void 0!==e.indices&&!t.index){const n=i.getDependency("accessor",e.indices).then((function(e){t.setIndex(e)}));s.push(n)}return We.workingColorSpace,kp(t,e),function(t,e,i){const n=e.attributes,s=new mi;if(void 0===n.POSITION)return;{const t=i.json.accessors[n.POSITION],e=t.min,r=t.max;if(void 0===e||void 0===r)return;if(s.set(new ui(e[0],e[1],e[2]),new ui(r[0],r[1],r[2])),t.normalized){const e=Wp(Rp[t.componentType]);s.min.multiplyScalar(e),s.max.multiplyScalar(e)}}const r=e.targets;if(void 0!==r){const t=new ui,e=new ui;for(let n=0,s=r.length;n<s;n++){const s=r[n];if(void 0!==s.POSITION){const n=i.json.accessors[s.POSITION],r=n.min,a=n.max;if(void 0!==r&&void 0!==a){if(e.setX(Math.max(Math.abs(r[0]),Math.abs(a[0]))),e.setY(Math.max(Math.abs(r[1]),Math.abs(a[1]))),e.setZ(Math.max(Math.abs(r[2]),Math.abs(a[2]))),n.normalized){const t=Wp(Rp[n.componentType]);e.multiplyScalar(t)}t.max(e)}}}s.expandByVector(t)}t.boundingBox=s;const a=new Ii;s.getCenter(a.center),a.radius=s.min.distanceTo(s.max)/2,t.boundingSphere=a}(t,e,i),Promise.all(s).then((function(){return void 0!==e.targets?function(t,e,i){let n=!1,s=!1,r=!1;for(let h=0,c=e.length;h<c;h++){const t=e[h];if(void 0!==t.POSITION&&(n=!0),void 0!==t.NORMAL&&(s=!0),void 0!==t.COLOR_0&&(r=!0),n&&s&&r)break}if(!n&&!s&&!r)return Promise.resolve(t);const a=[],o=[],l=[];for(let h=0,c=e.length;h<c;h++){const c=e[h];if(n){const e=void 0!==c.POSITION?i.getDependency("accessor",c.POSITION):t.attributes.position;a.push(e)}if(s){const e=void 0!==c.NORMAL?i.getDependency("accessor",c.NORMAL):t.attributes.normal;o.push(e)}if(r){const e=void 0!==c.COLOR_0?i.getDependency("accessor",c.COLOR_0):t.attributes.color;l.push(e)}}return Promise.all([Promise.all(a),Promise.all(o),Promise.all(l)]).then((function(e){const i=e[0],a=e[1],o=e[2];return n&&(t.morphAttributes.position=i),s&&(t.morphAttributes.normal=a),r&&(t.morphAttributes.color=o),t.morphTargetsRelative=!0,t}))}(t,e.targets,i):t}))}class $p{constructor(){this.isPass=!0,this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){}dispose(){}}const Yp=new Ys(-1,1,1,-1,0,1);const Zp=new class extends Jn{constructor(){super(),this.setAttribute("position",new Wn([-1,3,0,-1,-1,0,3,-1,0],3)),this.setAttribute("uv",new Wn([0,2,0,0,2,0],2))}};class Kp{constructor(t){this._mesh=new cs(Zp,t)}dispose(){this._mesh.geometry.dispose()}render(t){t.render(this._mesh,Yp)}get material(){return this._mesh.material}set material(t){this._mesh.material=t}}class Jp extends Jn{constructor(t=(t,e,i)=>i.set(t,e,Math.cos(t)*Math.sin(e)),e=8,i=8){super(),this.type="ParametricGeometry",this.parameters={func:t,slices:e,stacks:i};const n=[],s=[],r=[],a=[],o=1e-5,l=new ui,h=new ui,c=new ui,u=new ui,d=new ui,p=e+1;for(let m=0;m<=i;m++){const n=m/i;for(let i=0;i<=e;i++){const p=i/e;t(p,n,h),s.push(h.x,h.y,h.z),p-o>=0?(t(p-o,n,c),u.subVectors(h,c)):(t(p+o,n,c),u.subVectors(c,h)),n-o>=0?(t(p,n-o,c),d.subVectors(h,c)):(t(p,n+o,c),d.subVectors(c,h)),l.crossVectors(u,d).normalize(),r.push(l.x,l.y,l.z),a.push(p,n)}}for(let m=0;m<i;m++)for(let t=0;t<e;t++){const e=m*p+t,i=m*p+t+1,s=(m+1)*p+t+1,r=(m+1)*p+t;n.push(e,i,r),n.push(i,s,r)}this.setIndex(n),this.setAttribute("position",new Wn(s,3)),this.setAttribute("normal",new Wn(r,3)),this.setAttribute("uv",new Wn(a,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}}class Qp extends qh{constructor(t,e={}){const i=e.font;if(void 0===i)super();else{const n=i.generateShapes(t,e.size);void 0===e.depth&&e.height,e.depth=void 0!==e.depth?e.depth:void 0!==e.height?e.height:50,void 0===e.bevelThickness&&(e.bevelThickness=10),void 0===e.bevelSize&&(e.bevelSize=8),void 0===e.bevelEnabled&&(e.bevelEnabled=!1),super(n,e)}this.type="TextGeometry"}}const tm=new WeakMap;class em extends Ec{constructor(t){super(t),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(t){return this.decoderPath=t,this}setDecoderConfig(t){return this.decoderConfig=t,this}setWorkerLimit(t){return this.workerLimit=t,this}load(t,e,i,n){const s=new Nc(this.manager);s.setPath(this.path),s.setResponseType("arraybuffer"),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(t,(t=>{this.parse(t,e,n)}),i,n)}parse(t,e,i=()=>{}){this.decodeDracoFile(t,e,null,null,oe,i).catch(i)}decodeDracoFile(t,e,i,n,s=le,r=()=>{}){const a={attributeIDs:i||this.defaultAttributeIDs,attributeTypes:n||this.defaultAttributeTypes,useUniqueIDs:!!i,vertexColorSpace:s};return this.decodeGeometry(t,a).then(e).catch(r)}decodeGeometry(t,e){const i=JSON.stringify(e);if(tm.has(t)){const e=tm.get(t);if(e.key===i)return e.promise;if(0===t.byteLength)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let n;const s=this.workerNextTaskID++,r=t.byteLength,a=this._getWorker(s,r).then((i=>(n=i,new Promise(((i,r)=>{n._callbacks[s]={resolve:i,reject:r},n.postMessage({type:"decode",id:s,taskConfig:e,buffer:t},[t])}))))).then((t=>this._createGeometry(t.geometry)));return a.catch((()=>!0)).then((()=>{n&&s&&this._releaseTask(n,s)})),tm.set(t,{key:i,promise:a}),a}_createGeometry(t){const e=new Jn;t.index&&e.setIndex(new Vn(t.index.array,1));for(let i=0;i<t.attributes.length;i++){const n=t.attributes[i],s=n.name,r=n.array,a=n.itemSize,o=new Vn(r,a);"color"===s&&(this._assignVertexColorSpace(o,n.vertexColorSpace),o.normalized=r instanceof Float32Array==!1),e.setAttribute(s,o)}return e}_assignVertexColorSpace(t,e){if(e!==oe)return;const i=new Dn;for(let n=0,s=t.count;n<s;n++)i.fromBufferAttribute(t,n),We.toWorkingColorSpace(i,oe),t.setXYZ(n,i.r,i.g,i.b)}_loadLibrary(t,e){const i=new Nc(this.manager);return i.setPath(this.decoderPath),i.setResponseType(e),i.setWithCredentials(this.withCredentials),new Promise(((e,n)=>{i.load(t,e,void 0,n)}))}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const t="object"!=typeof WebAssembly||"js"===this.decoderConfig.type,e=[];return t?e.push(this._loadLibrary("draco_decoder.js","text")):(e.push(this._loadLibrary("draco_wasm_wrapper.js","text")),e.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(e).then((e=>{const i=e[0];t||(this.decoderConfig.wasmBinary=e[1]);const n=im.toString(),s=["/* draco decoder */",i,"","/* worker */",n.substring(n.indexOf("{")+1,n.lastIndexOf("}"))].join("\n");this.workerSourceURL=URL.createObjectURL(new Blob([s]))})),this.decoderPending}_getWorker(t,e){return this._initDecoder().then((()=>{if(this.workerPool.length<this.workerLimit){const t=new Worker(this.workerSourceURL);t._callbacks={},t._taskCosts={},t._taskLoad=0,t.postMessage({type:"init",decoderConfig:this.decoderConfig}),t.onmessage=function(e){const i=e.data;switch(i.type){case"decode":t._callbacks[i.id].resolve(i);break;case"error":t._callbacks[i.id].reject(i)}},this.workerPool.push(t)}else this.workerPool.sort((function(t,e){return t._taskLoad>e._taskLoad?-1:1}));const i=this.workerPool[this.workerPool.length-1];return i._taskCosts[t]=e,i._taskLoad+=e,i}))}_releaseTask(t,e){t._taskLoad-=t._taskCosts[e],delete t._callbacks[e],delete t._taskCosts[e]}debug(){}dispose(){for(let t=0;t<this.workerPool.length;++t)this.workerPool[t].terminate();return this.workerPool.length=0,""!==this.workerSourceURL&&URL.revokeObjectURL(this.workerSourceURL),this}}function im(){let t,e;function i(t,e,i,n,s,r){const a=r.num_components(),o=i.num_points()*a,l=o*s.BYTES_PER_ELEMENT,h=function(t,e){switch(e){case Float32Array:return t.DT_FLOAT32;case Int8Array:return t.DT_INT8;case Int16Array:return t.DT_INT16;case Int32Array:return t.DT_INT32;case Uint8Array:return t.DT_UINT8;case Uint16Array:return t.DT_UINT16;case Uint32Array:return t.DT_UINT32}}(t,s),c=t._malloc(l);e.GetAttributeDataArrayForAllPoints(i,r,h,l,c);const u=new s(t.HEAPF32.buffer,c,o).slice();return t._free(c),{name:n,array:u,itemSize:a}}onmessage=function(n){const s=n.data;switch(s.type){case"init":t=s.decoderConfig,e=new Promise((function(e){t.onModuleLoaded=function(t){e({draco:t})},DracoDecoderModule(t)}));break;case"decode":const n=s.buffer,r=s.taskConfig;e.then((t=>{const e=t.draco,a=new e.Decoder;try{const t=function(t,e,n,s){const r=s.attributeIDs,a=s.attributeTypes;let o,l;const h=e.GetEncodedGeometryType(n);if(h===t.TRIANGULAR_MESH)o=new t.Mesh,l=e.DecodeArrayToMesh(n,n.byteLength,o);else{if(h!==t.POINT_CLOUD)throw new Error("THREE.DRACOLoader: Unexpected geometry type.");o=new t.PointCloud,l=e.DecodeArrayToPointCloud(n,n.byteLength,o)}if(!l.ok()||0===o.ptr)throw new Error("THREE.DRACOLoader: Decoding failed: "+l.error_msg());const c={index:null,attributes:[]};for(const u in r){const n=self[a[u]];let l,h;if(s.useUniqueIDs)h=r[u],l=e.GetAttributeByUniqueId(o,h);else{if(h=e.GetAttributeId(o,t[r[u]]),-1===h)continue;l=e.GetAttribute(o,h)}const d=i(t,e,o,u,n,l);"color"===u&&(d.vertexColorSpace=s.vertexColorSpace),c.attributes.push(d)}h===t.TRIANGULAR_MESH&&(c.index=function(t,e,i){const n=i.num_faces(),s=3*n,r=4*s,a=t._malloc(r);e.GetTrianglesUInt32Array(i,r,a);const o=new Uint32Array(t.HEAPF32.buffer,a,s).slice();return t._free(a),{array:o,itemSize:1}}(t,e,o));return t.destroy(o),c}(e,a,new Int8Array(n),r),o=t.attributes.map((t=>t.array.buffer));t.index&&o.push(t.index.array.buffer),self.postMessage({type:"decode",id:s.id,geometry:t},o)}catch(o){self.postMessage({type:"error",id:s.id,error:o.message})}finally{e.destroy(a)}}))}}}class nm extends Ec{constructor(t){super(t)}load(t,e,i,n){const s=this,r=new Nc(this.manager);r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(t,(function(t){const i=s.parse(JSON.parse(t));e&&e(i)}),i,n)}parse(t){return new sm(t)}}class sm{constructor(t){this.isFont=!0,this.type="Font",this.data=t}generateShapes(t,e=100){const i=[],n=function(t,e,i){const n=Array.from(t),s=e/i.resolution,r=(i.boundingBox.yMax-i.boundingBox.yMin+i.underlineThickness)*s,a=[];let o=0,l=0;for(let h=0;h<n.length;h++){const t=n[h];if("\n"===t)o=0,l-=r;else{const e=rm(t,s,o,l,i);o+=e.offsetX,a.push(e.path)}}return a}(t,e,this.data);for(let s=0,r=n.length;s<r;s++)i.push(...n[s].toShapes());return i}}function rm(t,e,i,n,s){const r=s.glyphs[t]||s.glyphs["?"];if(!r)return;const a=new Vu;let o,l,h,c,u,d,p,m;if(r.o){const t=r._cachedOutline||(r._cachedOutline=r.o.split(" "));for(let s=0,r=t.length;s<r;){switch(t[s++]){case"m":o=t[s++]*e+i,l=t[s++]*e+n,a.moveTo(o,l);break;case"l":o=t[s++]*e+i,l=t[s++]*e+n,a.lineTo(o,l);break;case"q":h=t[s++]*e+i,c=t[s++]*e+n,u=t[s++]*e+i,d=t[s++]*e+n,a.quadraticCurveTo(u,d,h,c);break;case"b":h=t[s++]*e+i,c=t[s++]*e+n,u=t[s++]*e+i,d=t[s++]*e+n,p=t[s++]*e+i,m=t[s++]*e+n,a.bezierCurveTo(u,d,p,m,h,c)}}}return{offsetX:r.ha*e,path:a}}class am{constructor(t,e,i){this.variables=[],this.currentTextureIndex=0;let n=lt;const s={passThruTexture:{value:null}},r=l("uniform sampler2D passThruTexture;\n\nvoid main() {\n\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\n\n\tgl_FragColor = texture2D( passThruTexture, uv );\n\n}\n",s),a=new Kp(r);function o(i){i.defines.resolution="vec2( "+t.toFixed(1)+", "+e.toFixed(1)+" )"}function l(t,e){const i=new xs({name:"GPUComputationShader",uniforms:e=e||{},vertexShader:"void main()\t{\n\n\tgl_Position = vec4( position, 1.0 );\n\n}\n",fragmentShader:t});return o(i),i}this.setDataType=function(t){return n=t,this},this.addVariable=function(t,e,i){const n={name:t,initialValueTexture:i,material:this.createShaderMaterial(e),dependencies:null,renderTargets:[],wrapS:null,wrapT:null,minFilter:Z,magFilter:Z};return this.variables.push(n),n},this.setVariableDependencies=function(t,e){t.dependencies=e},this.init=function(){if(0===i.capabilities.maxVertexTextures)return"No support for vertex shader textures.";for(let i=0;i<this.variables.length;i++){const n=this.variables[i];n.renderTargets[0]=this.createRenderTarget(t,e,n.wrapS,n.wrapT,n.minFilter,n.magFilter),n.renderTargets[1]=this.createRenderTarget(t,e,n.wrapS,n.wrapT,n.minFilter,n.magFilter),this.renderTexture(n.initialValueTexture,n.renderTargets[0]),this.renderTexture(n.initialValueTexture,n.renderTargets[1]);const s=n.material,r=s.uniforms;if(null!==n.dependencies)for(let t=0;t<n.dependencies.length;t++){const e=n.dependencies[t];if(e.name!==n.name){let t=!1;for(let i=0;i<this.variables.length;i++)if(e.name===this.variables[i].name){t=!0;break}if(!t)return"Variable dependency not found. Variable="+n.name+", dependency="+e.name}r[e.name]={value:null},s.fragmentShader="\nuniform sampler2D "+e.name+";\n"+s.fragmentShader}}return this.currentTextureIndex=0,null},this.compute=function(){const t=this.currentTextureIndex,e=0===this.currentTextureIndex?1:0;for(let i=0,n=this.variables.length;i<n;i++){const n=this.variables[i];if(null!==n.dependencies){const e=n.material.uniforms;for(let i=0,s=n.dependencies.length;i<s;i++){const s=n.dependencies[i];e[s.name].value=s.renderTargets[t].texture}}this.doRenderTarget(n.material,n.renderTargets[e])}this.currentTextureIndex=e},this.getCurrentRenderTarget=function(t){return t.renderTargets[this.currentTextureIndex]},this.getAlternateRenderTarget=function(t){return t.renderTargets[0===this.currentTextureIndex?1:0]},this.dispose=function(){a.dispose();const t=this.variables;for(let e=0;e<t.length;e++){const i=t[e];i.initialValueTexture&&i.initialValueTexture.dispose();const n=i.renderTargets;for(let t=0;t<n.length;t++){n[t].dispose()}}},this.addResolutionDefine=o,this.createShaderMaterial=l,this.createRenderTarget=function(i,s,r,a,o,l){return new oi(i=i||t,s=s||e,{wrapS:r=r||$,wrapT:a=a||$,minFilter:o=o||Z,magFilter:l=l||Z,format:mt,type:n,depthBuffer:!1})},this.createTexture=function(){const i=new Float32Array(t*e*4),n=new rl(i,t,e,mt,lt);return n.needsUpdate=!0,n},this.renderTexture=function(t,e){s.passThruTexture.value=t,this.doRenderTarget(r,e),s.passThruTexture.value=null},this.doRenderTarget=function(t,e){const n=i.getRenderTarget(),s=i.xr.enabled,o=i.shadowMap.autoUpdate;i.xr.enabled=!1,i.shadowMap.autoUpdate=!1,a.material=t,i.setRenderTarget(e),a.render(i),a.material=r,i.xr.enabled=s,i.shadowMap.autoUpdate=o,i.setRenderTarget(n)}}}class om extends cs{constructor(t,e={}){super(t),this.isReflectorForSSRPass=!0,this.type="ReflectorForSSRPass";const i=this,n=void 0!==e.color?new Dn(e.color):new Dn(8355711),s=e.textureWidth||512,r=e.textureHeight||512,a=e.clipBias||0,o=e.shader||om.ReflectorShader,l=!0===e.useDepthTexture,h=new ui(0,1,0),c=new ui,u=new ui;i.needsUpdate=!1,i.maxDistance=om.ReflectorShader.uniforms.maxDistance.value,i.opacity=om.ReflectorShader.uniforms.opacity.value,i.color=n,i.resolution=e.resolution||new Fe(window.innerWidth,window.innerHeight),i._distanceAttenuation=om.ReflectorShader.defines.DISTANCE_ATTENUATION,Object.defineProperty(i,"distanceAttenuation",{get:()=>i._distanceAttenuation,set(t){i._distanceAttenuation!==t&&(i._distanceAttenuation=t,i.material.defines.DISTANCE_ATTENUATION=t,i.material.needsUpdate=!0)}}),i._fresnel=om.ReflectorShader.defines.FRESNEL,Object.defineProperty(i,"fresnel",{get:()=>i._fresnel,set(t){i._fresnel!==t&&(i._fresnel=t,i.material.defines.FRESNEL=t,i.material.needsUpdate=!0)}});const d=new ui,p=new ui,m=new ui,f=new Vi,g=new ui(0,0,-1),x=new ui,v=new ui,_=new Vi,y=new Ss;let b;l&&(b=new yr,b.type=rt,b.minFilter=Z,b.magFilter=Z);const S=new oi(s,r,{depthTexture:l?b:null,type:ht}),M=new xs({name:void 0!==o.name?o.name:"unspecified",transparent:l,defines:Object.assign({},om.ReflectorShader.defines,{useDepthTexture:l}),uniforms:gs.clone(o.uniforms),fragmentShader:o.fragmentShader,vertexShader:o.vertexShader});M.uniforms.tDiffuse.value=S.texture,M.uniforms.color.value=i.color,M.uniforms.textureMatrix.value=_,l&&(M.uniforms.tDepth.value=S.depthTexture),this.material=M;const T=[new Ns(new ui(0,1,0),a)];this.doRender=function(t,e,n){if(M.uniforms.maxDistance.value=i.maxDistance,M.uniforms.color.value=i.color,M.uniforms.opacity.value=i.opacity,c.copy(n.position).normalize(),u.copy(c).reflect(h),M.uniforms.fresnelCoe.value=(c.dot(u)+1)/2,p.setFromMatrixPosition(i.matrixWorld),m.setFromMatrixPosition(n.matrixWorld),f.extractRotation(i.matrixWorld),d.set(0,0,1),d.applyMatrix4(f),x.subVectors(p,m),x.dot(d)>0)return;x.reflect(d).negate(),x.add(p),f.extractRotation(n.matrixWorld),g.set(0,0,-1),g.applyMatrix4(f),g.add(m),v.subVectors(p,g),v.reflect(d).negate(),v.add(p),y.position.copy(x),y.up.set(0,1,0),y.up.applyMatrix4(f),y.up.reflect(d),y.lookAt(v),y.far=n.far,y.updateMatrixWorld(),y.projectionMatrix.copy(n.projectionMatrix),M.uniforms.virtualCameraNear.value=n.near,M.uniforms.virtualCameraFar.value=n.far,M.uniforms.virtualCameraMatrixWorld.value=y.matrixWorld,M.uniforms.virtualCameraProjectionMatrix.value=n.projectionMatrix,M.uniforms.virtualCameraProjectionMatrixInverse.value=n.projectionMatrixInverse,M.uniforms.resolution.value=i.resolution,_.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),_.multiply(y.projectionMatrix),_.multiply(y.matrixWorldInverse),_.multiply(i.matrixWorld);const s=t.getRenderTarget(),r=t.xr.enabled,a=t.shadowMap.autoUpdate,o=t.clippingPlanes;t.xr.enabled=!1,t.shadowMap.autoUpdate=!1,t.clippingPlanes=T,t.setRenderTarget(S),t.state.buffers.depth.setMask(!0),!1===t.autoClear&&t.clear(),t.render(e,y),t.xr.enabled=r,t.shadowMap.autoUpdate=a,t.clippingPlanes=o,t.setRenderTarget(s);const l=n.viewport;void 0!==l&&t.state.viewport(l)},this.getRenderTarget=function(){return S}}}om.ReflectorShader={name:"ReflectorShader",defines:{DISTANCE_ATTENUATION:!0,FRESNEL:!0},uniforms:{color:{value:null},tDiffuse:{value:null},tDepth:{value:null},textureMatrix:{value:new Vi},maxDistance:{value:180},opacity:{value:.5},fresnelCoe:{value:null},virtualCameraNear:{value:null},virtualCameraFar:{value:null},virtualCameraProjectionMatrix:{value:new Vi},virtualCameraMatrixWorld:{value:new Vi},virtualCameraProjectionMatrixInverse:{value:new Vi},resolution:{value:new Fe}},vertexShader:"\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDepth;\n\t\tuniform float maxDistance;\n\t\tuniform float opacity;\n\t\tuniform float fresnelCoe;\n\t\tuniform float virtualCameraNear;\n\t\tuniform float virtualCameraFar;\n\t\tuniform mat4 virtualCameraProjectionMatrix;\n\t\tuniform mat4 virtualCameraProjectionMatrixInverse;\n\t\tuniform mat4 virtualCameraMatrixWorld;\n\t\tuniform vec2 resolution;\n\t\tvarying vec4 vUv;\n\t\t#include <packing>\n\t\tfloat blendOverlay( float base, float blend ) {\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\t\t}\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\t\t}\n\t\tfloat getDepth( const in vec2 uv ) {\n\t\t\treturn texture2D( tDepth, uv ).x;\n\t\t}\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\treturn perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );\n\t\t}\n\t\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\n\t\t\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\n\t\t\tclipPosition *= clipW; //clip\n\t\t\treturn ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view\n\t\t}\n\t\tvoid main() {\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\t#ifdef useDepthTexture\n\t\t\t\tvec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;\n\t\t\t\tuv.x=1.-uv.x;\n\t\t\t\tfloat depth = texture2DProj( tDepth, vUv ).r;\n\t\t\t\tfloat viewZ = getViewZ( depth );\n\t\t\t\tfloat clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];\n\t\t\t\tvec3 viewPosition=getViewPosition( uv, depth, clipW );\n\t\t\t\tvec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;\n\t\t\t\tif(worldPosition.y>maxDistance) discard;\n\t\t\t\tfloat op=opacity;\n\t\t\t\t#ifdef DISTANCE_ATTENUATION\n\t\t\t\t\tfloat ratio=1.-(worldPosition.y/maxDistance);\n\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t#endif\n\t\t\t\t#ifdef FRESNEL\n\t\t\t\t\top*=fresnelCoe;\n\t\t\t\t#endif\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\n\t\t\t#else\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\t\t\t#endif\n\t\t}\n\t"};const lm={name:"CopyShader",uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\n\t\t}"};class hm extends $p{constructor(t,e){super(),this.textureID=void 0!==e?e:"tDiffuse",t instanceof xs?(this.uniforms=t.uniforms,this.material=t):t&&(this.uniforms=gs.clone(t.uniforms),this.material=new xs({name:void 0!==t.name?t.name:"unspecified",defines:Object.assign({},t.defines),uniforms:this.uniforms,vertexShader:t.vertexShader,fragmentShader:t.fragmentShader})),this.fsQuad=new Kp(this.material)}render(t,e,i){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=i.texture),this.fsQuad.material=this.material,this.renderToScreen?(t.setRenderTarget(null),this.fsQuad.render(t)):(t.setRenderTarget(e),this.clear&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),this.fsQuad.render(t))}dispose(){this.material.dispose(),this.fsQuad.dispose()}}class cm extends $p{constructor(t,e){super(),this.scene=t,this.camera=e,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(t,e,i){const n=t.getContext(),s=t.state;let r,a;s.buffers.color.setMask(!1),s.buffers.depth.setMask(!1),s.buffers.color.setLocked(!0),s.buffers.depth.setLocked(!0),this.inverse?(r=0,a=1):(r=1,a=0),s.buffers.stencil.setTest(!0),s.buffers.stencil.setOp(n.REPLACE,n.REPLACE,n.REPLACE),s.buffers.stencil.setFunc(n.ALWAYS,r,4294967295),s.buffers.stencil.setClear(a),s.buffers.stencil.setLocked(!0),t.setRenderTarget(i),this.clear&&t.clear(),t.render(this.scene,this.camera),t.setRenderTarget(e),this.clear&&t.clear(),t.render(this.scene,this.camera),s.buffers.color.setLocked(!1),s.buffers.depth.setLocked(!1),s.buffers.color.setMask(!0),s.buffers.depth.setMask(!0),s.buffers.stencil.setLocked(!1),s.buffers.stencil.setFunc(n.EQUAL,1,4294967295),s.buffers.stencil.setOp(n.KEEP,n.KEEP,n.KEEP),s.buffers.stencil.setLocked(!0)}}class um extends $p{constructor(){super(),this.needsSwap=!1}render(t){t.state.buffers.stencil.setLocked(!1),t.state.buffers.stencil.setTest(!1)}}class dm{constructor(t,e){if(this.renderer=t,this._pixelRatio=t.getPixelRatio(),void 0===e){const i=t.getSize(new Fe);this._width=i.width,this._height=i.height,(e=new oi(this._width*this._pixelRatio,this._height*this._pixelRatio,{type:ht})).texture.name="EffectComposer.rt1"}else this._width=e.width,this._height=e.height;this.renderTarget1=e,this.renderTarget2=e.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],this.copyPass=new hm(lm),this.copyPass.material.blending=0,this.clock=new eu}swapBuffers(){const t=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=t}addPass(t){this.passes.push(t),t.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}insertPass(t,e){this.passes.splice(e,0,t),t.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}removePass(t){const e=this.passes.indexOf(t);-1!==e&&this.passes.splice(e,1)}isLastEnabledPass(t){for(let e=t+1;e<this.passes.length;e++)if(this.passes[e].enabled)return!1;return!0}render(t){void 0===t&&(t=this.clock.getDelta());const e=this.renderer.getRenderTarget();let i=!1;for(let n=0,s=this.passes.length;n<s;n++){const e=this.passes[n];if(!1!==e.enabled){if(e.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(n),e.render(this.renderer,this.writeBuffer,this.readBuffer,t,i),e.needsSwap){if(i){const e=this.renderer.getContext(),i=this.renderer.state.buffers.stencil;i.setFunc(e.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,t),i.setFunc(e.EQUAL,1,4294967295)}this.swapBuffers()}void 0!==cm&&(e instanceof cm?i=!0:e instanceof um&&(i=!1))}}this.renderer.setRenderTarget(e)}reset(t){if(void 0===t){const e=this.renderer.getSize(new Fe);this._pixelRatio=this.renderer.getPixelRatio(),this._width=e.width,this._height=e.height,(t=this.renderTarget1.clone()).setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=t,this.renderTarget2=t.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2}setSize(t,e){this._width=t,this._height=e;const i=this._width*this._pixelRatio,n=this._height*this._pixelRatio;this.renderTarget1.setSize(i,n),this.renderTarget2.setSize(i,n);for(let s=0;s<this.passes.length;s++)this.passes[s].setSize(i,n)}setPixelRatio(t){this._pixelRatio=t,this.setSize(this._width,this._height)}dispose(){this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.copyPass.dispose()}}const pm={name:"OutputShader",uniforms:{tDiffuse:{value:null},toneMappingExposure:{value:1}},vertexShader:"\n\t\tprecision highp float;\n\n\t\tuniform mat4 modelViewMatrix;\n\t\tuniform mat4 projectionMatrix;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\t\n\t\tprecision highp float;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\t#include <tonemapping_pars_fragment>\n\t\t#include <colorspace_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = texture2D( tDiffuse, vUv );\n\n\t\t\t// tone mapping\n\n\t\t\t#ifdef LINEAR_TONE_MAPPING\n\n\t\t\t\tgl_FragColor.rgb = LinearToneMapping( gl_FragColor.rgb );\n\n\t\t\t#elif defined( REINHARD_TONE_MAPPING )\n\n\t\t\t\tgl_FragColor.rgb = ReinhardToneMapping( gl_FragColor.rgb );\n\n\t\t\t#elif defined( CINEON_TONE_MAPPING )\n\n\t\t\t\tgl_FragColor.rgb = CineonToneMapping( gl_FragColor.rgb );\n\n\t\t\t#elif defined( ACES_FILMIC_TONE_MAPPING )\n\n\t\t\t\tgl_FragColor.rgb = ACESFilmicToneMapping( gl_FragColor.rgb );\n\n\t\t\t#elif defined( AGX_TONE_MAPPING )\n\n\t\t\t\tgl_FragColor.rgb = AgXToneMapping( gl_FragColor.rgb );\n\n\t\t\t#elif defined( NEUTRAL_TONE_MAPPING )\n\n\t\t\t\tgl_FragColor.rgb = NeutralToneMapping( gl_FragColor.rgb );\n\n\t\t\t#endif\n\n\t\t\t// color space\n\n\t\t\t#ifdef SRGB_TRANSFER\n\n\t\t\t\tgl_FragColor = sRGBTransferOETF( gl_FragColor );\n\n\t\t\t#endif\n\n\t\t}"};class mm extends $p{constructor(){super();const t=pm;this.uniforms=gs.clone(t.uniforms),this.material=new ec({name:t.name,uniforms:this.uniforms,vertexShader:t.vertexShader,fragmentShader:t.fragmentShader}),this.fsQuad=new Kp(this.material),this._outputColorSpace=null,this._toneMapping=null}render(t,e,i){this.uniforms.tDiffuse.value=i.texture,this.uniforms.toneMappingExposure.value=t.toneMappingExposure,this._outputColorSpace===t.outputColorSpace&&this._toneMapping===t.toneMapping||(this._outputColorSpace=t.outputColorSpace,this._toneMapping=t.toneMapping,this.material.defines={},We.getTransfer(this._outputColorSpace)===ce&&(this.material.defines.SRGB_TRANSFER=""),1===this._toneMapping?this.material.defines.LINEAR_TONE_MAPPING="":2===this._toneMapping?this.material.defines.REINHARD_TONE_MAPPING="":3===this._toneMapping?this.material.defines.CINEON_TONE_MAPPING="":4===this._toneMapping?this.material.defines.ACES_FILMIC_TONE_MAPPING="":6===this._toneMapping?this.material.defines.AGX_TONE_MAPPING="":7===this._toneMapping&&(this.material.defines.NEUTRAL_TONE_MAPPING=""),this.material.needsUpdate=!0),!0===this.renderToScreen?(t.setRenderTarget(null),this.fsQuad.render(t)):(t.setRenderTarget(e),this.clear&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),this.fsQuad.render(t))}dispose(){this.material.dispose(),this.fsQuad.dispose()}}class fm extends $p{constructor(t,e,i=null,n=null,s=null){super(),this.scene=t,this.camera=e,this.overrideMaterial=i,this.clearColor=n,this.clearAlpha=s,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1,this._oldClearColor=new Dn}render(t,e,i){const n=t.autoClear;let s,r;t.autoClear=!1,null!==this.overrideMaterial&&(r=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),null!==this.clearColor&&(t.getClearColor(this._oldClearColor),t.setClearColor(this.clearColor,t.getClearAlpha())),null!==this.clearAlpha&&(s=t.getClearAlpha(),t.setClearAlpha(this.clearAlpha)),1==this.clearDepth&&t.clearDepth(),t.setRenderTarget(this.renderToScreen?null:i),!0===this.clear&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),t.render(this.scene,this.camera),null!==this.clearColor&&t.setClearColor(this._oldClearColor),null!==this.clearAlpha&&t.setClearAlpha(s),null!==this.overrideMaterial&&(this.scene.overrideMaterial=r),t.autoClear=n}}const gm={name:"SSRShader",defines:{MAX_STEP:0,PERSPECTIVE_CAMERA:!0,DISTANCE_ATTENUATION:!0,FRESNEL:!0,INFINITE_THICK:!1,SELECTIVE:!1},uniforms:{tDiffuse:{value:null},tNormal:{value:null},tMetalness:{value:null},tDepth:{value:null},cameraNear:{value:null},cameraFar:{value:null},resolution:{value:new Fe},cameraProjectionMatrix:{value:new Vi},cameraInverseProjectionMatrix:{value:new Vi},opacity:{value:.5},maxDistance:{value:180},cameraRange:{value:0},thickness:{value:.018}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}\n\n\t",fragmentShader:'\n\t\t// precision highp float;\n\t\tprecision highp sampler2D;\n\t\tvarying vec2 vUv;\n\t\tuniform sampler2D tDepth;\n\t\tuniform sampler2D tNormal;\n\t\tuniform sampler2D tMetalness;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform float cameraRange;\n\t\tuniform vec2 resolution;\n\t\tuniform float opacity;\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\t\tuniform float maxDistance;\n\t\tuniform float thickness;\n\t\tuniform mat4 cameraProjectionMatrix;\n\t\tuniform mat4 cameraInverseProjectionMatrix;\n\t\t#include <packing>\n\t\tfloat pointToLineDistance(vec3 x0, vec3 x1, vec3 x2) {\n\t\t\t//x0: point, x1: linePointA, x2: linePointB\n\t\t\t//https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html\n\t\t\treturn length(cross(x0-x1,x0-x2))/length(x2-x1);\n\t\t}\n\t\tfloat pointPlaneDistance(vec3 point,vec3 planePoint,vec3 planeNormal){\n\t\t\t// https://mathworld.wolfram.com/Point-PlaneDistance.html\n\t\t\t//// https://en.wikipedia.org/wiki/Plane_(geometry)\n\t\t\t//// http://paulbourke.net/geometry/pointlineplane/\n\t\t\tfloat a=planeNormal.x,b=planeNormal.y,c=planeNormal.z;\n\t\t\tfloat x0=point.x,y0=point.y,z0=point.z;\n\t\t\tfloat x=planePoint.x,y=planePoint.y,z=planePoint.z;\n\t\t\tfloat d=-(a*x+b*y+c*z);\n\t\t\tfloat distance=(a*x0+b*y0+c*z0+d)/sqrt(a*a+b*b+c*c);\n\t\t\treturn distance;\n\t\t}\n\t\tfloat getDepth( const in vec2 uv ) {\n\t\t\treturn texture2D( tDepth, uv ).x;\n\t\t}\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\t#ifdef PERSPECTIVE_CAMERA\n\t\t\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n\t\t\t#else\n\t\t\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n\t\t\t#endif\n\t\t}\n\t\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\n\t\t\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\n\t\t\tclipPosition *= clipW; //clip\n\t\t\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;//view\n\t\t}\n\t\tvec3 getViewNormal( const in vec2 uv ) {\n\t\t\treturn unpackRGBToNormal( texture2D( tNormal, uv ).xyz );\n\t\t}\n\t\tvec2 viewPositionToXY(vec3 viewPosition){\n\t\t\tvec2 xy;\n\t\t\tvec4 clip=cameraProjectionMatrix*vec4(viewPosition,1);\n\t\t\txy=clip.xy;//clip\n\t\t\tfloat clipW=clip.w;\n\t\t\txy/=clipW;//NDC\n\t\t\txy=(xy+1.)/2.;//uv\n\t\t\txy*=resolution;//screen\n\t\t\treturn xy;\n\t\t}\n\t\tvoid main(){\n\t\t\t#ifdef SELECTIVE\n\t\t\t\tfloat metalness=texture2D(tMetalness,vUv).r;\n\t\t\t\tif(metalness==0.) return;\n\t\t\t#endif\n\n\t\t\tfloat depth = getDepth( vUv );\n\t\t\tfloat viewZ = getViewZ( depth );\n\t\t\tif(-viewZ>=cameraFar) return;\n\n\t\t\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ+cameraProjectionMatrix[3][3];\n\t\t\tvec3 viewPosition=getViewPosition( vUv, depth, clipW );\n\n\t\t\tvec2 d0=gl_FragCoord.xy;\n\t\t\tvec2 d1;\n\n\t\t\tvec3 viewNormal=getViewNormal( vUv );\n\n\t\t\t#ifdef PERSPECTIVE_CAMERA\n\t\t\t\tvec3 viewIncidentDir=normalize(viewPosition);\n\t\t\t\tvec3 viewReflectDir=reflect(viewIncidentDir,viewNormal);\n\t\t\t#else\n\t\t\t\tvec3 viewIncidentDir=vec3(0,0,-1);\n\t\t\t\tvec3 viewReflectDir=reflect(viewIncidentDir,viewNormal);\n\t\t\t#endif\n\n\t\t\tfloat maxReflectRayLen=maxDistance/dot(-viewIncidentDir,viewNormal);\n\t\t\t// dot(a,b)==length(a)*length(b)*cos(theta) // https://www.mathsisfun.com/algebra/vectors-dot-product.html\n\t\t\t// if(a.isNormalized&&b.isNormalized) dot(a,b)==cos(theta)\n\t\t\t// maxDistance/maxReflectRayLen=cos(theta)\n\t\t\t// maxDistance/maxReflectRayLen==dot(a,b)\n\t\t\t// maxReflectRayLen==maxDistance/dot(a,b)\n\n\t\t\tvec3 d1viewPosition=viewPosition+viewReflectDir*maxReflectRayLen;\n\t\t\t#ifdef PERSPECTIVE_CAMERA\n\t\t\t\tif(d1viewPosition.z>-cameraNear){\n\t\t\t\t\t//https://tutorial.math.lamar.edu/Classes/CalcIII/EqnsOfLines.aspx\n\t\t\t\t\tfloat t=(-cameraNear-viewPosition.z)/viewReflectDir.z;\n\t\t\t\t\td1viewPosition=viewPosition+viewReflectDir*t;\n\t\t\t\t}\n\t\t\t#endif\n\t\t\td1=viewPositionToXY(d1viewPosition);\n\n\t\t\tfloat totalLen=length(d1-d0);\n\t\t\tfloat xLen=d1.x-d0.x;\n\t\t\tfloat yLen=d1.y-d0.y;\n\t\t\tfloat totalStep=max(abs(xLen),abs(yLen));\n\t\t\tfloat xSpan=xLen/totalStep;\n\t\t\tfloat ySpan=yLen/totalStep;\n\t\t\tfor(float i=0.;i<float(MAX_STEP);i++){\n\t\t\t\tif(i>=totalStep) break;\n\t\t\t\tvec2 xy=vec2(d0.x+i*xSpan,d0.y+i*ySpan);\n\t\t\t\tif(xy.x<0.||xy.x>resolution.x||xy.y<0.||xy.y>resolution.y) break;\n\t\t\t\tfloat s=length(xy-d0)/totalLen;\n\t\t\t\tvec2 uv=xy/resolution;\n\n\t\t\t\tfloat d = getDepth(uv);\n\t\t\t\tfloat vZ = getViewZ( d );\n\t\t\t\tif(-vZ>=cameraFar) continue;\n\t\t\t\tfloat cW = cameraProjectionMatrix[2][3] * vZ+cameraProjectionMatrix[3][3];\n\t\t\t\tvec3 vP=getViewPosition( uv, d, cW );\n\n\t\t\t\t#ifdef PERSPECTIVE_CAMERA\n\t\t\t\t\t// https://comp.nus.edu.sg/~lowkl/publications/lowk_persp_interp_techrep.pdf\n\t\t\t\t\tfloat recipVPZ=1./viewPosition.z;\n\t\t\t\t\tfloat viewReflectRayZ=1./(recipVPZ+s*(1./d1viewPosition.z-recipVPZ));\n\t\t\t\t#else\n\t\t\t\t\tfloat viewReflectRayZ=viewPosition.z+s*(d1viewPosition.z-viewPosition.z);\n\t\t\t\t#endif\n\n\t\t\t\t// if(viewReflectRayZ>vZ) continue; // will cause "npm run make-screenshot webgl_postprocessing_ssr" high probability hang.\n\t\t\t\t// https://github.com/mrdoob/three.js/pull/21539#issuecomment-821061164\n\t\t\t\tif(viewReflectRayZ<=vZ){\n\n\t\t\t\t\tbool hit;\n\t\t\t\t\t#ifdef INFINITE_THICK\n\t\t\t\t\t\thit=true;\n\t\t\t\t\t#else\n\t\t\t\t\t\tfloat away=pointToLineDistance(vP,viewPosition,d1viewPosition);\n\n\t\t\t\t\t\tfloat minThickness;\n\t\t\t\t\t\tvec2 xyNeighbor=xy;\n\t\t\t\t\t\txyNeighbor.x+=1.;\n\t\t\t\t\t\tvec2 uvNeighbor=xyNeighbor/resolution;\n\t\t\t\t\t\tvec3 vPNeighbor=getViewPosition(uvNeighbor,d,cW);\n\t\t\t\t\t\tminThickness=vPNeighbor.x-vP.x;\n\t\t\t\t\t\tminThickness*=3.;\n\t\t\t\t\t\tfloat tk=max(minThickness,thickness);\n\n\t\t\t\t\t\thit=away<=tk;\n\t\t\t\t\t#endif\n\n\t\t\t\t\tif(hit){\n\t\t\t\t\t\tvec3 vN=getViewNormal( uv );\n\t\t\t\t\t\tif(dot(viewReflectDir,vN)>=0.) continue;\n\t\t\t\t\t\tfloat distance=pointPlaneDistance(vP,viewPosition,viewNormal);\n\t\t\t\t\t\tif(distance>maxDistance) break;\n\t\t\t\t\t\tfloat op=opacity;\n\t\t\t\t\t\t#ifdef DISTANCE_ATTENUATION\n\t\t\t\t\t\t\tfloat ratio=1.-(distance/maxDistance);\n\t\t\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#ifdef FRESNEL\n\t\t\t\t\t\t\tfloat fresnelCoe=(dot(viewIncidentDir,viewReflectDir)+1.)/2.;\n\t\t\t\t\t\t\top*=fresnelCoe;\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\tvec4 reflectColor=texture2D(tDiffuse,uv);\n\t\t\t\t\t\tgl_FragColor.xyz=reflectColor.xyz;\n\t\t\t\t\t\tgl_FragColor.a=op;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t'},xm={name:"SSRDepthShader",defines:{PERSPECTIVE_CAMERA:1},uniforms:{tDepth:{value:null},cameraNear:{value:null},cameraFar:{value:null}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}\n\n\t",fragmentShader:"\n\n\t\tuniform sampler2D tDepth;\n\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\n\t\tvarying vec2 vUv;\n\n\t\t#include <packing>\n\n\t\tfloat getLinearDepth( const in vec2 uv ) {\n\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\n\t\t\t\tfloat fragCoordZ = texture2D( tDepth, uv ).x;\n\t\t\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n\t\t\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\n\t\t\t#else\n\n\t\t\t\treturn texture2D( tDepth, uv ).x;\n\n\t\t\t#endif\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tfloat depth = getLinearDepth( vUv );\n\t\t\tfloat d = 1.0 - depth;\n\t\t\t// d=(d-.999)*1000.;\n\t\t\tgl_FragColor = vec4( vec3( d ), 1.0 );\n\n\t\t}\n\n\t"},vm={name:"SSRBlurShader",uniforms:{tDiffuse:{value:null},resolution:{value:new Fe},opacity:{value:.5}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}\n\n\t",fragmentShader:"\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec2 resolution;\n\t\tvarying vec2 vUv;\n\t\tvoid main() {\n\t\t\t//reverse engineering from PhotoShop blur filter, then change coefficient\n\n\t\t\tvec2 texelSize = ( 1.0 / resolution );\n\n\t\t\tvec4 c=texture2D(tDiffuse,vUv);\n\n\t\t\tvec2 offset;\n\n\t\t\toffset=(vec2(-1,0))*texelSize;\n\t\t\tvec4 cl=texture2D(tDiffuse,vUv+offset);\n\n\t\t\toffset=(vec2(1,0))*texelSize;\n\t\t\tvec4 cr=texture2D(tDiffuse,vUv+offset);\n\n\t\t\toffset=(vec2(0,-1))*texelSize;\n\t\t\tvec4 cb=texture2D(tDiffuse,vUv+offset);\n\n\t\t\toffset=(vec2(0,1))*texelSize;\n\t\t\tvec4 ct=texture2D(tDiffuse,vUv+offset);\n\n\t\t\t// float coeCenter=.5;\n\t\t\t// float coeSide=.125;\n\t\t\tfloat coeCenter=.2;\n\t\t\tfloat coeSide=.2;\n\t\t\tfloat a=c.a*coeCenter+cl.a*coeSide+cr.a*coeSide+cb.a*coeSide+ct.a*coeSide;\n\t\t\tvec3 rgb=(c.rgb*c.a*coeCenter+cl.rgb*cl.a*coeSide+cr.rgb*cr.a*coeSide+cb.rgb*cb.a*coeSide+ct.rgb*ct.a*coeSide)/a;\n\t\t\tgl_FragColor=vec4(rgb,a);\n\n\t\t}\n\t"};class _m extends $p{constructor({renderer:t,scene:e,camera:i,width:n,height:s,selects:r,bouncing:a=!1,groundReflector:o}){super(),this.width=void 0!==n?n:512,this.height=void 0!==s?s:512,this.clear=!0,this.renderer=t,this.scene=e,this.camera=i,this.groundReflector=o,this.opacity=gm.uniforms.opacity.value,this.output=0,this.maxDistance=gm.uniforms.maxDistance.value,this.thickness=gm.uniforms.thickness.value,this.tempColor=new Dn,this._selects=r,this.selective=Array.isArray(this._selects),Object.defineProperty(this,"selects",{get(){return this._selects},set(t){this._selects!==t&&(this._selects=t,Array.isArray(t)?(this.selective=!0,this.ssrMaterial.defines.SELECTIVE=!0,this.ssrMaterial.needsUpdate=!0):(this.selective=!1,this.ssrMaterial.defines.SELECTIVE=!1,this.ssrMaterial.needsUpdate=!0))}}),this._bouncing=a,Object.defineProperty(this,"bouncing",{get(){return this._bouncing},set(t){this._bouncing!==t&&(this._bouncing=t,this.ssrMaterial.uniforms.tDiffuse.value=t?this.prevRenderTarget.texture:this.beautyRenderTarget.texture)}}),this.blur=!0,this._distanceAttenuation=gm.defines.DISTANCE_ATTENUATION,Object.defineProperty(this,"distanceAttenuation",{get(){return this._distanceAttenuation},set(t){this._distanceAttenuation!==t&&(this._distanceAttenuation=t,this.ssrMaterial.defines.DISTANCE_ATTENUATION=t,this.ssrMaterial.needsUpdate=!0)}}),this._fresnel=gm.defines.FRESNEL,Object.defineProperty(this,"fresnel",{get(){return this._fresnel},set(t){this._fresnel!==t&&(this._fresnel=t,this.ssrMaterial.defines.FRESNEL=t,this.ssrMaterial.needsUpdate=!0)}}),this._infiniteThick=gm.defines.INFINITE_THICK,Object.defineProperty(this,"infiniteThick",{get(){return this._infiniteThick},set(t){this._infiniteThick!==t&&(this._infiniteThick=t,this.ssrMaterial.defines.INFINITE_THICK=t,this.ssrMaterial.needsUpdate=!0)}});const l=new yr;l.type=rt,l.minFilter=Z,l.magFilter=Z,this.beautyRenderTarget=new oi(this.width,this.height,{minFilter:Z,magFilter:Z,type:ht,depthTexture:l,depthBuffer:!0}),this.prevRenderTarget=new oi(this.width,this.height,{minFilter:Z,magFilter:Z}),this.normalRenderTarget=new oi(this.width,this.height,{minFilter:Z,magFilter:Z,type:ht}),this.metalnessRenderTarget=new oi(this.width,this.height,{minFilter:Z,magFilter:Z,type:ht}),this.ssrRenderTarget=new oi(this.width,this.height,{minFilter:Z,magFilter:Z}),this.blurRenderTarget=this.ssrRenderTarget.clone(),this.blurRenderTarget2=this.ssrRenderTarget.clone(),this.ssrMaterial=new xs({defines:Object.assign({},gm.defines,{MAX_STEP:Math.sqrt(this.width*this.width+this.height*this.height)}),uniforms:gs.clone(gm.uniforms),vertexShader:gm.vertexShader,fragmentShader:gm.fragmentShader,blending:0}),this.ssrMaterial.uniforms.tDiffuse.value=this.beautyRenderTarget.texture,this.ssrMaterial.uniforms.tNormal.value=this.normalRenderTarget.texture,this.ssrMaterial.defines.SELECTIVE=this.selective,this.ssrMaterial.needsUpdate=!0,this.ssrMaterial.uniforms.tMetalness.value=this.metalnessRenderTarget.texture,this.ssrMaterial.uniforms.tDepth.value=this.beautyRenderTarget.depthTexture,this.ssrMaterial.uniforms.cameraNear.value=this.camera.near,this.ssrMaterial.uniforms.cameraFar.value=this.camera.far,this.ssrMaterial.uniforms.thickness.value=this.thickness,this.ssrMaterial.uniforms.resolution.value.set(this.width,this.height),this.ssrMaterial.uniforms.cameraProjectionMatrix.value.copy(this.camera.projectionMatrix),this.ssrMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(this.camera.projectionMatrixInverse),this.normalMaterial=new rc,this.normalMaterial.blending=0,this.metalnessOnMaterial=new On({color:"white"}),this.metalnessOffMaterial=new On({color:"black"}),this.blurMaterial=new xs({defines:Object.assign({},vm.defines),uniforms:gs.clone(vm.uniforms),vertexShader:vm.vertexShader,fragmentShader:vm.fragmentShader}),this.blurMaterial.uniforms.tDiffuse.value=this.ssrRenderTarget.texture,this.blurMaterial.uniforms.resolution.value.set(this.width,this.height),this.blurMaterial2=new xs({defines:Object.assign({},vm.defines),uniforms:gs.clone(vm.uniforms),vertexShader:vm.vertexShader,fragmentShader:vm.fragmentShader}),this.blurMaterial2.uniforms.tDiffuse.value=this.blurRenderTarget.texture,this.blurMaterial2.uniforms.resolution.value.set(this.width,this.height),this.depthRenderMaterial=new xs({defines:Object.assign({},xm.defines),uniforms:gs.clone(xm.uniforms),vertexShader:xm.vertexShader,fragmentShader:xm.fragmentShader,blending:0}),this.depthRenderMaterial.uniforms.tDepth.value=this.beautyRenderTarget.depthTexture,this.depthRenderMaterial.uniforms.cameraNear.value=this.camera.near,this.depthRenderMaterial.uniforms.cameraFar.value=this.camera.far,this.copyMaterial=new xs({uniforms:gs.clone(lm.uniforms),vertexShader:lm.vertexShader,fragmentShader:lm.fragmentShader,transparent:!0,depthTest:!1,depthWrite:!1,blendSrc:S,blendDst:M,blendEquation:f,blendSrcAlpha:S,blendDstAlpha:M,blendEquationAlpha:f}),this.fsQuad=new Kp(null),this.originalClearColor=new Dn}dispose(){this.beautyRenderTarget.dispose(),this.prevRenderTarget.dispose(),this.normalRenderTarget.dispose(),this.metalnessRenderTarget.dispose(),this.ssrRenderTarget.dispose(),this.blurRenderTarget.dispose(),this.blurRenderTarget2.dispose(),this.normalMaterial.dispose(),this.metalnessOnMaterial.dispose(),this.metalnessOffMaterial.dispose(),this.blurMaterial.dispose(),this.blurMaterial2.dispose(),this.copyMaterial.dispose(),this.depthRenderMaterial.dispose(),this.fsQuad.dispose()}render(t,e){switch(t.setRenderTarget(this.beautyRenderTarget),t.clear(),this.groundReflector&&(this.groundReflector.visible=!1,this.groundReflector.doRender(this.renderer,this.scene,this.camera),this.groundReflector.visible=!0),t.render(this.scene,this.camera),this.groundReflector&&(this.groundReflector.visible=!1),this.renderOverride(t,this.normalMaterial,this.normalRenderTarget,0,0),this.selective&&this.renderMetalness(t,this.metalnessOnMaterial,this.metalnessRenderTarget,0,0),this.ssrMaterial.uniforms.opacity.value=this.opacity,this.ssrMaterial.uniforms.maxDistance.value=this.maxDistance,this.ssrMaterial.uniforms.thickness.value=this.thickness,this.renderPass(t,this.ssrMaterial,this.ssrRenderTarget),this.blur&&(this.renderPass(t,this.blurMaterial,this.blurRenderTarget),this.renderPass(t,this.blurMaterial2,this.blurRenderTarget2)),this.output){case _m.OUTPUT.Default:this.bouncing?(this.copyMaterial.uniforms.tDiffuse.value=this.beautyRenderTarget.texture,this.copyMaterial.blending=0,this.renderPass(t,this.copyMaterial,this.prevRenderTarget),this.blur?this.copyMaterial.uniforms.tDiffuse.value=this.blurRenderTarget2.texture:this.copyMaterial.uniforms.tDiffuse.value=this.ssrRenderTarget.texture,this.copyMaterial.blending=1,this.renderPass(t,this.copyMaterial,this.prevRenderTarget),this.copyMaterial.uniforms.tDiffuse.value=this.prevRenderTarget.texture,this.copyMaterial.blending=0,this.renderPass(t,this.copyMaterial,this.renderToScreen?null:e)):(this.copyMaterial.uniforms.tDiffuse.value=this.beautyRenderTarget.texture,this.copyMaterial.blending=0,this.renderPass(t,this.copyMaterial,this.renderToScreen?null:e),this.blur?this.copyMaterial.uniforms.tDiffuse.value=this.blurRenderTarget2.texture:this.copyMaterial.uniforms.tDiffuse.value=this.ssrRenderTarget.texture,this.copyMaterial.blending=1,this.renderPass(t,this.copyMaterial,this.renderToScreen?null:e));break;case _m.OUTPUT.SSR:this.blur?this.copyMaterial.uniforms.tDiffuse.value=this.blurRenderTarget2.texture:this.copyMaterial.uniforms.tDiffuse.value=this.ssrRenderTarget.texture,this.copyMaterial.blending=0,this.renderPass(t,this.copyMaterial,this.renderToScreen?null:e),this.bouncing&&(this.blur?this.copyMaterial.uniforms.tDiffuse.value=this.blurRenderTarget2.texture:this.copyMaterial.uniforms.tDiffuse.value=this.beautyRenderTarget.texture,this.copyMaterial.blending=0,this.renderPass(t,this.copyMaterial,this.prevRenderTarget),this.copyMaterial.uniforms.tDiffuse.value=this.ssrRenderTarget.texture,this.copyMaterial.blending=1,this.renderPass(t,this.copyMaterial,this.prevRenderTarget));break;case _m.OUTPUT.Beauty:this.copyMaterial.uniforms.tDiffuse.value=this.beautyRenderTarget.texture,this.copyMaterial.blending=0,this.renderPass(t,this.copyMaterial,this.renderToScreen?null:e);break;case _m.OUTPUT.Depth:this.renderPass(t,this.depthRenderMaterial,this.renderToScreen?null:e);break;case _m.OUTPUT.Normal:this.copyMaterial.uniforms.tDiffuse.value=this.normalRenderTarget.texture,this.copyMaterial.blending=0,this.renderPass(t,this.copyMaterial,this.renderToScreen?null:e);break;case _m.OUTPUT.Metalness:this.copyMaterial.uniforms.tDiffuse.value=this.metalnessRenderTarget.texture,this.copyMaterial.blending=0,this.renderPass(t,this.copyMaterial,this.renderToScreen?null:e)}}renderPass(t,e,i,n,s){this.originalClearColor.copy(t.getClearColor(this.tempColor));const r=t.getClearAlpha(this.tempColor),a=t.autoClear;t.setRenderTarget(i),t.autoClear=!1,null!=n&&(t.setClearColor(n),t.setClearAlpha(s||0),t.clear()),this.fsQuad.material=e,this.fsQuad.render(t),t.autoClear=a,t.setClearColor(this.originalClearColor),t.setClearAlpha(r)}renderOverride(t,e,i,n,s){this.originalClearColor.copy(t.getClearColor(this.tempColor));const r=t.getClearAlpha(this.tempColor),a=t.autoClear;t.setRenderTarget(i),t.autoClear=!1,n=e.clearColor||n,s=e.clearAlpha||s,null!=n&&(t.setClearColor(n),t.setClearAlpha(s||0),t.clear()),this.scene.overrideMaterial=e,t.render(this.scene,this.camera),this.scene.overrideMaterial=null,t.autoClear=a,t.setClearColor(this.originalClearColor),t.setClearAlpha(r)}renderMetalness(t,e,i,n,s){this.originalClearColor.copy(t.getClearColor(this.tempColor));const r=t.getClearAlpha(this.tempColor),a=t.autoClear,o=this.scene.background,l=this.scene.fog;t.setRenderTarget(i),t.autoClear=!1,this.scene.background=null,this.scene.fog=null,n=e.clearColor||n,s=e.clearAlpha||s,null!=n&&(t.setClearColor(n),t.setClearAlpha(s||0),t.clear()),this.scene.traverseVisible((t=>{t._SSRPassBackupMaterial=t.material,this._selects.includes(t)?t.material=this.metalnessOnMaterial:t.material=this.metalnessOffMaterial})),t.render(this.scene,this.camera),this.scene.traverseVisible((t=>{t.material=t._SSRPassBackupMaterial})),t.autoClear=a,t.setClearColor(this.originalClearColor),t.setClearAlpha(r),this.scene.background=o,this.scene.fog=l}setSize(t,e){this.width=t,this.height=e,this.ssrMaterial.defines.MAX_STEP=Math.sqrt(t*t+e*e),this.ssrMaterial.needsUpdate=!0,this.beautyRenderTarget.setSize(t,e),this.prevRenderTarget.setSize(t,e),this.ssrRenderTarget.setSize(t,e),this.normalRenderTarget.setSize(t,e),this.metalnessRenderTarget.setSize(t,e),this.blurRenderTarget.setSize(t,e),this.blurRenderTarget2.setSize(t,e),this.ssrMaterial.uniforms.resolution.value.set(t,e),this.ssrMaterial.uniforms.cameraProjectionMatrix.value.copy(this.camera.projectionMatrix),this.ssrMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(this.camera.projectionMatrixInverse),this.blurMaterial.uniforms.resolution.value.set(t,e),this.blurMaterial2.uniforms.resolution.value.set(t,e)}}_m.OUTPUT={Default:0,SSR:1,Beauty:3,Depth:4,Normal:5,Metalness:7};const ym={name:"LuminosityHighPassShader",shaderID:"luminosityHighPass",uniforms:{tDiffuse:{value:null},luminosityThreshold:{value:1},smoothWidth:{value:1},defaultColor:{value:new Dn(0)},defaultOpacity:{value:0}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec3 defaultColor;\n\t\tuniform float defaultOpacity;\n\t\tuniform float luminosityThreshold;\n\t\tuniform float smoothWidth;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\n\t\t\tfloat v = luminance( texel.xyz );\n\n\t\t\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n\n\t\t\tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n\n\t\t\tgl_FragColor = mix( outputColor, texel, alpha );\n\n\t\t}"};class bm extends $p{constructor(t,e,i,n){super(),this.strength=void 0!==e?e:1,this.radius=i,this.threshold=n,this.resolution=void 0!==t?new Fe(t.x,t.y):new Fe(256,256),this.clearColor=new Dn(0,0,0),this.renderTargetsHorizontal=[],this.renderTargetsVertical=[],this.nMips=5;let s=Math.round(this.resolution.x/2),r=Math.round(this.resolution.y/2);this.renderTargetBright=new oi(s,r,{type:ht}),this.renderTargetBright.texture.name="UnrealBloomPass.bright",this.renderTargetBright.texture.generateMipmaps=!1;for(let h=0;h<this.nMips;h++){const t=new oi(s,r,{type:ht});t.texture.name="UnrealBloomPass.h"+h,t.texture.generateMipmaps=!1,this.renderTargetsHorizontal.push(t);const e=new oi(s,r,{type:ht});e.texture.name="UnrealBloomPass.v"+h,e.texture.generateMipmaps=!1,this.renderTargetsVertical.push(e),s=Math.round(s/2),r=Math.round(r/2)}const a=ym;this.highPassUniforms=gs.clone(a.uniforms),this.highPassUniforms.luminosityThreshold.value=n,this.highPassUniforms.smoothWidth.value=.01,this.materialHighPassFilter=new xs({uniforms:this.highPassUniforms,vertexShader:a.vertexShader,fragmentShader:a.fragmentShader}),this.separableBlurMaterials=[];const o=[3,5,7,9,11];s=Math.round(this.resolution.x/2),r=Math.round(this.resolution.y/2);for(let h=0;h<this.nMips;h++)this.separableBlurMaterials.push(this.getSeperableBlurMaterial(o[h])),this.separableBlurMaterials[h].uniforms.invSize.value=new Fe(1/s,1/r),s=Math.round(s/2),r=Math.round(r/2);this.compositeMaterial=this.getCompositeMaterial(this.nMips),this.compositeMaterial.uniforms.blurTexture1.value=this.renderTargetsVertical[0].texture,this.compositeMaterial.uniforms.blurTexture2.value=this.renderTargetsVertical[1].texture,this.compositeMaterial.uniforms.blurTexture3.value=this.renderTargetsVertical[2].texture,this.compositeMaterial.uniforms.blurTexture4.value=this.renderTargetsVertical[3].texture,this.compositeMaterial.uniforms.blurTexture5.value=this.renderTargetsVertical[4].texture,this.compositeMaterial.uniforms.bloomStrength.value=e,this.compositeMaterial.uniforms.bloomRadius.value=.1;this.compositeMaterial.uniforms.bloomFactors.value=[1,.8,.6,.4,.2],this.bloomTintColors=[new ui(1,1,1),new ui(1,1,1),new ui(1,1,1),new ui(1,1,1),new ui(1,1,1)],this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors;const l=lm;this.copyUniforms=gs.clone(l.uniforms),this.blendMaterial=new xs({uniforms:this.copyUniforms,vertexShader:l.vertexShader,fragmentShader:l.fragmentShader,blending:2,depthTest:!1,depthWrite:!1,transparent:!0}),this.enabled=!0,this.needsSwap=!1,this._oldClearColor=new Dn,this.oldClearAlpha=1,this.basic=new On,this.fsQuad=new Kp(null)}dispose(){for(let t=0;t<this.renderTargetsHorizontal.length;t++)this.renderTargetsHorizontal[t].dispose();for(let t=0;t<this.renderTargetsVertical.length;t++)this.renderTargetsVertical[t].dispose();this.renderTargetBright.dispose();for(let t=0;t<this.separableBlurMaterials.length;t++)this.separableBlurMaterials[t].dispose();this.compositeMaterial.dispose(),this.blendMaterial.dispose(),this.basic.dispose(),this.fsQuad.dispose()}setSize(t,e){let i=Math.round(t/2),n=Math.round(e/2);this.renderTargetBright.setSize(i,n);for(let s=0;s<this.nMips;s++)this.renderTargetsHorizontal[s].setSize(i,n),this.renderTargetsVertical[s].setSize(i,n),this.separableBlurMaterials[s].uniforms.invSize.value=new Fe(1/i,1/n),i=Math.round(i/2),n=Math.round(n/2)}render(t,e,i,n,s){t.getClearColor(this._oldClearColor),this.oldClearAlpha=t.getClearAlpha();const r=t.autoClear;t.autoClear=!1,t.setClearColor(this.clearColor,0),s&&t.state.buffers.stencil.setTest(!1),this.renderToScreen&&(this.fsQuad.material=this.basic,this.basic.map=i.texture,t.setRenderTarget(null),t.clear(),this.fsQuad.render(t)),this.highPassUniforms.tDiffuse.value=i.texture,this.highPassUniforms.luminosityThreshold.value=this.threshold,this.fsQuad.material=this.materialHighPassFilter,t.setRenderTarget(this.renderTargetBright),t.clear(),this.fsQuad.render(t);let a=this.renderTargetBright;for(let o=0;o<this.nMips;o++)this.fsQuad.material=this.separableBlurMaterials[o],this.separableBlurMaterials[o].uniforms.colorTexture.value=a.texture,this.separableBlurMaterials[o].uniforms.direction.value=bm.BlurDirectionX,t.setRenderTarget(this.renderTargetsHorizontal[o]),t.clear(),this.fsQuad.render(t),this.separableBlurMaterials[o].uniforms.colorTexture.value=this.renderTargetsHorizontal[o].texture,this.separableBlurMaterials[o].uniforms.direction.value=bm.BlurDirectionY,t.setRenderTarget(this.renderTargetsVertical[o]),t.clear(),this.fsQuad.render(t),a=this.renderTargetsVertical[o];this.fsQuad.material=this.compositeMaterial,this.compositeMaterial.uniforms.bloomStrength.value=this.strength,this.compositeMaterial.uniforms.bloomRadius.value=this.radius,this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,t.setRenderTarget(this.renderTargetsHorizontal[0]),t.clear(),this.fsQuad.render(t),this.fsQuad.material=this.blendMaterial,this.copyUniforms.tDiffuse.value=this.renderTargetsHorizontal[0].texture,s&&t.state.buffers.stencil.setTest(!0),this.renderToScreen?(t.setRenderTarget(null),this.fsQuad.render(t)):(t.setRenderTarget(i),this.fsQuad.render(t)),t.setClearColor(this._oldClearColor,this.oldClearAlpha),t.autoClear=r}getSeperableBlurMaterial(t){const e=[];for(let i=0;i<t;i++)e.push(.39894*Math.exp(-.5*i*i/(t*t))/t);return new xs({defines:{KERNEL_RADIUS:t},uniforms:{colorTexture:{value:null},invSize:{value:new Fe(.5,.5)},direction:{value:new Fe(.5,.5)},gaussianCoefficients:{value:e}},vertexShader:"varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 invSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float gaussianCoefficients[KERNEL_RADIUS];\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tfloat weightSum = gaussianCoefficients[0];\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv ).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianCoefficients[i];\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset ).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset ).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}"})}getCompositeMaterial(t){return new xs({defines:{NUM_MIPS:t},uniforms:{blurTexture1:{value:null},blurTexture2:{value:null},blurTexture3:{value:null},blurTexture4:{value:null},blurTexture5:{value:null},bloomStrength:{value:1},bloomFactors:{value:null},bloomTintColors:{value:null},bloomRadius:{value:0}},vertexShader:"varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}"})}}bm.BlurDirectionX=new Fe(1,0),bm.BlurDirectionY=new Fe(0,1);const Sm={name:"FXAAShader",uniforms:{tDiffuse:{value:null},resolution:{value:new Fe(1/1024,1/512)}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\t// FXAA algorithm from NVIDIA, C# implementation by Jasper Flick, GLSL port by Dave Hoskins\n\t\t// http://developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf\n\t\t// https://catlikecoding.com/unity/tutorials/advanced-rendering/fxaa/\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec2 resolution;\n\t\tvarying vec2 vUv;\n\n\t\t#define EDGE_STEP_COUNT 6\n\t\t#define EDGE_GUESS 8.0\n\t\t#define EDGE_STEPS 1.0, 1.5, 2.0, 2.0, 2.0, 4.0\n\t\tconst float edgeSteps[EDGE_STEP_COUNT] = float[EDGE_STEP_COUNT]( EDGE_STEPS );\n\n\t\tfloat _ContrastThreshold = 0.0312;\n\t\tfloat _RelativeThreshold = 0.063;\n\t\tfloat _SubpixelBlending = 1.0;\n\n\t\tvec4 Sample( sampler2D  tex2D, vec2 uv ) {\n\n\t\t\treturn texture( tex2D, uv );\n\n\t\t}\n\n\t\tfloat SampleLuminance( sampler2D tex2D, vec2 uv ) {\n\n\t\t\treturn dot( Sample( tex2D, uv ).rgb, vec3( 0.3, 0.59, 0.11 ) );\n\n\t\t}\n\n\t\tfloat SampleLuminance( sampler2D tex2D, vec2 texSize, vec2 uv, float uOffset, float vOffset ) {\n\n\t\t\tuv += texSize * vec2(uOffset, vOffset);\n\t\t\treturn SampleLuminance(tex2D, uv);\n\n\t\t}\n\n\t\tstruct LuminanceData {\n\n\t\t\tfloat m, n, e, s, w;\n\t\t\tfloat ne, nw, se, sw;\n\t\t\tfloat highest, lowest, contrast;\n\n\t\t};\n\n\t\tLuminanceData SampleLuminanceNeighborhood( sampler2D tex2D, vec2 texSize, vec2 uv ) {\n\n\t\t\tLuminanceData l;\n\t\t\tl.m = SampleLuminance( tex2D, uv );\n\t\t\tl.n = SampleLuminance( tex2D, texSize, uv,  0.0,  1.0 );\n\t\t\tl.e = SampleLuminance( tex2D, texSize, uv,  1.0,  0.0 );\n\t\t\tl.s = SampleLuminance( tex2D, texSize, uv,  0.0, -1.0 );\n\t\t\tl.w = SampleLuminance( tex2D, texSize, uv, -1.0,  0.0 );\n\n\t\t\tl.ne = SampleLuminance( tex2D, texSize, uv,  1.0,  1.0 );\n\t\t\tl.nw = SampleLuminance( tex2D, texSize, uv, -1.0,  1.0 );\n\t\t\tl.se = SampleLuminance( tex2D, texSize, uv,  1.0, -1.0 );\n\t\t\tl.sw = SampleLuminance( tex2D, texSize, uv, -1.0, -1.0 );\n\n\t\t\tl.highest = max( max( max( max( l.n, l.e ), l.s ), l.w ), l.m );\n\t\t\tl.lowest = min( min( min( min( l.n, l.e ), l.s ), l.w ), l.m );\n\t\t\tl.contrast = l.highest - l.lowest;\n\t\t\treturn l;\n\n\t\t}\n\n\t\tbool ShouldSkipPixel( LuminanceData l ) {\n\n\t\t\tfloat threshold = max( _ContrastThreshold, _RelativeThreshold * l.highest );\n\t\t\treturn l.contrast < threshold;\n\n\t\t}\n\n\t\tfloat DeterminePixelBlendFactor( LuminanceData l ) {\n\n\t\t\tfloat f = 2.0 * ( l.n + l.e + l.s + l.w );\n\t\t\tf += l.ne + l.nw + l.se + l.sw;\n\t\t\tf *= 1.0 / 12.0;\n\t\t\tf = abs( f - l.m );\n\t\t\tf = clamp( f / l.contrast, 0.0, 1.0 );\n\n\t\t\tfloat blendFactor = smoothstep( 0.0, 1.0, f );\n\t\t\treturn blendFactor * blendFactor * _SubpixelBlending;\n\n\t\t}\n\n\t\tstruct EdgeData {\n\n\t\t\tbool isHorizontal;\n\t\t\tfloat pixelStep;\n\t\t\tfloat oppositeLuminance, gradient;\n\n\t\t};\n\n\t\tEdgeData DetermineEdge( vec2 texSize, LuminanceData l ) {\n\n\t\t\tEdgeData e;\n\t\t\tfloat horizontal =\n\t\t\t\tabs( l.n + l.s - 2.0 * l.m ) * 2.0 +\n\t\t\t\tabs( l.ne + l.se - 2.0 * l.e ) +\n\t\t\t\tabs( l.nw + l.sw - 2.0 * l.w );\n\t\t\tfloat vertical =\n\t\t\t\tabs( l.e + l.w - 2.0 * l.m ) * 2.0 +\n\t\t\t\tabs( l.ne + l.nw - 2.0 * l.n ) +\n\t\t\t\tabs( l.se + l.sw - 2.0 * l.s );\n\t\t\te.isHorizontal = horizontal >= vertical;\n\n\t\t\tfloat pLuminance = e.isHorizontal ? l.n : l.e;\n\t\t\tfloat nLuminance = e.isHorizontal ? l.s : l.w;\n\t\t\tfloat pGradient = abs( pLuminance - l.m );\n\t\t\tfloat nGradient = abs( nLuminance - l.m );\n\n\t\t\te.pixelStep = e.isHorizontal ? texSize.y : texSize.x;\n\t\t\t\n\t\t\tif (pGradient < nGradient) {\n\n\t\t\t\te.pixelStep = -e.pixelStep;\n\t\t\t\te.oppositeLuminance = nLuminance;\n\t\t\t\te.gradient = nGradient;\n\n\t\t\t} else {\n\n\t\t\t\te.oppositeLuminance = pLuminance;\n\t\t\t\te.gradient = pGradient;\n\n\t\t\t}\n\n\t\t\treturn e;\n\n\t\t}\n\n\t\tfloat DetermineEdgeBlendFactor( sampler2D  tex2D, vec2 texSize, LuminanceData l, EdgeData e, vec2 uv ) {\n\n\t\t\tvec2 uvEdge = uv;\n\t\t\tvec2 edgeStep;\n\t\t\tif (e.isHorizontal) {\n\n\t\t\t\tuvEdge.y += e.pixelStep * 0.5;\n\t\t\t\tedgeStep = vec2( texSize.x, 0.0 );\n\n\t\t\t} else {\n\n\t\t\t\tuvEdge.x += e.pixelStep * 0.5;\n\t\t\t\tedgeStep = vec2( 0.0, texSize.y );\n\n\t\t\t}\n\n\t\t\tfloat edgeLuminance = ( l.m + e.oppositeLuminance ) * 0.5;\n\t\t\tfloat gradientThreshold = e.gradient * 0.25;\n\n\t\t\tvec2 puv = uvEdge + edgeStep * edgeSteps[0];\n\t\t\tfloat pLuminanceDelta = SampleLuminance( tex2D, puv ) - edgeLuminance;\n\t\t\tbool pAtEnd = abs( pLuminanceDelta ) >= gradientThreshold;\n\n\t\t\tfor ( int i = 1; i < EDGE_STEP_COUNT && !pAtEnd; i++ ) {\n\n\t\t\t\tpuv += edgeStep * edgeSteps[i];\n\t\t\t\tpLuminanceDelta = SampleLuminance( tex2D, puv ) - edgeLuminance;\n\t\t\t\tpAtEnd = abs( pLuminanceDelta ) >= gradientThreshold;\n\n\t\t\t}\n\n\t\t\tif ( !pAtEnd ) {\n\n\t\t\t\tpuv += edgeStep * EDGE_GUESS;\n\n\t\t\t}\n\n\t\t\tvec2 nuv = uvEdge - edgeStep * edgeSteps[0];\n\t\t\tfloat nLuminanceDelta = SampleLuminance( tex2D, nuv ) - edgeLuminance;\n\t\t\tbool nAtEnd = abs( nLuminanceDelta ) >= gradientThreshold;\n\n\t\t\tfor ( int i = 1; i < EDGE_STEP_COUNT && !nAtEnd; i++ ) {\n\n\t\t\t\tnuv -= edgeStep * edgeSteps[i];\n\t\t\t\tnLuminanceDelta = SampleLuminance( tex2D, nuv ) - edgeLuminance;\n\t\t\t\tnAtEnd = abs( nLuminanceDelta ) >= gradientThreshold;\n\n\t\t\t}\n\n\t\t\tif ( !nAtEnd ) {\n\n\t\t\t\tnuv -= edgeStep * EDGE_GUESS;\n\n\t\t\t}\n\n\t\t\tfloat pDistance, nDistance;\n\t\t\tif ( e.isHorizontal ) {\n\n\t\t\t\tpDistance = puv.x - uv.x;\n\t\t\t\tnDistance = uv.x - nuv.x;\n\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tpDistance = puv.y - uv.y;\n\t\t\t\tnDistance = uv.y - nuv.y;\n\n\t\t\t}\n\n\t\t\tfloat shortestDistance;\n\t\t\tbool deltaSign;\n\t\t\tif ( pDistance <= nDistance ) {\n\n\t\t\t\tshortestDistance = pDistance;\n\t\t\t\tdeltaSign = pLuminanceDelta >= 0.0;\n\n\t\t\t} else {\n\n\t\t\t\tshortestDistance = nDistance;\n\t\t\t\tdeltaSign = nLuminanceDelta >= 0.0;\n\n\t\t\t}\n\n\t\t\tif ( deltaSign == ( l.m - edgeLuminance >= 0.0 ) ) {\n\n\t\t\t\treturn 0.0;\n\n\t\t\t}\n\n\t\t\treturn 0.5 - shortestDistance / ( pDistance + nDistance );\n\n\t\t}\n\n\t\tvec4 ApplyFXAA( sampler2D  tex2D, vec2 texSize, vec2 uv ) {\n\n\t\t\tLuminanceData luminance = SampleLuminanceNeighborhood( tex2D, texSize, uv );\n\t\t\tif ( ShouldSkipPixel( luminance ) ) {\n\n\t\t\t\treturn Sample( tex2D, uv );\n\n\t\t\t}\n\n\t\t\tfloat pixelBlend = DeterminePixelBlendFactor( luminance );\n\t\t\tEdgeData edge = DetermineEdge( texSize, luminance );\n\t\t\tfloat edgeBlend = DetermineEdgeBlendFactor( tex2D, texSize, luminance, edge, uv );\n\t\t\tfloat finalBlend = max( pixelBlend, edgeBlend );\n\n\t\t\tif (edge.isHorizontal) {\n\n\t\t\t\tuv.y += edge.pixelStep * finalBlend;\n\n\t\t\t} else {\n\n\t\t\t\tuv.x += edge.pixelStep * finalBlend;\n\n\t\t\t}\n\n\t\t\treturn Sample( tex2D, uv );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = ApplyFXAA( tDiffuse, resolution.xy, vUv );\n\t\t\t\n\t\t}"};class Mm{static createButton(t,e={}){const i=document.createElement("button");function n(){i.style.display="",i.style.cursor="auto",i.style.left="calc(50% - 75px)",i.style.width="150px",i.onmouseenter=null,i.onmouseleave=null,i.onclick=null}function s(t){t.style.position="absolute",t.style.bottom="20px",t.style.padding="12px 6px",t.style.border="1px solid #fff",t.style.borderRadius="4px",t.style.background="rgba(0,0,0,0.1)",t.style.color="#fff",t.style.font="normal 13px sans-serif",t.style.textAlign="center",t.style.opacity="0.5",t.style.outline="none",t.style.zIndex="999"}if("xr"in navigator)return i.id="VRButton",i.style.display="none",s(i),navigator.xr.isSessionSupported("immersive-vr").then((function(s){s?function(){let n=null;async function s(e){e.addEventListener("end",r),await t.xr.setSession(e),i.textContent="EXIT VR",n=e}function r(){n.removeEventListener("end",r),i.textContent="ENTER VR",n=null}i.style.display="",i.style.cursor="pointer",i.style.left="calc(50% - 50px)",i.style.width="100px",i.textContent="ENTER VR";const a={...e,optionalFeatures:["local-floor","bounded-floor","layers",...e.optionalFeatures||[]]};i.onmouseenter=function(){i.style.opacity="1.0"},i.onmouseleave=function(){i.style.opacity="0.5"},i.onclick=function(){null===n?navigator.xr.requestSession("immersive-vr",a).then(s):(n.end(),void 0!==navigator.xr.offerSession&&navigator.xr.offerSession("immersive-vr",a).then(s).catch((t=>{})))},void 0!==navigator.xr.offerSession&&navigator.xr.offerSession("immersive-vr",a).then(s).catch((t=>{}))}():(n(),i.textContent="VR NOT SUPPORTED"),s&&Mm.xrSessionIsGranted&&i.click()})).catch((function(t){n(),i.textContent="VR NOT ALLOWED"})),i;{const t=document.createElement("a");return!1===window.isSecureContext?(t.href=document.location.href.replace(/^http:/,"https:"),t.innerHTML="WEBXR NEEDS HTTPS"):(t.href="https://immersiveweb.dev/",t.innerHTML="WEBXR NOT AVAILABLE"),t.style.left="calc(50% - 90px)",t.style.width="180px",t.style.textDecoration="none",s(t),t}}static registerSessionGrantedListener(){if("undefined"!=typeof navigator&&"xr"in navigator){if(/WebXRViewer\//i.test(navigator.userAgent))return;navigator.xr.addEventListener("sessiongranted",(()=>{Mm.xrSessionIsGranted=!0}))}}}Mm.xrSessionIsGranted=!1,Mm.registerSessionGrantedListener();var Tm=Object.freeze({Linear:Object.freeze({None:function(t){return t},In:function(t){return this.None(t)},Out:function(t){return this.None(t)},InOut:function(t){return this.None(t)}}),Quadratic:Object.freeze({In:function(t){return t*t},Out:function(t){return t*(2-t)},InOut:function(t){return(t*=2)<1?.5*t*t:-.5*(--t*(t-2)-1)}}),Cubic:Object.freeze({In:function(t){return t*t*t},Out:function(t){return--t*t*t+1},InOut:function(t){return(t*=2)<1?.5*t*t*t:.5*((t-=2)*t*t+2)}}),Quartic:Object.freeze({In:function(t){return t*t*t*t},Out:function(t){return 1- --t*t*t*t},InOut:function(t){return(t*=2)<1?.5*t*t*t*t:-.5*((t-=2)*t*t*t-2)}}),Quintic:Object.freeze({In:function(t){return t*t*t*t*t},Out:function(t){return--t*t*t*t*t+1},InOut:function(t){return(t*=2)<1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2)}}),Sinusoidal:Object.freeze({In:function(t){return 1-Math.sin((1-t)*Math.PI/2)},Out:function(t){return Math.sin(t*Math.PI/2)},InOut:function(t){return.5*(1-Math.sin(Math.PI*(.5-t)))}}),Exponential:Object.freeze({In:function(t){return 0===t?0:Math.pow(1024,t-1)},Out:function(t){return 1===t?1:1-Math.pow(2,-10*t)},InOut:function(t){return 0===t?0:1===t?1:(t*=2)<1?.5*Math.pow(1024,t-1):.5*(2-Math.pow(2,-10*(t-1)))}}),Circular:Object.freeze({In:function(t){return 1-Math.sqrt(1-t*t)},Out:function(t){return Math.sqrt(1- --t*t)},InOut:function(t){return(t*=2)<1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)}}),Elastic:Object.freeze({In:function(t){return 0===t?0:1===t?1:-Math.pow(2,10*(t-1))*Math.sin(5*(t-1.1)*Math.PI)},Out:function(t){return 0===t?0:1===t?1:Math.pow(2,-10*t)*Math.sin(5*(t-.1)*Math.PI)+1},InOut:function(t){return 0===t?0:1===t?1:(t*=2)<1?-.5*Math.pow(2,10*(t-1))*Math.sin(5*(t-1.1)*Math.PI):.5*Math.pow(2,-10*(t-1))*Math.sin(5*(t-1.1)*Math.PI)+1}}),Back:Object.freeze({In:function(t){var e=1.70158;return 1===t?1:t*t*((e+1)*t-e)},Out:function(t){var e=1.70158;return 0===t?0:--t*t*((e+1)*t+e)+1},InOut:function(t){var e=2.5949095;return(t*=2)<1?t*t*((e+1)*t-e)*.5:.5*((t-=2)*t*((e+1)*t+e)+2)}}),Bounce:Object.freeze({In:function(t){return 1-Tm.Bounce.Out(1-t)},Out:function(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375},InOut:function(t){return t<.5?.5*Tm.Bounce.In(2*t):.5*Tm.Bounce.Out(2*t-1)+.5}}),generatePow:function(t){return void 0===t&&(t=4),t=(t=t<Number.EPSILON?Number.EPSILON:t)>1e4?1e4:t,{In:function(e){return Math.pow(e,t)},Out:function(e){return 1-Math.pow(1-e,t)},InOut:function(e){return e<.5?Math.pow(2*e,t)/2:(1-Math.pow(2-2*e,t))/2+.5}}}}),wm=function(){return performance.now()},Am=function(){function t(){this._tweens={},this._tweensAddedDuringUpdate={}}return t.prototype.getAll=function(){var t=this;return Object.keys(this._tweens).map((function(e){return t._tweens[e]}))},t.prototype.removeAll=function(){this._tweens={}},t.prototype.add=function(t){this._tweens[t.getId()]=t,this._tweensAddedDuringUpdate[t.getId()]=t},t.prototype.remove=function(t){delete this._tweens[t.getId()],delete this._tweensAddedDuringUpdate[t.getId()]},t.prototype.update=function(t,e){void 0===t&&(t=wm()),void 0===e&&(e=!1);var i=Object.keys(this._tweens);if(0===i.length)return!1;for(;i.length>0;){this._tweensAddedDuringUpdate={};for(var n=0;n<i.length;n++){var s=this._tweens[i[n]],r=!e;s&&!1===s.update(t,r)&&!e&&delete this._tweens[i[n]]}i=Object.keys(this._tweensAddedDuringUpdate)}return!0},t}(),Em={Linear:function(t,e){var i=t.length-1,n=i*e,s=Math.floor(n),r=Em.Utils.Linear;return e<0?r(t[0],t[1],n):e>1?r(t[i],t[i-1],i-n):r(t[s],t[s+1>i?i:s+1],n-s)},Bezier:function(t,e){for(var i=0,n=t.length-1,s=Math.pow,r=Em.Utils.Bernstein,a=0;a<=n;a++)i+=s(1-e,n-a)*s(e,a)*t[a]*r(n,a);return i},CatmullRom:function(t,e){var i=t.length-1,n=i*e,s=Math.floor(n),r=Em.Utils.CatmullRom;return t[0]===t[i]?(e<0&&(s=Math.floor(n=i*(1+e))),r(t[(s-1+i)%i],t[s],t[(s+1)%i],t[(s+2)%i],n-s)):e<0?t[0]-(r(t[0],t[0],t[1],t[1],-n)-t[0]):e>1?t[i]-(r(t[i],t[i],t[i-1],t[i-1],n-i)-t[i]):r(t[s?s-1:0],t[s],t[i<s+1?i:s+1],t[i<s+2?i:s+2],n-s)},Utils:{Linear:function(t,e,i){return(e-t)*i+t},Bernstein:function(t,e){var i=Em.Utils.Factorial;return i(t)/i(e)/i(t-e)},Factorial:function(){var t=[1];return function(e){var i=1;if(t[e])return t[e];for(var n=e;n>1;n--)i*=n;return t[e]=i,i}}(),CatmullRom:function(t,e,i,n,s){var r=.5*(i-t),a=.5*(n-e),o=s*s;return(2*e-2*i+r+a)*(s*o)+(-3*e+3*i-2*r-a)*o+r*s+e}}},Cm=function(){function t(){}return t.nextId=function(){return t._nextId++},t._nextId=0,t}(),Rm=new Am,Nm=function(){function t(t,e){void 0===e&&(e=Rm),this._object=t,this._group=e,this._isPaused=!1,this._pauseStart=0,this._valuesStart={},this._valuesEnd={},this._valuesStartRepeat={},this._duration=1e3,this._isDynamic=!1,this._initialRepeat=0,this._repeat=0,this._yoyo=!1,this._isPlaying=!1,this._reversed=!1,this._delayTime=0,this._startTime=0,this._easingFunction=Tm.Linear.None,this._interpolationFunction=Em.Linear,this._chainedTweens=[],this._onStartCallbackFired=!1,this._onEveryStartCallbackFired=!1,this._id=Cm.nextId(),this._isChainStopped=!1,this._propertiesAreSetUp=!1,this._goToEnd=!1}return t.prototype.getId=function(){return this._id},t.prototype.isPlaying=function(){return this._isPlaying},t.prototype.isPaused=function(){return this._isPaused},t.prototype.getDuration=function(){return this._duration},t.prototype.to=function(t,e){if(void 0===e&&(e=1e3),this._isPlaying)throw new Error("Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.");return this._valuesEnd=t,this._propertiesAreSetUp=!1,this._duration=e<0?0:e,this},t.prototype.duration=function(t){return void 0===t&&(t=1e3),this._duration=t<0?0:t,this},t.prototype.dynamic=function(t){return void 0===t&&(t=!1),this._isDynamic=t,this},t.prototype.start=function(t,e){if(void 0===t&&(t=wm()),void 0===e&&(e=!1),this._isPlaying)return this;if(this._group&&this._group.add(this),this._repeat=this._initialRepeat,this._reversed)for(var i in this._reversed=!1,this._valuesStartRepeat)this._swapEndStartRepeatValues(i),this._valuesStart[i]=this._valuesStartRepeat[i];if(this._isPlaying=!0,this._isPaused=!1,this._onStartCallbackFired=!1,this._onEveryStartCallbackFired=!1,this._isChainStopped=!1,this._startTime=t,this._startTime+=this._delayTime,!this._propertiesAreSetUp||e){if(this._propertiesAreSetUp=!0,!this._isDynamic){var n={};for(var s in this._valuesEnd)n[s]=this._valuesEnd[s];this._valuesEnd=n}this._setupProperties(this._object,this._valuesStart,this._valuesEnd,this._valuesStartRepeat,e)}return this},t.prototype.startFromCurrentValues=function(t){return this.start(t,!0)},t.prototype._setupProperties=function(t,e,i,n,s){for(var r in i){var a=t[r],o=Array.isArray(a),l=o?"array":typeof a,h=!o&&Array.isArray(i[r]);if("undefined"!==l&&"function"!==l){if(h){if(0===(g=i[r]).length)continue;for(var c=[a],u=0,d=g.length;u<d;u+=1){var p=this._handleRelativeValue(a,g[u]);if(isNaN(p)){h=!1;break}c.push(p)}h&&(i[r]=c)}if("object"!==l&&!o||!a||h)(void 0===e[r]||s)&&(e[r]=a),o||(e[r]*=1),n[r]=h?i[r].slice().reverse():e[r]||0;else{e[r]=o?[]:{};var m=a;for(var f in m)e[r][f]=m[f];n[r]=o?[]:{};var g=i[r];if(!this._isDynamic){var x={};for(var f in g)x[f]=g[f];i[r]=g=x}this._setupProperties(m,e[r],g,n[r],s)}}}},t.prototype.stop=function(){return this._isChainStopped||(this._isChainStopped=!0,this.stopChainedTweens()),this._isPlaying?(this._group&&this._group.remove(this),this._isPlaying=!1,this._isPaused=!1,this._onStopCallback&&this._onStopCallback(this._object),this):this},t.prototype.end=function(){return this._goToEnd=!0,this.update(1/0),this},t.prototype.pause=function(t){return void 0===t&&(t=wm()),this._isPaused||!this._isPlaying||(this._isPaused=!0,this._pauseStart=t,this._group&&this._group.remove(this)),this},t.prototype.resume=function(t){return void 0===t&&(t=wm()),this._isPaused&&this._isPlaying?(this._isPaused=!1,this._startTime+=t-this._pauseStart,this._pauseStart=0,this._group&&this._group.add(this),this):this},t.prototype.stopChainedTweens=function(){for(var t=0,e=this._chainedTweens.length;t<e;t++)this._chainedTweens[t].stop();return this},t.prototype.group=function(t){return void 0===t&&(t=Rm),this._group=t,this},t.prototype.delay=function(t){return void 0===t&&(t=0),this._delayTime=t,this},t.prototype.repeat=function(t){return void 0===t&&(t=0),this._initialRepeat=t,this._repeat=t,this},t.prototype.repeatDelay=function(t){return this._repeatDelayTime=t,this},t.prototype.yoyo=function(t){return void 0===t&&(t=!1),this._yoyo=t,this},t.prototype.easing=function(t){return void 0===t&&(t=Tm.Linear.None),this._easingFunction=t,this},t.prototype.interpolation=function(t){return void 0===t&&(t=Em.Linear),this._interpolationFunction=t,this},t.prototype.chain=function(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];return this._chainedTweens=t,this},t.prototype.onStart=function(t){return this._onStartCallback=t,this},t.prototype.onEveryStart=function(t){return this._onEveryStartCallback=t,this},t.prototype.onUpdate=function(t){return this._onUpdateCallback=t,this},t.prototype.onRepeat=function(t){return this._onRepeatCallback=t,this},t.prototype.onComplete=function(t){return this._onCompleteCallback=t,this},t.prototype.onStop=function(t){return this._onStopCallback=t,this},t.prototype.update=function(t,e){var i,n,s=this;if(void 0===t&&(t=wm()),void 0===e&&(e=!0),this._isPaused)return!0;var r=this._startTime+this._duration;if(!this._goToEnd&&!this._isPlaying){if(t>r)return!1;e&&this.start(t,!0)}if(this._goToEnd=!1,t<this._startTime)return!0;!1===this._onStartCallbackFired&&(this._onStartCallback&&this._onStartCallback(this._object),this._onStartCallbackFired=!0),!1===this._onEveryStartCallbackFired&&(this._onEveryStartCallback&&this._onEveryStartCallback(this._object),this._onEveryStartCallbackFired=!0);var a=t-this._startTime,o=this._duration+(null!==(i=this._repeatDelayTime)&&void 0!==i?i:this._delayTime),l=this._duration+this._repeat*o,h=function(){if(0===s._duration)return 1;if(a>l)return 1;var t=Math.trunc(a/o),e=a-t*o,i=Math.min(e/s._duration,1);return 0===i&&a===s._duration?1:i}(),c=this._easingFunction(h);if(this._updateProperties(this._object,this._valuesStart,this._valuesEnd,c),this._onUpdateCallback&&this._onUpdateCallback(this._object,h),0===this._duration||a>=this._duration){if(this._repeat>0){var u=Math.min(Math.trunc((a-this._duration)/o)+1,this._repeat);for(n in isFinite(this._repeat)&&(this._repeat-=u),this._valuesStartRepeat)this._yoyo||"string"!=typeof this._valuesEnd[n]||(this._valuesStartRepeat[n]=this._valuesStartRepeat[n]+parseFloat(this._valuesEnd[n])),this._yoyo&&this._swapEndStartRepeatValues(n),this._valuesStart[n]=this._valuesStartRepeat[n];return this._yoyo&&(this._reversed=!this._reversed),this._startTime+=o*u,this._onRepeatCallback&&this._onRepeatCallback(this._object),this._onEveryStartCallbackFired=!1,!0}this._onCompleteCallback&&this._onCompleteCallback(this._object);for(var d=0,p=this._chainedTweens.length;d<p;d++)this._chainedTweens[d].start(this._startTime+this._duration,!1);return this._isPlaying=!1,!1}return!0},t.prototype._updateProperties=function(t,e,i,n){for(var s in i)if(void 0!==e[s]){var r=e[s]||0,a=i[s],o=Array.isArray(t[s]),l=Array.isArray(a);!o&&l?t[s]=this._interpolationFunction(a,n):"object"==typeof a&&a?this._updateProperties(t[s],r,a,n):"number"==typeof(a=this._handleRelativeValue(r,a))&&(t[s]=r+(a-r)*n)}},t.prototype._handleRelativeValue=function(t,e){return"string"!=typeof e?e:"+"===e.charAt(0)||"-"===e.charAt(0)?t+parseFloat(e):parseFloat(e)},t.prototype._swapEndStartRepeatValues=function(t){var e=this._valuesStartRepeat[t],i=this._valuesEnd[t];this._valuesStartRepeat[t]="string"==typeof i?this._valuesStartRepeat[t]+parseFloat(i):this._valuesEnd[t],this._valuesEnd[t]=e},t}(),Pm=Cm.nextId,Im=Rm,Lm=Im.getAll.bind(Im),Dm=Im.removeAll.bind(Im),Um=Im.add.bind(Im),Fm=Im.remove.bind(Im),Bm=Im.update.bind(Im),Om={Easing:Tm,Group:Am,Interpolation:Em,now:wm,Sequence:Cm,nextId:Pm,Tween:Nm,VERSION:"23.1.1",getAll:Lm,removeAll:Dm,add:Um,remove:Fm,update:Bm};
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const zm="170",km=2,Vm=2,Gm=100,Hm=101,Wm=102,jm=200,Xm=201,qm=202,$m=203,Ym=204,Zm=205,Km=206,Jm=207,Qm=208,tf=209,ef=210,nf=301,sf=302,rf=303,af=304,of=1e3,lf=1001,hf=1002,cf=1003,uf=1004,df=1005,pf=1006,mf=1007,ff=1008,gf=1009,xf=1010,vf=1011,_f=1012,yf=1013,bf=1014,Sf=1015,Mf=1016,Tf=1020,wf=1022,Af=1023,Ef=1026,Cf=1027,Rf=1028,Nf=1029,Pf=1030,If=1031,Lf=1033,Df=33776,Uf=33777,Ff=33778,Bf=33779,Of=37492,zf=37496,kf=37808,Vf=37809,Gf=37810,Hf=37811,Wf=37812,jf=37813,Xf=37814,qf=37815,$f=37816,Yf=37817,Zf=37818,Kf=37819,Jf=37820,Qf=37821,tg=36492,eg="",ig="srgb",ng="srgb-linear",sg="linear",rg="srgb",ag=7680,og=512,lg=513,hg=514,cg=515,ug=516,dg=517,pg=518,mg=519,fg=35044,gg=35048,xg=2e3,vg=2001;class _g{addEventListener(t,e){void 0===this._listeners&&(this._listeners={});const i=this._listeners;void 0===i[t]&&(i[t]=[]),-1===i[t].indexOf(e)&&i[t].push(e)}hasEventListener(t,e){if(void 0===this._listeners)return!1;const i=this._listeners;return void 0!==i[t]&&-1!==i[t].indexOf(e)}removeEventListener(t,e){if(void 0===this._listeners)return;const i=this._listeners[t];if(void 0!==i){const t=i.indexOf(e);-1!==t&&i.splice(t,1)}}dispatchEvent(t){if(void 0===this._listeners)return;const e=this._listeners[t.type];if(void 0!==e){t.target=this;const i=e.slice(0);for(let e=0,n=i.length;e<n;e++)i[e].call(this,t);t.target=null}}}const yg=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let bg=1234567;const Sg=Math.PI/180,Mg=180/Math.PI;function Tg(){const t=4294967295*Math.random()|0,e=4294967295*Math.random()|0,i=4294967295*Math.random()|0,n=4294967295*Math.random()|0;return(yg[255&t]+yg[t>>8&255]+yg[t>>16&255]+yg[t>>24&255]+"-"+yg[255&e]+yg[e>>8&255]+"-"+yg[e>>16&15|64]+yg[e>>24&255]+"-"+yg[63&i|128]+yg[i>>8&255]+"-"+yg[i>>16&255]+yg[i>>24&255]+yg[255&n]+yg[n>>8&255]+yg[n>>16&255]+yg[n>>24&255]).toLowerCase()}function wg(t,e,i){return Math.max(e,Math.min(i,t))}function Ag(t,e){return(t%e+e)%e}function Eg(t,e,i){return(1-i)*t+i*e}function Cg(t,e){switch(e.constructor){case Float32Array:return t;case Uint32Array:return t/4294967295;case Uint16Array:return t/65535;case Uint8Array:return t/255;case Int32Array:return Math.max(t/2147483647,-1);case Int16Array:return Math.max(t/32767,-1);case Int8Array:return Math.max(t/127,-1);default:throw new Error("Invalid component type.")}}function Rg(t,e){switch(e.constructor){case Float32Array:return t;case Uint32Array:return Math.round(4294967295*t);case Uint16Array:return Math.round(65535*t);case Uint8Array:return Math.round(255*t);case Int32Array:return Math.round(2147483647*t);case Int16Array:return Math.round(32767*t);case Int8Array:return Math.round(127*t);default:throw new Error("Invalid component type.")}}const Ng={DEG2RAD:Sg,RAD2DEG:Mg,generateUUID:Tg,clamp:wg,euclideanModulo:Ag,mapLinear:function(t,e,i,n,s){return n+(t-e)*(s-n)/(i-e)},inverseLerp:function(t,e,i){return t!==e?(i-t)/(e-t):0},lerp:Eg,damp:function(t,e,i,n){return Eg(t,e,1-Math.exp(-i*n))},pingpong:function(t,e=1){return e-Math.abs(Ag(t,2*e)-e)},smoothstep:function(t,e,i){return t<=e?0:t>=i?1:(t=(t-e)/(i-e))*t*(3-2*t)},smootherstep:function(t,e,i){return t<=e?0:t>=i?1:(t=(t-e)/(i-e))*t*t*(t*(6*t-15)+10)},randInt:function(t,e){return t+Math.floor(Math.random()*(e-t+1))},randFloat:function(t,e){return t+Math.random()*(e-t)},randFloatSpread:function(t){return t*(.5-Math.random())},seededRandom:function(t){void 0!==t&&(bg=t);let e=bg+=1831565813;return e=Math.imul(e^e>>>15,1|e),e^=e+Math.imul(e^e>>>7,61|e),((e^e>>>14)>>>0)/4294967296},degToRad:function(t){return t*Sg},radToDeg:function(t){return t*Mg},isPowerOfTwo:function(t){return!(t&t-1)&&0!==t},ceilPowerOfTwo:function(t){return Math.pow(2,Math.ceil(Math.log(t)/Math.LN2))},floorPowerOfTwo:function(t){return Math.pow(2,Math.floor(Math.log(t)/Math.LN2))},setQuaternionFromProperEuler:function(t,e,i,n,s){const r=Math.cos,a=Math.sin,o=r(i/2),l=a(i/2),h=r((e+n)/2),c=a((e+n)/2),u=r((e-n)/2),d=a((e-n)/2),p=r((n-e)/2),m=a((n-e)/2);switch(s){case"XYX":t.set(o*c,l*u,l*d,o*h);break;case"YZY":t.set(l*d,o*c,l*u,o*h);break;case"ZXZ":t.set(l*u,l*d,o*c,o*h);break;case"XZX":t.set(o*c,l*m,l*p,o*h);break;case"YXY":t.set(l*p,o*c,l*m,o*h);break;case"ZYZ":t.set(l*m,l*p,o*c,o*h)}},normalize:Rg,denormalize:Cg};class Pg{constructor(t=0,e=0){Pg.prototype.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,i=this.y,n=t.elements;return this.x=n[0]*e+n[3]*i+n[6],this.y=n[1]*e+n[4]*i+n[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const i=this.dot(t)/e;return Math.acos(wg(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,i=this.y-t.y;return e*e+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const i=Math.cos(e),n=Math.sin(e),s=this.x-t.x,r=this.y-t.y;return this.x=s*i-r*n+t.x,this.y=s*n+r*i+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class Ig{constructor(t,e,i,n,s,r,a,o,l){Ig.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],void 0!==t&&this.set(t,e,i,n,s,r,a,o,l)}set(t,e,i,n,s,r,a,o,l){const h=this.elements;return h[0]=t,h[1]=n,h[2]=a,h[3]=e,h[4]=s,h[5]=o,h[6]=i,h[7]=r,h[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],this}extractBasis(t,e,i){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const i=t.elements,n=e.elements,s=this.elements,r=i[0],a=i[3],o=i[6],l=i[1],h=i[4],c=i[7],u=i[2],d=i[5],p=i[8],m=n[0],f=n[3],g=n[6],x=n[1],v=n[4],_=n[7],y=n[2],b=n[5],S=n[8];return s[0]=r*m+a*x+o*y,s[3]=r*f+a*v+o*b,s[6]=r*g+a*_+o*S,s[1]=l*m+h*x+c*y,s[4]=l*f+h*v+c*b,s[7]=l*g+h*_+c*S,s[2]=u*m+d*x+p*y,s[5]=u*f+d*v+p*b,s[8]=u*g+d*_+p*S,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],i=t[1],n=t[2],s=t[3],r=t[4],a=t[5],o=t[6],l=t[7],h=t[8];return e*r*h-e*a*l-i*s*h+i*a*o+n*s*l-n*r*o}invert(){const t=this.elements,e=t[0],i=t[1],n=t[2],s=t[3],r=t[4],a=t[5],o=t[6],l=t[7],h=t[8],c=h*r-a*l,u=a*o-h*s,d=l*s-r*o,p=e*c+i*u+n*d;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);const m=1/p;return t[0]=c*m,t[1]=(n*l-h*i)*m,t[2]=(a*i-n*r)*m,t[3]=u*m,t[4]=(h*e-n*o)*m,t[5]=(n*s-a*e)*m,t[6]=d*m,t[7]=(i*o-l*e)*m,t[8]=(r*e-i*s)*m,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,i,n,s,r,a){const o=Math.cos(s),l=Math.sin(s);return this.set(i*o,i*l,-i*(o*r+l*a)+r+t,-n*l,n*o,-n*(-l*r+o*a)+a+e,0,0,1),this}scale(t,e){return this.premultiply(Lg.makeScale(t,e)),this}rotate(t){return this.premultiply(Lg.makeRotation(-t)),this}translate(t,e){return this.premultiply(Lg.makeTranslation(t,e)),this}makeTranslation(t,e){return t.isVector2?this.set(1,0,t.x,0,1,t.y,0,0,1):this.set(1,0,t,0,1,e,0,0,1),this}makeRotation(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,-i,0,i,e,0,0,0,1),this}makeScale(t,e){return this.set(t,0,0,0,e,0,0,0,1),this}equals(t){const e=this.elements,i=t.elements;for(let n=0;n<9;n++)if(e[n]!==i[n])return!1;return!0}fromArray(t,e=0){for(let i=0;i<9;i++)this.elements[i]=t[i+e];return this}toArray(t=[],e=0){const i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t}clone(){return(new this.constructor).fromArray(this.elements)}}const Lg=new Ig;function Dg(t){return document.createElementNS("http://www.w3.org/1999/xhtml",t)}const Ug={};const Fg={enabled:!0,workingColorSpace:ng,spaces:{},convert:function(t,e,i){return!1!==this.enabled&&e!==i&&e&&i?(this.spaces[e].transfer===rg&&(t.r=Bg(t.r),t.g=Bg(t.g),t.b=Bg(t.b)),this.spaces[e].primaries!==this.spaces[i].primaries&&(t.applyMatrix3(this.spaces[e].toXYZ),t.applyMatrix3(this.spaces[i].fromXYZ)),this.spaces[i].transfer===rg&&(t.r=Og(t.r),t.g=Og(t.g),t.b=Og(t.b)),t):t},fromWorkingColorSpace:function(t,e){return this.convert(t,this.workingColorSpace,e)},toWorkingColorSpace:function(t,e){return this.convert(t,e,this.workingColorSpace)},getPrimaries:function(t){return this.spaces[t].primaries},getTransfer:function(t){return t===eg?sg:this.spaces[t].transfer},getLuminanceCoefficients:function(t,e=this.workingColorSpace){return t.fromArray(this.spaces[e].luminanceCoefficients)},define:function(t){Object.assign(this.spaces,t)},_getMatrix:function(t,e,i){return t.copy(this.spaces[e].toXYZ).multiply(this.spaces[i].fromXYZ)},_getDrawingBufferColorSpace:function(t){return this.spaces[t].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(t=this.workingColorSpace){return this.spaces[t].workingColorSpaceConfig.unpackColorSpace}};function Bg(t){return t<.04045?.0773993808*t:Math.pow(.9478672986*t+.0521327014,2.4)}function Og(t){return t<.0031308?12.92*t:1.055*Math.pow(t,.41666)-.055}const zg=[.64,.33,.3,.6,.15,.06],kg=[.2126,.7152,.0722],Vg=[.3127,.329],Gg=(new Ig).set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),Hg=(new Ig).set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);let Wg;Fg.define({[ng]:{primaries:zg,whitePoint:Vg,transfer:sg,toXYZ:Gg,fromXYZ:Hg,luminanceCoefficients:kg,workingColorSpaceConfig:{unpackColorSpace:ig},outputColorSpaceConfig:{drawingBufferColorSpace:ig}},[ig]:{primaries:zg,whitePoint:Vg,transfer:rg,toXYZ:Gg,fromXYZ:Hg,luminanceCoefficients:kg,outputColorSpaceConfig:{drawingBufferColorSpace:ig}}});class jg{static getDataURL(t){if(/^data:/i.test(t.src))return t.src;if("undefined"==typeof HTMLCanvasElement)return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{void 0===Wg&&(Wg=Dg("canvas")),Wg.width=t.width,Wg.height=t.height;const i=Wg.getContext("2d");t instanceof ImageData?i.putImageData(t,0,0):i.drawImage(t,0,0,t.width,t.height),e=Wg}return e.width>2048||e.height>2048?e.toDataURL("image/jpeg",.6):e.toDataURL("image/png")}static sRGBToLinear(t){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const e=Dg("canvas");e.width=t.width,e.height=t.height;const i=e.getContext("2d");i.drawImage(t,0,0,t.width,t.height);const n=i.getImageData(0,0,t.width,t.height),s=n.data;for(let t=0;t<s.length;t++)s[t]=255*Bg(s[t]/255);return i.putImageData(n,0,0),e}if(t.data){const e=t.data.slice(0);for(let t=0;t<e.length;t++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[t]=Math.floor(255*Bg(e[t]/255)):e[t]=Bg(e[t]);return{data:e,width:t.width,height:t.height}}return t}}let Xg=0;class qg{constructor(t=null){this.isSource=!0,Object.defineProperty(this,"id",{value:Xg++}),this.uuid=Tg(),this.data=t,this.dataReady=!0,this.version=0}set needsUpdate(t){!0===t&&this.version++}toJSON(t){const e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.images[this.uuid])return t.images[this.uuid];const i={uuid:this.uuid,url:""},n=this.data;if(null!==n){let t;if(Array.isArray(n)){t=[];for(let e=0,i=n.length;e<i;e++)n[e].isDataTexture?t.push($g(n[e].image)):t.push($g(n[e]))}else t=$g(n);i.url=t}return e||(t.images[this.uuid]=i),i}}function $g(t){return"undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap?jg.getDataURL(t):t.data?{data:Array.from(t.data),width:t.width,height:t.height,type:t.data.constructor.name}:{}}let Yg=0;class Zg extends _g{constructor(t=Zg.DEFAULT_IMAGE,e=Zg.DEFAULT_MAPPING,i=1001,n=1001,s=1006,r=1008,a=1023,o=1009,l=Zg.DEFAULT_ANISOTROPY,h=""){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:Yg++}),this.uuid=Tg(),this.name="",this.source=new qg(t),this.mipmaps=[],this.mapping=e,this.channel=0,this.wrapS=i,this.wrapT=n,this.magFilter=s,this.minFilter=r,this.anisotropy=l,this.format=a,this.internalFormat=null,this.type=o,this.offset=new Pg(0,0),this.repeat=new Pg(1,1),this.center=new Pg(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Ig,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=h,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.pmremVersion=0}get image(){return this.source.data}set image(t=null){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return(new this.constructor).copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.channel=t.channel,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.colorSpace=t.colorSpace,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}toJSON(t){const e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.textures[this.uuid])return t.textures[this.uuid];const i={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(i.userData=this.userData),e||(t.textures[this.uuid]=i),i}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(300!==this.mapping)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case of:t.x=t.x-Math.floor(t.x);break;case lf:t.x=t.x<0?0:1;break;case hf:1===Math.abs(Math.floor(t.x)%2)?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x)}if(t.y<0||t.y>1)switch(this.wrapT){case of:t.y=t.y-Math.floor(t.y);break;case lf:t.y=t.y<0?0:1;break;case hf:1===Math.abs(Math.floor(t.y)%2)?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y)}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){!0===t&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(t){!0===t&&this.pmremVersion++}}Zg.DEFAULT_IMAGE=null,Zg.DEFAULT_MAPPING=300,Zg.DEFAULT_ANISOTROPY=1;class Kg{constructor(t=0,e=0,i=0,n=1){Kg.prototype.isVector4=!0,this.x=t,this.y=e,this.z=i,this.w=n}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,i,n){return this.x=t,this.y=e,this.z=i,this.w=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=void 0!==t.w?t.w:1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,i=this.y,n=this.z,s=this.w,r=t.elements;return this.x=r[0]*e+r[4]*i+r[8]*n+r[12]*s,this.y=r[1]*e+r[5]*i+r[9]*n+r[13]*s,this.z=r[2]*e+r[6]*i+r[10]*n+r[14]*s,this.w=r[3]*e+r[7]*i+r[11]*n+r[15]*s,this}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this.w/=t.w,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,i,n,s;const r=.01,a=.1,o=t.elements,l=o[0],h=o[4],c=o[8],u=o[1],d=o[5],p=o[9],m=o[2],f=o[6],g=o[10];if(Math.abs(h-u)<r&&Math.abs(c-m)<r&&Math.abs(p-f)<r){if(Math.abs(h+u)<a&&Math.abs(c+m)<a&&Math.abs(p+f)<a&&Math.abs(l+d+g-3)<a)return this.set(1,0,0,0),this;e=Math.PI;const t=(l+1)/2,o=(d+1)/2,x=(g+1)/2,v=(h+u)/4,_=(c+m)/4,y=(p+f)/4;return t>o&&t>x?t<r?(i=0,n=.707106781,s=.707106781):(i=Math.sqrt(t),n=v/i,s=_/i):o>x?o<r?(i=.707106781,n=0,s=.707106781):(n=Math.sqrt(o),i=v/n,s=y/n):x<r?(i=.707106781,n=.707106781,s=0):(s=Math.sqrt(x),i=_/s,n=y/s),this.set(i,n,s,e),this}let x=Math.sqrt((f-p)*(f-p)+(c-m)*(c-m)+(u-h)*(u-h));return Math.abs(x)<.001&&(x=1),this.x=(f-p)/x,this.y=(c-m)/x,this.z=(u-h)/x,this.w=Math.acos((l+d+g-1)/2),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this.w=e[15],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this.z=t.z+(e.z-t.z)*i,this.w=t.w+(e.w-t.w)*i,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class Jg extends _g{constructor(t=1,e=1,i={}){super(),this.isRenderTarget=!0,this.width=t,this.height=e,this.depth=1,this.scissor=new Kg(0,0,t,e),this.scissorTest=!1,this.viewport=new Kg(0,0,t,e);const n={width:t,height:e,depth:1};i=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:pf,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1},i);const s=new Zg(n,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.colorSpace);s.flipY=!1,s.generateMipmaps=i.generateMipmaps,s.internalFormat=i.internalFormat,this.textures=[];const r=i.count;for(let a=0;a<r;a++)this.textures[a]=s.clone(),this.textures[a].isRenderTargetTexture=!0;this.depthBuffer=i.depthBuffer,this.stencilBuffer=i.stencilBuffer,this.resolveDepthBuffer=i.resolveDepthBuffer,this.resolveStencilBuffer=i.resolveStencilBuffer,this.depthTexture=i.depthTexture,this.samples=i.samples}get texture(){return this.textures[0]}set texture(t){this.textures[0]=t}setSize(t,e,i=1){if(this.width!==t||this.height!==e||this.depth!==i){this.width=t,this.height=e,this.depth=i;for(let n=0,s=this.textures.length;n<s;n++)this.textures[n].image.width=t,this.textures[n].image.height=e,this.textures[n].image.depth=i;this.dispose()}this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return(new this.constructor).copy(this)}copy(t){this.width=t.width,this.height=t.height,this.depth=t.depth,this.scissor.copy(t.scissor),this.scissorTest=t.scissorTest,this.viewport.copy(t.viewport),this.textures.length=0;for(let i=0,n=t.textures.length;i<n;i++)this.textures[i]=t.textures[i].clone(),this.textures[i].isRenderTargetTexture=!0;const e=Object.assign({},t.texture.image);return this.texture.source=new qg(e),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.resolveDepthBuffer=t.resolveDepthBuffer,this.resolveStencilBuffer=t.resolveStencilBuffer,null!==t.depthTexture&&(this.depthTexture=t.depthTexture.clone()),this.samples=t.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class Qg extends Jg{constructor(t=1,e=1,i={}){super(t,e,i),this.isWebGLRenderTarget=!0}}class tx extends Zg{constructor(t=null,e=1,i=1,n=1){super(null),this.isDataArrayTexture=!0,this.image={data:t,width:e,height:i,depth:n},this.magFilter=cf,this.minFilter=cf,this.wrapR=lf,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(t){this.layerUpdates.add(t)}clearLayerUpdates(){this.layerUpdates.clear()}}class ex{constructor(t=0,e=0,i=0,n=1){this.isQuaternion=!0,this._x=t,this._y=e,this._z=i,this._w=n}static slerpFlat(t,e,i,n,s,r,a){let o=i[n+0],l=i[n+1],h=i[n+2],c=i[n+3];const u=s[r+0],d=s[r+1],p=s[r+2],m=s[r+3];if(0===a)return t[e+0]=o,t[e+1]=l,t[e+2]=h,void(t[e+3]=c);if(1===a)return t[e+0]=u,t[e+1]=d,t[e+2]=p,void(t[e+3]=m);if(c!==m||o!==u||l!==d||h!==p){let t=1-a;const e=o*u+l*d+h*p+c*m,i=e>=0?1:-1,n=1-e*e;if(n>Number.EPSILON){const s=Math.sqrt(n),r=Math.atan2(s,e*i);t=Math.sin(t*r)/s,a=Math.sin(a*r)/s}const s=a*i;if(o=o*t+u*s,l=l*t+d*s,h=h*t+p*s,c=c*t+m*s,t===1-a){const t=1/Math.sqrt(o*o+l*l+h*h+c*c);o*=t,l*=t,h*=t,c*=t}}t[e]=o,t[e+1]=l,t[e+2]=h,t[e+3]=c}static multiplyQuaternionsFlat(t,e,i,n,s,r){const a=i[n],o=i[n+1],l=i[n+2],h=i[n+3],c=s[r],u=s[r+1],d=s[r+2],p=s[r+3];return t[e]=a*p+h*c+o*d-l*u,t[e+1]=o*p+h*u+l*c-a*d,t[e+2]=l*p+h*d+a*u-o*c,t[e+3]=h*p-a*c-o*u-l*d,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,i,n){return this._x=t,this._y=e,this._z=i,this._w=n,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e=!0){const i=t._x,n=t._y,s=t._z,r=t._order,a=Math.cos,o=Math.sin,l=a(i/2),h=a(n/2),c=a(s/2),u=o(i/2),d=o(n/2),p=o(s/2);switch(r){case"XYZ":this._x=u*h*c+l*d*p,this._y=l*d*c-u*h*p,this._z=l*h*p+u*d*c,this._w=l*h*c-u*d*p;break;case"YXZ":this._x=u*h*c+l*d*p,this._y=l*d*c-u*h*p,this._z=l*h*p-u*d*c,this._w=l*h*c+u*d*p;break;case"ZXY":this._x=u*h*c-l*d*p,this._y=l*d*c+u*h*p,this._z=l*h*p+u*d*c,this._w=l*h*c-u*d*p;break;case"ZYX":this._x=u*h*c-l*d*p,this._y=l*d*c+u*h*p,this._z=l*h*p-u*d*c,this._w=l*h*c+u*d*p;break;case"YZX":this._x=u*h*c+l*d*p,this._y=l*d*c+u*h*p,this._z=l*h*p-u*d*c,this._w=l*h*c-u*d*p;break;case"XZY":this._x=u*h*c-l*d*p,this._y=l*d*c-u*h*p,this._z=l*h*p+u*d*c,this._w=l*h*c+u*d*p}return!0===e&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const i=e/2,n=Math.sin(i);return this._x=t.x*n,this._y=t.y*n,this._z=t.z*n,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,i=e[0],n=e[4],s=e[8],r=e[1],a=e[5],o=e[9],l=e[2],h=e[6],c=e[10],u=i+a+c;if(u>0){const t=.5/Math.sqrt(u+1);this._w=.25/t,this._x=(h-o)*t,this._y=(s-l)*t,this._z=(r-n)*t}else if(i>a&&i>c){const t=2*Math.sqrt(1+i-a-c);this._w=(h-o)/t,this._x=.25*t,this._y=(n+r)/t,this._z=(s+l)/t}else if(a>c){const t=2*Math.sqrt(1+a-i-c);this._w=(s-l)/t,this._x=(n+r)/t,this._y=.25*t,this._z=(o+h)/t}else{const t=2*Math.sqrt(1+c-i-a);this._w=(r-n)/t,this._x=(s+l)/t,this._y=(o+h)/t,this._z=.25*t}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let i=t.dot(e)+1;return i<Number.EPSILON?(i=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=i):(this._x=0,this._y=-t.z,this._z=t.y,this._w=i)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=i),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(wg(this.dot(t),-1,1)))}rotateTowards(t,e){const i=this.angleTo(t);if(0===i)return this;const n=Math.min(1,e/i);return this.slerp(t,n),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const i=t._x,n=t._y,s=t._z,r=t._w,a=e._x,o=e._y,l=e._z,h=e._w;return this._x=i*h+r*a+n*l-s*o,this._y=n*h+r*o+s*a-i*l,this._z=s*h+r*l+i*o-n*a,this._w=r*h-i*a-n*o-s*l,this._onChangeCallback(),this}slerp(t,e){if(0===e)return this;if(1===e)return this.copy(t);const i=this._x,n=this._y,s=this._z,r=this._w;let a=r*t._w+i*t._x+n*t._y+s*t._z;if(a<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,a=-a):this.copy(t),a>=1)return this._w=r,this._x=i,this._y=n,this._z=s,this;const o=1-a*a;if(o<=Number.EPSILON){const t=1-e;return this._w=t*r+e*this._w,this._x=t*i+e*this._x,this._y=t*n+e*this._y,this._z=t*s+e*this._z,this.normalize(),this}const l=Math.sqrt(o),h=Math.atan2(l,a),c=Math.sin((1-e)*h)/l,u=Math.sin(e*h)/l;return this._w=r*c+this._w*u,this._x=i*c+this._x*u,this._y=n*c+this._y*u,this._z=s*c+this._z*u,this._onChangeCallback(),this}slerpQuaternions(t,e,i){return this.copy(t).slerp(e,i)}random(){const t=2*Math.PI*Math.random(),e=2*Math.PI*Math.random(),i=Math.random(),n=Math.sqrt(1-i),s=Math.sqrt(i);return this.set(n*Math.sin(t),n*Math.cos(t),s*Math.sin(e),s*Math.cos(e))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class ix{constructor(t=0,e=0,i=0){ix.prototype.isVector3=!0,this.x=t,this.y=e,this.z=i}set(t,e,i){return void 0===i&&(i=this.z),this.x=t,this.y=e,this.z=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return this.applyQuaternion(sx.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(sx.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,i=this.y,n=this.z,s=t.elements;return this.x=s[0]*e+s[3]*i+s[6]*n,this.y=s[1]*e+s[4]*i+s[7]*n,this.z=s[2]*e+s[5]*i+s[8]*n,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,i=this.y,n=this.z,s=t.elements,r=1/(s[3]*e+s[7]*i+s[11]*n+s[15]);return this.x=(s[0]*e+s[4]*i+s[8]*n+s[12])*r,this.y=(s[1]*e+s[5]*i+s[9]*n+s[13])*r,this.z=(s[2]*e+s[6]*i+s[10]*n+s[14])*r,this}applyQuaternion(t){const e=this.x,i=this.y,n=this.z,s=t.x,r=t.y,a=t.z,o=t.w,l=2*(r*n-a*i),h=2*(a*e-s*n),c=2*(s*i-r*e);return this.x=e+o*l+r*c-a*h,this.y=i+o*h+a*l-s*c,this.z=n+o*c+s*h-r*l,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,i=this.y,n=this.z,s=t.elements;return this.x=s[0]*e+s[4]*i+s[8]*n,this.y=s[1]*e+s[5]*i+s[9]*n,this.z=s[2]*e+s[6]*i+s[10]*n,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this.z=t.z+(e.z-t.z)*i,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,e){const i=t.x,n=t.y,s=t.z,r=e.x,a=e.y,o=e.z;return this.x=n*o-s*a,this.y=s*r-i*o,this.z=i*a-n*r,this}projectOnVector(t){const e=t.lengthSq();if(0===e)return this.set(0,0,0);const i=t.dot(this)/e;return this.copy(t).multiplyScalar(i)}projectOnPlane(t){return nx.copy(this).projectOnVector(t),this.sub(nx)}reflect(t){return this.sub(nx.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const i=this.dot(t)/e;return Math.acos(wg(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,i=this.y-t.y,n=this.z-t.z;return e*e+i*i+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,i){const n=Math.sin(e)*t;return this.x=n*Math.sin(i),this.y=Math.cos(e)*t,this.z=n*Math.cos(i),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,i){return this.x=t*Math.sin(e),this.y=i,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),i=this.setFromMatrixColumn(t,1).length(),n=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=i,this.z=n,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,4*e)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,3*e)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}setFromColor(t){return this.x=t.r,this.y=t.g,this.z=t.b,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=Math.random()*Math.PI*2,e=2*Math.random()-1,i=Math.sqrt(1-e*e);return this.x=i*Math.cos(t),this.y=e,this.z=i*Math.sin(t),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const nx=new ix,sx=new ex;class rx{constructor(t=new ix(1/0,1/0,1/0),e=new ix(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){this.makeEmpty();for(let e=0,i=t.length;e<i;e+=3)this.expandByPoint(ox.fromArray(t,e));return this}setFromBufferAttribute(t){this.makeEmpty();for(let e=0,i=t.count;e<i;e++)this.expandByPoint(ox.fromBufferAttribute(t,e));return this}setFromPoints(t){this.makeEmpty();for(let e=0,i=t.length;e<i;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const i=ox.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(i),this.max.copy(t).add(i),this}setFromObject(t,e=!1){return this.makeEmpty(),this.expandByObject(t,e)}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,e=!1){t.updateWorldMatrix(!1,!1);const i=t.geometry;if(void 0!==i){const n=i.getAttribute("position");if(!0===e&&void 0!==n&&!0!==t.isInstancedMesh)for(let e=0,i=n.count;e<i;e++)!0===t.isMesh?t.getVertexPosition(e,ox):ox.fromBufferAttribute(n,e),ox.applyMatrix4(t.matrixWorld),this.expandByPoint(ox);else void 0!==t.boundingBox?(null===t.boundingBox&&t.computeBoundingBox(),lx.copy(t.boundingBox)):(null===i.boundingBox&&i.computeBoundingBox(),lx.copy(i.boundingBox)),lx.applyMatrix4(t.matrixWorld),this.union(lx)}const n=t.children;for(let s=0,r=n.length;s<r;s++)this.expandByObject(n[s],e);return this}containsPoint(t){return t.x>=this.min.x&&t.x<=this.max.x&&t.y>=this.min.y&&t.y<=this.max.y&&t.z>=this.min.z&&t.z<=this.max.z}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return t.max.x>=this.min.x&&t.min.x<=this.max.x&&t.max.y>=this.min.y&&t.min.y<=this.max.y&&t.max.z>=this.min.z&&t.min.z<=this.max.z}intersectsSphere(t){return this.clampPoint(t.center,ox),ox.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,i;return t.normal.x>0?(e=t.normal.x*this.min.x,i=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,i=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,i+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,i+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,i+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,i+=t.normal.z*this.min.z),e<=-t.constant&&i>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(fx),gx.subVectors(this.max,fx),hx.subVectors(t.a,fx),cx.subVectors(t.b,fx),ux.subVectors(t.c,fx),dx.subVectors(cx,hx),px.subVectors(ux,cx),mx.subVectors(hx,ux);let e=[0,-dx.z,dx.y,0,-px.z,px.y,0,-mx.z,mx.y,dx.z,0,-dx.x,px.z,0,-px.x,mx.z,0,-mx.x,-dx.y,dx.x,0,-px.y,px.x,0,-mx.y,mx.x,0];return!!_x(e,hx,cx,ux,gx)&&(e=[1,0,0,0,1,0,0,0,1],!!_x(e,hx,cx,ux,gx)&&(xx.crossVectors(dx,px),e=[xx.x,xx.y,xx.z],_x(e,hx,cx,ux,gx)))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return this.clampPoint(t,ox).distanceTo(t)}getBoundingSphere(t){return this.isEmpty()?t.makeEmpty():(this.getCenter(t.center),t.radius=.5*this.getSize(ox).length()),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()||(ax[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),ax[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),ax[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),ax[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),ax[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),ax[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),ax[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),ax[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(ax)),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}const ax=[new ix,new ix,new ix,new ix,new ix,new ix,new ix,new ix],ox=new ix,lx=new rx,hx=new ix,cx=new ix,ux=new ix,dx=new ix,px=new ix,mx=new ix,fx=new ix,gx=new ix,xx=new ix,vx=new ix;function _x(t,e,i,n,s){for(let r=0,a=t.length-3;r<=a;r+=3){vx.fromArray(t,r);const a=s.x*Math.abs(vx.x)+s.y*Math.abs(vx.y)+s.z*Math.abs(vx.z),o=e.dot(vx),l=i.dot(vx),h=n.dot(vx);if(Math.max(-Math.max(o,l,h),Math.min(o,l,h))>a)return!1}return!0}const yx=new rx,bx=new ix,Sx=new ix;class Mx{constructor(t=new ix,e=-1){this.isSphere=!0,this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const i=this.center;void 0!==e?i.copy(e):yx.setFromPoints(t).getCenter(i);let n=0;for(let s=0,r=t.length;s<r;s++)n=Math.max(n,i.distanceToSquared(t[s]));return this.radius=Math.sqrt(n),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const i=this.center.distanceToSquared(t);return e.copy(t),i>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){if(this.isEmpty())return this.center.copy(t),this.radius=0,this;bx.subVectors(t,this.center);const e=bx.lengthSq();if(e>this.radius*this.radius){const t=Math.sqrt(e),i=.5*(t-this.radius);this.center.addScaledVector(bx,i/t),this.radius+=i}return this}union(t){return t.isEmpty()?this:this.isEmpty()?(this.copy(t),this):(!0===this.center.equals(t.center)?this.radius=Math.max(this.radius,t.radius):(Sx.subVectors(t.center,this.center).setLength(t.radius),this.expandByPoint(bx.copy(t.center).add(Sx)),this.expandByPoint(bx.copy(t.center).sub(Sx))),this)}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return(new this.constructor).copy(this)}}const Tx=new ix,wx=new ix,Ax=new ix,Ex=new ix,Cx=new ix,Rx=new ix,Nx=new ix;class Px{constructor(t=new ix,e=new ix(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.origin).addScaledVector(this.direction,t)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,Tx)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const i=e.dot(this.direction);return i<0?e.copy(this.origin):e.copy(this.origin).addScaledVector(this.direction,i)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=Tx.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(Tx.copy(this.origin).addScaledVector(this.direction,e),Tx.distanceToSquared(t))}distanceSqToSegment(t,e,i,n){wx.copy(t).add(e).multiplyScalar(.5),Ax.copy(e).sub(t).normalize(),Ex.copy(this.origin).sub(wx);const s=.5*t.distanceTo(e),r=-this.direction.dot(Ax),a=Ex.dot(this.direction),o=-Ex.dot(Ax),l=Ex.lengthSq(),h=Math.abs(1-r*r);let c,u,d,p;if(h>0)if(c=r*o-a,u=r*a-o,p=s*h,c>=0)if(u>=-p)if(u<=p){const t=1/h;c*=t,u*=t,d=c*(c+r*u+2*a)+u*(r*c+u+2*o)+l}else u=s,c=Math.max(0,-(r*u+a)),d=-c*c+u*(u+2*o)+l;else u=-s,c=Math.max(0,-(r*u+a)),d=-c*c+u*(u+2*o)+l;else u<=-p?(c=Math.max(0,-(-r*s+a)),u=c>0?-s:Math.min(Math.max(-s,-o),s),d=-c*c+u*(u+2*o)+l):u<=p?(c=0,u=Math.min(Math.max(-s,-o),s),d=u*(u+2*o)+l):(c=Math.max(0,-(r*s+a)),u=c>0?s:Math.min(Math.max(-s,-o),s),d=-c*c+u*(u+2*o)+l);else u=r>0?-s:s,c=Math.max(0,-(r*u+a)),d=-c*c+u*(u+2*o)+l;return i&&i.copy(this.origin).addScaledVector(this.direction,c),n&&n.copy(wx).addScaledVector(Ax,u),d}intersectSphere(t,e){Tx.subVectors(t.center,this.origin);const i=Tx.dot(this.direction),n=Tx.dot(Tx)-i*i,s=t.radius*t.radius;if(n>s)return null;const r=Math.sqrt(s-n),a=i-r,o=i+r;return o<0?null:a<0?this.at(o,e):this.at(a,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(0===e)return 0===t.distanceToPoint(this.origin)?0:null;const i=-(this.origin.dot(t.normal)+t.constant)/e;return i>=0?i:null}intersectPlane(t,e){const i=this.distanceToPlane(t);return null===i?null:this.at(i,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);if(0===e)return!0;return t.normal.dot(this.direction)*e<0}intersectBox(t,e){let i,n,s,r,a,o;const l=1/this.direction.x,h=1/this.direction.y,c=1/this.direction.z,u=this.origin;return l>=0?(i=(t.min.x-u.x)*l,n=(t.max.x-u.x)*l):(i=(t.max.x-u.x)*l,n=(t.min.x-u.x)*l),h>=0?(s=(t.min.y-u.y)*h,r=(t.max.y-u.y)*h):(s=(t.max.y-u.y)*h,r=(t.min.y-u.y)*h),i>r||s>n?null:((s>i||isNaN(i))&&(i=s),(r<n||isNaN(n))&&(n=r),c>=0?(a=(t.min.z-u.z)*c,o=(t.max.z-u.z)*c):(a=(t.max.z-u.z)*c,o=(t.min.z-u.z)*c),i>o||a>n?null:((a>i||i!=i)&&(i=a),(o<n||n!=n)&&(n=o),n<0?null:this.at(i>=0?i:n,e)))}intersectsBox(t){return null!==this.intersectBox(t,Tx)}intersectTriangle(t,e,i,n,s){Cx.subVectors(e,t),Rx.subVectors(i,t),Nx.crossVectors(Cx,Rx);let r,a=this.direction.dot(Nx);if(a>0){if(n)return null;r=1}else{if(!(a<0))return null;r=-1,a=-a}Ex.subVectors(this.origin,t);const o=r*this.direction.dot(Rx.crossVectors(Ex,Rx));if(o<0)return null;const l=r*this.direction.dot(Cx.cross(Ex));if(l<0)return null;if(o+l>a)return null;const h=-r*Ex.dot(Nx);return h<0?null:this.at(h/a,s)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}}class Ix{constructor(t,e,i,n,s,r,a,o,l,h,c,u,d,p,m,f){Ix.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],void 0!==t&&this.set(t,e,i,n,s,r,a,o,l,h,c,u,d,p,m,f)}set(t,e,i,n,s,r,a,o,l,h,c,u,d,p,m,f){const g=this.elements;return g[0]=t,g[4]=e,g[8]=i,g[12]=n,g[1]=s,g[5]=r,g[9]=a,g[13]=o,g[2]=l,g[6]=h,g[10]=c,g[14]=u,g[3]=d,g[7]=p,g[11]=m,g[15]=f,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new Ix).fromArray(this.elements)}copy(t){const e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],e[9]=i[9],e[10]=i[10],e[11]=i[11],e[12]=i[12],e[13]=i[13],e[14]=i[14],e[15]=i[15],this}copyPosition(t){const e=this.elements,i=t.elements;return e[12]=i[12],e[13]=i[13],e[14]=i[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,i){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(t,e,i){return this.set(t.x,e.x,i.x,0,t.y,e.y,i.y,0,t.z,e.z,i.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,i=t.elements,n=1/Lx.setFromMatrixColumn(t,0).length(),s=1/Lx.setFromMatrixColumn(t,1).length(),r=1/Lx.setFromMatrixColumn(t,2).length();return e[0]=i[0]*n,e[1]=i[1]*n,e[2]=i[2]*n,e[3]=0,e[4]=i[4]*s,e[5]=i[5]*s,e[6]=i[6]*s,e[7]=0,e[8]=i[8]*r,e[9]=i[9]*r,e[10]=i[10]*r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){const e=this.elements,i=t.x,n=t.y,s=t.z,r=Math.cos(i),a=Math.sin(i),o=Math.cos(n),l=Math.sin(n),h=Math.cos(s),c=Math.sin(s);if("XYZ"===t.order){const t=r*h,i=r*c,n=a*h,s=a*c;e[0]=o*h,e[4]=-o*c,e[8]=l,e[1]=i+n*l,e[5]=t-s*l,e[9]=-a*o,e[2]=s-t*l,e[6]=n+i*l,e[10]=r*o}else if("YXZ"===t.order){const t=o*h,i=o*c,n=l*h,s=l*c;e[0]=t+s*a,e[4]=n*a-i,e[8]=r*l,e[1]=r*c,e[5]=r*h,e[9]=-a,e[2]=i*a-n,e[6]=s+t*a,e[10]=r*o}else if("ZXY"===t.order){const t=o*h,i=o*c,n=l*h,s=l*c;e[0]=t-s*a,e[4]=-r*c,e[8]=n+i*a,e[1]=i+n*a,e[5]=r*h,e[9]=s-t*a,e[2]=-r*l,e[6]=a,e[10]=r*o}else if("ZYX"===t.order){const t=r*h,i=r*c,n=a*h,s=a*c;e[0]=o*h,e[4]=n*l-i,e[8]=t*l+s,e[1]=o*c,e[5]=s*l+t,e[9]=i*l-n,e[2]=-l,e[6]=a*o,e[10]=r*o}else if("YZX"===t.order){const t=r*o,i=r*l,n=a*o,s=a*l;e[0]=o*h,e[4]=s-t*c,e[8]=n*c+i,e[1]=c,e[5]=r*h,e[9]=-a*h,e[2]=-l*h,e[6]=i*c+n,e[10]=t-s*c}else if("XZY"===t.order){const t=r*o,i=r*l,n=a*o,s=a*l;e[0]=o*h,e[4]=-c,e[8]=l*h,e[1]=t*c+s,e[5]=r*h,e[9]=i*c-n,e[2]=n*c-i,e[6]=a*h,e[10]=s*c+t}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(Ux,t,Fx)}lookAt(t,e,i){const n=this.elements;return zx.subVectors(t,e),0===zx.lengthSq()&&(zx.z=1),zx.normalize(),Bx.crossVectors(i,zx),0===Bx.lengthSq()&&(1===Math.abs(i.z)?zx.x+=1e-4:zx.z+=1e-4,zx.normalize(),Bx.crossVectors(i,zx)),Bx.normalize(),Ox.crossVectors(zx,Bx),n[0]=Bx.x,n[4]=Ox.x,n[8]=zx.x,n[1]=Bx.y,n[5]=Ox.y,n[9]=zx.y,n[2]=Bx.z,n[6]=Ox.z,n[10]=zx.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const i=t.elements,n=e.elements,s=this.elements,r=i[0],a=i[4],o=i[8],l=i[12],h=i[1],c=i[5],u=i[9],d=i[13],p=i[2],m=i[6],f=i[10],g=i[14],x=i[3],v=i[7],_=i[11],y=i[15],b=n[0],S=n[4],M=n[8],T=n[12],w=n[1],A=n[5],E=n[9],C=n[13],R=n[2],N=n[6],P=n[10],I=n[14],L=n[3],D=n[7],U=n[11],F=n[15];return s[0]=r*b+a*w+o*R+l*L,s[4]=r*S+a*A+o*N+l*D,s[8]=r*M+a*E+o*P+l*U,s[12]=r*T+a*C+o*I+l*F,s[1]=h*b+c*w+u*R+d*L,s[5]=h*S+c*A+u*N+d*D,s[9]=h*M+c*E+u*P+d*U,s[13]=h*T+c*C+u*I+d*F,s[2]=p*b+m*w+f*R+g*L,s[6]=p*S+m*A+f*N+g*D,s[10]=p*M+m*E+f*P+g*U,s[14]=p*T+m*C+f*I+g*F,s[3]=x*b+v*w+_*R+y*L,s[7]=x*S+v*A+_*N+y*D,s[11]=x*M+v*E+_*P+y*U,s[15]=x*T+v*C+_*I+y*F,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],i=t[4],n=t[8],s=t[12],r=t[1],a=t[5],o=t[9],l=t[13],h=t[2],c=t[6],u=t[10],d=t[14];return t[3]*(+s*o*c-n*l*c-s*a*u+i*l*u+n*a*d-i*o*d)+t[7]*(+e*o*d-e*l*u+s*r*u-n*r*d+n*l*h-s*o*h)+t[11]*(+e*l*c-e*a*d-s*r*c+i*r*d+s*a*h-i*l*h)+t[15]*(-n*a*h-e*o*c+e*a*u+n*r*c-i*r*u+i*o*h)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,i){const n=this.elements;return t.isVector3?(n[12]=t.x,n[13]=t.y,n[14]=t.z):(n[12]=t,n[13]=e,n[14]=i),this}invert(){const t=this.elements,e=t[0],i=t[1],n=t[2],s=t[3],r=t[4],a=t[5],o=t[6],l=t[7],h=t[8],c=t[9],u=t[10],d=t[11],p=t[12],m=t[13],f=t[14],g=t[15],x=c*f*l-m*u*l+m*o*d-a*f*d-c*o*g+a*u*g,v=p*u*l-h*f*l-p*o*d+r*f*d+h*o*g-r*u*g,_=h*m*l-p*c*l+p*a*d-r*m*d-h*a*g+r*c*g,y=p*c*o-h*m*o-p*a*u+r*m*u+h*a*f-r*c*f,b=e*x+i*v+n*_+s*y;if(0===b)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const S=1/b;return t[0]=x*S,t[1]=(m*u*s-c*f*s-m*n*d+i*f*d+c*n*g-i*u*g)*S,t[2]=(a*f*s-m*o*s+m*n*l-i*f*l-a*n*g+i*o*g)*S,t[3]=(c*o*s-a*u*s-c*n*l+i*u*l+a*n*d-i*o*d)*S,t[4]=v*S,t[5]=(h*f*s-p*u*s+p*n*d-e*f*d-h*n*g+e*u*g)*S,t[6]=(p*o*s-r*f*s-p*n*l+e*f*l+r*n*g-e*o*g)*S,t[7]=(r*u*s-h*o*s+h*n*l-e*u*l-r*n*d+e*o*d)*S,t[8]=_*S,t[9]=(p*c*s-h*m*s-p*i*d+e*m*d+h*i*g-e*c*g)*S,t[10]=(r*m*s-p*a*s+p*i*l-e*m*l-r*i*g+e*a*g)*S,t[11]=(h*a*s-r*c*s-h*i*l+e*c*l+r*i*d-e*a*d)*S,t[12]=y*S,t[13]=(h*m*n-p*c*n+p*i*u-e*m*u-h*i*f+e*c*f)*S,t[14]=(p*a*n-r*m*n-p*i*o+e*m*o+r*i*f-e*a*f)*S,t[15]=(r*c*n-h*a*n+h*i*o-e*c*o-r*i*u+e*a*u)*S,this}scale(t){const e=this.elements,i=t.x,n=t.y,s=t.z;return e[0]*=i,e[4]*=n,e[8]*=s,e[1]*=i,e[5]*=n,e[9]*=s,e[2]*=i,e[6]*=n,e[10]*=s,e[3]*=i,e[7]*=n,e[11]*=s,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],i=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],n=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,i,n))}makeTranslation(t,e,i){return t.isVector3?this.set(1,0,0,t.x,0,1,0,t.y,0,0,1,t.z,0,0,0,1):this.set(1,0,0,t,0,1,0,e,0,0,1,i,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),i=Math.sin(t);return this.set(1,0,0,0,0,e,-i,0,0,i,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,0,i,0,0,1,0,0,-i,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,-i,0,0,i,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const i=Math.cos(e),n=Math.sin(e),s=1-i,r=t.x,a=t.y,o=t.z,l=s*r,h=s*a;return this.set(l*r+i,l*a-n*o,l*o+n*a,0,l*a+n*o,h*a+i,h*o-n*r,0,l*o-n*a,h*o+n*r,s*o*o+i,0,0,0,0,1),this}makeScale(t,e,i){return this.set(t,0,0,0,0,e,0,0,0,0,i,0,0,0,0,1),this}makeShear(t,e,i,n,s,r){return this.set(1,i,s,0,t,1,r,0,e,n,1,0,0,0,0,1),this}compose(t,e,i){const n=this.elements,s=e._x,r=e._y,a=e._z,o=e._w,l=s+s,h=r+r,c=a+a,u=s*l,d=s*h,p=s*c,m=r*h,f=r*c,g=a*c,x=o*l,v=o*h,_=o*c,y=i.x,b=i.y,S=i.z;return n[0]=(1-(m+g))*y,n[1]=(d+_)*y,n[2]=(p-v)*y,n[3]=0,n[4]=(d-_)*b,n[5]=(1-(u+g))*b,n[6]=(f+x)*b,n[7]=0,n[8]=(p+v)*S,n[9]=(f-x)*S,n[10]=(1-(u+m))*S,n[11]=0,n[12]=t.x,n[13]=t.y,n[14]=t.z,n[15]=1,this}decompose(t,e,i){const n=this.elements;let s=Lx.set(n[0],n[1],n[2]).length();const r=Lx.set(n[4],n[5],n[6]).length(),a=Lx.set(n[8],n[9],n[10]).length();this.determinant()<0&&(s=-s),t.x=n[12],t.y=n[13],t.z=n[14],Dx.copy(this);const o=1/s,l=1/r,h=1/a;return Dx.elements[0]*=o,Dx.elements[1]*=o,Dx.elements[2]*=o,Dx.elements[4]*=l,Dx.elements[5]*=l,Dx.elements[6]*=l,Dx.elements[8]*=h,Dx.elements[9]*=h,Dx.elements[10]*=h,e.setFromRotationMatrix(Dx),i.x=s,i.y=r,i.z=a,this}makePerspective(t,e,i,n,s,r,a=2e3){const o=this.elements,l=2*s/(e-t),h=2*s/(i-n),c=(e+t)/(e-t),u=(i+n)/(i-n);let d,p;if(a===xg)d=-(r+s)/(r-s),p=-2*r*s/(r-s);else{if(a!==vg)throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+a);d=-r/(r-s),p=-r*s/(r-s)}return o[0]=l,o[4]=0,o[8]=c,o[12]=0,o[1]=0,o[5]=h,o[9]=u,o[13]=0,o[2]=0,o[6]=0,o[10]=d,o[14]=p,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this}makeOrthographic(t,e,i,n,s,r,a=2e3){const o=this.elements,l=1/(e-t),h=1/(i-n),c=1/(r-s),u=(e+t)*l,d=(i+n)*h;let p,m;if(a===xg)p=(r+s)*c,m=-2*c;else{if(a!==vg)throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+a);p=s*c,m=-1*c}return o[0]=2*l,o[4]=0,o[8]=0,o[12]=-u,o[1]=0,o[5]=2*h,o[9]=0,o[13]=-d,o[2]=0,o[6]=0,o[10]=m,o[14]=-p,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}equals(t){const e=this.elements,i=t.elements;for(let n=0;n<16;n++)if(e[n]!==i[n])return!1;return!0}fromArray(t,e=0){for(let i=0;i<16;i++)this.elements[i]=t[i+e];return this}toArray(t=[],e=0){const i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t[e+9]=i[9],t[e+10]=i[10],t[e+11]=i[11],t[e+12]=i[12],t[e+13]=i[13],t[e+14]=i[14],t[e+15]=i[15],t}}const Lx=new ix,Dx=new Ix,Ux=new ix(0,0,0),Fx=new ix(1,1,1),Bx=new ix,Ox=new ix,zx=new ix,kx=new Ix,Vx=new ex;class Gx{constructor(t=0,e=0,i=0,n=Gx.DEFAULT_ORDER){this.isEuler=!0,this._x=t,this._y=e,this._z=i,this._order=n}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,i,n=this._order){return this._x=t,this._y=e,this._z=i,this._order=n,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,i=!0){const n=t.elements,s=n[0],r=n[4],a=n[8],o=n[1],l=n[5],h=n[9],c=n[2],u=n[6],d=n[10];switch(e){case"XYZ":this._y=Math.asin(wg(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-h,d),this._z=Math.atan2(-r,s)):(this._x=Math.atan2(u,l),this._z=0);break;case"YXZ":this._x=Math.asin(-wg(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(a,d),this._z=Math.atan2(o,l)):(this._y=Math.atan2(-c,s),this._z=0);break;case"ZXY":this._x=Math.asin(wg(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(-c,d),this._z=Math.atan2(-r,l)):(this._y=0,this._z=Math.atan2(o,s));break;case"ZYX":this._y=Math.asin(-wg(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(u,d),this._z=Math.atan2(o,s)):(this._x=0,this._z=Math.atan2(-r,l));break;case"YZX":this._z=Math.asin(wg(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-h,l),this._y=Math.atan2(-c,s)):(this._x=0,this._y=Math.atan2(a,d));break;case"XZY":this._z=Math.asin(-wg(r,-1,1)),Math.abs(r)<.9999999?(this._x=Math.atan2(u,l),this._y=Math.atan2(a,s)):(this._x=Math.atan2(-h,d),this._y=0)}return this._order=e,!0===i&&this._onChangeCallback(),this}setFromQuaternion(t,e,i){return kx.makeRotationFromQuaternion(t),this.setFromRotationMatrix(kx,e,i)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return Vx.setFromEuler(this),this.setFromQuaternion(Vx,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],void 0!==t[3]&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Gx.DEFAULT_ORDER="XYZ";class Hx{constructor(){this.mask=1}set(t){this.mask=1<<t>>>0}enable(t){this.mask|=1<<t}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t}disable(t){this.mask&=~(1<<t)}disableAll(){this.mask=0}test(t){return!!(this.mask&t.mask)}isEnabled(t){return!!(this.mask&1<<t)}}let Wx=0;const jx=new ix,Xx=new ex,qx=new Ix,$x=new ix,Yx=new ix,Zx=new ix,Kx=new ex,Jx=new ix(1,0,0),Qx=new ix(0,1,0),tv=new ix(0,0,1),ev={type:"added"},iv={type:"removed"},nv={type:"childadded",child:null},sv={type:"childremoved",child:null};class rv extends _g{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:Wx++}),this.uuid=Tg(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=rv.DEFAULT_UP.clone();const t=new ix,e=new Gx,i=new ex,n=new ix(1,1,1);e._onChange((function(){i.setFromEuler(e,!1)})),i._onChange((function(){e.setFromQuaternion(i,void 0,!1)})),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:i},scale:{configurable:!0,enumerable:!0,value:n},modelViewMatrix:{value:new Ix},normalMatrix:{value:new Ig}}),this.matrix=new Ix,this.matrixWorld=new Ix,this.matrixAutoUpdate=rv.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=rv.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new Hx,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return Xx.setFromAxisAngle(t,e),this.quaternion.multiply(Xx),this}rotateOnWorldAxis(t,e){return Xx.setFromAxisAngle(t,e),this.quaternion.premultiply(Xx),this}rotateX(t){return this.rotateOnAxis(Jx,t)}rotateY(t){return this.rotateOnAxis(Qx,t)}rotateZ(t){return this.rotateOnAxis(tv,t)}translateOnAxis(t,e){return jx.copy(t).applyQuaternion(this.quaternion),this.position.add(jx.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(Jx,t)}translateY(t){return this.translateOnAxis(Qx,t)}translateZ(t){return this.translateOnAxis(tv,t)}localToWorld(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(qx.copy(this.matrixWorld).invert())}lookAt(t,e,i){t.isVector3?$x.copy(t):$x.set(t,e,i);const n=this.parent;this.updateWorldMatrix(!0,!1),Yx.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?qx.lookAt(Yx,$x,this.up):qx.lookAt($x,Yx,this.up),this.quaternion.setFromRotationMatrix(qx),n&&(qx.extractRotation(n.matrixWorld),Xx.setFromRotationMatrix(qx),this.quaternion.premultiply(Xx.invert()))}add(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return t===this||t&&t.isObject3D&&(t.removeFromParent(),t.parent=this,this.children.push(t),t.dispatchEvent(ev),nv.child=t,this.dispatchEvent(nv),nv.child=null),this}remove(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}const e=this.children.indexOf(t);return-1!==e&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(iv),sv.child=t,this.dispatchEvent(sv),sv.child=null),this}removeFromParent(){const t=this.parent;return null!==t&&t.remove(this),this}clear(){return this.remove(...this.children)}attach(t){return this.updateWorldMatrix(!0,!1),qx.copy(this.matrixWorld).invert(),null!==t.parent&&(t.parent.updateWorldMatrix(!0,!1),qx.multiply(t.parent.matrixWorld)),t.applyMatrix4(qx),t.removeFromParent(),t.parent=this,this.children.push(t),t.updateWorldMatrix(!1,!0),t.dispatchEvent(ev),nv.child=t,this.dispatchEvent(nv),nv.child=null,this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let i=0,n=this.children.length;i<n;i++){const n=this.children[i].getObjectByProperty(t,e);if(void 0!==n)return n}}getObjectsByProperty(t,e,i=[]){this[t]===e&&i.push(this);const n=this.children;for(let s=0,r=n.length;s<r;s++)n[s].getObjectsByProperty(t,e,i);return i}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Yx,t,Zx),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Yx,Kx,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let i=0,n=e.length;i<n;i++)e[i].traverse(t)}traverseVisible(t){if(!1===this.visible)return;t(this);const e=this.children;for(let i=0,n=e.length;i<n;i++)e[i].traverseVisible(t)}traverseAncestors(t){const e=this.parent;null!==e&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(!0===this.matrixWorldAutoUpdate&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let i=0,n=e.length;i<n;i++){e[i].updateMatrixWorld(t)}}updateWorldMatrix(t,e){const i=this.parent;if(!0===t&&null!==i&&i.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),!0===this.matrixWorldAutoUpdate&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),!0===e){const t=this.children;for(let e=0,i=t.length;e<i;e++){t[e].updateWorldMatrix(!1,!0)}}}toJSON(t){const e=void 0===t||"string"==typeof t,i={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},i.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const n={};function s(e,i){return void 0===e[i.uuid]&&(e[i.uuid]=i.toJSON(t)),i.uuid}if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),!0===this.castShadow&&(n.castShadow=!0),!0===this.receiveShadow&&(n.receiveShadow=!0),!1===this.visible&&(n.visible=!1),!1===this.frustumCulled&&(n.frustumCulled=!1),0!==this.renderOrder&&(n.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(n.userData=this.userData),n.layers=this.layers.mask,n.matrix=this.matrix.toArray(),n.up=this.up.toArray(),!1===this.matrixAutoUpdate&&(n.matrixAutoUpdate=!1),this.isInstancedMesh&&(n.type="InstancedMesh",n.count=this.count,n.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(n.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(n.type="BatchedMesh",n.perObjectFrustumCulled=this.perObjectFrustumCulled,n.sortObjects=this.sortObjects,n.drawRanges=this._drawRanges,n.reservedRanges=this._reservedRanges,n.visibility=this._visibility,n.active=this._active,n.bounds=this._bounds.map((t=>({boxInitialized:t.boxInitialized,boxMin:t.box.min.toArray(),boxMax:t.box.max.toArray(),sphereInitialized:t.sphereInitialized,sphereRadius:t.sphere.radius,sphereCenter:t.sphere.center.toArray()}))),n.maxInstanceCount=this._maxInstanceCount,n.maxVertexCount=this._maxVertexCount,n.maxIndexCount=this._maxIndexCount,n.geometryInitialized=this._geometryInitialized,n.geometryCount=this._geometryCount,n.matricesTexture=this._matricesTexture.toJSON(t),null!==this._colorsTexture&&(n.colorsTexture=this._colorsTexture.toJSON(t)),null!==this.boundingSphere&&(n.boundingSphere={center:n.boundingSphere.center.toArray(),radius:n.boundingSphere.radius}),null!==this.boundingBox&&(n.boundingBox={min:n.boundingBox.min.toArray(),max:n.boundingBox.max.toArray()})),this.isScene)this.background&&(this.background.isColor?n.background=this.background.toJSON():this.background.isTexture&&(n.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&!0!==this.environment.isRenderTargetTexture&&(n.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){n.geometry=s(t.geometries,this.geometry);const e=this.geometry.parameters;if(void 0!==e&&void 0!==e.shapes){const i=e.shapes;if(Array.isArray(i))for(let e=0,n=i.length;e<n;e++){const n=i[e];s(t.shapes,n)}else s(t.shapes,i)}}if(this.isSkinnedMesh&&(n.bindMode=this.bindMode,n.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(s(t.skeletons,this.skeleton),n.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const e=[];for(let i=0,n=this.material.length;i<n;i++)e.push(s(t.materials,this.material[i]));n.material=e}else n.material=s(t.materials,this.material);if(this.children.length>0){n.children=[];for(let e=0;e<this.children.length;e++)n.children.push(this.children[e].toJSON(t).object)}if(this.animations.length>0){n.animations=[];for(let e=0;e<this.animations.length;e++){const i=this.animations[e];n.animations.push(s(t.animations,i))}}if(e){const e=r(t.geometries),n=r(t.materials),s=r(t.textures),a=r(t.images),o=r(t.shapes),l=r(t.skeletons),h=r(t.animations),c=r(t.nodes);e.length>0&&(i.geometries=e),n.length>0&&(i.materials=n),s.length>0&&(i.textures=s),a.length>0&&(i.images=a),o.length>0&&(i.shapes=o),l.length>0&&(i.skeletons=l),h.length>0&&(i.animations=h),c.length>0&&(i.nodes=c)}return i.object=n,i;function r(t){const e=[];for(const i in t){const n=t[i];delete n.metadata,e.push(n)}return e}}clone(t){return(new this.constructor).copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldAutoUpdate=t.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.animations=t.animations.slice(),this.userData=JSON.parse(JSON.stringify(t.userData)),!0===e)for(let i=0;i<t.children.length;i++){const e=t.children[i];this.add(e.clone())}return this}}rv.DEFAULT_UP=new ix(0,1,0),rv.DEFAULT_MATRIX_AUTO_UPDATE=!0,rv.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const av=new ix,ov=new ix,lv=new ix,hv=new ix,cv=new ix,uv=new ix,dv=new ix,pv=new ix,mv=new ix,fv=new ix,gv=new Kg,xv=new Kg,vv=new Kg;class _v{constructor(t=new ix,e=new ix,i=new ix){this.a=t,this.b=e,this.c=i}static getNormal(t,e,i,n){n.subVectors(i,e),av.subVectors(t,e),n.cross(av);const s=n.lengthSq();return s>0?n.multiplyScalar(1/Math.sqrt(s)):n.set(0,0,0)}static getBarycoord(t,e,i,n,s){av.subVectors(n,e),ov.subVectors(i,e),lv.subVectors(t,e);const r=av.dot(av),a=av.dot(ov),o=av.dot(lv),l=ov.dot(ov),h=ov.dot(lv),c=r*l-a*a;if(0===c)return s.set(0,0,0),null;const u=1/c,d=(l*o-a*h)*u,p=(r*h-a*o)*u;return s.set(1-d-p,p,d)}static containsPoint(t,e,i,n){return null!==this.getBarycoord(t,e,i,n,hv)&&(hv.x>=0&&hv.y>=0&&hv.x+hv.y<=1)}static getInterpolation(t,e,i,n,s,r,a,o){return null===this.getBarycoord(t,e,i,n,hv)?(o.x=0,o.y=0,"z"in o&&(o.z=0),"w"in o&&(o.w=0),null):(o.setScalar(0),o.addScaledVector(s,hv.x),o.addScaledVector(r,hv.y),o.addScaledVector(a,hv.z),o)}static getInterpolatedAttribute(t,e,i,n,s,r){return gv.setScalar(0),xv.setScalar(0),vv.setScalar(0),gv.fromBufferAttribute(t,e),xv.fromBufferAttribute(t,i),vv.fromBufferAttribute(t,n),r.setScalar(0),r.addScaledVector(gv,s.x),r.addScaledVector(xv,s.y),r.addScaledVector(vv,s.z),r}static isFrontFacing(t,e,i,n){return av.subVectors(i,e),ov.subVectors(t,e),av.cross(ov).dot(n)<0}set(t,e,i){return this.a.copy(t),this.b.copy(e),this.c.copy(i),this}setFromPointsAndIndices(t,e,i,n){return this.a.copy(t[e]),this.b.copy(t[i]),this.c.copy(t[n]),this}setFromAttributeAndIndices(t,e,i,n){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,i),this.c.fromBufferAttribute(t,n),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return av.subVectors(this.c,this.b),ov.subVectors(this.a,this.b),.5*av.cross(ov).length()}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return _v.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return _v.getBarycoord(t,this.a,this.b,this.c,e)}getInterpolation(t,e,i,n,s){return _v.getInterpolation(t,this.a,this.b,this.c,e,i,n,s)}containsPoint(t){return _v.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return _v.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const i=this.a,n=this.b,s=this.c;let r,a;cv.subVectors(n,i),uv.subVectors(s,i),pv.subVectors(t,i);const o=cv.dot(pv),l=uv.dot(pv);if(o<=0&&l<=0)return e.copy(i);mv.subVectors(t,n);const h=cv.dot(mv),c=uv.dot(mv);if(h>=0&&c<=h)return e.copy(n);const u=o*c-h*l;if(u<=0&&o>=0&&h<=0)return r=o/(o-h),e.copy(i).addScaledVector(cv,r);fv.subVectors(t,s);const d=cv.dot(fv),p=uv.dot(fv);if(p>=0&&d<=p)return e.copy(s);const m=d*l-o*p;if(m<=0&&l>=0&&p<=0)return a=l/(l-p),e.copy(i).addScaledVector(uv,a);const f=h*p-d*c;if(f<=0&&c-h>=0&&d-p>=0)return dv.subVectors(s,n),a=(c-h)/(c-h+(d-p)),e.copy(n).addScaledVector(dv,a);const g=1/(f+m+u);return r=m*g,a=u*g,e.copy(i).addScaledVector(cv,r).addScaledVector(uv,a)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}const yv={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},bv={h:0,s:0,l:0},Sv={h:0,s:0,l:0};function Mv(t,e,i){return i<0&&(i+=1),i>1&&(i-=1),i<1/6?t+6*(e-t)*i:i<.5?e:i<2/3?t+6*(e-t)*(2/3-i):t}class Tv{constructor(t,e,i){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(t,e,i)}set(t,e,i){if(void 0===e&&void 0===i){const e=t;e&&e.isColor?this.copy(e):"number"==typeof e?this.setHex(e):"string"==typeof e&&this.setStyle(e)}else this.setRGB(t,e,i);return this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t,e=ig){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(255&t)/255,Fg.toWorkingColorSpace(this,e),this}setRGB(t,e,i,n=Fg.workingColorSpace){return this.r=t,this.g=e,this.b=i,Fg.toWorkingColorSpace(this,n),this}setHSL(t,e,i,n=Fg.workingColorSpace){if(t=Ag(t,1),e=wg(e,0,1),i=wg(i,0,1),0===e)this.r=this.g=this.b=i;else{const n=i<=.5?i*(1+e):i+e-i*e,s=2*i-n;this.r=Mv(s,n,t+1/3),this.g=Mv(s,n,t),this.b=Mv(s,n,t-1/3)}return Fg.toWorkingColorSpace(this,n),this}setStyle(t,e=ig){function i(t){void 0!==t&&parseFloat(t)}let n;if(n=/^(\w+)\(([^\)]*)\)/.exec(t)){let t;const s=n[1],r=n[2];switch(s){case"rgb":case"rgba":if(t=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))return i(t[4]),this.setRGB(Math.min(255,parseInt(t[1],10))/255,Math.min(255,parseInt(t[2],10))/255,Math.min(255,parseInt(t[3],10))/255,e);if(t=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))return i(t[4]),this.setRGB(Math.min(100,parseInt(t[1],10))/100,Math.min(100,parseInt(t[2],10))/100,Math.min(100,parseInt(t[3],10))/100,e);break;case"hsl":case"hsla":if(t=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))return i(t[4]),this.setHSL(parseFloat(t[1])/360,parseFloat(t[2])/100,parseFloat(t[3])/100,e)}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(t)){const t=n[1],i=t.length;if(3===i)return this.setRGB(parseInt(t.charAt(0),16)/15,parseInt(t.charAt(1),16)/15,parseInt(t.charAt(2),16)/15,e);if(6===i)return this.setHex(parseInt(t,16),e)}else if(t&&t.length>0)return this.setColorName(t,e);return this}setColorName(t,e=ig){const i=yv[t.toLowerCase()];return void 0!==i&&this.setHex(i,e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=Bg(t.r),this.g=Bg(t.g),this.b=Bg(t.b),this}copyLinearToSRGB(t){return this.r=Og(t.r),this.g=Og(t.g),this.b=Og(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(t=ig){return Fg.fromWorkingColorSpace(wv.copy(this),t),65536*Math.round(wg(255*wv.r,0,255))+256*Math.round(wg(255*wv.g,0,255))+Math.round(wg(255*wv.b,0,255))}getHexString(t=ig){return("000000"+this.getHex(t).toString(16)).slice(-6)}getHSL(t,e=Fg.workingColorSpace){Fg.fromWorkingColorSpace(wv.copy(this),e);const i=wv.r,n=wv.g,s=wv.b,r=Math.max(i,n,s),a=Math.min(i,n,s);let o,l;const h=(a+r)/2;if(a===r)o=0,l=0;else{const t=r-a;switch(l=h<=.5?t/(r+a):t/(2-r-a),r){case i:o=(n-s)/t+(n<s?6:0);break;case n:o=(s-i)/t+2;break;case s:o=(i-n)/t+4}o/=6}return t.h=o,t.s=l,t.l=h,t}getRGB(t,e=Fg.workingColorSpace){return Fg.fromWorkingColorSpace(wv.copy(this),e),t.r=wv.r,t.g=wv.g,t.b=wv.b,t}getStyle(t=ig){Fg.fromWorkingColorSpace(wv.copy(this),t);const e=wv.r,i=wv.g,n=wv.b;return t!==ig?`color(${t} ${e.toFixed(3)} ${i.toFixed(3)} ${n.toFixed(3)})`:`rgb(${Math.round(255*e)},${Math.round(255*i)},${Math.round(255*n)})`}offsetHSL(t,e,i){return this.getHSL(bv),this.setHSL(bv.h+t,bv.s+e,bv.l+i)}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,i){return this.r=t.r+(e.r-t.r)*i,this.g=t.g+(e.g-t.g)*i,this.b=t.b+(e.b-t.b)*i,this}lerpHSL(t,e){this.getHSL(bv),t.getHSL(Sv);const i=Eg(bv.h,Sv.h,e),n=Eg(bv.s,Sv.s,e),s=Eg(bv.l,Sv.l,e);return this.setHSL(i,n,s),this}setFromVector3(t){return this.r=t.x,this.g=t.y,this.b=t.z,this}applyMatrix3(t){const e=this.r,i=this.g,n=this.b,s=t.elements;return this.r=s[0]*e+s[3]*i+s[6]*n,this.g=s[1]*e+s[4]*i+s[7]*n,this.b=s[2]*e+s[5]*i+s[8]*n,this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const wv=new Tv;Tv.NAMES=yv;let Av=0;class Ev extends _g{static get type(){return"Material"}get type(){return this.constructor.type}set type(t){}constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:Av++}),this.uuid=Tg(),this.name="",this.blending=1,this.side=0,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=Ym,this.blendDst=Zm,this.blendEquation=Gm,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new Tv(0,0,0),this.blendAlpha=0,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=ag,this.stencilZFail=ag,this.stencilZPass=ag,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(void 0!==t)for(const e in t){const i=t[e];if(void 0===i)continue;const n=this[e];void 0!==n&&(n&&n.isColor?n.set(i):n&&n.isVector3&&i&&i.isVector3?n.copy(i):this[e]=i)}}toJSON(t){const e=void 0===t||"string"==typeof t;e&&(t={textures:{},images:{}});const i={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};function n(t){const e=[];for(const i in t){const n=t[i];delete n.metadata,e.push(n)}return e}if(i.uuid=this.uuid,i.type=this.type,""!==this.name&&(i.name=this.name),this.color&&this.color.isColor&&(i.color=this.color.getHex()),void 0!==this.roughness&&(i.roughness=this.roughness),void 0!==this.metalness&&(i.metalness=this.metalness),void 0!==this.sheen&&(i.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(i.sheenColor=this.sheenColor.getHex()),void 0!==this.sheenRoughness&&(i.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(i.emissive=this.emissive.getHex()),void 0!==this.emissiveIntensity&&1!==this.emissiveIntensity&&(i.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(i.specular=this.specular.getHex()),void 0!==this.specularIntensity&&(i.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(i.specularColor=this.specularColor.getHex()),void 0!==this.shininess&&(i.shininess=this.shininess),void 0!==this.clearcoat&&(i.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(i.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(i.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(i.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(i.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,i.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),void 0!==this.dispersion&&(i.dispersion=this.dispersion),void 0!==this.iridescence&&(i.iridescence=this.iridescence),void 0!==this.iridescenceIOR&&(i.iridescenceIOR=this.iridescenceIOR),void 0!==this.iridescenceThicknessRange&&(i.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(i.iridescenceMap=this.iridescenceMap.toJSON(t).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(i.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(t).uuid),void 0!==this.anisotropy&&(i.anisotropy=this.anisotropy),void 0!==this.anisotropyRotation&&(i.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(i.anisotropyMap=this.anisotropyMap.toJSON(t).uuid),this.map&&this.map.isTexture&&(i.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(i.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(i.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(i.lightMap=this.lightMap.toJSON(t).uuid,i.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(i.aoMap=this.aoMap.toJSON(t).uuid,i.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(i.bumpMap=this.bumpMap.toJSON(t).uuid,i.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(i.normalMap=this.normalMap.toJSON(t).uuid,i.normalMapType=this.normalMapType,i.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(i.displacementMap=this.displacementMap.toJSON(t).uuid,i.displacementScale=this.displacementScale,i.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(i.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(i.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(i.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(i.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(i.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(i.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(i.envMap=this.envMap.toJSON(t).uuid,void 0!==this.combine&&(i.combine=this.combine)),void 0!==this.envMapRotation&&(i.envMapRotation=this.envMapRotation.toArray()),void 0!==this.envMapIntensity&&(i.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&(i.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&(i.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(i.gradientMap=this.gradientMap.toJSON(t).uuid),void 0!==this.transmission&&(i.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(i.transmissionMap=this.transmissionMap.toJSON(t).uuid),void 0!==this.thickness&&(i.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(i.thicknessMap=this.thicknessMap.toJSON(t).uuid),void 0!==this.attenuationDistance&&this.attenuationDistance!==1/0&&(i.attenuationDistance=this.attenuationDistance),void 0!==this.attenuationColor&&(i.attenuationColor=this.attenuationColor.getHex()),void 0!==this.size&&(i.size=this.size),null!==this.shadowSide&&(i.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&(i.sizeAttenuation=this.sizeAttenuation),1!==this.blending&&(i.blending=this.blending),0!==this.side&&(i.side=this.side),!0===this.vertexColors&&(i.vertexColors=!0),this.opacity<1&&(i.opacity=this.opacity),!0===this.transparent&&(i.transparent=!0),this.blendSrc!==Ym&&(i.blendSrc=this.blendSrc),this.blendDst!==Zm&&(i.blendDst=this.blendDst),this.blendEquation!==Gm&&(i.blendEquation=this.blendEquation),null!==this.blendSrcAlpha&&(i.blendSrcAlpha=this.blendSrcAlpha),null!==this.blendDstAlpha&&(i.blendDstAlpha=this.blendDstAlpha),null!==this.blendEquationAlpha&&(i.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(i.blendColor=this.blendColor.getHex()),0!==this.blendAlpha&&(i.blendAlpha=this.blendAlpha),3!==this.depthFunc&&(i.depthFunc=this.depthFunc),!1===this.depthTest&&(i.depthTest=this.depthTest),!1===this.depthWrite&&(i.depthWrite=this.depthWrite),!1===this.colorWrite&&(i.colorWrite=this.colorWrite),255!==this.stencilWriteMask&&(i.stencilWriteMask=this.stencilWriteMask),519!==this.stencilFunc&&(i.stencilFunc=this.stencilFunc),0!==this.stencilRef&&(i.stencilRef=this.stencilRef),255!==this.stencilFuncMask&&(i.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==ag&&(i.stencilFail=this.stencilFail),this.stencilZFail!==ag&&(i.stencilZFail=this.stencilZFail),this.stencilZPass!==ag&&(i.stencilZPass=this.stencilZPass),!0===this.stencilWrite&&(i.stencilWrite=this.stencilWrite),void 0!==this.rotation&&0!==this.rotation&&(i.rotation=this.rotation),!0===this.polygonOffset&&(i.polygonOffset=!0),0!==this.polygonOffsetFactor&&(i.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(i.polygonOffsetUnits=this.polygonOffsetUnits),void 0!==this.linewidth&&1!==this.linewidth&&(i.linewidth=this.linewidth),void 0!==this.dashSize&&(i.dashSize=this.dashSize),void 0!==this.gapSize&&(i.gapSize=this.gapSize),void 0!==this.scale&&(i.scale=this.scale),!0===this.dithering&&(i.dithering=!0),this.alphaTest>0&&(i.alphaTest=this.alphaTest),!0===this.alphaHash&&(i.alphaHash=!0),!0===this.alphaToCoverage&&(i.alphaToCoverage=!0),!0===this.premultipliedAlpha&&(i.premultipliedAlpha=!0),!0===this.forceSinglePass&&(i.forceSinglePass=!0),!0===this.wireframe&&(i.wireframe=!0),this.wireframeLinewidth>1&&(i.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(i.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(i.wireframeLinejoin=this.wireframeLinejoin),!0===this.flatShading&&(i.flatShading=!0),!1===this.visible&&(i.visible=!1),!1===this.toneMapped&&(i.toneMapped=!1),!1===this.fog&&(i.fog=!1),Object.keys(this.userData).length>0&&(i.userData=this.userData),e){const e=n(t.textures),s=n(t.images);e.length>0&&(i.textures=e),s.length>0&&(i.images=s)}return i}clone(){return(new this.constructor).copy(this)}copy(t){this.name=t.name,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.blendColor.copy(t.blendColor),this.blendAlpha=t.blendAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let i=null;if(null!==e){const t=e.length;i=new Array(t);for(let n=0;n!==t;++n)i[n]=e[n].clone()}return this.clippingPlanes=i,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaHash=t.alphaHash,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.forceSinglePass=t.forceSinglePass,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){!0===t&&this.version++}onBuild(){}}class Cv extends Ev{static get type(){return"MeshBasicMaterial"}constructor(t){super(),this.isMeshBasicMaterial=!0,this.color=new Tv(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Gx,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}const Rv=Nv();function Nv(){const t=new ArrayBuffer(4),e=new Float32Array(t),i=new Uint32Array(t),n=new Uint32Array(512),s=new Uint32Array(512);for(let l=0;l<256;++l){const t=l-127;t<-27?(n[l]=0,n[256|l]=32768,s[l]=24,s[256|l]=24):t<-14?(n[l]=1024>>-t-14,n[256|l]=1024>>-t-14|32768,s[l]=-t-1,s[256|l]=-t-1):t<=15?(n[l]=t+15<<10,n[256|l]=t+15<<10|32768,s[l]=13,s[256|l]=13):t<128?(n[l]=31744,n[256|l]=64512,s[l]=24,s[256|l]=24):(n[l]=31744,n[256|l]=64512,s[l]=13,s[256|l]=13)}const r=new Uint32Array(2048),a=new Uint32Array(64),o=new Uint32Array(64);for(let l=1;l<1024;++l){let t=l<<13,e=0;for(;!(8388608&t);)t<<=1,e-=8388608;t&=-8388609,e+=947912704,r[l]=t|e}for(let l=1024;l<2048;++l)r[l]=939524096+(l-1024<<13);for(let l=1;l<31;++l)a[l]=l<<23;a[31]=1199570944,a[32]=2147483648;for(let l=33;l<63;++l)a[l]=2147483648+(l-32<<23);a[63]=3347054592;for(let l=1;l<64;++l)32!==l&&(o[l]=1024);return{floatView:e,uint32View:i,baseTable:n,shiftTable:s,mantissaTable:r,exponentTable:a,offsetTable:o}}function Pv(t){Math.abs(t),t=wg(t,-65504,65504),Rv.floatView[0]=t;const e=Rv.uint32View[0],i=e>>23&511;return Rv.baseTable[i]+((8388607&e)>>Rv.shiftTable[i])}function Iv(t){const e=t>>10;return Rv.uint32View[0]=Rv.mantissaTable[Rv.offsetTable[e]+(1023&t)]+Rv.exponentTable[e],Rv.floatView[0]}const Lv=new ix,Dv=new Pg;class Uv{constructor(t,e,i=!1){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=t,this.itemSize=e,this.count=void 0!==t?t.length/e:0,this.normalized=i,this.usage=fg,this.updateRanges=[],this.gpuType=Sf,this.version=0}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this.gpuType=t.gpuType,this}copyAt(t,e,i){t*=this.itemSize,i*=e.itemSize;for(let n=0,s=this.itemSize;n<s;n++)this.array[t+n]=e.array[i+n];return this}copyArray(t){return this.array.set(t),this}applyMatrix3(t){if(2===this.itemSize)for(let e=0,i=this.count;e<i;e++)Dv.fromBufferAttribute(this,e),Dv.applyMatrix3(t),this.setXY(e,Dv.x,Dv.y);else if(3===this.itemSize)for(let e=0,i=this.count;e<i;e++)Lv.fromBufferAttribute(this,e),Lv.applyMatrix3(t),this.setXYZ(e,Lv.x,Lv.y,Lv.z);return this}applyMatrix4(t){for(let e=0,i=this.count;e<i;e++)Lv.fromBufferAttribute(this,e),Lv.applyMatrix4(t),this.setXYZ(e,Lv.x,Lv.y,Lv.z);return this}applyNormalMatrix(t){for(let e=0,i=this.count;e<i;e++)Lv.fromBufferAttribute(this,e),Lv.applyNormalMatrix(t),this.setXYZ(e,Lv.x,Lv.y,Lv.z);return this}transformDirection(t){for(let e=0,i=this.count;e<i;e++)Lv.fromBufferAttribute(this,e),Lv.transformDirection(t),this.setXYZ(e,Lv.x,Lv.y,Lv.z);return this}set(t,e=0){return this.array.set(t,e),this}getComponent(t,e){let i=this.array[t*this.itemSize+e];return this.normalized&&(i=Cg(i,this.array)),i}setComponent(t,e,i){return this.normalized&&(i=Rg(i,this.array)),this.array[t*this.itemSize+e]=i,this}getX(t){let e=this.array[t*this.itemSize];return this.normalized&&(e=Cg(e,this.array)),e}setX(t,e){return this.normalized&&(e=Rg(e,this.array)),this.array[t*this.itemSize]=e,this}getY(t){let e=this.array[t*this.itemSize+1];return this.normalized&&(e=Cg(e,this.array)),e}setY(t,e){return this.normalized&&(e=Rg(e,this.array)),this.array[t*this.itemSize+1]=e,this}getZ(t){let e=this.array[t*this.itemSize+2];return this.normalized&&(e=Cg(e,this.array)),e}setZ(t,e){return this.normalized&&(e=Rg(e,this.array)),this.array[t*this.itemSize+2]=e,this}getW(t){let e=this.array[t*this.itemSize+3];return this.normalized&&(e=Cg(e,this.array)),e}setW(t,e){return this.normalized&&(e=Rg(e,this.array)),this.array[t*this.itemSize+3]=e,this}setXY(t,e,i){return t*=this.itemSize,this.normalized&&(e=Rg(e,this.array),i=Rg(i,this.array)),this.array[t+0]=e,this.array[t+1]=i,this}setXYZ(t,e,i,n){return t*=this.itemSize,this.normalized&&(e=Rg(e,this.array),i=Rg(i,this.array),n=Rg(n,this.array)),this.array[t+0]=e,this.array[t+1]=i,this.array[t+2]=n,this}setXYZW(t,e,i,n,s){return t*=this.itemSize,this.normalized&&(e=Rg(e,this.array),i=Rg(i,this.array),n=Rg(n,this.array),s=Rg(s,this.array)),this.array[t+0]=e,this.array[t+1]=i,this.array[t+2]=n,this.array[t+3]=s,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return""!==this.name&&(t.name=this.name),this.usage!==fg&&(t.usage=this.usage),t}}class Fv extends Uv{constructor(t,e,i){super(new Uint16Array(t),e,i)}}class Bv extends Uv{constructor(t,e,i){super(new Uint32Array(t),e,i)}}class Ov extends Uv{constructor(t,e,i){super(new Uint16Array(t),e,i),this.isFloat16BufferAttribute=!0}getX(t){let e=Iv(this.array[t*this.itemSize]);return this.normalized&&(e=Cg(e,this.array)),e}setX(t,e){return this.normalized&&(e=Rg(e,this.array)),this.array[t*this.itemSize]=Pv(e),this}getY(t){let e=Iv(this.array[t*this.itemSize+1]);return this.normalized&&(e=Cg(e,this.array)),e}setY(t,e){return this.normalized&&(e=Rg(e,this.array)),this.array[t*this.itemSize+1]=Pv(e),this}getZ(t){let e=Iv(this.array[t*this.itemSize+2]);return this.normalized&&(e=Cg(e,this.array)),e}setZ(t,e){return this.normalized&&(e=Rg(e,this.array)),this.array[t*this.itemSize+2]=Pv(e),this}getW(t){let e=Iv(this.array[t*this.itemSize+3]);return this.normalized&&(e=Cg(e,this.array)),e}setW(t,e){return this.normalized&&(e=Rg(e,this.array)),this.array[t*this.itemSize+3]=Pv(e),this}setXY(t,e,i){return t*=this.itemSize,this.normalized&&(e=Rg(e,this.array),i=Rg(i,this.array)),this.array[t+0]=Pv(e),this.array[t+1]=Pv(i),this}setXYZ(t,e,i,n){return t*=this.itemSize,this.normalized&&(e=Rg(e,this.array),i=Rg(i,this.array),n=Rg(n,this.array)),this.array[t+0]=Pv(e),this.array[t+1]=Pv(i),this.array[t+2]=Pv(n),this}setXYZW(t,e,i,n,s){return t*=this.itemSize,this.normalized&&(e=Rg(e,this.array),i=Rg(i,this.array),n=Rg(n,this.array),s=Rg(s,this.array)),this.array[t+0]=Pv(e),this.array[t+1]=Pv(i),this.array[t+2]=Pv(n),this.array[t+3]=Pv(s),this}}class zv extends Uv{constructor(t,e,i){super(new Float32Array(t),e,i)}}let kv=0;const Vv=new Ix,Gv=new rv,Hv=new ix,Wv=new rx,jv=new rx,Xv=new ix;class qv extends _g{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:kv++}),this.uuid=Tg(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(function(t){for(let e=t.length-1;e>=0;--e)if(t[e]>=65535)return!0;return!1}(t)?Bv:Fv)(t,1):this.index=t,this}setIndirect(t){return this.indirect=t,this}getIndirect(){return this.indirect}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return void 0!==this.attributes[t]}addGroup(t,e,i=0){this.groups.push({start:t,count:e,materialIndex:i})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;void 0!==e&&(e.applyMatrix4(t),e.needsUpdate=!0);const i=this.attributes.normal;if(void 0!==i){const e=(new Ig).getNormalMatrix(t);i.applyNormalMatrix(e),i.needsUpdate=!0}const n=this.attributes.tangent;return void 0!==n&&(n.transformDirection(t),n.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(t){return Vv.makeRotationFromQuaternion(t),this.applyMatrix4(Vv),this}rotateX(t){return Vv.makeRotationX(t),this.applyMatrix4(Vv),this}rotateY(t){return Vv.makeRotationY(t),this.applyMatrix4(Vv),this}rotateZ(t){return Vv.makeRotationZ(t),this.applyMatrix4(Vv),this}translate(t,e,i){return Vv.makeTranslation(t,e,i),this.applyMatrix4(Vv),this}scale(t,e,i){return Vv.makeScale(t,e,i),this.applyMatrix4(Vv),this}lookAt(t){return Gv.lookAt(t),Gv.updateMatrix(),this.applyMatrix4(Gv.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Hv).negate(),this.translate(Hv.x,Hv.y,Hv.z),this}setFromPoints(t){const e=this.getAttribute("position");if(void 0===e){const e=[];for(let i=0,n=t.length;i<n;i++){const n=t[i];e.push(n.x,n.y,n.z||0)}this.setAttribute("position",new zv(e,3))}else{for(let i=0,n=e.count;i<n;i++){const n=t[i];e.setXYZ(i,n.x,n.y,n.z||0)}t.length,e.count,e.needsUpdate=!0}return this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new rx);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)this.boundingBox.set(new ix(-1/0,-1/0,-1/0),new ix(1/0,1/0,1/0));else{if(void 0!==t){if(this.boundingBox.setFromBufferAttribute(t),e)for(let t=0,i=e.length;t<i;t++){const i=e[t];Wv.setFromBufferAttribute(i),this.morphTargetsRelative?(Xv.addVectors(this.boundingBox.min,Wv.min),this.boundingBox.expandByPoint(Xv),Xv.addVectors(this.boundingBox.max,Wv.max),this.boundingBox.expandByPoint(Xv)):(this.boundingBox.expandByPoint(Wv.min),this.boundingBox.expandByPoint(Wv.max))}}else this.boundingBox.makeEmpty();isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z)}}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new Mx);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)this.boundingSphere.set(new ix,1/0);else if(t){const i=this.boundingSphere.center;if(Wv.setFromBufferAttribute(t),e)for(let t=0,s=e.length;t<s;t++){const i=e[t];jv.setFromBufferAttribute(i),this.morphTargetsRelative?(Xv.addVectors(Wv.min,jv.min),Wv.expandByPoint(Xv),Xv.addVectors(Wv.max,jv.max),Wv.expandByPoint(Xv)):(Wv.expandByPoint(jv.min),Wv.expandByPoint(jv.max))}Wv.getCenter(i);let n=0;for(let e=0,s=t.count;e<s;e++)Xv.fromBufferAttribute(t,e),n=Math.max(n,i.distanceToSquared(Xv));if(e)for(let s=0,r=e.length;s<r;s++){const r=e[s],a=this.morphTargetsRelative;for(let e=0,s=r.count;e<s;e++)Xv.fromBufferAttribute(r,e),a&&(Hv.fromBufferAttribute(t,e),Xv.add(Hv)),n=Math.max(n,i.distanceToSquared(Xv))}this.boundingSphere.radius=Math.sqrt(n),isNaN(this.boundingSphere.radius)}}computeTangents(){const t=this.index,e=this.attributes;if(null===t||void 0===e.position||void 0===e.normal||void 0===e.uv)return;const i=e.position,n=e.normal,s=e.uv;!1===this.hasAttribute("tangent")&&this.setAttribute("tangent",new Uv(new Float32Array(4*i.count),4));const r=this.getAttribute("tangent"),a=[],o=[];for(let M=0;M<i.count;M++)a[M]=new ix,o[M]=new ix;const l=new ix,h=new ix,c=new ix,u=new Pg,d=new Pg,p=new Pg,m=new ix,f=new ix;function g(t,e,n){l.fromBufferAttribute(i,t),h.fromBufferAttribute(i,e),c.fromBufferAttribute(i,n),u.fromBufferAttribute(s,t),d.fromBufferAttribute(s,e),p.fromBufferAttribute(s,n),h.sub(l),c.sub(l),d.sub(u),p.sub(u);const r=1/(d.x*p.y-p.x*d.y);isFinite(r)&&(m.copy(h).multiplyScalar(p.y).addScaledVector(c,-d.y).multiplyScalar(r),f.copy(c).multiplyScalar(d.x).addScaledVector(h,-p.x).multiplyScalar(r),a[t].add(m),a[e].add(m),a[n].add(m),o[t].add(f),o[e].add(f),o[n].add(f))}let x=this.groups;0===x.length&&(x=[{start:0,count:t.count}]);for(let M=0,T=x.length;M<T;++M){const e=x[M],i=e.start;for(let n=i,s=i+e.count;n<s;n+=3)g(t.getX(n+0),t.getX(n+1),t.getX(n+2))}const v=new ix,_=new ix,y=new ix,b=new ix;function S(t){y.fromBufferAttribute(n,t),b.copy(y);const e=a[t];v.copy(e),v.sub(y.multiplyScalar(y.dot(e))).normalize(),_.crossVectors(b,e);const i=_.dot(o[t])<0?-1:1;r.setXYZW(t,v.x,v.y,v.z,i)}for(let M=0,T=x.length;M<T;++M){const e=x[M],i=e.start;for(let n=i,s=i+e.count;n<s;n+=3)S(t.getX(n+0)),S(t.getX(n+1)),S(t.getX(n+2))}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(void 0!==e){let i=this.getAttribute("normal");if(void 0===i)i=new Uv(new Float32Array(3*e.count),3),this.setAttribute("normal",i);else for(let t=0,e=i.count;t<e;t++)i.setXYZ(t,0,0,0);const n=new ix,s=new ix,r=new ix,a=new ix,o=new ix,l=new ix,h=new ix,c=new ix;if(t)for(let u=0,d=t.count;u<d;u+=3){const d=t.getX(u+0),p=t.getX(u+1),m=t.getX(u+2);n.fromBufferAttribute(e,d),s.fromBufferAttribute(e,p),r.fromBufferAttribute(e,m),h.subVectors(r,s),c.subVectors(n,s),h.cross(c),a.fromBufferAttribute(i,d),o.fromBufferAttribute(i,p),l.fromBufferAttribute(i,m),a.add(h),o.add(h),l.add(h),i.setXYZ(d,a.x,a.y,a.z),i.setXYZ(p,o.x,o.y,o.z),i.setXYZ(m,l.x,l.y,l.z)}else for(let t=0,u=e.count;t<u;t+=3)n.fromBufferAttribute(e,t+0),s.fromBufferAttribute(e,t+1),r.fromBufferAttribute(e,t+2),h.subVectors(r,s),c.subVectors(n,s),h.cross(c),i.setXYZ(t+0,h.x,h.y,h.z),i.setXYZ(t+1,h.x,h.y,h.z),i.setXYZ(t+2,h.x,h.y,h.z);this.normalizeNormals(),i.needsUpdate=!0}}normalizeNormals(){const t=this.attributes.normal;for(let e=0,i=t.count;e<i;e++)Xv.fromBufferAttribute(t,e),Xv.normalize(),t.setXYZ(e,Xv.x,Xv.y,Xv.z)}toNonIndexed(){function t(t,e){const i=t.array,n=t.itemSize,s=t.normalized,r=new i.constructor(e.length*n);let a=0,o=0;for(let l=0,h=e.length;l<h;l++){a=t.isInterleavedBufferAttribute?e[l]*t.data.stride+t.offset:e[l]*n;for(let t=0;t<n;t++)r[o++]=i[a++]}return new Uv(r,n,s)}if(null===this.index)return this;const e=new qv,i=this.index.array,n=this.attributes;for(const a in n){const s=t(n[a],i);e.setAttribute(a,s)}const s=this.morphAttributes;for(const a in s){const n=[],r=s[a];for(let e=0,s=r.length;e<s;e++){const s=t(r[e],i);n.push(s)}e.morphAttributes[a]=n}e.morphTargetsRelative=this.morphTargetsRelative;const r=this.groups;for(let a=0,o=r.length;a<o;a++){const t=r[a];e.addGroup(t.start,t.count,t.materialIndex)}return e}toJSON(){const t={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),void 0!==this.parameters){const e=this.parameters;for(const i in e)void 0!==e[i]&&(t[i]=e[i]);return t}t.data={attributes:{}};const e=this.index;null!==e&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const i=this.attributes;for(const o in i){const e=i[o];t.data.attributes[o]=e.toJSON(t.data)}const n={};let s=!1;for(const o in this.morphAttributes){const e=this.morphAttributes[o],i=[];for(let n=0,s=e.length;n<s;n++){const s=e[n];i.push(s.toJSON(t.data))}i.length>0&&(n[o]=i,s=!0)}s&&(t.data.morphAttributes=n,t.data.morphTargetsRelative=this.morphTargetsRelative);const r=this.groups;r.length>0&&(t.data.groups=JSON.parse(JSON.stringify(r)));const a=this.boundingSphere;return null!==a&&(t.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),t}clone(){return(new this.constructor).copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const i=t.index;null!==i&&this.setIndex(i.clone(e));const n=t.attributes;for(const l in n){const t=n[l];this.setAttribute(l,t.clone(e))}const s=t.morphAttributes;for(const l in s){const t=[],i=s[l];for(let n=0,s=i.length;n<s;n++)t.push(i[n].clone(e));this.morphAttributes[l]=t}this.morphTargetsRelative=t.morphTargetsRelative;const r=t.groups;for(let l=0,h=r.length;l<h;l++){const t=r[l];this.addGroup(t.start,t.count,t.materialIndex)}const a=t.boundingBox;null!==a&&(this.boundingBox=a.clone());const o=t.boundingSphere;return null!==o&&(this.boundingSphere=o.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const $v=new Ix,Yv=new Px,Zv=new Mx,Kv=new ix,Jv=new ix,Qv=new ix,t_=new ix,e_=new ix,i_=new ix,n_=new ix,s_=new ix;class r_ extends rv{constructor(t=new qv,e=new Cv){super(),this.isMesh=!0,this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),void 0!==t.morphTargetInfluences&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),void 0!==t.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const i=t[e[0]];if(void 0!==i){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,e=i.length;t<e;t++){const e=i[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[e]=t}}}}getVertexPosition(t,e){const i=this.geometry,n=i.attributes.position,s=i.morphAttributes.position,r=i.morphTargetsRelative;e.fromBufferAttribute(n,t);const a=this.morphTargetInfluences;if(s&&a){i_.set(0,0,0);for(let i=0,n=s.length;i<n;i++){const n=a[i],o=s[i];0!==n&&(e_.fromBufferAttribute(o,t),r?i_.addScaledVector(e_,n):i_.addScaledVector(e_.sub(e),n))}e.add(i_)}return e}raycast(t,e){const i=this.geometry,n=this.material,s=this.matrixWorld;if(void 0!==n){if(null===i.boundingSphere&&i.computeBoundingSphere(),Zv.copy(i.boundingSphere),Zv.applyMatrix4(s),Yv.copy(t.ray).recast(t.near),!1===Zv.containsPoint(Yv.origin)){if(null===Yv.intersectSphere(Zv,Kv))return;if(Yv.origin.distanceToSquared(Kv)>(t.far-t.near)**2)return}$v.copy(s).invert(),Yv.copy(t.ray).applyMatrix4($v),null!==i.boundingBox&&!1===Yv.intersectsBox(i.boundingBox)||this._computeIntersections(t,e,Yv)}}_computeIntersections(t,e,i){let n;const s=this.geometry,r=this.material,a=s.index,o=s.attributes.position,l=s.attributes.uv,h=s.attributes.uv1,c=s.attributes.normal,u=s.groups,d=s.drawRange;if(null!==a)if(Array.isArray(r))for(let p=0,m=u.length;p<m;p++){const s=u[p],o=r[s.materialIndex];for(let r=Math.max(s.start,d.start),u=Math.min(a.count,Math.min(s.start+s.count,d.start+d.count));r<u;r+=3){n=a_(this,o,t,i,l,h,c,a.getX(r),a.getX(r+1),a.getX(r+2)),n&&(n.faceIndex=Math.floor(r/3),n.face.materialIndex=s.materialIndex,e.push(n))}}else{for(let s=Math.max(0,d.start),o=Math.min(a.count,d.start+d.count);s<o;s+=3){n=a_(this,r,t,i,l,h,c,a.getX(s),a.getX(s+1),a.getX(s+2)),n&&(n.faceIndex=Math.floor(s/3),e.push(n))}}else if(void 0!==o)if(Array.isArray(r))for(let p=0,m=u.length;p<m;p++){const s=u[p],a=r[s.materialIndex];for(let r=Math.max(s.start,d.start),u=Math.min(o.count,Math.min(s.start+s.count,d.start+d.count));r<u;r+=3){n=a_(this,a,t,i,l,h,c,r,r+1,r+2),n&&(n.faceIndex=Math.floor(r/3),n.face.materialIndex=s.materialIndex,e.push(n))}}else{for(let s=Math.max(0,d.start),a=Math.min(o.count,d.start+d.count);s<a;s+=3){n=a_(this,r,t,i,l,h,c,s,s+1,s+2),n&&(n.faceIndex=Math.floor(s/3),e.push(n))}}}}function a_(t,e,i,n,s,r,a,o,l,h){t.getVertexPosition(o,Jv),t.getVertexPosition(l,Qv),t.getVertexPosition(h,t_);const c=function(t,e,i,n,s,r,a,o){let l;if(l=1===e.side?n.intersectTriangle(a,r,s,!0,o):n.intersectTriangle(s,r,a,0===e.side,o),null===l)return null;s_.copy(o),s_.applyMatrix4(t.matrixWorld);const h=i.ray.origin.distanceTo(s_);return h<i.near||h>i.far?null:{distance:h,point:s_.clone(),object:t}}(t,e,i,n,Jv,Qv,t_,n_);if(c){const t=new ix;_v.getBarycoord(n_,Jv,Qv,t_,t),s&&(c.uv=_v.getInterpolatedAttribute(s,o,l,h,t,new Pg)),r&&(c.uv1=_v.getInterpolatedAttribute(r,o,l,h,t,new Pg)),a&&(c.normal=_v.getInterpolatedAttribute(a,o,l,h,t,new ix),c.normal.dot(n.direction)>0&&c.normal.multiplyScalar(-1));const e={a:o,b:l,c:h,normal:new ix,materialIndex:0};_v.getNormal(Jv,Qv,t_,e.normal),c.face=e,c.barycoord=t}return c}class o_ extends qv{constructor(t=1,e=1,i=1,n=1,s=1,r=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:i,widthSegments:n,heightSegments:s,depthSegments:r};const a=this;n=Math.floor(n),s=Math.floor(s),r=Math.floor(r);const o=[],l=[],h=[],c=[];let u=0,d=0;function p(t,e,i,n,s,r,p,m,f,g,x){const v=r/f,_=p/g,y=r/2,b=p/2,S=m/2,M=f+1,T=g+1;let w=0,A=0;const E=new ix;for(let a=0;a<T;a++){const r=a*_-b;for(let o=0;o<M;o++){const u=o*v-y;E[t]=u*n,E[e]=r*s,E[i]=S,l.push(E.x,E.y,E.z),E[t]=0,E[e]=0,E[i]=m>0?1:-1,h.push(E.x,E.y,E.z),c.push(o/f),c.push(1-a/g),w+=1}}for(let a=0;a<g;a++)for(let t=0;t<f;t++){const e=u+t+M*a,i=u+t+M*(a+1),n=u+(t+1)+M*(a+1),s=u+(t+1)+M*a;o.push(e,i,s),o.push(i,n,s),A+=6}a.addGroup(d,A,x),d+=A,u+=w}p("z","y","x",-1,-1,i,e,t,r,s,0),p("z","y","x",1,-1,i,e,-t,r,s,1),p("x","z","y",1,1,t,i,e,n,r,2),p("x","z","y",1,-1,t,i,-e,n,r,3),p("x","y","z",1,-1,t,e,i,n,s,4),p("x","y","z",-1,-1,t,e,-i,n,s,5),this.setIndex(o),this.setAttribute("position",new zv(l,3)),this.setAttribute("normal",new zv(h,3)),this.setAttribute("uv",new zv(c,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new o_(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}function l_(t){const e={};for(const i in t){e[i]={};for(const n in t[i]){const s=t[i][n];s&&(s.isColor||s.isMatrix3||s.isMatrix4||s.isVector2||s.isVector3||s.isVector4||s.isTexture||s.isQuaternion)?s.isRenderTargetTexture?e[i][n]=null:e[i][n]=s.clone():Array.isArray(s)?e[i][n]=s.slice():e[i][n]=s}}return e}class h_ extends Ev{static get type(){return"ShaderMaterial"}constructor(t){super(),this.isShaderMaterial=!0,this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader="\nvoid main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n",this.fragmentShader="\nvoid main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}\n",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==t&&this.setValues(t)}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=l_(t.uniforms),this.uniformsGroups=function(t){const e=[];for(let i=0;i<t.length;i++)e.push(t[i].clone());return e}(t.uniformsGroups),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.fog=t.fog,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const n in this.uniforms){const i=this.uniforms[n].value;i&&i.isTexture?e.uniforms[n]={type:"t",value:i.toJSON(t).uuid}:i&&i.isColor?e.uniforms[n]={type:"c",value:i.getHex()}:i&&i.isVector2?e.uniforms[n]={type:"v2",value:i.toArray()}:i&&i.isVector3?e.uniforms[n]={type:"v3",value:i.toArray()}:i&&i.isVector4?e.uniforms[n]={type:"v4",value:i.toArray()}:i&&i.isMatrix3?e.uniforms[n]={type:"m3",value:i.toArray()}:i&&i.isMatrix4?e.uniforms[n]={type:"m4",value:i.toArray()}:e.uniforms[n]={value:i}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader,e.lights=this.lights,e.clipping=this.clipping;const i={};for(const n in this.extensions)!0===this.extensions[n]&&(i[n]=!0);return Object.keys(i).length>0&&(e.extensions=i),e}}class c_ extends rv{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new Ix,this.projectionMatrix=new Ix,this.projectionMatrixInverse=new Ix,this.coordinateSystem=xg}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this.coordinateSystem=t.coordinateSystem,this}getWorldDirection(t){return super.getWorldDirection(t).negate()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return(new this.constructor).copy(this)}}const u_=new ix,d_=new Pg,p_=new Pg;class m_ extends c_{constructor(t=50,e=1,i=.1,n=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=i,this.far=n,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=null===t.view?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=2*Mg*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(.5*Sg*this.fov);return.5*this.getFilmHeight()/t}getEffectiveFOV(){return 2*Mg*Math.atan(Math.tan(.5*Sg*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(t,e,i){u_.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),e.set(u_.x,u_.y).multiplyScalar(-t/u_.z),u_.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),i.set(u_.x,u_.y).multiplyScalar(-t/u_.z)}getViewSize(t,e){return this.getViewBounds(t,d_,p_),e.subVectors(p_,d_)}setViewOffset(t,e,i,n,s,r){this.aspect=t/e,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=i,this.view.offsetY=n,this.view.width=s,this.view.height=r,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(.5*Sg*this.fov)/this.zoom,i=2*e,n=this.aspect*i,s=-.5*n;const r=this.view;if(null!==this.view&&this.view.enabled){const t=r.fullWidth,a=r.fullHeight;s+=r.offsetX*n/t,e-=r.offsetY*i/a,n*=r.width/t,i*=r.height/a}const a=this.filmOffset;0!==a&&(s+=t*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+n,e,e-i,t,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,null!==this.view&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}const f_=-90;class g_ extends rv{constructor(t,e,i){super(),this.type="CubeCamera",this.renderTarget=i,this.coordinateSystem=null,this.activeMipmapLevel=0;const n=new m_(f_,1,t,e);n.layers=this.layers,this.add(n);const s=new m_(f_,1,t,e);s.layers=this.layers,this.add(s);const r=new m_(f_,1,t,e);r.layers=this.layers,this.add(r);const a=new m_(f_,1,t,e);a.layers=this.layers,this.add(a);const o=new m_(f_,1,t,e);o.layers=this.layers,this.add(o);const l=new m_(f_,1,t,e);l.layers=this.layers,this.add(l)}updateCoordinateSystem(){const t=this.coordinateSystem,e=this.children.concat(),[i,n,s,r,a,o]=e;for(const l of e)this.remove(l);if(t===xg)i.up.set(0,1,0),i.lookAt(1,0,0),n.up.set(0,1,0),n.lookAt(-1,0,0),s.up.set(0,0,-1),s.lookAt(0,1,0),r.up.set(0,0,1),r.lookAt(0,-1,0),a.up.set(0,1,0),a.lookAt(0,0,1),o.up.set(0,1,0),o.lookAt(0,0,-1);else{if(t!==vg)throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+t);i.up.set(0,-1,0),i.lookAt(-1,0,0),n.up.set(0,-1,0),n.lookAt(1,0,0),s.up.set(0,0,1),s.lookAt(0,1,0),r.up.set(0,0,-1),r.lookAt(0,-1,0),a.up.set(0,-1,0),a.lookAt(0,0,1),o.up.set(0,-1,0),o.lookAt(0,0,-1)}for(const l of e)this.add(l),l.updateMatrixWorld()}update(t,e){null===this.parent&&this.updateMatrixWorld();const{renderTarget:i,activeMipmapLevel:n}=this;this.coordinateSystem!==t.coordinateSystem&&(this.coordinateSystem=t.coordinateSystem,this.updateCoordinateSystem());const[s,r,a,o,l,h]=this.children,c=t.getRenderTarget(),u=t.getActiveCubeFace(),d=t.getActiveMipmapLevel(),p=t.xr.enabled;t.xr.enabled=!1;const m=i.texture.generateMipmaps;i.texture.generateMipmaps=!1,t.setRenderTarget(i,0,n),t.render(e,s),t.setRenderTarget(i,1,n),t.render(e,r),t.setRenderTarget(i,2,n),t.render(e,a),t.setRenderTarget(i,3,n),t.render(e,o),t.setRenderTarget(i,4,n),t.render(e,l),i.texture.generateMipmaps=m,t.setRenderTarget(i,5,n),t.render(e,h),t.setRenderTarget(c,u,d),t.xr.enabled=p,i.texture.needsPMREMUpdate=!0}}class x_ extends Zg{constructor(t,e,i,n,s,r,a,o,l,h){super(t=void 0!==t?t:[],e=void 0!==e?e:nf,i,n,s,r,a,o,l,h),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}class v_ extends Qg{constructor(t=1,e={}){super(t,t,e),this.isWebGLCubeRenderTarget=!0;const i={width:t,height:t,depth:1},n=[i,i,i,i,i,i];this.texture=new x_(n,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=void 0!==e.generateMipmaps&&e.generateMipmaps,this.texture.minFilter=void 0!==e.minFilter?e.minFilter:pf}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.colorSpace=e.colorSpace,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const i={uniforms:{tEquirect:{value:null}},vertexShader:"\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",fragmentShader:"\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"},n=new o_(5,5,5),s=new h_({name:"CubemapFromEquirect",uniforms:l_(i.uniforms),vertexShader:i.vertexShader,fragmentShader:i.fragmentShader,side:1,blending:0});s.uniforms.tEquirect.value=e;const r=new r_(n,s),a=e.minFilter;e.minFilter===ff&&(e.minFilter=pf);return new g_(1,10,this).update(t,r),e.minFilter=a,r.geometry.dispose(),r.material.dispose(),this}clear(t,e,i,n){const s=t.getRenderTarget();for(let r=0;r<6;r++)t.setRenderTarget(this,r),t.clear(e,i,n);t.setRenderTarget(s)}}class __ extends rv{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new Gx,this.environmentIntensity=1,this.environmentRotation=new Gx,this.overrideMaterial=null,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),null!==t.background&&(this.background=t.background.clone()),null!==t.environment&&(this.environment=t.environment.clone()),null!==t.fog&&(this.fog=t.fog.clone()),this.backgroundBlurriness=t.backgroundBlurriness,this.backgroundIntensity=t.backgroundIntensity,this.backgroundRotation.copy(t.backgroundRotation),this.environmentIntensity=t.environmentIntensity,this.environmentRotation.copy(t.environmentRotation),null!==t.overrideMaterial&&(this.overrideMaterial=t.overrideMaterial.clone()),this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return null!==this.fog&&(e.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(e.object.backgroundBlurriness=this.backgroundBlurriness),1!==this.backgroundIntensity&&(e.object.backgroundIntensity=this.backgroundIntensity),e.object.backgroundRotation=this.backgroundRotation.toArray(),1!==this.environmentIntensity&&(e.object.environmentIntensity=this.environmentIntensity),e.object.environmentRotation=this.environmentRotation.toArray(),e}}class y_{constructor(t,e){this.isInterleavedBuffer=!0,this.array=t,this.stride=e,this.count=void 0!==t?t.length/e:0,this.usage=fg,this.updateRanges=[],this.version=0,this.uuid=Tg()}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,i){t*=this.stride,i*=e.stride;for(let n=0,s=this.stride;n<s;n++)this.array[t+n]=e.array[i+n];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=Tg()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),i=new this.constructor(e,this.stride);return i.setUsage(this.usage),i}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=Tg()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const b_=new ix;class S_{constructor(t,e,i,n=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=t,this.itemSize=e,this.offset=i,this.normalized=n}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,i=this.data.count;e<i;e++)b_.fromBufferAttribute(this,e),b_.applyMatrix4(t),this.setXYZ(e,b_.x,b_.y,b_.z);return this}applyNormalMatrix(t){for(let e=0,i=this.count;e<i;e++)b_.fromBufferAttribute(this,e),b_.applyNormalMatrix(t),this.setXYZ(e,b_.x,b_.y,b_.z);return this}transformDirection(t){for(let e=0,i=this.count;e<i;e++)b_.fromBufferAttribute(this,e),b_.transformDirection(t),this.setXYZ(e,b_.x,b_.y,b_.z);return this}getComponent(t,e){let i=this.array[t*this.data.stride+this.offset+e];return this.normalized&&(i=Cg(i,this.array)),i}setComponent(t,e,i){return this.normalized&&(i=Rg(i,this.array)),this.data.array[t*this.data.stride+this.offset+e]=i,this}setX(t,e){return this.normalized&&(e=Rg(e,this.array)),this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.normalized&&(e=Rg(e,this.array)),this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.normalized&&(e=Rg(e,this.array)),this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.normalized&&(e=Rg(e,this.array)),this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){let e=this.data.array[t*this.data.stride+this.offset];return this.normalized&&(e=Cg(e,this.array)),e}getY(t){let e=this.data.array[t*this.data.stride+this.offset+1];return this.normalized&&(e=Cg(e,this.array)),e}getZ(t){let e=this.data.array[t*this.data.stride+this.offset+2];return this.normalized&&(e=Cg(e,this.array)),e}getW(t){let e=this.data.array[t*this.data.stride+this.offset+3];return this.normalized&&(e=Cg(e,this.array)),e}setXY(t,e,i){return t=t*this.data.stride+this.offset,this.normalized&&(e=Rg(e,this.array),i=Rg(i,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=i,this}setXYZ(t,e,i,n){return t=t*this.data.stride+this.offset,this.normalized&&(e=Rg(e,this.array),i=Rg(i,this.array),n=Rg(n,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=i,this.data.array[t+2]=n,this}setXYZW(t,e,i,n,s){return t=t*this.data.stride+this.offset,this.normalized&&(e=Rg(e,this.array),i=Rg(i,this.array),n=Rg(n,this.array),s=Rg(s,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=i,this.data.array[t+2]=n,this.data.array[t+3]=s,this}clone(t){if(void 0===t){const t=[];for(let e=0;e<this.count;e++){const i=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[i+e])}return new Uv(new this.array.constructor(t),this.itemSize,this.normalized)}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new S_(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(void 0===t){const t=[];for(let e=0;e<this.count;e++){const i=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[i+e])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class M_ extends Ev{static get type(){return"SpriteMaterial"}constructor(t){super(),this.isSpriteMaterial=!0,this.color=new Tv(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}class T_ extends Zg{constructor(t=null,e=1,i=1,n,s,r,a,o,l=1003,h=1003,c,u){super(null,r,a,o,l,h,n,s,c,u),this.isDataTexture=!0,this.image={data:t,width:e,height:i},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class w_ extends Uv{constructor(t,e,i,n=1){super(t,e,i),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=n}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}const A_=new Ix,E_=new Ix,C_=[],R_=new rx,N_=new Ix,P_=new r_,I_=new Mx;class L_ extends r_{constructor(t,e,i){super(t,e),this.isInstancedMesh=!0,this.instanceMatrix=new w_(new Float32Array(16*i),16),this.instanceColor=null,this.morphTexture=null,this.count=i,this.boundingBox=null,this.boundingSphere=null;for(let n=0;n<i;n++)this.setMatrixAt(n,N_)}computeBoundingBox(){const t=this.geometry,e=this.count;null===this.boundingBox&&(this.boundingBox=new rx),null===t.boundingBox&&t.computeBoundingBox(),this.boundingBox.makeEmpty();for(let i=0;i<e;i++)this.getMatrixAt(i,A_),R_.copy(t.boundingBox).applyMatrix4(A_),this.boundingBox.union(R_)}computeBoundingSphere(){const t=this.geometry,e=this.count;null===this.boundingSphere&&(this.boundingSphere=new Mx),null===t.boundingSphere&&t.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let i=0;i<e;i++)this.getMatrixAt(i,A_),I_.copy(t.boundingSphere).applyMatrix4(A_),this.boundingSphere.union(I_)}copy(t,e){return super.copy(t,e),this.instanceMatrix.copy(t.instanceMatrix),null!==t.morphTexture&&(this.morphTexture=t.morphTexture.clone()),null!==t.instanceColor&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,null!==t.boundingBox&&(this.boundingBox=t.boundingBox.clone()),null!==t.boundingSphere&&(this.boundingSphere=t.boundingSphere.clone()),this}getColorAt(t,e){e.fromArray(this.instanceColor.array,3*t)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,16*t)}getMorphAt(t,e){const i=e.morphTargetInfluences,n=this.morphTexture.source.data.data,s=t*(i.length+1)+1;for(let r=0;r<i.length;r++)i[r]=n[s+r]}raycast(t,e){const i=this.matrixWorld,n=this.count;if(P_.geometry=this.geometry,P_.material=this.material,void 0!==P_.material&&(null===this.boundingSphere&&this.computeBoundingSphere(),I_.copy(this.boundingSphere),I_.applyMatrix4(i),!1!==t.ray.intersectsSphere(I_)))for(let s=0;s<n;s++){this.getMatrixAt(s,A_),E_.multiplyMatrices(i,A_),P_.matrixWorld=E_,P_.raycast(t,C_);for(let t=0,i=C_.length;t<i;t++){const i=C_[t];i.instanceId=s,i.object=this,e.push(i)}C_.length=0}}setColorAt(t,e){null===this.instanceColor&&(this.instanceColor=new w_(new Float32Array(3*this.instanceMatrix.count).fill(1),3)),e.toArray(this.instanceColor.array,3*t)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,16*t)}setMorphAt(t,e){const i=e.morphTargetInfluences,n=i.length+1;null===this.morphTexture&&(this.morphTexture=new T_(new Float32Array(n*this.count),n,this.count,Rf,Sf));const s=this.morphTexture.source.data.data;let r=0;for(let l=0;l<i.length;l++)r+=i[l];const a=this.geometry.morphTargetsRelative?1:1-r,o=n*t;s[o]=a,s.set(i,o+1)}updateMorphTargets(){}dispose(){return this.dispatchEvent({type:"dispose"}),null!==this.morphTexture&&(this.morphTexture.dispose(),this.morphTexture=null),this}}const D_=new ix,U_=new ix,F_=new Ig;class B_{constructor(t=new ix(1,0,0),e=0){this.isPlane=!0,this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,i,n){return this.normal.set(t,e,i),this.constant=n,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,i){const n=D_.subVectors(i,e).cross(U_.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(n,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(t).addScaledVector(this.normal,-this.distanceToPoint(t))}intersectLine(t,e){const i=t.delta(D_),n=this.normal.dot(i);if(0===n)return 0===this.distanceToPoint(t.start)?e.copy(t.start):null;const s=-(t.start.dot(this.normal)+this.constant)/n;return s<0||s>1?null:e.copy(t.start).addScaledVector(i,s)}intersectsLine(t){const e=this.distanceToPoint(t.start),i=this.distanceToPoint(t.end);return e<0&&i>0||i<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const i=e||F_.getNormalMatrix(t),n=this.coplanarPoint(D_).applyMatrix4(t),s=this.normal.applyMatrix3(i).normalize();return this.constant=-n.dot(s),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return(new this.constructor).copy(this)}}const O_=new Mx,z_=new ix;class k_{constructor(t=new B_,e=new B_,i=new B_,n=new B_,s=new B_,r=new B_){this.planes=[t,e,i,n,s,r]}set(t,e,i,n,s,r){const a=this.planes;return a[0].copy(t),a[1].copy(e),a[2].copy(i),a[3].copy(n),a[4].copy(s),a[5].copy(r),this}copy(t){const e=this.planes;for(let i=0;i<6;i++)e[i].copy(t.planes[i]);return this}setFromProjectionMatrix(t,e=2e3){const i=this.planes,n=t.elements,s=n[0],r=n[1],a=n[2],o=n[3],l=n[4],h=n[5],c=n[6],u=n[7],d=n[8],p=n[9],m=n[10],f=n[11],g=n[12],x=n[13],v=n[14],_=n[15];if(i[0].setComponents(o-s,u-l,f-d,_-g).normalize(),i[1].setComponents(o+s,u+l,f+d,_+g).normalize(),i[2].setComponents(o+r,u+h,f+p,_+x).normalize(),i[3].setComponents(o-r,u-h,f-p,_-x).normalize(),i[4].setComponents(o-a,u-c,f-m,_-v).normalize(),e===xg)i[5].setComponents(o+a,u+c,f+m,_+v).normalize();else{if(e!==vg)throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+e);i[5].setComponents(a,c,m,v).normalize()}return this}intersectsObject(t){if(void 0!==t.boundingSphere)null===t.boundingSphere&&t.computeBoundingSphere(),O_.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);else{const e=t.geometry;null===e.boundingSphere&&e.computeBoundingSphere(),O_.copy(e.boundingSphere).applyMatrix4(t.matrixWorld)}return this.intersectsSphere(O_)}intersectsSprite(t){return O_.center.set(0,0,0),O_.radius=.7071067811865476,O_.applyMatrix4(t.matrixWorld),this.intersectsSphere(O_)}intersectsSphere(t){const e=this.planes,i=t.center,n=-t.radius;for(let s=0;s<6;s++){if(e[s].distanceToPoint(i)<n)return!1}return!0}intersectsBox(t){const e=this.planes;for(let i=0;i<6;i++){const n=e[i];if(z_.x=n.normal.x>0?t.max.x:t.min.x,z_.y=n.normal.y>0?t.max.y:t.min.y,z_.z=n.normal.z>0?t.max.z:t.min.z,n.distanceToPoint(z_)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let i=0;i<6;i++)if(e[i].distanceToPoint(t)<0)return!1;return!0}clone(){return(new this.constructor).copy(this)}}class V_ extends Ev{static get type(){return"LineBasicMaterial"}constructor(t){super(),this.isLineBasicMaterial=!0,this.color=new Tv(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this.fog=t.fog,this}}const G_=new ix,H_=new ix,W_=new Ix,j_=new Px,X_=new Mx,q_=new ix,$_=new ix;class Y_ extends rv{constructor(t=new qv,e=new V_){super(),this.isLine=!0,this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(null===t.index){const e=t.attributes.position,i=[0];for(let t=1,n=e.count;t<n;t++)G_.fromBufferAttribute(e,t-1),H_.fromBufferAttribute(e,t),i[t]=i[t-1],i[t]+=G_.distanceTo(H_);t.setAttribute("lineDistance",new zv(i,1))}return this}raycast(t,e){const i=this.geometry,n=this.matrixWorld,s=t.params.Line.threshold,r=i.drawRange;if(null===i.boundingSphere&&i.computeBoundingSphere(),X_.copy(i.boundingSphere),X_.applyMatrix4(n),X_.radius+=s,!1===t.ray.intersectsSphere(X_))return;W_.copy(n).invert(),j_.copy(t.ray).applyMatrix4(W_);const a=s/((this.scale.x+this.scale.y+this.scale.z)/3),o=a*a,l=this.isLineSegments?2:1,h=i.index,c=i.attributes.position;if(null!==h){const i=Math.max(0,r.start),n=Math.min(h.count,r.start+r.count);for(let s=i,r=n-1;s<r;s+=l){const i=h.getX(s),n=h.getX(s+1),r=Z_(this,t,j_,o,i,n);r&&e.push(r)}if(this.isLineLoop){const s=h.getX(n-1),r=h.getX(i),a=Z_(this,t,j_,o,s,r);a&&e.push(a)}}else{const i=Math.max(0,r.start),n=Math.min(c.count,r.start+r.count);for(let s=i,r=n-1;s<r;s+=l){const i=Z_(this,t,j_,o,s,s+1);i&&e.push(i)}if(this.isLineLoop){const s=Z_(this,t,j_,o,n-1,i);s&&e.push(s)}}}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const i=t[e[0]];if(void 0!==i){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,e=i.length;t<e;t++){const e=i[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[e]=t}}}}}function Z_(t,e,i,n,s,r){const a=t.geometry.attributes.position;G_.fromBufferAttribute(a,s),H_.fromBufferAttribute(a,r);if(i.distanceSqToSegment(G_,H_,q_,$_)>n)return;q_.applyMatrix4(t.matrixWorld);const o=e.ray.origin.distanceTo(q_);return o<e.near||o>e.far?void 0:{distance:o,point:$_.clone().applyMatrix4(t.matrixWorld),index:s,face:null,faceIndex:null,barycoord:null,object:t}}const K_=new ix,J_=new ix;class Q_ extends Y_{constructor(t,e){super(t,e),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(null===t.index){const e=t.attributes.position,i=[];for(let t=0,n=e.count;t<n;t+=2)K_.fromBufferAttribute(e,t),J_.fromBufferAttribute(e,t+1),i[t]=0===t?0:i[t-1],i[t+1]=i[t]+K_.distanceTo(J_);t.setAttribute("lineDistance",new zv(i,1))}return this}}class ty extends Ev{static get type(){return"PointsMaterial"}constructor(t){super(),this.isPointsMaterial=!0,this.color=new Tv(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}class ey extends Zg{constructor(t,e,i,n,s,r,a,o,l){super(t,e,i,n,s,r,a,o,l),this.isVideoTexture=!0,this.minFilter=void 0!==r?r:pf,this.magFilter=void 0!==s?s:pf,this.generateMipmaps=!1;const h=this;"requestVideoFrameCallback"in t&&t.requestVideoFrameCallback((function e(){h.needsUpdate=!0,t.requestVideoFrameCallback(e)}))}clone(){return new this.constructor(this.image).copy(this)}update(){const t=this.image;!1==="requestVideoFrameCallback"in t&&t.readyState>=t.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}class iy extends Zg{constructor(t,e){super({width:t,height:e}),this.isFramebufferTexture=!0,this.magFilter=cf,this.minFilter=cf,this.generateMipmaps=!1,this.needsUpdate=!0}}class ny extends Zg{constructor(t,e,i,n,s,r,a,o,l){super(t,e,i,n,s,r,a,o,l),this.isCanvasTexture=!0,this.needsUpdate=!0}}class sy extends Zg{constructor(t,e,i,n,s,r,a,o,l,h=1026){if(h!==Ef&&h!==Cf)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===i&&h===Ef&&(i=bf),void 0===i&&h===Cf&&(i=Tf),super(null,n,s,r,a,o,h,i,l),this.isDepthTexture=!0,this.image={width:t,height:e},this.magFilter=void 0!==a?a:cf,this.minFilter=void 0!==o?o:cf,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(t){return super.copy(t),this.compareFunction=t.compareFunction,this}toJSON(t){const e=super.toJSON(t);return null!==this.compareFunction&&(e.compareFunction=this.compareFunction),e}}class ry extends qv{constructor(t=1,e=1,i=1,n=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:i,heightSegments:n};const s=t/2,r=e/2,a=Math.floor(i),o=Math.floor(n),l=a+1,h=o+1,c=t/a,u=e/o,d=[],p=[],m=[],f=[];for(let g=0;g<h;g++){const t=g*u-r;for(let e=0;e<l;e++){const i=e*c-s;p.push(i,-t,0),m.push(0,0,1),f.push(e/a),f.push(1-g/o)}}for(let g=0;g<o;g++)for(let t=0;t<a;t++){const e=t+l*g,i=t+l*(g+1),n=t+1+l*(g+1),s=t+1+l*g;d.push(e,i,s),d.push(i,n,s)}this.setIndex(d),this.setAttribute("position",new zv(p,3)),this.setAttribute("normal",new zv(m,3)),this.setAttribute("uv",new zv(f,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new ry(t.width,t.height,t.widthSegments,t.heightSegments)}}class ay extends qv{constructor(t=1,e=32,i=16,n=0,s=2*Math.PI,r=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:e,heightSegments:i,phiStart:n,phiLength:s,thetaStart:r,thetaLength:a},e=Math.max(3,Math.floor(e)),i=Math.max(2,Math.floor(i));const o=Math.min(r+a,Math.PI);let l=0;const h=[],c=new ix,u=new ix,d=[],p=[],m=[],f=[];for(let g=0;g<=i;g++){const d=[],x=g/i;let v=0;0===g&&0===r?v=.5/e:g===i&&o===Math.PI&&(v=-.5/e);for(let i=0;i<=e;i++){const o=i/e;c.x=-t*Math.cos(n+o*s)*Math.sin(r+x*a),c.y=t*Math.cos(r+x*a),c.z=t*Math.sin(n+o*s)*Math.sin(r+x*a),p.push(c.x,c.y,c.z),u.copy(c).normalize(),m.push(u.x,u.y,u.z),f.push(o+v,1-x),d.push(l++)}h.push(d)}for(let g=0;g<i;g++)for(let t=0;t<e;t++){const e=h[g][t+1],n=h[g][t],s=h[g+1][t],a=h[g+1][t+1];(0!==g||r>0)&&d.push(e,n,a),(g!==i-1||o<Math.PI)&&d.push(n,s,a)}this.setIndex(d),this.setAttribute("position",new zv(p,3)),this.setAttribute("normal",new zv(m,3)),this.setAttribute("uv",new zv(f,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new ay(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength)}}class oy extends Ev{static get type(){return"ShadowMaterial"}constructor(t){super(),this.isShadowMaterial=!0,this.color=new Tv(0),this.transparent=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.fog=t.fog,this}}class ly extends Ev{static get type(){return"MeshStandardMaterial"}constructor(t){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.color=new Tv(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Tv(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Pg(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Gx,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.envMapIntensity=t.envMapIntensity,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class hy extends ly{static get type(){return"MeshPhysicalMaterial"}constructor(t){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Pg(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return wg(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new Tv(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new Tv(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Tv(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._dispersion=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(t)}get anisotropy(){return this._anisotropy}set anisotropy(t){this._anisotropy>0!=t>0&&this.version++,this._anisotropy=t}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get iridescence(){return this._iridescence}set iridescence(t){this._iridescence>0!=t>0&&this.version++,this._iridescence=t}get dispersion(){return this._dispersion}set dispersion(t){this._dispersion>0!=t>0&&this.version++,this._dispersion=t}get sheen(){return this._sheen}set sheen(t){this._sheen>0!=t>0&&this.version++,this._sheen=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=t.anisotropy,this.anisotropyRotation=t.anisotropyRotation,this.anisotropyMap=t.anisotropyMap,this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.dispersion=t.dispersion,this.ior=t.ior,this.iridescence=t.iridescence,this.iridescenceMap=t.iridescenceMap,this.iridescenceIOR=t.iridescenceIOR,this.iridescenceThicknessRange=[...t.iridescenceThicknessRange],this.iridescenceThicknessMap=t.iridescenceThicknessMap,this.sheen=t.sheen,this.sheenColor.copy(t.sheenColor),this.sheenColorMap=t.sheenColorMap,this.sheenRoughness=t.sheenRoughness,this.sheenRoughnessMap=t.sheenRoughnessMap,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationColor.copy(t.attenuationColor),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularColor.copy(t.specularColor),this.specularColorMap=t.specularColorMap,this}}class cy extends Ev{static get type(){return"MeshPhongMaterial"}constructor(t){super(),this.isMeshPhongMaterial=!0,this.color=new Tv(16777215),this.specular=new Tv(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Tv(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Pg(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Gx,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class uy extends Ev{static get type(){return"MeshToonMaterial"}constructor(t){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.color=new Tv(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Tv(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Pg(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.gradientMap=t.gradientMap,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}class dy extends Ev{static get type(){return"MeshNormalMaterial"}constructor(t){super(),this.isMeshNormalMaterial=!0,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Pg(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this}}class py extends Ev{static get type(){return"MeshLambertMaterial"}constructor(t){super(),this.isMeshLambertMaterial=!0,this.color=new Tv(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Tv(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Pg(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Gx,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class my extends Ev{static get type(){return"MeshMatcapMaterial"}constructor(t){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.color=new Tv(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Pg(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={MATCAP:""},this.color.copy(t.color),this.matcap=t.matcap,this.map=t.map,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.flatShading=t.flatShading,this.fog=t.fog,this}}class fy extends V_{static get type(){return"LineDashedMaterial"}constructor(t){super(),this.isLineDashedMaterial=!0,this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}copy(t){return super.copy(t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this}}const gy={enabled:!1,files:{},add:function(t,e){!1!==this.enabled&&(this.files[t]=e)},get:function(t){if(!1!==this.enabled)return this.files[t]},remove:function(t){delete this.files[t]},clear:function(){this.files={}}};class xy{constructor(t,e,i){const n=this;let s,r=!1,a=0,o=0;const l=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=i,this.itemStart=function(t){o++,!1===r&&void 0!==n.onStart&&n.onStart(t,a,o),r=!0},this.itemEnd=function(t){a++,void 0!==n.onProgress&&n.onProgress(t,a,o),a===o&&(r=!1,void 0!==n.onLoad&&n.onLoad())},this.itemError=function(t){void 0!==n.onError&&n.onError(t)},this.resolveURL=function(t){return s?s(t):t},this.setURLModifier=function(t){return s=t,this},this.addHandler=function(t,e){return l.push(t,e),this},this.removeHandler=function(t){const e=l.indexOf(t);return-1!==e&&l.splice(e,2),this},this.getHandler=function(t){for(let e=0,i=l.length;e<i;e+=2){const i=l[e],n=l[e+1];if(i.global&&(i.lastIndex=0),i.test(t))return n}return null}}}const vy=new xy;class _y{constructor(t){this.manager=void 0!==t?t:vy,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const i=this;return new Promise((function(n,s){i.load(t,n,e,s)}))}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}_y.DEFAULT_MATERIAL_NAME="__DEFAULT";class yy extends _y{constructor(t){super(t)}load(t,e,i,n){void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const s=this,r=gy.get(t);if(void 0!==r)return s.manager.itemStart(t),setTimeout((function(){e&&e(r),s.manager.itemEnd(t)}),0),r;const a=Dg("img");function o(){h(),gy.add(t,this),e&&e(this),s.manager.itemEnd(t)}function l(e){h(),n&&n(e),s.manager.itemError(t),s.manager.itemEnd(t)}function h(){a.removeEventListener("load",o,!1),a.removeEventListener("error",l,!1)}return a.addEventListener("load",o,!1),a.addEventListener("error",l,!1),"data:"!==t.slice(0,5)&&void 0!==this.crossOrigin&&(a.crossOrigin=this.crossOrigin),s.manager.itemStart(t),a.src=t,a}}class by extends _y{constructor(t){super(t)}load(t,e,i,n){const s=new Zg,r=new yy(this.manager);return r.setCrossOrigin(this.crossOrigin),r.setPath(this.path),r.load(t,(function(t){s.image=t,s.needsUpdate=!0,void 0!==e&&e(s)}),i,n),s}}class Sy extends rv{constructor(t,e=1){super(),this.isLight=!0,this.type="Light",this.color=new Tv(t),this.intensity=e}dispose(){}copy(t,e){return super.copy(t,e),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,void 0!==this.groundColor&&(e.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(e.object.distance=this.distance),void 0!==this.angle&&(e.object.angle=this.angle),void 0!==this.decay&&(e.object.decay=this.decay),void 0!==this.penumbra&&(e.object.penumbra=this.penumbra),void 0!==this.shadow&&(e.object.shadow=this.shadow.toJSON()),void 0!==this.target&&(e.object.target=this.target.uuid),e}}class My extends Sy{constructor(t,e,i){super(t,i),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(rv.DEFAULT_UP),this.updateMatrix(),this.groundColor=new Tv(e)}copy(t,e){return super.copy(t,e),this.groundColor.copy(t.groundColor),this}}const Ty=new Ix,wy=new ix,Ay=new ix;class Ey{constructor(t){this.camera=t,this.intensity=1,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Pg(512,512),this.map=null,this.mapPass=null,this.matrix=new Ix,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new k_,this._frameExtents=new Pg(1,1),this._viewportCount=1,this._viewports=[new Kg(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,i=this.matrix;wy.setFromMatrixPosition(t.matrixWorld),e.position.copy(wy),Ay.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(Ay),e.updateMatrixWorld(),Ty.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Ty),i.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),i.multiply(Ty)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.intensity=t.intensity,this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return(new this.constructor).copy(this)}toJSON(){const t={};return 1!==this.intensity&&(t.intensity=this.intensity),0!==this.bias&&(t.bias=this.bias),0!==this.normalBias&&(t.normalBias=this.normalBias),1!==this.radius&&(t.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class Cy extends Ey{constructor(){super(new m_(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(t){const e=this.camera,i=2*Mg*t.angle*this.focus,n=this.mapSize.width/this.mapSize.height,s=t.distance||e.far;i===e.fov&&n===e.aspect&&s===e.far||(e.fov=i,e.aspect=n,e.far=s,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}class Ry extends Sy{constructor(t,e,i=0,n=Math.PI/3,s=0,r=2){super(t,e),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(rv.DEFAULT_UP),this.updateMatrix(),this.target=new rv,this.distance=i,this.angle=n,this.penumbra=s,this.decay=r,this.map=null,this.shadow=new Cy}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}const Ny=new Ix,Py=new ix,Iy=new ix;class Ly extends Ey{constructor(){super(new m_(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new Pg(4,2),this._viewportCount=6,this._viewports=[new Kg(2,1,1,1),new Kg(0,1,1,1),new Kg(3,1,1,1),new Kg(1,1,1,1),new Kg(3,0,1,1),new Kg(1,0,1,1)],this._cubeDirections=[new ix(1,0,0),new ix(-1,0,0),new ix(0,0,1),new ix(0,0,-1),new ix(0,1,0),new ix(0,-1,0)],this._cubeUps=[new ix(0,1,0),new ix(0,1,0),new ix(0,1,0),new ix(0,1,0),new ix(0,0,1),new ix(0,0,-1)]}updateMatrices(t,e=0){const i=this.camera,n=this.matrix,s=t.distance||i.far;s!==i.far&&(i.far=s,i.updateProjectionMatrix()),Py.setFromMatrixPosition(t.matrixWorld),i.position.copy(Py),Iy.copy(i.position),Iy.add(this._cubeDirections[e]),i.up.copy(this._cubeUps[e]),i.lookAt(Iy),i.updateMatrixWorld(),n.makeTranslation(-Py.x,-Py.y,-Py.z),Ny.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Ny)}}class Dy extends Sy{constructor(t,e,i=0,n=2){super(t,e),this.isPointLight=!0,this.type="PointLight",this.distance=i,this.decay=n,this.shadow=new Ly}get power(){return 4*this.intensity*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}class Uy extends c_{constructor(t=-1,e=1,i=1,n=-1,s=.1,r=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=i,this.bottom=n,this.near=s,this.far=r,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=null===t.view?null:Object.assign({},t.view),this}setViewOffset(t,e,i,n,s,r){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=i,this.view.offsetY=n,this.view.width=s,this.view.height=r,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),i=(this.right+this.left)/2,n=(this.top+this.bottom)/2;let s=i-t,r=i+t,a=n+e,o=n-e;if(null!==this.view&&this.view.enabled){const t=(this.right-this.left)/this.view.fullWidth/this.zoom,e=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=t*this.view.offsetX,r=s+t*this.view.width,a-=e*this.view.offsetY,o=a-e*this.view.height}this.projectionMatrix.makeOrthographic(s,r,a,o,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,null!==this.view&&(e.object.view=Object.assign({},this.view)),e}}class Fy extends Ey{constructor(){super(new Uy(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class By extends Sy{constructor(t,e){super(t,e),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(rv.DEFAULT_UP),this.updateMatrix(),this.target=new rv,this.shadow=new Fy}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}class Oy extends Sy{constructor(t,e){super(t,e),this.isAmbientLight=!0,this.type="AmbientLight"}}class zy extends Sy{constructor(t,e,i=10,n=10){super(t,e),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=i,this.height=n}get power(){return this.intensity*this.width*this.height*Math.PI}set power(t){this.intensity=t/(this.width*this.height*Math.PI)}copy(t){return super.copy(t),this.width=t.width,this.height=t.height,this}toJSON(t){const e=super.toJSON(t);return e.object.width=this.width,e.object.height=this.height,e}}class ky{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new ix)}set(t){for(let e=0;e<9;e++)this.coefficients[e].copy(t[e]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,e){const i=t.x,n=t.y,s=t.z,r=this.coefficients;return e.copy(r[0]).multiplyScalar(.282095),e.addScaledVector(r[1],.488603*n),e.addScaledVector(r[2],.488603*s),e.addScaledVector(r[3],.488603*i),e.addScaledVector(r[4],i*n*1.092548),e.addScaledVector(r[5],n*s*1.092548),e.addScaledVector(r[6],.315392*(3*s*s-1)),e.addScaledVector(r[7],i*s*1.092548),e.addScaledVector(r[8],.546274*(i*i-n*n)),e}getIrradianceAt(t,e){const i=t.x,n=t.y,s=t.z,r=this.coefficients;return e.copy(r[0]).multiplyScalar(.886227),e.addScaledVector(r[1],1.023328*n),e.addScaledVector(r[2],1.023328*s),e.addScaledVector(r[3],1.023328*i),e.addScaledVector(r[4],.858086*i*n),e.addScaledVector(r[5],.858086*n*s),e.addScaledVector(r[6],.743125*s*s-.247708),e.addScaledVector(r[7],.858086*i*s),e.addScaledVector(r[8],.429043*(i*i-n*n)),e}add(t){for(let e=0;e<9;e++)this.coefficients[e].add(t.coefficients[e]);return this}addScaledSH(t,e){for(let i=0;i<9;i++)this.coefficients[i].addScaledVector(t.coefficients[i],e);return this}scale(t){for(let e=0;e<9;e++)this.coefficients[e].multiplyScalar(t);return this}lerp(t,e){for(let i=0;i<9;i++)this.coefficients[i].lerp(t.coefficients[i],e);return this}equals(t){for(let e=0;e<9;e++)if(!this.coefficients[e].equals(t.coefficients[e]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return(new this.constructor).copy(this)}fromArray(t,e=0){const i=this.coefficients;for(let n=0;n<9;n++)i[n].fromArray(t,e+3*n);return this}toArray(t=[],e=0){const i=this.coefficients;for(let n=0;n<9;n++)i[n].toArray(t,e+3*n);return t}static getBasisAt(t,e){const i=t.x,n=t.y,s=t.z;e[0]=.282095,e[1]=.488603*n,e[2]=.488603*s,e[3]=.488603*i,e[4]=1.092548*i*n,e[5]=1.092548*n*s,e[6]=.315392*(3*s*s-1),e[7]=1.092548*i*s,e[8]=.546274*(i*i-n*n)}}class Vy extends Sy{constructor(t=new ky,e=1){super(void 0,e),this.isLightProbe=!0,this.sh=t}copy(t){return super.copy(t),this.sh.copy(t.sh),this}fromJSON(t){return this.intensity=t.intensity,this.sh.fromArray(t.sh),this}toJSON(t){const e=super.toJSON(t);return e.object.sh=this.sh.toArray(),e}}class Gy{constructor(t=!0){this.autoStart=t,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=Hy(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let t=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const e=Hy();t=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=t}return t}}function Hy(){return performance.now()}class Wy extends y_{constructor(t,e,i=1){super(t,e),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=i}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}clone(t){const e=super.clone(t);return e.meshPerAttribute=this.meshPerAttribute,e}toJSON(t){const e=super.toJSON(t);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}}class jy extends r_{constructor(t,e,i){super(new ay(e,4,2),new Cv({wireframe:!0,fog:!1,toneMapped:!1})),this.light=t,this.color=i,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),void 0!==this.color?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}class Xy extends Q_{constructor(t=10,e=10,i=4473924,n=8947848){i=new Tv(i),n=new Tv(n);const s=e/2,r=t/e,a=t/2,o=[],l=[];for(let c=0,u=0,d=-a;c<=e;c++,d+=r){o.push(-a,0,d,a,0,d),o.push(d,0,-a,d,0,a);const t=c===s?i:n;t.toArray(l,u),u+=3,t.toArray(l,u),u+=3,t.toArray(l,u),u+=3,t.toArray(l,u),u+=3}const h=new qv;h.setAttribute("position",new zv(o,3)),h.setAttribute("color",new zv(l,3));super(h,new V_({vertexColors:!0,toneMapped:!1})),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}const qy=new ix,$y=new ix,Yy=new ix;class Zy extends rv{constructor(t,e,i){super(),this.light=t,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=i,this.type="DirectionalLightHelper",void 0===e&&(e=1);let n=new qv;n.setAttribute("position",new zv([-e,e,0,e,e,0,e,-e,0,-e,-e,0,-e,e,0],3));const s=new V_({fog:!1,toneMapped:!1});this.lightPlane=new Y_(n,s),this.add(this.lightPlane),n=new qv,n.setAttribute("position",new zv([0,0,0,0,0,1],3)),this.targetLine=new Y_(n,s),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),qy.setFromMatrixPosition(this.light.matrixWorld),$y.setFromMatrixPosition(this.light.target.matrixWorld),Yy.subVectors($y,qy),this.lightPlane.lookAt($y),void 0!==this.color?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt($y),this.targetLine.scale.z=Yy.length()}}class Ky extends Q_{constructor(t=1){const e=[0,0,0,t,0,0,0,0,0,0,t,0,0,0,0,0,0,t],i=new qv;i.setAttribute("position",new zv(e,3)),i.setAttribute("color",new zv([1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],3));super(i,new V_({vertexColors:!0,toneMapped:!1})),this.type="AxesHelper"}setColors(t,e,i){const n=new Tv,s=this.geometry.attributes.color.array;return n.set(t),n.toArray(s,0),n.toArray(s,3),n.set(e),n.toArray(s,6),n.toArray(s,9),n.set(i),n.toArray(s,12),n.toArray(s,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}const Jy=["alphaMap","alphaTest","anisotropy","anisotropyMap","anisotropyRotation","aoMap","attenuationColor","attenuationDistance","bumpMap","clearcoat","clearcoatMap","clearcoatNormalMap","clearcoatNormalScale","clearcoatRoughness","color","dispersion","displacementMap","emissive","emissiveMap","envMap","gradientMap","ior","iridescence","iridescenceIOR","iridescenceMap","iridescenceThicknessMap","lightMap","map","matcap","metalness","metalnessMap","normalMap","normalScale","opacity","roughness","roughnessMap","sheen","sheenColor","sheenColorMap","sheenRoughnessMap","shininess","specular","specularColor","specularColorMap","specularIntensity","specularIntensityMap","specularMap","thickness","transmission","transmissionMap"];class Qy{constructor(t){this.renderObjects=new WeakMap,this.hasNode=this.containsNode(t),this.hasAnimation=!0===t.object.isSkinnedMesh,this.refreshUniforms=Jy,this.renderId=0}firstInitialization(t){return!1===this.renderObjects.has(t)&&(this.getRenderObjectData(t),!0)}getRenderObjectData(t){let e=this.renderObjects.get(t);if(void 0===e){const{geometry:i,material:n}=t;if(e={material:this.getMaterialData(n),geometry:{attributes:this.getAttributesData(i.attributes),indexVersion:i.index?i.index.version:null,drawRange:{start:i.drawRange.start,count:i.drawRange.count}},worldMatrix:t.object.matrixWorld.clone()},t.object.center&&(e.center=t.object.center.clone()),t.object.morphTargetInfluences&&(e.morphTargetInfluences=t.object.morphTargetInfluences.slice()),null!==t.bundle&&(e.version=t.bundle.version),e.material.transmission>0){const{width:i,height:n}=t.context;e.bufferWidth=i,e.bufferHeight=n}this.renderObjects.set(t,e)}return e}getAttributesData(t){const e={};for(const i in t){const n=t[i];e[i]={version:n.version}}return e}containsNode(t){const e=t.material;for(const i in e)if(e[i]&&e[i].isNode)return!0;return null!==t.renderer.nodes.modelViewMatrix||null!==t.renderer.nodes.modelNormalViewMatrix}getMaterialData(t){const e={};for(const i of this.refreshUniforms){const n=t[i];null!=n&&("object"==typeof n&&void 0!==n.clone?!0===n.isTexture?e[i]={id:n.id,version:n.version}:e[i]=n.clone():e[i]=n)}return e}equals(t){const{object:e,material:i,geometry:n}=t,s=this.getRenderObjectData(t);if(!0!==s.worldMatrix.equals(e.matrixWorld))return s.worldMatrix.copy(e.matrixWorld),!1;const r=s.material;for(const m in r){const t=r[m],e=i[m];if(void 0!==t.equals){if(!1===t.equals(e))return t.copy(e),!1}else if(!0===e.isTexture){if(t.id!==e.id||t.version!==e.version)return t.id=e.id,t.version=e.version,!1}else if(t!==e)return r[m]=e,!1}if(r.transmission>0){const{width:e,height:i}=t.context;if(s.bufferWidth!==e||s.bufferHeight!==i)return s.bufferWidth=e,s.bufferHeight=i,!1}const a=s.geometry,o=n.attributes,l=a.attributes,h=Object.keys(l),c=Object.keys(o);if(h.length!==c.length)return s.geometry.attributes=this.getAttributesData(o),!1;for(const m of h){const t=l[m],e=o[m];if(void 0===e)return delete l[m],!1;if(t.version!==e.version)return t.version=e.version,!1}const u=n.index,d=a.indexVersion,p=u?u.version:null;if(d!==p)return a.indexVersion=p,!1;if(a.drawRange.start!==n.drawRange.start||a.drawRange.count!==n.drawRange.count)return a.drawRange.start=n.drawRange.start,a.drawRange.count=n.drawRange.count,!1;if(s.morphTargetInfluences){let t=!1;for(let i=0;i<s.morphTargetInfluences.length;i++)s.morphTargetInfluences[i]!==e.morphTargetInfluences[i]&&(t=!0);if(t)return!0}return s.center&&!1===s.center.equals(e.center)?(s.center.copy(e.center),!0):(null!==t.bundle&&(s.version=t.bundle.version),!0)}needsRefresh(t,e){if(this.hasNode||this.hasAnimation||this.firstInitialization(t))return!0;const{renderId:i}=e;if(this.renderId!==i)return this.renderId=i,!0;const n=!0===t.object.static,s=null!==t.bundle&&!0===t.bundle.static&&this.getRenderObjectData(t).version===t.bundle.version;if(n||s)return!1;return!0!==this.equals(t)}}function tb(t,e=0){let i=3735928559^e,n=1103547991^e;if(t instanceof Array)for(let s,r=0;r<t.length;r++)s=t[r],i=Math.imul(i^s,2654435761),n=Math.imul(n^s,1597334677);else for(let s,r=0;r<t.length;r++)s=t.charCodeAt(r),i=Math.imul(i^s,2654435761),n=Math.imul(n^s,1597334677);return i=Math.imul(i^i>>>16,2246822507),i^=Math.imul(n^n>>>13,3266489909),n=Math.imul(n^n>>>16,2246822507),n^=Math.imul(i^i>>>13,3266489909),4294967296*(2097151&n)+(i>>>0)}const eb=t=>tb(t),ib=(...t)=>tb(t);function nb(t,e=!1){const i=[];!0===t.isNode&&(i.push(t.id),t=t.getSelf());for(const{property:n,childNode:s}of sb(t))i.push(i,tb(n.slice(0,-4)),s.getCacheKey(e));return tb(i)}function*sb(t,e=!1){for(const i in t){if(!0===i.startsWith("_"))continue;const n=t[i];if(!0===Array.isArray(n))for(let t=0;t<n.length;t++){const s=n[t];s&&(!0===s.isNode||e&&"function"==typeof s.toJSON)&&(yield{property:i,index:t,childNode:s})}else if(n&&!0===n.isNode)yield{property:i,childNode:n};else if("object"==typeof n)for(const t in n){const s=n[t];s&&(!0===s.isNode||e&&"function"==typeof s.toJSON)&&(yield{property:i,index:t,childNode:s})}}}function rb(t){if(null==t)return null;const e=typeof t;return!0===t.isNode?"node":"number"===e?"float":"boolean"===e?"bool":"string"===e?"string":"function"===e?"shader":!0===t.isVector2?"vec2":!0===t.isVector3?"vec3":!0===t.isVector4?"vec4":!0===t.isMatrix3?"mat3":!0===t.isMatrix4?"mat4":!0===t.isColor?"color":t instanceof ArrayBuffer?"ArrayBuffer":null}function ab(t,...e){const i=t?t.slice(-4):void 0;return 1===e.length&&("vec2"===i?e=[e[0],e[0]]:"vec3"===i?e=[e[0],e[0],e[0]]:"vec4"===i&&(e=[e[0],e[0],e[0],e[0]])),"color"===t?new Tv(...e):"vec2"===i?new Pg(...e):"vec3"===i?new ix(...e):"vec4"===i?new Kg(...e):"mat3"===i?new Ig(...e):"mat4"===i?new Ix(...e):"bool"===t?e[0]||!1:"float"===t||"int"===t||"uint"===t?e[0]||0:"string"===t?e[0]||"":"ArrayBuffer"===t?(n=e[0],Uint8Array.from(atob(n),(t=>t.charCodeAt(0))).buffer):null;var n}const ob="vertex",lb="none",hb="frame",cb="render",ub="object",db=["setup","analyze","generate"],pb=["fragment","vertex","compute"],mb=["x","y","z","w"];let fb=0;class gb extends _g{static get type(){return"Node"}constructor(t=null){super(),this.nodeType=t,this.updateType=lb,this.updateBeforeType=lb,this.updateAfterType=lb,this.uuid=Ng.generateUUID(),this.version=0,this._cacheKey=null,this._cacheKeyVersion=0,this.global=!1,this.isNode=!0,Object.defineProperty(this,"id",{value:fb++})}set needsUpdate(t){!0===t&&this.version++}get type(){return this.constructor.type}onUpdate(t,e){return this.updateType=e,this.update=t.bind(this.getSelf()),this}onFrameUpdate(t){return this.onUpdate(t,hb)}onRenderUpdate(t){return this.onUpdate(t,cb)}onObjectUpdate(t){return this.onUpdate(t,ub)}onReference(t){return this.updateReference=t.bind(this.getSelf()),this}getSelf(){return this.self||this}updateReference(){return this}isGlobal(){return this.global}*getChildren(){for(const{childNode:t}of sb(this))yield t}dispose(){this.dispatchEvent({type:"dispose"})}traverse(t){t(this);for(const e of this.getChildren())e.traverse(t)}getCacheKey(t=!1){return!0!==(t=t||this.version!==this._cacheKeyVersion)&&null!==this._cacheKey||(this._cacheKey=nb(this,t),this._cacheKeyVersion=this.version),this._cacheKey}getScope(){return this}getHash(){return this.uuid}getUpdateType(){return this.updateType}getUpdateBeforeType(){return this.updateBeforeType}getUpdateAfterType(){return this.updateAfterType}getElementType(t){const e=this.getNodeType(t);return t.getElementType(e)}getNodeType(t){const e=t.getNodeProperties(this);return e.outputNode?e.outputNode.getNodeType(t):this.nodeType}getShared(t){const e=this.getHash(t);return t.getNodeFromHash(e)||this}setup(t){const e=t.getNodeProperties(this);let i=0;for(const n of this.getChildren())e["node"+i++]=n;return null}analyze(t){if(1===t.increaseUsage(this)){const e=t.getNodeProperties(this);for(const i of Object.values(e))i&&!0===i.isNode&&i.build(t)}}generate(t,e){const{outputNode:i}=t.getNodeProperties(this);if(i&&!0===i.isNode)return i.build(t,e)}updateBefore(){}updateAfter(){}update(){}build(t,e=null){const i=this.getShared(t);if(this!==i)return i.build(t,e);t.addNode(this),t.addChain(this);let n=null;const s=t.getBuildStage();if("setup"===s){this.updateReference(t);const e=t.getNodeProperties(this);if(!0!==e.initialized){t.stack.nodes.length;e.initialized=!0,e.outputNode=this.setup(t),null!==e.outputNode&&t.stack.nodes.length;for(const i of Object.values(e))i&&!0===i.isNode&&i.build(t)}}else if("analyze"===s)this.analyze(t);else if("generate"===s){if(1===this.generate.length){const i=this.getNodeType(t),s=t.getDataFromNode(this);n=s.snippet,void 0===n?(n=this.generate(t)||"",s.snippet=n):void 0!==s.flowCodes&&void 0!==t.context.nodeBlock&&t.addFlowCodeHierarchy(this,t.context.nodeBlock),n=t.format(n,i,e)}else n=this.generate(t,e)||""}return t.removeChain(this),t.addSequentialNode(this),n}getSerializeChildren(){return sb(this)}serialize(t){const e=this.getSerializeChildren(),i={};for(const{property:n,index:s,childNode:r}of e)void 0!==s?(void 0===i[n]&&(i[n]=Number.isInteger(s)?[]:{}),i[n][s]=r.toJSON(t.meta).uuid):i[n]=r.toJSON(t.meta).uuid;Object.keys(i).length>0&&(t.inputNodes=i)}deserialize(t){if(void 0!==t.inputNodes){const e=t.meta.nodes;for(const i in t.inputNodes)if(Array.isArray(t.inputNodes[i])){const n=[];for(const s of t.inputNodes[i])n.push(e[s]);this[i]=n}else if("object"==typeof t.inputNodes[i]){const n={};for(const s in t.inputNodes[i]){const r=t.inputNodes[i][s];n[s]=e[r]}this[i]=n}else{const n=t.inputNodes[i];this[i]=e[n]}}}toJSON(t){const{uuid:e,type:i}=this,n=void 0===t||"string"==typeof t;n&&(t={textures:{},images:{},nodes:{}});let s=t.nodes[e];function r(t){const e=[];for(const i in t){const n=t[i];delete n.metadata,e.push(n)}return e}if(void 0===s&&(s={uuid:e,type:i,meta:t,metadata:{version:4.6,type:"Node",generator:"Node.toJSON"}},!0!==n&&(t.nodes[s.uuid]=s),this.serialize(s),delete s.meta),n){const e=r(t.textures),i=r(t.images),n=r(t.nodes);e.length>0&&(s.textures=e),i.length>0&&(s.images=i),n.length>0&&(s.nodes=n)}return s}}class xb extends gb{static get type(){return"ArrayElementNode"}constructor(t,e){super(),this.node=t,this.indexNode=e,this.isArrayElementNode=!0}getNodeType(t){return this.node.getElementType(t)}generate(t){return`${this.node.build(t)}[ ${this.indexNode.build(t,"uint")} ]`}}class vb extends gb{static get type(){return"ConvertNode"}constructor(t,e){super(),this.node=t,this.convertTo=e}getNodeType(t){const e=this.node.getNodeType(t);let i=null;for(const n of this.convertTo.split("|"))null!==i&&t.getTypeLength(e)!==t.getTypeLength(n)||(i=n);return i}serialize(t){super.serialize(t),t.convertTo=this.convertTo}deserialize(t){super.deserialize(t),this.convertTo=t.convertTo}generate(t,e){const i=this.node,n=this.getNodeType(t),s=i.build(t,n);return t.format(s,n,e)}}class _b extends gb{static get type(){return"TempNode"}constructor(t){super(t),this.isTempNode=!0}hasDependencies(t){return t.getDataFromNode(this).usageCount>1}build(t,e){if("generate"===t.getBuildStage()){const i=t.getVectorType(this.getNodeType(t,e)),n=t.getDataFromNode(this);if(void 0!==n.propertyName)return t.format(n.propertyName,i,e);if("void"!==i&&"void"!==e&&this.hasDependencies(t)){const s=super.build(t,i),r=t.getVarFromNode(this,null,i),a=t.getPropertyName(r);return t.addLineFlowCode(`${a} = ${s}`,this),n.snippet=s,n.propertyName=a,t.format(n.propertyName,i,e)}}return super.build(t,e)}}class yb extends _b{static get type(){return"JoinNode"}constructor(t=[],e=null){super(e),this.nodes=t}getNodeType(t){return null!==this.nodeType?t.getVectorType(this.nodeType):t.getTypeFromLength(this.nodes.reduce(((e,i)=>e+t.getTypeLength(i.getNodeType(t))),0))}generate(t,e){const i=this.getNodeType(t),n=this.nodes,s=t.getComponentType(i),r=[];for(const o of n){let e=o.build(t);const i=t.getComponentType(o.getNodeType(t));i!==s&&(e=t.format(e,i,s)),r.push(e)}const a=`${t.getType(i)}( ${r.join(", ")} )`;return t.format(a,i,e)}}const bb=mb.join("");class Sb extends gb{static get type(){return"SplitNode"}constructor(t,e="x"){super(),this.node=t,this.components=e,this.isSplitNode=!0}getVectorLength(){let t=this.components.length;for(const e of this.components)t=Math.max(mb.indexOf(e)+1,t);return t}getComponentType(t){return t.getComponentType(this.node.getNodeType(t))}getNodeType(t){return t.getTypeFromLength(this.components.length,this.getComponentType(t))}generate(t,e){const i=this.node,n=t.getTypeLength(i.getNodeType(t));let s=null;if(n>1){let r=null;this.getVectorLength()>=n&&(r=t.getTypeFromLength(this.getVectorLength(),this.getComponentType(t)));const a=i.build(t,r);s=this.components.length===n&&this.components===bb.slice(0,this.components.length)?t.format(a,r,e):t.format(`${a}.${this.components}`,this.getNodeType(t),e)}else s=i.build(t,e);return s}serialize(t){super.serialize(t),t.components=this.components}deserialize(t){super.deserialize(t),this.components=t.components}}class Mb extends _b{static get type(){return"SetNode"}constructor(t,e,i){super(),this.sourceNode=t,this.components=e,this.targetNode=i}getNodeType(t){return this.sourceNode.getNodeType(t)}generate(t){const{sourceNode:e,components:i,targetNode:n}=this,s=this.getNodeType(t),r=t.getTypeFromLength(i.length,n.getNodeType(t)),a=n.build(t,r),o=e.build(t,s),l=t.getTypeLength(s),h=[];for(let c=0;c<l;c++){const t=mb[c];t===i[0]?(h.push(a),c+=i.length-1):h.push(o+"."+t)}return`${t.getType(s)}( ${h.join(", ")} )`}}class Tb extends _b{static get type(){return"FlipNode"}constructor(t,e){super(),this.sourceNode=t,this.components=e}getNodeType(t){return this.sourceNode.getNodeType(t)}generate(t){const{components:e,sourceNode:i}=this,n=this.getNodeType(t),s=i.build(t),r=t.getVarFromNode(this),a=t.getPropertyName(r);t.addLineFlowCode(a+" = "+s,this);const o=t.getTypeLength(n),l=[];let h=0;for(let c=0;c<o;c++){const t=mb[c];t===e[h]?(l.push("1.0 - "+a+"."+t),h++):l.push(a+"."+t)}return`${t.getType(n)}( ${l.join(", ")} )`}}class wb extends gb{static get type(){return"InputNode"}constructor(t,e=null){super(e),this.isInputNode=!0,this.value=t,this.precision=null}getNodeType(){return null===this.nodeType?rb(this.value):this.nodeType}getInputType(t){return this.getNodeType(t)}setPrecision(t){return this.precision=t,this}serialize(t){super.serialize(t),t.value=this.value,this.value&&this.value.toArray&&(t.value=this.value.toArray()),t.valueType=rb(this.value),t.nodeType=this.nodeType,"ArrayBuffer"===t.valueType&&(t.value=function(t){let e="";const i=new Uint8Array(t);for(let n=0;n<i.length;n++)e+=String.fromCharCode(i[n]);return btoa(e)}(t.value)),t.precision=this.precision}deserialize(t){super.deserialize(t),this.nodeType=t.nodeType,this.value=Array.isArray(t.value)?ab(t.valueType,...t.value):t.value,this.precision=t.precision||null,this.value&&this.value.fromArray&&(this.value=this.value.fromArray(t.value))}generate(){}}class Ab extends wb{static get type(){return"ConstNode"}constructor(t,e=null){super(t,e),this.isConstNode=!0}generateConst(t){return t.generateConst(this.getNodeType(t),this.value)}generate(t,e){const i=this.getNodeType(t);return t.format(this.generateConst(t),i,e)}}let Eb=null;const Cb=new Map;function Rb(t,e){if(!Cb.has(t)){if("function"!=typeof e)throw new Error(`Node element ${t} is not a function`);Cb.set(t,e)}}const Nb=t=>t.replace(/r|s/g,"x").replace(/g|t/g,"y").replace(/b|p/g,"z").replace(/a|q/g,"w"),Pb=t=>Nb(t).split("").sort().join(""),Ib={setup(t,e){const i=e.shift();return t(iS(i),...e)},get(t,e,i){if("string"==typeof e&&void 0===t[e]){if(!0!==t.isStackNode&&"assign"===e)return(...t)=>(Eb.assign(i,...t),i);if(Cb.has(e)){const n=Cb.get(e);return t.isStackNode?(...t)=>i.add(n(...t)):(...t)=>n(i,...t)}if("self"===e)return t;if(e.endsWith("Assign")&&Cb.has(e.slice(0,e.length-6))){const n=Cb.get(e.slice(0,e.length-6));return t.isStackNode?(...t)=>i.assign(t[0],n(...t)):(...t)=>i.assign(n(i,...t))}if(!0===/^[xyzwrgbastpq]{1,4}$/.test(e))return e=Nb(e),eS(new Sb(i,e));if(!0===/^set[XYZWRGBASTPQ]{1,4}$/.test(e))return e=Pb(e.slice(3).toLowerCase()),i=>eS(new Mb(t,e,i));if(!0===/^flip[XYZWRGBASTPQ]{1,4}$/.test(e))return e=Pb(e.slice(4).toLowerCase()),()=>eS(new Tb(eS(t),e));if("width"===e||"height"===e||"depth"===e)return"width"===e?e="x":"height"===e?e="y":"depth"===e&&(e="z"),eS(new Sb(t,e));if(!0===/^\d+$/.test(e))return eS(new xb(i,new Ab(Number(e),"uint")))}return Reflect.get(t,e,i)},set:(t,e,i,n)=>"string"!=typeof e||void 0!==t[e]||!0!==/^[xyzwrgbastpq]{1,4}$/.test(e)&&"width"!==e&&"height"!==e&&"depth"!==e&&!0!==/^\d+$/.test(e)?Reflect.set(t,e,i,n):(n[e].assign(i),!0)},Lb=new WeakMap,Db=new WeakMap,Ub=function(t,e=null){for(const i in t)t[i]=eS(t[i],e);return t},Fb=function(t,e=null){const i=t.length;for(let n=0;n<i;n++)t[n]=eS(t[n],e);return t},Bb=function(t,e=null,i=null,n=null){const s=t=>eS(null!==n?Object.assign(t,n):t);return null===e?(...e)=>s(new t(...nS(e))):null!==i?(i=eS(i),(...n)=>s(new t(e,...nS(n),i))):(...i)=>s(new t(e,...nS(i)))},Ob=function(t,...e){return eS(new t(...nS(e)))};class zb extends gb{constructor(t,e){super(),this.shaderNode=t,this.inputNodes=e}getNodeType(t){return this.shaderNode.nodeType||this.getOutputNode(t).getNodeType(t)}call(t){const{shaderNode:e,inputNodes:i}=this,n=t.getNodeProperties(e);if(n.onceOutput)return n.onceOutput;let s=null;if(e.layout){let n=Db.get(t.constructor);void 0===n&&(n=new WeakMap,Db.set(t.constructor,n));let r=n.get(e);void 0===r&&(r=eS(t.buildFunctionNode(e)),n.set(e,r)),null!==t.currentFunctionNode&&t.currentFunctionNode.includes.push(r),s=eS(r.call(i))}else{const n=e.jsFunc,r=null!==i?n(i,t):n(t);s=eS(r)}return e.once&&(n.onceOutput=s),s}getOutputNode(t){const e=t.getNodeProperties(this);return null===e.outputNode&&(e.outputNode=this.setupOutput(t)),e.outputNode}setup(t){return this.getOutputNode(t)}setupOutput(t){return t.addStack(),t.stack.outputNode=this.call(t),t.removeStack()}generate(t,e){return this.getOutputNode(t).build(t,e)}}class kb extends gb{constructor(t,e){super(e),this.jsFunc=t,this.layout=null,this.global=!0,this.once=!1}setLayout(t){return this.layout=t,this}call(t=null){return iS(t),eS(new zb(this,t))}setup(){return this.call()}}const Vb=[!1,!0],Gb=[0,1,2,3],Hb=[-1,-2],Wb=[.5,1.5,1/3,1e-6,1e6,Math.PI,2*Math.PI,1/Math.PI,2/Math.PI,1/(2*Math.PI),Math.PI/2],jb=new Map;for(const FF of Vb)jb.set(FF,new Ab(FF));const Xb=new Map;for(const FF of Gb)Xb.set(FF,new Ab(FF,"uint"));const qb=new Map([...Xb].map((t=>new Ab(t.value,"int"))));for(const FF of Hb)qb.set(FF,new Ab(FF,"int"));const $b=new Map([...qb].map((t=>new Ab(t.value))));for(const FF of Wb)$b.set(FF,new Ab(FF));for(const FF of Wb)$b.set(-FF,new Ab(-FF));const Yb={bool:jb,uint:Xb,ints:qb,float:$b},Zb=new Map([...jb,...$b]),Kb=(t,e)=>Zb.has(t)?Zb.get(t):!0===t.isNode?t:new Ab(t,e),Jb=function(t,e=null){return(...i)=>{if((0===i.length||!["bool","float","int","uint"].includes(t)&&i.every((t=>"object"!=typeof t)))&&(i=[ab(t,...i)]),1===i.length&&null!==e&&e.has(i[0]))return eS(e.get(i[0]));if(1===i.length){const e=Kb(i[0],t);return(t=>{try{return t.getNodeType()}catch(e){return}})(e)===t?eS(e):eS(new vb(e,t))}const n=i.map((t=>Kb(t)));return eS(new yb(n,t))}},Qb=t=>"object"==typeof t&&null!==t?t.value:t;function tS(t,e){return new Proxy(new kb(t,e),Ib)}const eS=(t,e=null)=>function(t,e=null){const i=rb(t);if("node"===i){let e=Lb.get(t);return void 0===e&&(e=new Proxy(t,Ib),Lb.set(t,e),Lb.set(e,e)),e}return null===e&&("float"===i||"boolean"===i)||i&&"shader"!==i&&"string"!==i?eS(Kb(t,e)):"shader"===i?aS(t):t}(t,e),iS=(t,e=null)=>new Ub(t,e),nS=(t,e=null)=>new Fb(t,e),sS=(...t)=>new Bb(...t),rS=(...t)=>new Ob(...t),aS=(t,e)=>{const i=new tS(t,e),n=(...t)=>{let e;return iS(t),e=t[0]&&t[0].isNode?[...t]:t[0],i.call(e)};return n.shaderNode=i,n.setLayout=t=>(i.setLayout(t),n),n.once=()=>(i.once=!0,n),n};Rb("toGlobal",(t=>(t.global=!0,t)));const oS=t=>{Eb=t},lS=()=>Eb,hS=(...t)=>Eb.If(...t);Rb("append",(function(t){return Eb&&Eb.add(t),t}));const cS=new Jb("color"),uS=new Jb("float",Yb.float),dS=new Jb("int",Yb.ints),pS=new Jb("uint",Yb.uint),mS=new Jb("bool",Yb.bool),fS=new Jb("vec2"),gS=new Jb("ivec2"),xS=new Jb("uvec2"),vS=new Jb("bvec2"),_S=new Jb("vec3"),yS=new Jb("ivec3"),bS=new Jb("uvec3"),SS=new Jb("bvec3"),MS=new Jb("vec4"),TS=new Jb("ivec4"),wS=new Jb("uvec4"),AS=new Jb("bvec4"),ES=new Jb("mat2"),CS=new Jb("mat3"),RS=new Jb("mat4");Rb("toColor",cS),Rb("toFloat",uS),Rb("toInt",dS),Rb("toUint",pS),Rb("toBool",mS),Rb("toVec2",fS),Rb("toIVec2",gS),Rb("toUVec2",xS),Rb("toBVec2",vS),Rb("toVec3",_S),Rb("toIVec3",yS),Rb("toUVec3",bS),Rb("toBVec3",SS),Rb("toVec4",MS),Rb("toIVec4",TS),Rb("toUVec4",wS),Rb("toBVec4",AS),Rb("toMat2",ES),Rb("toMat3",CS),Rb("toMat4",RS);Rb("element",sS(xb)),Rb("convert",((t,e)=>eS(new vb(eS(t),e))));class NS extends gb{static get type(){return"UniformGroupNode"}constructor(t,e=!1,i=1){super("string"),this.name=t,this.version=0,this.shared=e,this.order=i,this.isUniformGroup=!0}set needsUpdate(t){!0===t&&this.version++}serialize(t){super.serialize(t),t.name=this.name,t.version=this.version,t.shared=this.shared}deserialize(t){super.deserialize(t),this.name=t.name,this.version=t.version,this.shared=t.shared}}const PS=t=>new NS(t),IS=(t,e=0)=>new NS(t,!0,e),LS=IS("frame"),DS=IS("render"),US=PS("object");class FS extends wb{static get type(){return"UniformNode"}constructor(t,e=null){super(t,e),this.isUniformNode=!0,this.name="",this.groupNode=US}label(t){return this.name=t,this}setGroup(t){return this.groupNode=t,this}getGroup(){return this.groupNode}getUniformHash(t){return this.getHash(t)}onUpdate(t,e){const i=this.getSelf();return t=t.bind(i),super.onUpdate((e=>{const n=t(e,i);void 0!==n&&(this.value=n)}),e)}generate(t,e){const i=this.getNodeType(t),n=this.getUniformHash(t);let s=t.getNodeFromHash(n);void 0===s&&(t.setHashNode(this,n),s=this);const r=s.getInputType(t),a=t.getUniformFromNode(s,r,t.shaderStage,this.name||t.context.label),o=t.getPropertyName(a);return void 0!==t.context.label&&delete t.context.label,t.format(o,i,e)}}const BS=(t,e)=>{const i=(t=>null!=t?t.nodeType||t.convertTo||("string"==typeof t?t:null):null)(e||t),n=t&&!0===t.isNode?t.node&&t.node.value||t.value:t;return eS(new FS(n,i))};class OS extends gb{static get type(){return"PropertyNode"}constructor(t,e=null,i=!1){super(t),this.name=e,this.varying=i,this.isPropertyNode=!0}getHash(t){return this.name||super.getHash(t)}isGlobal(){return!0}generate(t){let e;return!0===this.varying?(e=t.getVaryingFromNode(this,this.name),e.needsInterpolation=!0):e=t.getVarFromNode(this,this.name),t.getPropertyName(e)}}const zS=(t,e)=>eS(new OS(t,e)),kS=(t,e)=>eS(new OS(t,e,!0)),VS=rS(OS,"vec4","DiffuseColor"),GS=rS(OS,"vec3","EmissiveColor"),HS=rS(OS,"float","Roughness"),WS=rS(OS,"float","Metalness"),jS=rS(OS,"float","Clearcoat"),XS=rS(OS,"float","ClearcoatRoughness"),qS=rS(OS,"vec3","Sheen"),$S=rS(OS,"float","SheenRoughness"),YS=rS(OS,"float","Iridescence"),ZS=rS(OS,"float","IridescenceIOR"),KS=rS(OS,"float","IridescenceThickness"),JS=rS(OS,"float","AlphaT"),QS=rS(OS,"float","Anisotropy"),tM=rS(OS,"vec3","AnisotropyT"),eM=rS(OS,"vec3","AnisotropyB"),iM=rS(OS,"color","SpecularColor"),nM=rS(OS,"float","SpecularF90"),sM=rS(OS,"float","Shininess"),rM=rS(OS,"vec4","Output"),aM=rS(OS,"float","dashSize"),oM=rS(OS,"float","gapSize"),lM=rS(OS,"float","IOR"),hM=rS(OS,"float","Transmission"),cM=rS(OS,"float","Thickness"),uM=rS(OS,"float","AttenuationDistance"),dM=rS(OS,"color","AttenuationColor"),pM=rS(OS,"float","Dispersion");class mM extends _b{static get type(){return"AssignNode"}constructor(t,e){super(),this.targetNode=t,this.sourceNode=e}hasDependencies(){return!1}getNodeType(t,e){return"void"!==e?this.targetNode.getNodeType(t):"void"}needsSplitAssign(t){const{targetNode:e}=this;if(!1===t.isAvailable("swizzleAssign")&&e.isSplitNode&&e.components.length>1){const i=t.getTypeLength(e.node.getNodeType(t));return mb.join("").slice(0,i)!==e.components}return!1}generate(t,e){const{targetNode:i,sourceNode:n}=this,s=this.needsSplitAssign(t),r=i.getNodeType(t),a=i.context({assign:!0}).build(t),o=n.build(t,r),l=n.getNodeType(t),h=t.getDataFromNode(this);let c;if(!0===h.initialized)"void"!==e&&(c=a);else if(s){const n=t.getVarFromNode(this,null,r),s=t.getPropertyName(n);t.addLineFlowCode(`${s} = ${o}`,this);const l=i.node.context({assign:!0}).build(t);for(let e=0;e<i.components.length;e++){const n=i.components[e];t.addLineFlowCode(`${l}.${n} = ${s}[ ${e} ]`,this)}"void"!==e&&(c=a)}else c=`${a} = ${o}`,"void"!==e&&"void"!==l||(t.addLineFlowCode(c,this),"void"!==e&&(c=a));return h.initialized=!0,t.format(c,r,e)}}Rb("assign",sS(mM));class fM extends _b{static get type(){return"FunctionCallNode"}constructor(t=null,e={}){super(),this.functionNode=t,this.parameters=e}setParameters(t){return this.parameters=t,this}getParameters(){return this.parameters}getNodeType(t){return this.functionNode.getNodeType(t)}generate(t){const e=[],i=this.functionNode,n=i.getInputs(t),s=this.parameters,r=(e,i)=>{const n=i.type;let s;return s="pointer"===n?"&"+e.build(t):e.build(t,n),s};if(Array.isArray(s))for(let a=0;a<s.length;a++)e.push(r(s[a],n[a]));else for(const a of n){const t=s[a.name];if(void 0===t)throw new Error(`FunctionCallNode: Input '${a.name}' not found in FunctionNode.`);e.push(r(t,a))}return`${i.build(t,"property")}( ${e.join(", ")} )`}}Rb("call",((t,...e)=>(e=e.length>1||e[0]&&!0===e[0].isNode?nS(e):iS(e[0]),eS(new fM(eS(t),e)))));class gM extends _b{static get type(){return"OperatorNode"}constructor(t,e,i,...n){if(super(),n.length>0){let s=new gM(t,e,i);for(let e=0;e<n.length-1;e++)s=new gM(t,s,n[e]);e=s,i=n[n.length-1]}this.op=t,this.aNode=e,this.bNode=i}getNodeType(t,e){const i=this.op,n=this.aNode,s=this.bNode,r=n.getNodeType(t),a=void 0!==s?s.getNodeType(t):null;if("void"===r||"void"===a)return"void";if("%"===i)return r;if("~"===i||"&"===i||"|"===i||"^"===i||">>"===i||"<<"===i)return t.getIntegerType(r);if("!"===i||"=="===i||"&&"===i||"||"===i||"^^"===i)return"bool";if("<"===i||">"===i||"<="===i||">="===i){const i=e?t.getTypeLength(e):Math.max(t.getTypeLength(r),t.getTypeLength(a));return i>1?`bvec${i}`:"bool"}return"float"===r&&t.isMatrix(a)?a:t.isMatrix(r)&&t.isVector(a)?t.getVectorFromMatrix(r):t.isVector(r)&&t.isMatrix(a)?t.getVectorFromMatrix(a):t.getTypeLength(a)>t.getTypeLength(r)?a:r}generate(t,e){const i=this.op,n=this.aNode,s=this.bNode,r=this.getNodeType(t,e);let a=null,o=null;"void"!==r?(a=n.getNodeType(t),o=void 0!==s?s.getNodeType(t):null,"<"===i||">"===i||"<="===i||">="===i||"=="===i?t.isVector(a)?o=a:a!==o&&(a=o="float"):">>"===i||"<<"===i?(a=r,o=t.changeComponentType(o,"uint")):t.isMatrix(a)&&t.isVector(o)?o=t.getVectorFromMatrix(a):a=t.isVector(a)&&t.isMatrix(o)?t.getVectorFromMatrix(o):o=r):a=o=r;const l=n.build(t,a),h=void 0!==s?s.build(t,o):null,c=t.getTypeLength(e),u=t.getFunctionOperator(i);return"void"!==e?"<"===i&&c>1?t.useComparisonMethod?t.format(`${t.getMethod("lessThan",e)}( ${l}, ${h} )`,r,e):t.format(`( ${l} < ${h} )`,r,e):"<="===i&&c>1?t.useComparisonMethod?t.format(`${t.getMethod("lessThanEqual",e)}( ${l}, ${h} )`,r,e):t.format(`( ${l} <= ${h} )`,r,e):">"===i&&c>1?t.useComparisonMethod?t.format(`${t.getMethod("greaterThan",e)}( ${l}, ${h} )`,r,e):t.format(`( ${l} > ${h} )`,r,e):">="===i&&c>1?t.useComparisonMethod?t.format(`${t.getMethod("greaterThanEqual",e)}( ${l}, ${h} )`,r,e):t.format(`( ${l} >= ${h} )`,r,e):"!"===i||"~"===i?t.format(`(${i}${l})`,a,e):u?t.format(`${u}( ${l}, ${h} )`,r,e):t.format(`( ${l} ${i} ${h} )`,r,e):"void"!==a?u?t.format(`${u}( ${l}, ${h} )`,r,e):t.format(`${l} ${i} ${h}`,r,e):void 0}serialize(t){super.serialize(t),t.op=this.op}deserialize(t){super.deserialize(t),this.op=t.op}}const xM=sS(gM,"+"),vM=sS(gM,"-"),_M=sS(gM,"*"),yM=sS(gM,"/"),bM=sS(gM,"%"),SM=sS(gM,"=="),MM=sS(gM,"!="),TM=sS(gM,"<"),wM=sS(gM,">"),AM=sS(gM,"<="),EM=sS(gM,">="),CM=sS(gM,"&&"),RM=sS(gM,"||"),NM=sS(gM,"!"),PM=sS(gM,"^^"),IM=sS(gM,"&"),LM=sS(gM,"~"),DM=sS(gM,"|"),UM=sS(gM,"^"),FM=sS(gM,"<<"),BM=sS(gM,">>");Rb("add",xM),Rb("sub",vM),Rb("mul",_M),Rb("div",yM),Rb("modInt",bM),Rb("equal",SM),Rb("notEqual",MM),Rb("lessThan",TM),Rb("greaterThan",wM),Rb("lessThanEqual",AM),Rb("greaterThanEqual",EM),Rb("and",CM),Rb("or",RM),Rb("not",NM),Rb("xor",PM),Rb("bitAnd",IM),Rb("bitNot",LM),Rb("bitOr",DM),Rb("bitXor",UM),Rb("shiftLeft",FM),Rb("shiftRight",BM);Rb("remainder",((...t)=>bM(...t)));class OM extends _b{static get type(){return"MathNode"}constructor(t,e,i=null,n=null){super(),this.method=t,this.aNode=e,this.bNode=i,this.cNode=n}getInputType(t){const e=this.aNode.getNodeType(t),i=this.bNode?this.bNode.getNodeType(t):null,n=this.cNode?this.cNode.getNodeType(t):null,s=t.isMatrix(e)?0:t.getTypeLength(e),r=t.isMatrix(i)?0:t.getTypeLength(i),a=t.isMatrix(n)?0:t.getTypeLength(n);return s>r&&s>a?e:r>a?i:a>s?n:e}getNodeType(t){const e=this.method;return e===OM.LENGTH||e===OM.DISTANCE||e===OM.DOT?"float":e===OM.CROSS?"vec3":e===OM.ALL?"bool":e===OM.EQUALS?t.changeComponentType(this.aNode.getNodeType(t),"bool"):e===OM.MOD?this.aNode.getNodeType(t):this.getInputType(t)}generate(t,e){const i=this.method,n=this.getNodeType(t),s=this.getInputType(t),r=this.aNode,a=this.bNode,o=this.cNode,l=!0===t.renderer.isWebGLRenderer;if(i===OM.TRANSFORM_DIRECTION){let i=r,n=a;t.isMatrix(i.getNodeType(t))?n=MS(_S(n),0):i=MS(_S(i),0);const s=_M(i,n).xyz;return tT(s).build(t,e)}if(i===OM.NEGATE)return t.format("( - "+r.build(t,s)+" )",n,e);if(i===OM.ONE_MINUS)return vM(1,r).build(t,e);if(i===OM.RECIPROCAL)return yM(1,r).build(t,e);if(i===OM.DIFFERENCE)return lT(vM(r,a)).build(t,e);{const h=[];return i===OM.CROSS||i===OM.MOD?h.push(r.build(t,n),a.build(t,n)):l&&i===OM.STEP?h.push(r.build(t,1===t.getTypeLength(r.getNodeType(t))?"float":s),a.build(t,s)):l&&(i===OM.MIN||i===OM.MAX)||i===OM.MOD?h.push(r.build(t,s),a.build(t,1===t.getTypeLength(a.getNodeType(t))?"float":s)):i===OM.REFRACT?h.push(r.build(t,s),a.build(t,s),o.build(t,"float")):i===OM.MIX?h.push(r.build(t,s),a.build(t,s),o.build(t,1===t.getTypeLength(o.getNodeType(t))?"float":s)):(h.push(r.build(t,s)),null!==a&&h.push(a.build(t,s)),null!==o&&h.push(o.build(t,s))),t.format(`${t.getMethod(i,n)}( ${h.join(", ")} )`,n,e)}}serialize(t){super.serialize(t),t.method=this.method}deserialize(t){super.deserialize(t),this.method=t.method}}OM.ALL="all",OM.ANY="any",OM.EQUALS="equals",OM.RADIANS="radians",OM.DEGREES="degrees",OM.EXP="exp",OM.EXP2="exp2",OM.LOG="log",OM.LOG2="log2",OM.SQRT="sqrt",OM.INVERSE_SQRT="inversesqrt",OM.FLOOR="floor",OM.CEIL="ceil",OM.NORMALIZE="normalize",OM.FRACT="fract",OM.SIN="sin",OM.COS="cos",OM.TAN="tan",OM.ASIN="asin",OM.ACOS="acos",OM.ATAN="atan",OM.ABS="abs",OM.SIGN="sign",OM.LENGTH="length",OM.NEGATE="negate",OM.ONE_MINUS="oneMinus",OM.DFDX="dFdx",OM.DFDY="dFdy",OM.ROUND="round",OM.RECIPROCAL="reciprocal",OM.TRUNC="trunc",OM.FWIDTH="fwidth",OM.BITCAST="bitcast",OM.TRANSPOSE="transpose",OM.ATAN2="atan2",OM.MIN="min",OM.MAX="max",OM.MOD="mod",OM.STEP="step",OM.REFLECT="reflect",OM.DISTANCE="distance",OM.DIFFERENCE="difference",OM.DOT="dot",OM.CROSS="cross",OM.POW="pow",OM.TRANSFORM_DIRECTION="transformDirection",OM.MIX="mix",OM.CLAMP="clamp",OM.REFRACT="refract",OM.SMOOTHSTEP="smoothstep",OM.FACEFORWARD="faceforward";const zM=uS(1e-6),kM=uS(Math.PI),VM=sS(OM,OM.ALL),GM=sS(OM,OM.ANY),HM=sS(OM,OM.EQUALS),WM=sS(OM,OM.RADIANS),jM=sS(OM,OM.DEGREES),XM=sS(OM,OM.EXP),qM=sS(OM,OM.EXP2),$M=sS(OM,OM.LOG),YM=sS(OM,OM.LOG2),ZM=sS(OM,OM.SQRT),KM=sS(OM,OM.INVERSE_SQRT),JM=sS(OM,OM.FLOOR),QM=sS(OM,OM.CEIL),tT=sS(OM,OM.NORMALIZE),eT=sS(OM,OM.FRACT),iT=sS(OM,OM.SIN),nT=sS(OM,OM.COS),sT=sS(OM,OM.TAN),rT=sS(OM,OM.ASIN),aT=sS(OM,OM.ACOS),oT=sS(OM,OM.ATAN),lT=sS(OM,OM.ABS),hT=sS(OM,OM.SIGN),cT=sS(OM,OM.LENGTH),uT=sS(OM,OM.NEGATE),dT=sS(OM,OM.ONE_MINUS),pT=sS(OM,OM.DFDX),mT=sS(OM,OM.DFDY),fT=sS(OM,OM.ROUND),gT=sS(OM,OM.RECIPROCAL),xT=sS(OM,OM.TRUNC),vT=sS(OM,OM.FWIDTH);OM.BITCAST;const _T=sS(OM,OM.TRANSPOSE),yT=sS(OM,OM.ATAN2),bT=sS(OM,OM.MIN),ST=sS(OM,OM.MAX),MT=sS(OM,OM.MOD),TT=sS(OM,OM.STEP),wT=sS(OM,OM.REFLECT),AT=sS(OM,OM.DISTANCE),ET=sS(OM,OM.DIFFERENCE),CT=sS(OM,OM.DOT),RT=sS(OM,OM.CROSS),NT=sS(OM,OM.POW),PT=sS(OM,OM.POW,2),IT=sS(OM,OM.POW,3),LT=sS(OM,OM.POW,4),DT=sS(OM,OM.TRANSFORM_DIRECTION),UT=sS(OM,OM.MIX),FT=(t,e=0,i=1)=>eS(new OM(OM.CLAMP,eS(t),eS(e),eS(i))),BT=sS(OM,OM.REFRACT),OT=sS(OM,OM.SMOOTHSTEP),zT=sS(OM,OM.FACEFORWARD),kT=aS((([t])=>{const e=CT(t.xy,fS(12.9898,78.233)),i=MT(e,kM);return eT(iT(i).mul(43758.5453))}));Rb("all",VM),Rb("any",GM),Rb("equals",HM),Rb("radians",WM),Rb("degrees",jM),Rb("exp",XM),Rb("exp2",qM),Rb("log",$M),Rb("log2",YM),Rb("sqrt",ZM),Rb("inverseSqrt",KM),Rb("floor",JM),Rb("ceil",QM),Rb("normalize",tT),Rb("fract",eT),Rb("sin",iT),Rb("cos",nT),Rb("tan",sT),Rb("asin",rT),Rb("acos",aT),Rb("atan",oT),Rb("abs",lT),Rb("sign",hT),Rb("length",cT),Rb("lengthSq",(t=>CT(t,t))),Rb("negate",uT),Rb("oneMinus",dT),Rb("dFdx",pT),Rb("dFdy",mT),Rb("round",fT),Rb("reciprocal",gT),Rb("trunc",xT),Rb("fwidth",vT),Rb("atan2",yT),Rb("min",bT),Rb("max",ST),Rb("mod",MT),Rb("step",TT),Rb("reflect",wT),Rb("distance",AT),Rb("dot",CT),Rb("cross",RT),Rb("pow",NT),Rb("pow2",PT),Rb("pow3",IT),Rb("pow4",LT),Rb("transformDirection",DT),Rb("mix",((t,e,i)=>UT(e,i,t))),Rb("clamp",FT),Rb("refract",BT),Rb("smoothstep",((t,e,i)=>OT(e,i,t))),Rb("faceForward",zT),Rb("difference",ET),Rb("saturate",(t=>FT(t))),Rb("cbrt",(t=>_M(hT(t),NT(lT(t),1/3)))),Rb("transpose",_T),Rb("rand",kT);class VT extends gb{static get type(){return"ConditionalNode"}constructor(t,e,i=null){super(),this.condNode=t,this.ifNode=e,this.elseNode=i}getNodeType(t){const e=this.ifNode.getNodeType(t);if(null!==this.elseNode){const i=this.elseNode.getNodeType(t);if(t.getTypeLength(i)>t.getTypeLength(e))return i}return e}setup(t){const e=this.condNode.cache(),i=this.ifNode.cache(),n=this.elseNode?this.elseNode.cache():null,s=t.context.nodeBlock;t.getDataFromNode(i).parentNodeBlock=s,null!==n&&(t.getDataFromNode(n).parentNodeBlock=s);const r=t.getNodeProperties(this);r.condNode=e,r.ifNode=i.context({nodeBlock:i}),r.elseNode=n?n.context({nodeBlock:n}):null}generate(t,e){const i=this.getNodeType(t),n=t.getDataFromNode(this);if(void 0!==n.nodeProperty)return n.nodeProperty;const{condNode:s,ifNode:r,elseNode:a}=t.getNodeProperties(this),o="void"!==e,l=o?zS(i).build(t):"";n.nodeProperty=l;const h=s.build(t,"bool");t.addFlowCode(`\n${t.tab}if ( ${h} ) {\n\n`).addFlowTab();let c=r.build(t,i);if(c&&(c=o?l+" = "+c+";":"return "+c+";"),t.removeFlowTab().addFlowCode(t.tab+"\t"+c+"\n\n"+t.tab+"}"),null!==a){t.addFlowCode(" else {\n\n").addFlowTab();let e=a.build(t,i);e&&(e=o?l+" = "+e+";":"return "+e+";"),t.removeFlowTab().addFlowCode(t.tab+"\t"+e+"\n\n"+t.tab+"}\n\n")}else t.addFlowCode("\n\n");return t.format(l,i,e)}}const GT=sS(VT);Rb("select",GT);Rb("cond",((...t)=>GT(...t)));class HT extends gb{static get type(){return"ContextNode"}constructor(t,e={}){super(),this.isContextNode=!0,this.node=t,this.value=e}getScope(){return this.node.getScope()}getNodeType(t){return this.node.getNodeType(t)}analyze(t){this.node.build(t)}setup(t){const e=t.getContext();t.setContext({...t.context,...this.value});const i=this.node.build(t);return t.setContext(e),i}generate(t,e){const i=t.getContext();t.setContext({...t.context,...this.value});const n=this.node.build(t,e);return t.setContext(i),n}}const WT=sS(HT);Rb("context",WT),Rb("label",((t,e)=>WT(t,{label:e})));class jT extends gb{static get type(){return"VarNode"}constructor(t,e=null){super(),this.node=t,this.name=e,this.global=!0,this.isVarNode=!0}getHash(t){return this.name||super.getHash(t)}getNodeType(t){return this.node.getNodeType(t)}generate(t){const{node:e,name:i}=this,n=t.getVarFromNode(this,i,t.getVectorType(this.getNodeType(t))),s=t.getPropertyName(n),r=e.build(t,n.type);return t.addLineFlowCode(`${s} = ${r}`,this),s}}const XT=sS(jT);Rb("toVar",((...t)=>XT(...t).append()));Rb("temp",(t=>XT(t)));class qT extends gb{static get type(){return"VaryingNode"}constructor(t,e=null){super(),this.node=t,this.name=e,this.isVaryingNode=!0}isGlobal(){return!0}getHash(t){return this.name||super.getHash(t)}getNodeType(t){return this.node.getNodeType(t)}setupVarying(t){const e=t.getNodeProperties(this);let i=e.varying;if(void 0===i){const n=this.name,s=this.getNodeType(t);e.varying=i=t.getVaryingFromNode(this,n,s),e.node=this.node}return i.needsInterpolation||(i.needsInterpolation="fragment"===t.shaderStage),i}setup(t){this.setupVarying(t)}analyze(t){return this.setupVarying(t),this.node.analyze(t)}generate(t){const e=t.getNodeProperties(this),i=this.setupVarying(t);if(void 0===e.propertyName){const n=this.getNodeType(t),s=t.getPropertyName(i,ob);t.flowNodeFromShaderStage(ob,this.node,n,s),e.propertyName=s}return t.getPropertyName(i)}}const $T=sS(qT);Rb("varying",$T);const YT=aS((([t])=>{const e=t.mul(.9478672986).add(.0521327014).pow(2.4),i=t.mul(.0773993808),n=t.lessThanEqual(.04045);return UT(e,i,n)})).setLayout({name:"sRGBTransferEOTF",type:"vec3",inputs:[{name:"color",type:"vec3"}]}),ZT=aS((([t])=>{const e=t.pow(.41666).mul(1.055).sub(.055),i=t.mul(12.92),n=t.lessThanEqual(.0031308);return UT(e,i,n)})).setLayout({name:"sRGBTransferOETF",type:"vec3",inputs:[{name:"color",type:"vec3"}]}),KT="WorkingColorSpace",JT="OutputColorSpace";class QT extends _b{static get type(){return"ColorSpaceNode"}constructor(t,e,i){super("vec4"),this.colorNode=t,this.source=e,this.target=i}resolveColorSpace(t,e){return e===KT?Fg.workingColorSpace:e===JT?t.context.outputColorSpace||t.renderer.outputColorSpace:e}setup(t){const{colorNode:e}=this,i=this.resolveColorSpace(t,this.source),n=this.resolveColorSpace(t,this.target);let s=e;return!1!==Fg.enabled&&i!==n&&i&&n?(Fg.getTransfer(i)===rg&&(s=MS(YT(s.rgb),s.a)),Fg.getPrimaries(i)!==Fg.getPrimaries(n)&&(s=MS(CS(Fg._getMatrix(new Ig,i,n)).mul(s.rgb),s.a)),Fg.getTransfer(n)===rg&&(s=MS(ZT(s.rgb),s.a)),s):s}}const tw=(t,e)=>eS(new QT(eS(t),e,KT));Rb("toOutputColorSpace",(t=>eS(new QT(eS(t),KT,JT)))),Rb("toWorkingColorSpace",(t=>eS(new QT(eS(t),JT,KT)))),Rb("workingToColorSpace",((t,e)=>eS(new QT(eS(t),KT,e)))),Rb("colorSpaceToWorking",tw);let ew=class extends xb{static get type(){return"ReferenceElementNode"}constructor(t,e){super(t,e),this.referenceNode=t,this.isReferenceElementNode=!0}getNodeType(){return this.referenceNode.uniformType}generate(t){const e=super.generate(t),i=this.referenceNode.getNodeType(),n=this.getNodeType();return t.format(e,i,n)}};class iw extends gb{static get type(){return"ReferenceBaseNode"}constructor(t,e,i=null,n=null){super(),this.property=t,this.uniformType=e,this.object=i,this.count=n,this.properties=t.split("."),this.reference=i,this.node=null,this.group=null,this.updateType=ub}setGroup(t){return this.group=t,this}element(t){return eS(new ew(this,eS(t)))}setNodeType(t){const e=BS(null,t).getSelf();null!==this.group&&e.setGroup(this.group),this.node=e}getNodeType(t){return null===this.node&&(this.updateReference(t),this.updateValue()),this.node.getNodeType(t)}getValueFromReference(t=this.reference){const{properties:e}=this;let i=t[e[0]];for(let n=1;n<e.length;n++)i=i[e[n]];return i}updateReference(t){return this.reference=null!==this.object?this.object:t.object,this.reference}setup(){return this.updateValue(),this.node}update(){this.updateValue()}updateValue(){null===this.node&&this.setNodeType(this.uniformType);const t=this.getValueFromReference();Array.isArray(t)?this.node.array=t:this.node.value=t}}class nw extends iw{static get type(){return"RendererReferenceNode"}constructor(t,e,i=null){super(t,e,i),this.renderer=i,this.setGroup(DS)}updateReference(t){return this.reference=null!==this.renderer?this.renderer:t.renderer,this.reference}}const sw=(t,e,i)=>eS(new nw(t,e,i));class rw extends _b{static get type(){return"ToneMappingNode"}constructor(t,e=aw,i=null){super("vec3"),this.toneMapping=t,this.exposureNode=e,this.colorNode=i}getCacheKey(){return ib(super.getCacheKey(),this.toneMapping)}setup(t){const e=this.colorNode||t.context.color,i=this.toneMapping;if(0===i)return e;let n=null;const s=t.renderer.library.getToneMappingFunction(i);return n=null!==s?MS(s(e.rgb,this.exposureNode),e.a):e,n}}const aw=sw("toneMappingExposure","float");Rb("toneMapping",((t,e,i)=>((t,e,i)=>eS(new rw(t,eS(e),eS(i))))(e,i,t)));class ow extends wb{static get type(){return"BufferAttributeNode"}constructor(t,e=null,i=0,n=0){super(t,e),this.isBufferNode=!0,this.bufferType=e,this.bufferStride=i,this.bufferOffset=n,this.usage=fg,this.instanced=!1,this.attribute=null,this.global=!0,t&&!0===t.isBufferAttribute&&(this.attribute=t,this.usage=t.usage,this.instanced=t.isInstancedBufferAttribute)}getHash(t){if(0===this.bufferStride&&0===this.bufferOffset){let e=t.globalCache.getData(this.value);return void 0===e&&(e={node:this},t.globalCache.setData(this.value,e)),e.node.uuid}return this.uuid}getNodeType(t){return null===this.bufferType&&(this.bufferType=t.getTypeFromAttribute(this.attribute)),this.bufferType}setup(t){if(null!==this.attribute)return;const e=this.getNodeType(t),i=this.value,n=t.getTypeLength(e),s=this.bufferStride||n,r=this.bufferOffset,a=!0===i.isInterleavedBuffer?i:new y_(i,s),o=new S_(a,n,r);a.setUsage(this.usage),this.attribute=o,this.attribute.isInstancedBufferAttribute=this.instanced}generate(t){const e=this.getNodeType(t),i=t.getBufferAttributeFromNode(this,e),n=t.getPropertyName(i);let s=null;if("vertex"===t.shaderStage||"compute"===t.shaderStage)this.name=n,s=n;else{s=$T(this).build(t,e)}return s}getInputType(){return"bufferAttribute"}setUsage(t){return this.usage=t,this.attribute&&!0===this.attribute.isBufferAttribute&&(this.attribute.usage=t),this}setInstanced(t){return this.instanced=t,this}}const lw=(t,e,i,n)=>eS(new ow(t,e,i,n)),hw=(t,e,i,n)=>lw(t,e,i,n).setInstanced(!0),cw=(t,e,i,n)=>((t,e,i,n)=>lw(t,e,i,n).setUsage(gg))(t,e,i,n).setInstanced(!0);Rb("toAttribute",(t=>lw(t.value)));class uw extends gb{static get type(){return"ComputeNode"}constructor(t,e,i=[64]){super("void"),this.isComputeNode=!0,this.computeNode=t,this.count=e,this.workgroupSize=i,this.dispatchCount=0,this.version=1,this.updateBeforeType=ub,this.onInitFunction=null,this.updateDispatchCount()}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){!0===t&&this.version++}updateDispatchCount(){const{count:t,workgroupSize:e}=this;let i=e[0];for(let n=1;n<e.length;n++)i*=e[n];this.dispatchCount=Math.ceil(t/i)}onInit(t){return this.onInitFunction=t,this}updateBefore({renderer:t}){t.compute(this)}generate(t){const{shaderStage:e}=t;if("compute"===e){const e=this.computeNode.build(t,"void");""!==e&&t.addLineFlowCode(e,this)}}}Rb("compute",((t,e,i)=>eS(new uw(eS(t),e,i))));class dw extends gb{static get type(){return"CacheNode"}constructor(t,e=!0){super(),this.node=t,this.parent=e,this.isCacheNode=!0}getNodeType(t){return this.node.getNodeType(t)}build(t,...e){const i=t.getCache(),n=t.getCacheFromNode(this,this.parent);t.setCache(n);const s=this.node.build(t,...e);return t.setCache(i),s}}const pw=(t,...e)=>eS(new dw(eS(t),...e));Rb("cache",pw);class mw extends gb{static get type(){return"BypassNode"}constructor(t,e){super(),this.isBypassNode=!0,this.outputNode=t,this.callNode=e}getNodeType(t){return this.outputNode.getNodeType(t)}generate(t){const e=this.callNode.build(t,"void");return""!==e&&t.addLineFlowCode(e,this),this.outputNode.build(t)}}Rb("bypass",sS(mw));class fw extends gb{static get type(){return"RemapNode"}constructor(t,e,i,n=uS(0),s=uS(1)){super(),this.node=t,this.inLowNode=e,this.inHighNode=i,this.outLowNode=n,this.outHighNode=s,this.doClamp=!0}setup(){const{node:t,inLowNode:e,inHighNode:i,outLowNode:n,outHighNode:s,doClamp:r}=this;let a=t.sub(e).div(i.sub(e));return!0===r&&(a=a.clamp()),a.mul(s.sub(n)).add(n)}}const gw=sS(fw,null,null,{doClamp:!1}),xw=sS(fw);Rb("remap",gw),Rb("remapClamp",xw);class vw extends gb{static get type(){return"ExpressionNode"}constructor(t="",e="void"){super(e),this.snippet=t}generate(t,e){const i=this.getNodeType(t),n=this.snippet;if("void"!==i)return t.format(`( ${n} )`,i,e);t.addLineFlowCode(n,this)}}const _w=sS(vw);Rb("discard",(t=>(t?GT(t,_w("discard")):_w("discard")).append()));class yw extends _b{static get type(){return"RenderOutputNode"}constructor(t,e,i){super("vec4"),this.colorNode=t,this.toneMapping=e,this.outputColorSpace=i,this.isRenderOutput=!0}setup({context:t}){let e=this.colorNode||t.color;const i=(null!==this.toneMapping?this.toneMapping:t.toneMapping)||0,n=(null!==this.outputColorSpace?this.outputColorSpace:t.outputColorSpace)||eg;return 0!==i&&(e=e.toneMapping(i)),n!==eg&&n!==Fg.workingColorSpace&&(e=e.workingToColorSpace(n)),e}}Rb("renderOutput",((t,e=null,i=null)=>eS(new yw(eS(t),e,i))));class bw extends gb{static get type(){return"AttributeNode"}constructor(t,e=null){super(e),this.global=!0,this._attributeName=t}getHash(t){return this.getAttributeName(t)}getNodeType(t){let e=this.nodeType;if(null===e){const i=this.getAttributeName(t);if(t.hasGeometryAttribute(i)){const n=t.geometry.getAttribute(i);e=t.getTypeFromAttribute(n)}else e="float"}return e}setAttributeName(t){return this._attributeName=t,this}getAttributeName(){return this._attributeName}generate(t){const e=this.getAttributeName(t),i=this.getNodeType(t);if(!0===t.hasGeometryAttribute(e)){const n=t.geometry.getAttribute(e),s=t.getTypeFromAttribute(n),r=t.getAttribute(e,s);if("vertex"===t.shaderStage)return t.format(r.name,s,i);return $T(this).build(t,i)}return t.generateConst(i)}serialize(t){super.serialize(t),t.global=this.global,t._attributeName=this._attributeName}deserialize(t){super.deserialize(t),this.global=t.global,this._attributeName=t._attributeName}}const Sw=(t,e)=>eS(new bw(t,e)),Mw=t=>Sw("uv"+(t>0?t:""),"vec2");class Tw extends gb{static get type(){return"TextureSizeNode"}constructor(t,e=null){super("uvec2"),this.isTextureSizeNode=!0,this.textureNode=t,this.levelNode=e}generate(t,e){const i=this.textureNode.build(t,"property"),n=null===this.levelNode?"0":this.levelNode.build(t,"int");return t.format(`${t.getMethod("textureDimensions")}( ${i}, ${n} )`,this.getNodeType(t),e)}}const ww=sS(Tw);class Aw extends FS{static get type(){return"MaxMipLevelNode"}constructor(t){super(0),this._textureNode=t,this.updateType=hb}get textureNode(){return this._textureNode}get texture(){return this._textureNode.value}update(){const t=this.texture,e=t.images,i=e&&e.length>0?e[0]&&e[0].image||e[0]:t.image;if(i&&void 0!==i.width){const{width:t,height:e}=i;this.value=Math.log2(Math.max(t,e))}}}const Ew=sS(Aw);class Cw extends FS{static get type(){return"TextureNode"}constructor(t,e=null,i=null,n=null){super(t),this.isTextureNode=!0,this.uvNode=e,this.levelNode=i,this.biasNode=n,this.compareNode=null,this.depthNode=null,this.gradNode=null,this.sampler=!0,this.updateMatrix=!1,this.updateType=lb,this.referenceNode=null,this._value=t,this._matrixUniform=null,this.setUpdateMatrix(null===e)}set value(t){this.referenceNode?this.referenceNode.value=t:this._value=t}get value(){return this.referenceNode?this.referenceNode.value:this._value}getUniformHash(){return this.value.uuid}getNodeType(){return!0===this.value.isDepthTexture?"float":this.value.type===bf?"uvec4":this.value.type===yf?"ivec4":"vec4"}getInputType(){return"texture"}getDefaultUV(){return Mw(this.value.channel)}updateReference(){return this.value}getTransformedUV(t){return null===this._matrixUniform&&(this._matrixUniform=BS(this.value.matrix)),this._matrixUniform.mul(_S(t,1)).xy}setUpdateMatrix(t){return this.updateMatrix=t,this.updateType=t?hb:lb,this}setupUV(t,e){const i=this.value;return!t.isFlipY()||!0!==i.isRenderTargetTexture&&!0!==i.isFramebufferTexture&&!0!==i.isDepthTexture||(e=this.sampler?e.flipY():e.setY(dS(ww(this,this.levelNode).y).sub(e.y).sub(1))),e}setup(t){const e=t.getNodeProperties(this);e.referenceNode=this.referenceNode;let i=this.uvNode;null!==i&&!0!==t.context.forceUVContext||!t.context.getUV||(i=t.context.getUV(this)),i||(i=this.getDefaultUV()),!0===this.updateMatrix&&(i=this.getTransformedUV(i)),i=this.setupUV(t,i);let n=this.levelNode;null===n&&t.context.getTextureLevel&&(n=t.context.getTextureLevel(this)),e.uvNode=i,e.levelNode=n,e.biasNode=this.biasNode,e.compareNode=this.compareNode,e.gradNode=this.gradNode,e.depthNode=this.depthNode}generateUV(t,e){return e.build(t,!0===this.sampler?"vec2":"ivec2")}generateSnippet(t,e,i,n,s,r,a,o){const l=this.value;let h;return h=n?t.generateTextureLevel(l,e,i,n,r):s?t.generateTextureBias(l,e,i,s,r):o?t.generateTextureGrad(l,e,i,o,r):a?t.generateTextureCompare(l,e,i,a,r):!1===this.sampler?t.generateTextureLoad(l,e,i,r):t.generateTexture(l,e,i,r),h}generate(t,e){const i=t.getNodeProperties(this),n=this.value;if(!n||!0!==n.isTexture)throw new Error("TextureNode: Need a three.js texture.");const s=super.generate(t,"property");if("sampler"===e)return s+"_sampler";if(t.isReference(e))return s;{const r=t.getDataFromNode(this);let a=r.propertyName;if(void 0===a){const{uvNode:e,levelNode:n,biasNode:o,compareNode:l,depthNode:h,gradNode:c}=i,u=this.generateUV(t,e),d=n?n.build(t,"float"):null,p=o?o.build(t,"float"):null,m=h?h.build(t,"int"):null,f=l?l.build(t,"float"):null,g=c?[c[0].build(t,"vec2"),c[1].build(t,"vec2")]:null,x=t.getVarFromNode(this);a=t.getPropertyName(x);const v=this.generateSnippet(t,s,u,d,p,m,f,g);t.addLineFlowCode(`${a} = ${v}`,this),r.snippet=v,r.propertyName=a}let o=a;const l=this.getNodeType(t);return t.needsToWorkingColorSpace(n)&&(o=tw(_w(o,l),n.colorSpace).setup(t).build(t,l)),t.format(o,l,e)}}setSampler(t){return this.sampler=t,this}getSampler(){return this.sampler}uv(t){const e=this.clone();return e.uvNode=eS(t),e.referenceNode=this.getSelf(),eS(e)}blur(t){const e=this.clone();return e.biasNode=eS(t).mul(Ew(e)),e.referenceNode=this.getSelf(),eS(e)}level(t){const e=this.clone();return e.levelNode=eS(t),e.referenceNode=this.getSelf(),eS(e)}size(t){return ww(this,t)}bias(t){const e=this.clone();return e.biasNode=eS(t),e.referenceNode=this.getSelf(),eS(e)}compare(t){const e=this.clone();return e.compareNode=eS(t),e.referenceNode=this.getSelf(),eS(e)}grad(t,e){const i=this.clone();return i.gradNode=[eS(t),eS(e)],i.referenceNode=this.getSelf(),eS(i)}depth(t){const e=this.clone();return e.depthNode=eS(t),e.referenceNode=this.getSelf(),eS(e)}serialize(t){super.serialize(t),t.value=this.value.toJSON(t.meta).uuid,t.sampler=this.sampler,t.updateMatrix=this.updateMatrix,t.updateType=this.updateType}deserialize(t){super.deserialize(t),this.value=t.meta.textures[t.value],this.sampler=t.sampler,this.updateMatrix=t.updateMatrix,this.updateType=t.updateType}update(){const t=this.value,e=this._matrixUniform;null!==e&&(e.value=t.matrix),!0===t.matrixAutoUpdate&&t.updateMatrix()}clone(){const t=new this.constructor(this.value,this.uvNode,this.levelNode,this.biasNode);return t.sampler=this.sampler,t}}const Rw=sS(Cw),Nw=(...t)=>Rw(...t).setSampler(!1),Pw=BS("float").label("cameraNear").setGroup(DS).onRenderUpdate((({camera:t})=>t.near)),Iw=BS("float").label("cameraFar").setGroup(DS).onRenderUpdate((({camera:t})=>t.far)),Lw=BS("mat4").label("cameraProjectionMatrix").setGroup(DS).onRenderUpdate((({camera:t})=>t.projectionMatrix)),Dw=BS("mat4").label("cameraViewMatrix").setGroup(DS).onRenderUpdate((({camera:t})=>t.matrixWorldInverse)),Uw=BS(new ix).label("cameraPosition").setGroup(DS).onRenderUpdate((({camera:t},e)=>e.value.setFromMatrixPosition(t.matrixWorld)));class Fw extends gb{static get type(){return"Object3DNode"}constructor(t,e=null){super(),this.scope=t,this.object3d=e,this.updateType=ub,this._uniformNode=new FS(null)}getNodeType(){const t=this.scope;return t===Fw.WORLD_MATRIX?"mat4":t===Fw.POSITION||t===Fw.VIEW_POSITION||t===Fw.DIRECTION||t===Fw.SCALE?"vec3":void 0}update(t){const e=this.object3d,i=this._uniformNode,n=this.scope;if(n===Fw.WORLD_MATRIX)i.value=e.matrixWorld;else if(n===Fw.POSITION)i.value=i.value||new ix,i.value.setFromMatrixPosition(e.matrixWorld);else if(n===Fw.SCALE)i.value=i.value||new ix,i.value.setFromMatrixScale(e.matrixWorld);else if(n===Fw.DIRECTION)i.value=i.value||new ix,e.getWorldDirection(i.value);else if(n===Fw.VIEW_POSITION){const n=t.camera;i.value=i.value||new ix,i.value.setFromMatrixPosition(e.matrixWorld),i.value.applyMatrix4(n.matrixWorldInverse)}}generate(t){const e=this.scope;return e===Fw.WORLD_MATRIX?this._uniformNode.nodeType="mat4":e!==Fw.POSITION&&e!==Fw.VIEW_POSITION&&e!==Fw.DIRECTION&&e!==Fw.SCALE||(this._uniformNode.nodeType="vec3"),this._uniformNode.build(t)}serialize(t){super.serialize(t),t.scope=this.scope}deserialize(t){super.deserialize(t),this.scope=t.scope}}Fw.WORLD_MATRIX="worldMatrix",Fw.POSITION="position",Fw.SCALE="scale",Fw.VIEW_POSITION="viewPosition",Fw.DIRECTION="direction",Fw.DIRECTION,Fw.WORLD_MATRIX,Fw.POSITION,Fw.SCALE,Fw.VIEW_POSITION;class Bw extends Fw{static get type(){return"ModelNode"}constructor(t){super(t)}update(t){this.object3d=t.object,super.update(t)}}const Ow=rS(Bw,Bw.WORLD_MATRIX),zw=BS(new Ig).onObjectUpdate((({object:t},e)=>e.value.getNormalMatrix(t.matrixWorld))),kw=Dw.mul(Ow).toVar("modelViewMatrix"),Vw=Sw("position","vec3"),Gw=Vw.varying("positionLocal"),Hw=Vw.varying("positionPrevious"),Ww=Ow.mul(Gw).xyz.varying("v_positionWorld"),jw=Gw.transformDirection(Ow).varying("v_positionWorldDirection").normalize().toVar("positionWorldDirection"),Xw=kw.mul(Gw).xyz.varying("v_positionView"),qw=Xw.negate().varying("v_positionViewDirection").normalize().toVar("positionViewDirection");class $w extends gb{static get type(){return"FrontFacingNode"}constructor(){super("bool"),this.isFrontFacingNode=!0}generate(t){const{renderer:e,material:i}=t;return e.coordinateSystem===xg&&1===i.side?"false":t.getFrontFacing()}}const Yw=uS(rS($w)).mul(2).sub(1),Zw=Sw("normal","vec3"),Kw=aS((t=>!1===t.geometry.hasAttribute("normal")?_S(0,1,0):Zw),"vec3").once()().toVar("normalLocal"),Jw=Xw.dFdx().cross(Xw.dFdy()).normalize().toVar("normalFlat"),Qw=aS((t=>{let e;return e=!0===t.material.flatShading?Jw:$T(rA(Kw),"v_normalView").normalize(),e}),"vec3").once()().toVar("normalView"),tA=$T(Qw.transformDirection(Dw),"v_normalWorld").normalize().toVar("normalWorld"),eA=aS((t=>t.context.setupNormal()),"vec3").once()().mul(Yw).toVar("transformedNormalView"),iA=eA.transformDirection(Dw).toVar("transformedNormalWorld"),nA=aS((t=>t.context.setupClearcoatNormal()),"vec3").once()().mul(Yw).toVar("transformedClearcoatNormalView"),sA=aS((([t,e=Ow])=>{const i=CS(e),n=t.div(_S(i[0].dot(i[0]),i[1].dot(i[1]),i[2].dot(i[2])));return i.mul(n).xyz})),rA=aS((([t],e)=>{const i=e.renderer.nodes.modelNormalViewMatrix;if(null!==i)return i.transformDirection(t);const n=zw.mul(t);return Dw.transformDirection(n)})),aA=BS(0).onReference((({material:t})=>t)).onRenderUpdate((({material:t})=>t.refractionRatio)),oA=qw.negate().reflect(eA),lA=qw.negate().refract(eA,aA),hA=oA.transformDirection(Dw).toVar("reflectVector"),cA=lA.transformDirection(Dw).toVar("reflectVector");class uA extends Cw{static get type(){return"CubeTextureNode"}constructor(t,e=null,i=null,n=null){super(t,e,i,n),this.isCubeTextureNode=!0}getInputType(){return"cubeTexture"}getDefaultUV(){const t=this.value;return t.mapping===nf?hA:t.mapping===sf?cA:_S(0,0,0)}setUpdateMatrix(){}setupUV(t,e){const i=this.value;return t.renderer.coordinateSystem!==vg&&i.isRenderTargetTexture?e:_S(e.x.negate(),e.yz)}generateUV(t,e){return e.build(t,"vec3")}}const dA=sS(uA);class pA extends FS{static get type(){return"BufferNode"}constructor(t,e,i=0){super(t,e),this.isBufferNode=!0,this.bufferType=e,this.bufferCount=i}getElementType(t){return this.getNodeType(t)}getInputType(){return"buffer"}}const mA=(t,e,i)=>eS(new pA(t,e,i));class fA extends xb{static get type(){return"UniformArrayElementNode"}constructor(t,e){super(t,e),this.isArrayBufferElementNode=!0}generate(t){const e=super.generate(t),i=this.getNodeType();return t.format(e,"vec4",i)}}class gA extends pA{static get type(){return"UniformArrayNode"}constructor(t,e=null){super(null,"vec4"),this.array=t,this.elementType=e,this._elementType=null,this._elementLength=0,this.updateType=cb,this.isArrayBufferNode=!0}getElementType(){return this.elementType||this._elementType}getElementLength(){return this._elementLength}update(){const{array:t,value:e}=this,i=this.getElementLength(),n=this.getElementType();if(1===i)for(let s=0;s<t.length;s++){e[4*s]=t[s]}else if("color"===n)for(let s=0;s<t.length;s++){const i=4*s,n=t[s];e[i]=n.r,e[i+1]=n.g,e[i+2]=n.b||0}else for(let s=0;s<t.length;s++){const i=4*s,n=t[s];e[i]=n.x,e[i+1]=n.y,e[i+2]=n.z||0,e[i+3]=n.w||0}}setup(t){const e=this.array.length;this._elementType=null===this.elementType?rb(this.array[0]):this.elementType,this._elementLength=t.getTypeLength(this._elementType);let i=Float32Array;return"i"===this._elementType.charAt(0)?i=Int32Array:"u"===this._elementType.charAt(0)&&(i=Uint32Array),this.value=new i(4*e),this.bufferCount=e,this.bufferType=t.changeComponentType("vec4",t.getComponentType(this._elementType)),super.setup(t)}element(t){return eS(new fA(this,eS(t)))}}const xA=(t,e)=>eS(new gA(t,e));class vA extends xb{static get type(){return"ReferenceElementNode"}constructor(t,e){super(t,e),this.referenceNode=t,this.isReferenceElementNode=!0}getNodeType(){return this.referenceNode.uniformType}generate(t){const e=super.generate(t),i=this.referenceNode.getNodeType(),n=this.getNodeType();return t.format(e,i,n)}}class _A extends gb{static get type(){return"ReferenceNode"}constructor(t,e,i=null,n=null){super(),this.property=t,this.uniformType=e,this.object=i,this.count=n,this.properties=t.split("."),this.reference=i,this.node=null,this.group=null,this.name=null,this.updateType=ub}element(t){return eS(new vA(this,eS(t)))}setGroup(t){return this.group=t,this}label(t){return this.name=t,this}setNodeType(t){let e=null;e=null!==this.count?mA(null,t,this.count):Array.isArray(this.getValueFromReference())?xA(null,t):"texture"===t?Rw(null):"cubeTexture"===t?dA(null):BS(null,t),null!==this.group&&e.setGroup(this.group),null!==this.name&&e.label(this.name),this.node=e.getSelf()}getNodeType(t){return null===this.node&&(this.updateReference(t),this.updateValue()),this.node.getNodeType(t)}getValueFromReference(t=this.reference){const{properties:e}=this;let i=t[e[0]];for(let n=1;n<e.length;n++)i=i[e[n]];return i}updateReference(t){return this.reference=null!==this.object?this.object:t.object,this.reference}setup(){return this.updateValue(),this.node}update(){this.updateValue()}updateValue(){null===this.node&&this.setNodeType(this.uniformType);const t=this.getValueFromReference();Array.isArray(t)?this.node.array=t:this.node.value=t}}const yA=(t,e,i)=>eS(new _A(t,e,i)),bA=(t,e,i,n)=>eS(new _A(t,e,n,i));class SA extends _A{static get type(){return"MaterialReferenceNode"}constructor(t,e,i=null){super(t,e,i),this.material=i,this.isMaterialReferenceNode=!0}updateReference(t){return this.reference=null!==this.material?this.material:t.material,this.reference}}const MA=(t,e,i)=>eS(new SA(t,e,i)),TA=aS((t=>(!1===t.geometry.hasAttribute("tangent")&&t.geometry.computeTangents(),Sw("tangent","vec4"))))(),wA=TA.xyz.toVar("tangentLocal"),AA=kw.mul(MS(wA,0)).xyz.varying("v_tangentView").normalize().toVar("tangentView");var EA;const CA=CS(AA,$T((EA=Qw.cross(AA),EA.mul(TA.w).xyz),"v_bitangentView").normalize().toVar("bitangentView"),Qw),RA=(()=>{let t=eM.cross(qw);return t=t.cross(eM).normalize(),t=UT(t,eA,QS.mul(HS.oneMinus()).oneMinus().pow2().pow2()).normalize(),t})(),NA=aS((t=>{const{eye_pos:e,surf_norm:i,mapN:n,uv:s}=t,r=e.dFdx(),a=e.dFdy(),o=s.dFdx(),l=s.dFdy(),h=i,c=a.cross(h),u=h.cross(r),d=c.mul(o.x).add(u.mul(l.x)),p=c.mul(o.y).add(u.mul(l.y)),m=d.dot(d).max(p.dot(p)),f=Yw.mul(m.inverseSqrt());return xM(d.mul(n.x,f),p.mul(n.y,f),h.mul(n.z)).normalize()}));class PA extends _b{static get type(){return"NormalMapNode"}constructor(t,e=null){super("vec3"),this.node=t,this.scaleNode=e,this.normalMapType=0}setup(t){const{normalMapType:e,scaleNode:i}=this;let n=this.node.mul(2).sub(1);null!==i&&(n=_S(n.xy.mul(i),n.z));let s=null;if(1===e)s=rA(n);else if(0===e){s=!0===t.hasGeometryAttribute("tangent")?CA.mul(n).normalize():NA({eye_pos:Xw,surf_norm:Qw,mapN:n,uv:Mw()})}return s}}const IA=sS(PA),LA=aS((({textureNode:t,bumpScale:e})=>{const i=e=>t.cache().context({getUV:t=>e(t.uvNode||Mw()),forceUVContext:!0}),n=uS(i((t=>t)));return fS(uS(i((t=>t.add(t.dFdx())))).sub(n),uS(i((t=>t.add(t.dFdy())))).sub(n)).mul(e)})),DA=aS((t=>{const{surf_pos:e,surf_norm:i,dHdxy:n}=t,s=e.dFdx().normalize(),r=i,a=e.dFdy().normalize().cross(r),o=r.cross(s),l=s.dot(a).mul(Yw),h=l.sign().mul(n.x.mul(a).add(n.y.mul(o)));return l.abs().mul(i).sub(h).normalize()}));class UA extends _b{static get type(){return"BumpMapNode"}constructor(t,e=null){super("vec3"),this.textureNode=t,this.scaleNode=e}setup(){const t=null!==this.scaleNode?this.scaleNode:1,e=LA({textureNode:this.textureNode,bumpScale:t});return DA({surf_pos:Xw,surf_norm:Qw,dHdxy:e})}}const FA=sS(UA),BA=new Map;class OA extends gb{static get type(){return"MaterialNode"}constructor(t){super(),this.scope=t}getCache(t,e){let i=BA.get(t);return void 0===i&&(i=MA(t,e),BA.set(t,i)),i}getFloat(t){return this.getCache(t,"float")}getColor(t){return this.getCache(t,"color")}getTexture(t){return this.getCache("map"===t?"map":t+"Map","texture")}setup(t){const e=t.context.material,i=this.scope;let n=null;if(i===OA.COLOR){const t=void 0!==e.color?this.getColor(i):_S();n=e.map&&!0===e.map.isTexture?t.mul(this.getTexture("map")):t}else if(i===OA.OPACITY){const t=this.getFloat(i);n=e.alphaMap&&!0===e.alphaMap.isTexture?t.mul(this.getTexture("alpha")):t}else if(i===OA.SPECULAR_STRENGTH)n=e.specularMap&&!0===e.specularMap.isTexture?this.getTexture("specular").r:uS(1);else if(i===OA.SPECULAR_INTENSITY){const t=this.getFloat(i);n=e.specularMap?t.mul(this.getTexture(i).a):t}else if(i===OA.SPECULAR_COLOR){const t=this.getColor(i);n=e.specularColorMap&&!0===e.specularColorMap.isTexture?t.mul(this.getTexture(i).rgb):t}else if(i===OA.ROUGHNESS){const t=this.getFloat(i);n=e.roughnessMap&&!0===e.roughnessMap.isTexture?t.mul(this.getTexture(i).g):t}else if(i===OA.METALNESS){const t=this.getFloat(i);n=e.metalnessMap&&!0===e.metalnessMap.isTexture?t.mul(this.getTexture(i).b):t}else if(i===OA.EMISSIVE){const t=this.getFloat("emissiveIntensity"),s=this.getColor(i).mul(t);n=e.emissiveMap&&!0===e.emissiveMap.isTexture?s.mul(this.getTexture(i)):s}else if(i===OA.NORMAL)e.normalMap?(n=IA(this.getTexture("normal"),this.getCache("normalScale","vec2")),n.normalMapType=e.normalMapType):n=e.bumpMap?FA(this.getTexture("bump").r,this.getFloat("bumpScale")):Qw;else if(i===OA.CLEARCOAT){const t=this.getFloat(i);n=e.clearcoatMap&&!0===e.clearcoatMap.isTexture?t.mul(this.getTexture(i).r):t}else if(i===OA.CLEARCOAT_ROUGHNESS){const t=this.getFloat(i);n=e.clearcoatRoughnessMap&&!0===e.clearcoatRoughnessMap.isTexture?t.mul(this.getTexture(i).r):t}else if(i===OA.CLEARCOAT_NORMAL)n=e.clearcoatNormalMap?IA(this.getTexture(i),this.getCache(i+"Scale","vec2")):Qw;else if(i===OA.SHEEN){const t=this.getColor("sheenColor").mul(this.getFloat("sheen"));n=e.sheenColorMap&&!0===e.sheenColorMap.isTexture?t.mul(this.getTexture("sheenColor").rgb):t}else if(i===OA.SHEEN_ROUGHNESS){const t=this.getFloat(i);n=e.sheenRoughnessMap&&!0===e.sheenRoughnessMap.isTexture?t.mul(this.getTexture(i).a):t,n=n.clamp(.07,1)}else if(i===OA.ANISOTROPY)if(e.anisotropyMap&&!0===e.anisotropyMap.isTexture){const t=this.getTexture(i);n=ES(_E.x,_E.y,_E.y.negate(),_E.x).mul(t.rg.mul(2).sub(fS(1)).normalize().mul(t.b))}else n=_E;else if(i===OA.IRIDESCENCE_THICKNESS){const t=yA("1","float",e.iridescenceThicknessRange);if(e.iridescenceThicknessMap){const s=yA("0","float",e.iridescenceThicknessRange);n=t.sub(s).mul(this.getTexture(i).g).add(s)}else n=t}else if(i===OA.TRANSMISSION){const t=this.getFloat(i);n=e.transmissionMap?t.mul(this.getTexture(i).r):t}else if(i===OA.THICKNESS){const t=this.getFloat(i);n=e.thicknessMap?t.mul(this.getTexture(i).g):t}else if(i===OA.IOR)n=this.getFloat(i);else if(i===OA.LIGHT_MAP)n=this.getTexture(i).rgb.mul(this.getFloat("lightMapIntensity"));else if(i===OA.AO_MAP)n=this.getTexture(i).r.sub(1).mul(this.getFloat("aoMapIntensity")).add(1);else{const e=this.getNodeType(t);n=this.getCache(i,e)}return n}}OA.ALPHA_TEST="alphaTest",OA.COLOR="color",OA.OPACITY="opacity",OA.SHININESS="shininess",OA.SPECULAR="specular",OA.SPECULAR_STRENGTH="specularStrength",OA.SPECULAR_INTENSITY="specularIntensity",OA.SPECULAR_COLOR="specularColor",OA.REFLECTIVITY="reflectivity",OA.ROUGHNESS="roughness",OA.METALNESS="metalness",OA.NORMAL="normal",OA.CLEARCOAT="clearcoat",OA.CLEARCOAT_ROUGHNESS="clearcoatRoughness",OA.CLEARCOAT_NORMAL="clearcoatNormal",OA.EMISSIVE="emissive",OA.ROTATION="rotation",OA.SHEEN="sheen",OA.SHEEN_ROUGHNESS="sheenRoughness",OA.ANISOTROPY="anisotropy",OA.IRIDESCENCE="iridescence",OA.IRIDESCENCE_IOR="iridescenceIOR",OA.IRIDESCENCE_THICKNESS="iridescenceThickness",OA.IOR="ior",OA.TRANSMISSION="transmission",OA.THICKNESS="thickness",OA.ATTENUATION_DISTANCE="attenuationDistance",OA.ATTENUATION_COLOR="attenuationColor",OA.LINE_SCALE="scale",OA.LINE_DASH_SIZE="dashSize",OA.LINE_GAP_SIZE="gapSize",OA.LINE_WIDTH="linewidth",OA.LINE_DASH_OFFSET="dashOffset",OA.POINT_WIDTH="pointWidth",OA.DISPERSION="dispersion",OA.LIGHT_MAP="light",OA.AO_MAP="ao";const zA=rS(OA,OA.ALPHA_TEST),kA=rS(OA,OA.COLOR),VA=rS(OA,OA.SHININESS),GA=rS(OA,OA.EMISSIVE),HA=rS(OA,OA.OPACITY),WA=rS(OA,OA.SPECULAR),jA=rS(OA,OA.SPECULAR_INTENSITY),XA=rS(OA,OA.SPECULAR_COLOR),qA=rS(OA,OA.SPECULAR_STRENGTH),$A=rS(OA,OA.REFLECTIVITY),YA=rS(OA,OA.ROUGHNESS),ZA=rS(OA,OA.METALNESS),KA=rS(OA,OA.NORMAL).context({getUV:null}),JA=rS(OA,OA.CLEARCOAT),QA=rS(OA,OA.CLEARCOAT_ROUGHNESS),tE=rS(OA,OA.CLEARCOAT_NORMAL).context({getUV:null}),eE=rS(OA,OA.ROTATION),iE=rS(OA,OA.SHEEN),nE=rS(OA,OA.SHEEN_ROUGHNESS),sE=rS(OA,OA.ANISOTROPY),rE=rS(OA,OA.IRIDESCENCE),aE=rS(OA,OA.IRIDESCENCE_IOR),oE=rS(OA,OA.IRIDESCENCE_THICKNESS),lE=rS(OA,OA.TRANSMISSION),hE=rS(OA,OA.THICKNESS),cE=rS(OA,OA.IOR),uE=rS(OA,OA.ATTENUATION_DISTANCE),dE=rS(OA,OA.ATTENUATION_COLOR),pE=rS(OA,OA.LINE_SCALE),mE=rS(OA,OA.LINE_DASH_SIZE),fE=rS(OA,OA.LINE_GAP_SIZE);OA.LINE_WIDTH,OA.LINE_DASH_OFFSET,OA.POINT_WIDTH;const gE=rS(OA,OA.DISPERSION),xE=rS(OA,OA.LIGHT_MAP),vE=rS(OA,OA.AO_MAP),_E=BS(new Pg).onReference((function(t){return t.material})).onRenderUpdate((function({material:t}){this.value.set(t.anisotropy*Math.cos(t.anisotropyRotation),t.anisotropy*Math.sin(t.anisotropyRotation))}));class yE extends _b{static get type(){return"ModelViewProjectionNode"}constructor(t=null){super("vec4"),this.positionNode=t}setup(t){if("fragment"===t.shaderStage)return $T(t.context.mvp);const e=this.positionNode||Gw,i=t.renderer.nodes.modelViewMatrix||kw;return Lw.mul(i).mul(e)}}const bE=sS(yE);class SE extends gb{static get type(){return"IndexNode"}constructor(t){super("uint"),this.scope=t,this.isInstanceIndexNode=!0}generate(t){const e=this.getNodeType(t),i=this.scope;let n,s;if(i===SE.VERTEX)n=t.getVertexIndex();else if(i===SE.INSTANCE)n=t.getInstanceIndex();else if(i===SE.DRAW)n=t.getDrawIndex();else if(i===SE.INVOCATION_LOCAL)n=t.getInvocationLocalIndex();else if(i===SE.INVOCATION_SUBGROUP)n=t.getInvocationSubgroupIndex();else{if(i!==SE.SUBGROUP)throw new Error("THREE.IndexNode: Unknown scope: "+i);n=t.getSubgroupIndex()}if("vertex"===t.shaderStage||"compute"===t.shaderStage)s=n;else{s=$T(this).build(t,e)}return s}}SE.VERTEX="vertex",SE.INSTANCE="instance",SE.SUBGROUP="subgroup",SE.INVOCATION_LOCAL="invocationLocal",SE.INVOCATION_SUBGROUP="invocationSubgroup",SE.DRAW="draw";const ME=rS(SE,SE.VERTEX),TE=rS(SE,SE.INSTANCE);SE.SUBGROUP,SE.INVOCATION_SUBGROUP,SE.INVOCATION_LOCAL;const wE=rS(SE,SE.DRAW);class AE extends gb{static get type(){return"InstanceNode"}constructor(t){super("void"),this.instanceMesh=t,this.instanceMatrixNode=null,this.instanceColorNode=null,this.updateType=hb,this.buffer=null,this.bufferColor=null}setup(t){let e=this.instanceMatrixNode,i=this.instanceColorNode;const n=this.instanceMesh;if(null===e){const t=n.instanceMatrix;if(n.count<=1e3)e=mA(t.array,"mat4",Math.max(n.count,1)).element(TE);else{const i=new Wy(t.array,16,1);this.buffer=i;const n=t.usage===gg?cw:hw,s=[n(i,"vec4",16,0),n(i,"vec4",16,4),n(i,"vec4",16,8),n(i,"vec4",16,12)];e=RS(...s)}this.instanceMatrixNode=e}const s=n.instanceColor;if(s&&null===i){const t=new w_(s.array,3),e=s.usage===gg?cw:hw;this.bufferColor=t,i=_S(e(t,"vec3",3,0)),this.instanceColorNode=i}const r=e.mul(Gw).xyz;if(Gw.assign(r),t.hasGeometryAttribute("normal")){const t=sA(Kw,e);Kw.assign(t)}null!==this.instanceColorNode&&kS("vec3","vInstanceColor").assign(this.instanceColorNode)}update(){this.instanceMesh.instanceMatrix.usage!==gg&&null!=this.buffer&&this.instanceMesh.instanceMatrix.version!==this.buffer.version&&(this.buffer.version=this.instanceMesh.instanceMatrix.version),this.instanceMesh.instanceColor&&this.instanceMesh.instanceColor.usage!==gg&&null!=this.bufferColor&&this.instanceMesh.instanceColor.version!==this.bufferColor.version&&(this.bufferColor.version=this.instanceMesh.instanceColor.version)}}const EE=sS(AE);class CE extends gb{static get type(){return"BatchNode"}constructor(t){super("void"),this.batchMesh=t,this.batchingIdNode=null}setup(t){null===this.batchingIdNode&&(null===t.getDrawIndex()?this.batchingIdNode=TE:this.batchingIdNode=wE);const e=aS((([t])=>{const e=ww(Nw(this.batchMesh._indirectTexture),0),i=dS(t).modInt(dS(e)),n=dS(t).div(dS(e));return Nw(this.batchMesh._indirectTexture,gS(i,n)).x})).setLayout({name:"getIndirectIndex",type:"uint",inputs:[{name:"id",type:"int"}]})(dS(this.batchingIdNode)),i=this.batchMesh._matricesTexture,n=ww(Nw(i),0),s=uS(e).mul(4).toInt().toVar(),r=s.modInt(n),a=s.div(dS(n)),o=RS(Nw(i,gS(r,a)),Nw(i,gS(r.add(1),a)),Nw(i,gS(r.add(2),a)),Nw(i,gS(r.add(3),a))),l=this.batchMesh._colorsTexture;if(null!==l){const t=aS((([t])=>{const e=ww(Nw(l),0).x,i=t,n=i.modInt(e),s=i.div(e);return Nw(l,gS(n,s)).rgb})).setLayout({name:"getBatchingColor",type:"vec3",inputs:[{name:"id",type:"int"}]})(e);kS("vec3","vBatchColor").assign(t)}const h=CS(o);Gw.assign(o.mul(Gw));const c=Kw.div(_S(h[0].dot(h[0]),h[1].dot(h[1]),h[2].dot(h[2]))),u=h.mul(c).xyz;Kw.assign(u),t.hasGeometryAttribute("tangent")&&wA.mulAssign(h)}}const RE=sS(CE),NE=new WeakMap;class PE extends gb{static get type(){return"SkinningNode"}constructor(t,e=!1){let i,n,s;super("void"),this.skinnedMesh=t,this.useReference=e,this.updateType=ub,this.skinIndexNode=Sw("skinIndex","uvec4"),this.skinWeightNode=Sw("skinWeight","vec4"),e?(i=yA("bindMatrix","mat4"),n=yA("bindMatrixInverse","mat4"),s=bA("skeleton.boneMatrices","mat4",t.skeleton.bones.length)):(i=BS(t.bindMatrix,"mat4"),n=BS(t.bindMatrixInverse,"mat4"),s=mA(t.skeleton.boneMatrices,"mat4",t.skeleton.bones.length)),this.bindMatrixNode=i,this.bindMatrixInverseNode=n,this.boneMatricesNode=s,this.previousBoneMatricesNode=null}getSkinnedPosition(t=this.boneMatricesNode,e=Gw){const{skinIndexNode:i,skinWeightNode:n,bindMatrixNode:s,bindMatrixInverseNode:r}=this,a=t.element(i.x),o=t.element(i.y),l=t.element(i.z),h=t.element(i.w),c=s.mul(e),u=xM(a.mul(n.x).mul(c),o.mul(n.y).mul(c),l.mul(n.z).mul(c),h.mul(n.w).mul(c));return r.mul(u).xyz}getSkinnedNormal(t=this.boneMatricesNode,e=Kw){const{skinIndexNode:i,skinWeightNode:n,bindMatrixNode:s,bindMatrixInverseNode:r}=this,a=t.element(i.x),o=t.element(i.y),l=t.element(i.z),h=t.element(i.w);let c=xM(n.x.mul(a),n.y.mul(o),n.z.mul(l),n.w.mul(h));return c=r.mul(c).mul(s),c.transformDirection(e).xyz}getPreviousSkinnedPosition(t){const e=t.object;return null===this.previousBoneMatricesNode&&(e.skeleton.previousBoneMatrices=new Float32Array(e.skeleton.boneMatrices),this.previousBoneMatricesNode=bA("skeleton.previousBoneMatrices","mat4",e.skeleton.bones.length)),this.getSkinnedPosition(this.previousBoneMatricesNode,Hw)}needsPreviousBoneMatrices(t){const e=t.renderer.getMRT();return e&&e.has("velocity")}setup(t){this.needsPreviousBoneMatrices(t)&&Hw.assign(this.getPreviousSkinnedPosition(t));const e=this.getSkinnedPosition();if(Gw.assign(e),t.hasGeometryAttribute("normal")){const e=this.getSkinnedNormal();Kw.assign(e),t.hasGeometryAttribute("tangent")&&wA.assign(e)}}generate(t,e){if("void"!==e)return Gw.build(t,e)}update(t){const e=(this.useReference?t.object:this.skinnedMesh).skeleton;NE.get(e)!==t.frameId&&(NE.set(e,t.frameId),null!==this.previousBoneMatricesNode&&e.previousBoneMatrices.set(e.boneMatrices),e.update())}}class IE extends gb{static get type(){return"LoopNode"}constructor(t=[]){super(),this.params=t}getVarName(t){return String.fromCharCode("i".charCodeAt()+t)}getProperties(t){const e=t.getNodeProperties(this);if(void 0!==e.stackNode)return e;const i={};for(let s=0,r=this.params.length-1;s<r;s++){const t=this.params[s],e=!0!==t.isNode&&t.name||this.getVarName(s),n=!0!==t.isNode&&t.type||"int";i[e]=_w(e,n)}const n=t.addStack();return e.returnsNode=this.params[this.params.length-1](i,n,t),e.stackNode=n,t.removeStack(),e}getNodeType(t){const{returnsNode:e}=this.getProperties(t);return e?e.getNodeType(t):"void"}setup(t){this.getProperties(t)}generate(t){const e=this.getProperties(t),i=this.params,n=e.stackNode;for(let a=0,o=i.length-1;a<o;a++){const e=i[a];let n=null,s=null,r=null,o=null,l=null,h=null;e.isNode?(o="int",r=this.getVarName(a),n="0",s=e.build(t,o),l="<"):(o=e.type||"int",r=e.name||this.getVarName(a),n=e.start,s=e.end,l=e.condition,h=e.update,"number"==typeof n?n=t.generateConst(o,n):n&&n.isNode&&(n=n.build(t,o)),"number"==typeof s?s=t.generateConst(o,s):s&&s.isNode&&(s=s.build(t,o)),void 0!==n&&void 0===s?(n+=" - 1",s="0",l=">="):void 0!==s&&void 0===n&&(n="0",l="<"),void 0===l&&(l=Number(n)>Number(s)?">=":"<"));const c={start:n,end:s,condition:l},u=c.start,d=c.end;let p="",m="",f="";h||(h="int"===o||"uint"===o?l.includes("<")?"++":"--":l.includes("<")?"+= 1.":"-= 1."),p+=t.getVar(o,r)+" = "+u,m+=r+" "+l+" "+d,f+=r+" "+h;const g=`for ( ${p}; ${m}; ${f} )`;t.addFlowCode((0===a?"\n":"")+t.tab+g+" {\n\n").addFlowTab()}const s=n.build(t,"void"),r=e.returnsNode?e.returnsNode.build(t):"";t.removeFlowTab().addFlowCode("\n"+t.tab+s);for(let a=0,o=this.params.length-1;a<o;a++)t.addFlowCode((0===a?"":t.tab)+"}\n\n").removeFlowTab();return t.addFlowTab(),r}}const LE=(...t)=>eS(new IE(nS(t,"int"))).append(),DE=new WeakMap,UE=new Kg,FE=aS((({bufferMap:t,influence:e,stride:i,width:n,depth:s,offset:r})=>{const a=dS(ME).mul(i).add(r),o=a.div(n),l=a.sub(o.mul(n));return Nw(t,gS(l,o)).depth(s).mul(e)}));class BE extends gb{static get type(){return"MorphNode"}constructor(t){super("void"),this.mesh=t,this.morphBaseInfluence=BS(1),this.updateType=ub}setup(t){const{geometry:e}=t,i=void 0!==e.morphAttributes.position,n=e.hasAttribute("normal")&&void 0!==e.morphAttributes.normal,s=e.morphAttributes.position||e.morphAttributes.normal||e.morphAttributes.color,r=void 0!==s?s.length:0,{texture:a,stride:o,size:l}=function(t){const e=void 0!==t.morphAttributes.position,i=void 0!==t.morphAttributes.normal,n=void 0!==t.morphAttributes.color,s=t.morphAttributes.position||t.morphAttributes.normal||t.morphAttributes.color,r=void 0!==s?s.length:0;let a=DE.get(t);if(void 0===a||a.count!==r){let s=function(){f.dispose(),DE.delete(t),t.removeEventListener("dispose",s)};void 0!==a&&a.texture.dispose();const o=t.morphAttributes.position||[],l=t.morphAttributes.normal||[],h=t.morphAttributes.color||[];let c=0;!0===e&&(c=1),!0===i&&(c=2),!0===n&&(c=3);let u=t.attributes.position.count*c,d=1;const p=4096;u>p&&(d=Math.ceil(u/p),u=p);const m=new Float32Array(u*d*4*r),f=new tx(m,u,d,r);f.type=Sf,f.needsUpdate=!0;const g=4*c;for(let t=0;t<r;t++){const s=o[t],r=l[t],a=h[t],c=u*d*4*t;for(let t=0;t<s.count;t++){const o=t*g;!0===e&&(UE.fromBufferAttribute(s,t),m[c+o+0]=UE.x,m[c+o+1]=UE.y,m[c+o+2]=UE.z,m[c+o+3]=0),!0===i&&(UE.fromBufferAttribute(r,t),m[c+o+4]=UE.x,m[c+o+5]=UE.y,m[c+o+6]=UE.z,m[c+o+7]=0),!0===n&&(UE.fromBufferAttribute(a,t),m[c+o+8]=UE.x,m[c+o+9]=UE.y,m[c+o+10]=UE.z,m[c+o+11]=4===a.itemSize?UE.w:1)}}a={count:r,texture:f,stride:c,size:new Pg(u,d)},DE.set(t,a),t.addEventListener("dispose",s)}return a}(e);!0===i&&Gw.mulAssign(this.morphBaseInfluence),!0===n&&Kw.mulAssign(this.morphBaseInfluence);const h=dS(l.width);LE(r,(({i:t})=>{const e=uS(0).toVar();this.mesh.count>1&&null!==this.mesh.morphTexture&&void 0!==this.mesh.morphTexture?e.assign(Nw(this.mesh.morphTexture,gS(dS(t).add(1),dS(TE))).r):e.assign(yA("morphTargetInfluences","float").element(t).toVar()),!0===i&&Gw.addAssign(FE({bufferMap:a,influence:e,stride:o,width:h,depth:t,offset:dS(0)})),!0===n&&Kw.addAssign(FE({bufferMap:a,influence:e,stride:o,width:h,depth:t,offset:dS(1)}))}))}update(){const t=this.morphBaseInfluence;this.mesh.geometry.morphTargetsRelative?t.value=1:t.value=1-this.mesh.morphTargetInfluences.reduce(((t,e)=>t+e),0)}}const OE=sS(BE);class zE extends gb{static get type(){return"LightingNode"}constructor(){super("vec3"),this.isLightingNode=!0}generate(){}}class kE extends zE{static get type(){return"AONode"}constructor(t=null){super(),this.aoNode=t}setup(t){t.context.ambientOcclusion.mulAssign(this.aoNode)}}class VE extends HT{static get type(){return"LightingContextNode"}constructor(t,e=null,i=null,n=null){super(t),this.lightingModel=e,this.backdropNode=i,this.backdropAlphaNode=n,this._value=null}getContext(){const{backdropNode:t,backdropAlphaNode:e}=this,i={directDiffuse:_S().toVar("directDiffuse"),directSpecular:_S().toVar("directSpecular"),indirectDiffuse:_S().toVar("indirectDiffuse"),indirectSpecular:_S().toVar("indirectSpecular")};return{radiance:_S().toVar("radiance"),irradiance:_S().toVar("irradiance"),iblIrradiance:_S().toVar("iblIrradiance"),ambientOcclusion:uS(1).toVar("ambientOcclusion"),reflectedLight:i,backdrop:t,backdropAlpha:e}}setup(t){return this.value=this._value||(this._value=this.getContext()),this.value.lightingModel=this.lightingModel||t.context.lightingModel,super.setup(t)}}const GE=sS(VE);class HE extends zE{static get type(){return"IrradianceNode"}constructor(t){super(),this.node=t}setup(t){t.context.irradiance.addAssign(this.node)}}let WE,jE;class XE extends gb{static get type(){return"ScreenNode"}constructor(t){super(),this.scope=t,this.isViewportNode=!0}getNodeType(){return this.scope===XE.VIEWPORT?"vec4":"vec2"}getUpdateType(){let t=lb;return this.scope!==XE.SIZE&&this.scope!==XE.VIEWPORT||(t=cb),this.updateType=t,t}update({renderer:t}){const e=t.getRenderTarget();this.scope===XE.VIEWPORT?null!==e?jE.copy(e.viewport):(t.getViewport(jE),jE.multiplyScalar(t.getPixelRatio())):null!==e?(WE.width=e.width,WE.height=e.height):t.getDrawingBufferSize(WE)}setup(){const t=this.scope;let e=null;return e=t===XE.SIZE?BS(WE||(WE=new Pg)):t===XE.VIEWPORT?BS(jE||(jE=new Kg)):fS(YE.div($E)),e}generate(t){if(this.scope===XE.COORDINATE){let e=t.getFragCoord();if(t.isFlipY()){const i=t.getNodeProperties($E).outputNode.build(t);e=`${t.getType("vec2")}( ${e}.x, ${i}.y - ${e}.y )`}return e}return super.generate(t)}}XE.COORDINATE="coordinate",XE.VIEWPORT="viewport",XE.SIZE="size",XE.UV="uv";const qE=rS(XE,XE.UV),$E=rS(XE,XE.SIZE),YE=rS(XE,XE.COORDINATE),ZE=rS(XE,XE.VIEWPORT);ZE.zw,ZE.xy;const KE=new Pg;class JE extends Cw{static get type(){return"ViewportTextureNode"}constructor(t=qE,e=null,i=null){null===i&&((i=new iy).minFilter=ff),super(i,t,e),this.generateMipmaps=!1,this.isOutputTextureNode=!0,this.updateBeforeType=hb}updateBefore(t){const e=t.renderer;e.getDrawingBufferSize(KE);const i=this.value;i.image.width===KE.width&&i.image.height===KE.height||(i.image.width=KE.width,i.image.height=KE.height,i.needsUpdate=!0);const n=i.generateMipmaps;i.generateMipmaps=this.generateMipmaps,e.copyFramebufferToTexture(i),i.generateMipmaps=n}clone(){const t=new this.constructor(this.uvNode,this.levelNode,this.value);return t.generateMipmaps=this.generateMipmaps,t}}const QE=sS(JE,null,null,{generateMipmaps:!0});let tC=null;class eC extends JE{static get type(){return"ViewportDepthTextureNode"}constructor(t=qE,e=null){null===tC&&(tC=new sy),super(t,e,tC)}}const iC=sS(eC);class nC extends gb{static get type(){return"ViewportDepthNode"}constructor(t,e=null){super("float"),this.scope=t,this.valueNode=e,this.isViewportDepthNode=!0}generate(t){const{scope:e}=this;return e===nC.DEPTH_BASE?t.getFragDepth():super.generate(t)}setup({camera:t}){const{scope:e}=this,i=this.valueNode;let n=null;if(e===nC.DEPTH_BASE)null!==i&&(n=lC().assign(i));else if(e===nC.DEPTH)n=t.isPerspectiveCamera?rC(Xw.z,Pw,Iw):sC(Xw.z,Pw,Iw);else if(e===nC.LINEAR_DEPTH)if(null!==i)if(t.isPerspectiveCamera){const t=aC(i,Pw,Iw);n=sC(t,Pw,Iw)}else n=i;else n=sC(Xw.z,Pw,Iw);return n}}nC.DEPTH_BASE="depthBase",nC.DEPTH="depth",nC.LINEAR_DEPTH="linearDepth";const sC=(t,e,i)=>t.add(e).div(e.sub(i)),rC=(t,e,i)=>e.add(t).mul(i).div(i.sub(e).mul(t)),aC=(t,e,i)=>e.mul(i).div(i.sub(e).mul(t).sub(i)),oC=(t,e,i)=>{e=e.max(1e-6).toVar();const n=YM(t.div(e).add(1)),s=YM(i.div(e).add(1));return n.div(s)},lC=sS(nC,nC.DEPTH_BASE),hC=rS(nC,nC.DEPTH);nC.LINEAR_DEPTH;iC(),hC.assign=t=>lC(t);class cC extends gb{static get type(){return"ClippingNode"}constructor(t=cC.DEFAULT){super(),this.scope=t}setup(t){super.setup(t);const e=t.clippingContext,{localClipIntersection:i,localClippingCount:n,globalClippingCount:s}=e,r=s+n,a=i?r-n:r;return this.scope===cC.ALPHA_TO_COVERAGE?this.setupAlphaToCoverage(e.planes,r,a):this.setupDefault(e.planes,r,a)}setupAlphaToCoverage(t,e,i){return aS((()=>{const n=xA(t),s=zS("float","distanceToPlane"),r=zS("float","distanceToGradient"),a=zS("float","clipOpacity");let o;if(a.assign(1),LE(i,(({i:t})=>{o=n.element(t),s.assign(Xw.dot(o.xyz).negate().add(o.w)),r.assign(s.fwidth().div(2)),a.mulAssign(OT(r.negate(),r,s)),a.equal(0).discard()})),i<e){const t=zS("float","unionclipOpacity");t.assign(1),LE({start:i,end:e},(({i:e})=>{o=n.element(e),s.assign(Xw.dot(o.xyz).negate().add(o.w)),r.assign(s.fwidth().div(2)),t.mulAssign(OT(r.negate(),r,s).oneMinus())})),a.mulAssign(t.oneMinus())}VS.a.mulAssign(a),VS.a.equal(0).discard()}))()}setupDefault(t,e,i){return aS((()=>{const n=xA(t);let s;if(LE(i,(({i:t})=>{s=n.element(t),Xw.dot(s.xyz).greaterThan(s.w).discard()})),i<e){const t=zS("bool","clipped");t.assign(!0),LE({start:i,end:e},(({i:e})=>{s=n.element(e),t.assign(Xw.dot(s.xyz).greaterThan(s.w).and(t))})),t.discard()}}))()}}cC.ALPHA_TO_COVERAGE="alphaToCoverage",cC.DEFAULT="default";const uC=aS((([t])=>eT(_M(1e4,iT(_M(17,t.x).add(_M(.1,t.y)))).mul(xM(.1,lT(iT(_M(13,t.y).add(t.x)))))))),dC=aS((([t])=>uC(fS(uC(t.xy),t.z)))),pC=aS((([t])=>{const e=ST(cT(pT(t.xyz)),cT(mT(t.xyz))).toVar("maxDeriv"),i=uS(1).div(uS(.05).mul(e)).toVar("pixScale"),n=fS(qM(JM(YM(i))),qM(QM(YM(i)))).toVar("pixScales"),s=fS(dC(JM(n.x.mul(t.xyz))),dC(JM(n.y.mul(t.xyz)))).toVar("alpha"),r=eT(YM(i)).toVar("lerpFactor"),a=xM(_M(r.oneMinus(),s.x),_M(r,s.y)).toVar("x"),o=bT(r,r.oneMinus()).toVar("a"),l=_S(a.mul(a).div(_M(2,o).mul(vM(1,o))),a.sub(_M(.5,o)).div(vM(1,o)),vM(1,vM(1,a).mul(vM(1,a)).div(_M(2,o).mul(vM(1,o))))).toVar("cases"),h=a.lessThan(o.oneMinus()).select(a.lessThan(o).select(l.x,l.y),l.z);return FT(h,1e-6,1)}));class mC extends Ev{static get type(){return"NodeMaterial"}constructor(){super(),this.isNodeMaterial=!0,this.type=this.constructor.type,this.forceSinglePass=!1,this.fog=!0,this.lights=!1,this.lightsNode=null,this.envNode=null,this.aoNode=null,this.colorNode=null,this.normalNode=null,this.opacityNode=null,this.backdropNode=null,this.backdropAlphaNode=null,this.alphaTestNode=null,this.positionNode=null,this.geometryNode=null,this.depthNode=null,this.shadowNode=null,this.shadowPositionNode=null,this.outputNode=null,this.mrtNode=null,this.fragmentNode=null,this.vertexNode=null}customProgramCacheKey(){return this.type+nb(this)}build(t){this.setup(t)}setupObserver(t){return new Qy(t)}setup(t){let e;t.context.setupNormal=()=>this.setupNormal(t),t.addStack(),t.stack.outputNode=this.vertexNode||this.setupPosition(t),null!==this.geometryNode&&(t.stack.outputNode=t.stack.outputNode.bypass(this.geometryNode)),t.addFlow("vertex",t.removeStack()),t.addStack();const i=this.setupClipping(t);if(!0===this.depthWrite&&this.setupDepth(t),null===this.fragmentNode){this.setupDiffuseColor(t),this.setupVariants(t);const n=this.setupLighting(t);null!==i&&t.stack.add(i);const s=MS(n,VS.a).max(0);e=this.setupOutput(t,s),rM.assign(e),null!==this.outputNode&&(e=this.outputNode);if(null!==t.renderer.getRenderTarget()){const i=t.renderer.getMRT(),n=this.mrtNode;null!==i?(e=i,null!==n&&(e=i.merge(n))):null!==n&&(e=n)}}else{let i=this.fragmentNode;!0!==i.isOutputStructNode&&(i=MS(i)),e=this.setupOutput(t,i)}t.stack.outputNode=e,t.addFlow("fragment",t.removeStack()),t.monitor=this.setupObserver(t)}setupClipping(t){if(null===t.clippingContext)return null;const{globalClippingCount:e,localClippingCount:i}=t.clippingContext;let n=null;if(e||i){const e=t.renderer.samples;this.alphaToCoverage&&e>1?n=eS(new cC(cC.ALPHA_TO_COVERAGE)):t.stack.add(eS(new cC))}return n}setupDepth(t){const{renderer:e,camera:i}=t;let n=this.depthNode;if(null===n){const t=e.getMRT();t&&t.has("depth")?n=t.get("depth"):!0===e.logarithmicDepthBuffer&&(n=i.isPerspectiveCamera?oC(bE().w,Pw,Iw):sC(Xw.z,Pw,Iw))}null!==n&&hC.assign(n).append()}setupPosition(t){const{object:e}=t,i=e.geometry;var n;if(t.addStack(),(i.morphAttributes.position||i.morphAttributes.normal||i.morphAttributes.color)&&OE(e).append(),!0===e.isSkinnedMesh&&(n=e,eS(new PE(n,!0))).append(),this.displacementMap){const t=MA("displacementMap","texture"),e=MA("displacementScale","float"),i=MA("displacementBias","float");Gw.addAssign(Kw.normalize().mul(t.x.mul(e).add(i)))}e.isBatchedMesh&&RE(e).append(),e.instanceMatrix&&!0===e.instanceMatrix.isInstancedBufferAttribute&&EE(e).append(),null!==this.positionNode&&Gw.assign(this.positionNode);const s=bE();return t.context.vertex=t.removeStack(),t.context.mvp=s,s}setupDiffuseColor({object:t,geometry:e}){let i=this.colorNode?MS(this.colorNode):kA;if(!0===this.vertexColors&&e.hasAttribute("color")&&(i=MS(i.xyz.mul(Sw("color","vec3")),i.a)),t.instanceColor){i=kS("vec3","vInstanceColor").mul(i)}if(t.isBatchedMesh&&t._colorsTexture){i=kS("vec3","vBatchColor").mul(i)}VS.assign(i);const n=this.opacityNode?uS(this.opacityNode):HA;if(VS.a.assign(VS.a.mul(n)),null!==this.alphaTestNode||this.alphaTest>0){const t=null!==this.alphaTestNode?uS(this.alphaTestNode):zA;VS.a.lessThanEqual(t).discard()}!0===this.alphaHash&&VS.a.lessThan(pC(Gw)).discard(),!1===this.transparent&&1===this.blending&&!1===this.alphaToCoverage&&VS.a.assign(1)}setupVariants(){}setupOutgoingLight(){return!0===this.lights?_S(0):VS.rgb}setupNormal(){return this.normalNode?_S(this.normalNode):KA}setupEnvironment(){let t=null;return this.envNode?t=this.envNode:this.envMap&&(t=this.envMap.isCubeTexture?MA("envMap","cubeTexture"):MA("envMap","texture")),t}setupLightMap(t){let e=null;return t.material.lightMap&&(e=new HE(xE)),e}setupLights(t){const e=[],i=this.setupEnvironment(t);i&&i.isLightingNode&&e.push(i);const n=this.setupLightMap(t);if(n&&n.isLightingNode&&e.push(n),null!==this.aoNode||t.material.aoMap){const t=null!==this.aoNode?this.aoNode:vE;e.push(new kE(t))}let s=this.lightsNode||t.lightsNode;return e.length>0&&(s=t.renderer.lighting.createNode([...s.getLights(),...e])),s}setupLightingModel(){}setupLighting(t){const{material:e}=t,{backdropNode:i,backdropAlphaNode:n,emissiveNode:s}=this,r=!0===this.lights||null!==this.lightsNode?this.setupLights(t):null;let a=this.setupOutgoingLight(t);if(r&&r.getScope().hasLights){const e=this.setupLightingModel(t);a=GE(r,e,i,n)}else null!==i&&(a=_S(null!==n?UT(a,i,n):i));return(s&&!0===s.isNode||e.emissive&&!0===e.emissive.isColor)&&(GS.assign(_S(s||GA)),a=a.add(GS)),a}setupOutput(t,e){if(!0===this.fog){const i=t.fogNode;i&&(e=MS(i.mix(e.rgb,i.colorNode),e.a))}return e}setDefaultValues(t){for(const i in t){const e=t[i];void 0===this[i]&&(this[i]=e,e&&e.clone&&(this[i]=e.clone()))}const e=Object.getOwnPropertyDescriptors(t.constructor.prototype);for(const i in e)void 0===Object.getOwnPropertyDescriptor(this.constructor.prototype,i)&&void 0!==e[i].get&&Object.defineProperty(this.constructor.prototype,i,e[i])}toJSON(t){const e=void 0===t||"string"==typeof t;e&&(t={textures:{},images:{},nodes:{}});const i=Ev.prototype.toJSON.call(this,t),n=sb(this);i.inputNodes={};for(const{property:r,childNode:a}of n)i.inputNodes[r]=a.toJSON(t).uuid;function s(t){const e=[];for(const i in t){const n=t[i];delete n.metadata,e.push(n)}return e}if(e){const e=s(t.textures),n=s(t.images),r=s(t.nodes);e.length>0&&(i.textures=e),n.length>0&&(i.images=n),r.length>0&&(i.nodes=r)}return i}copy(t){return this.lightsNode=t.lightsNode,this.envNode=t.envNode,this.colorNode=t.colorNode,this.normalNode=t.normalNode,this.opacityNode=t.opacityNode,this.backdropNode=t.backdropNode,this.backdropAlphaNode=t.backdropAlphaNode,this.alphaTestNode=t.alphaTestNode,this.positionNode=t.positionNode,this.geometryNode=t.geometryNode,this.depthNode=t.depthNode,this.shadowNode=t.shadowNode,this.shadowPositionNode=t.shadowPositionNode,this.outputNode=t.outputNode,this.mrtNode=t.mrtNode,this.fragmentNode=t.fragmentNode,this.vertexNode=t.vertexNode,super.copy(t)}}const fC=new V_;class gC extends mC{static get type(){return"LineBasicNodeMaterial"}constructor(t){super(),this.isLineBasicNodeMaterial=!0,this.lights=!1,this.setDefaultValues(fC),this.setValues(t)}}const xC=new fy;class vC extends mC{static get type(){return"LineDashedNodeMaterial"}constructor(t){super(),this.isLineDashedNodeMaterial=!0,this.lights=!1,this.setDefaultValues(xC),this.offsetNode=null,this.dashScaleNode=null,this.dashSizeNode=null,this.gapSizeNode=null,this.setValues(t)}setupVariants(){const t=this.offsetNode,e=this.dashScaleNode?uS(this.dashScaleNode):pE,i=this.dashSizeNode?uS(this.dashSizeNode):mE,n=this.dashSizeNode?uS(this.dashGapNode):fE;aM.assign(i),oM.assign(n);const s=$T(Sw("lineDistance").mul(e));(t?s.add(t):s).mod(aM.add(oM)).greaterThan(aM).discard()}}const _C=new dy;class yC extends mC{static get type(){return"MeshNormalNodeMaterial"}constructor(t){super(),this.lights=!1,this.isMeshNormalNodeMaterial=!0,this.setDefaultValues(_C),this.setValues(t)}setupDiffuseColor(){const t=this.opacityNode?uS(this.opacityNode):HA;VS.assign(MS(eS(eA).mul(.5).add(.5),t))}}class bC extends _b{static get type(){return"EquirectUVNode"}constructor(t=jw){super("vec2"),this.dirNode=t}setup(){const t=this.dirNode,e=t.z.atan2(t.x).mul(1/(2*Math.PI)).add(.5),i=t.y.clamp(-1,1).asin().mul(1/Math.PI).add(.5);return fS(e,i)}}const SC=sS(bC);class MC extends v_{constructor(t=1,e={}){super(t,e),this.isCubeRenderTarget=!0}fromEquirectangularTexture(t,e){const i=e.minFilter,n=e.generateMipmaps;e.generateMipmaps=!0,this.texture.type=e.type,this.texture.colorSpace=e.colorSpace,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const s=new o_(5,5,5),r=SC(jw),a=new mC;a.colorNode=Rw(e,r,0),a.side=1,a.blending=0;const o=new r_(s,a),l=new __;l.add(o),e.minFilter===ff&&(e.minFilter=pf);const h=new g_(1,10,this),c=t.getMRT();return t.setMRT(null),h.update(t,l),t.setMRT(c),e.minFilter=i,e.currentGenerateMipmaps=n,o.geometry.dispose(),o.material.dispose(),this}}const TC=new WeakMap;class wC extends _b{static get type(){return"CubeMapNode"}constructor(t){super("vec3"),this.envNode=t,this._cubeTexture=null,this._cubeTextureNode=dA();const e=new x_;e.isRenderTargetTexture=!0,this._defaultTexture=e,this.updateBeforeType=cb}updateBefore(t){const{renderer:e,material:i}=t,n=this.envNode;if(n.isTextureNode||n.isMaterialReferenceNode){const t=n.isTextureNode?n.value:i[n.property];if(t&&t.isTexture){const i=t.mapping;if(i===rf||i===af){if(TC.has(t)){const e=TC.get(t);EC(e,t.mapping),this._cubeTexture=e}else{const i=t.image;if(function(t){return null!=t&&t.height>0}(i)){const n=new MC(i.height);n.fromEquirectangularTexture(e,t),EC(n.texture,t.mapping),this._cubeTexture=n.texture,TC.set(t,n.texture),t.addEventListener("dispose",AC)}else this._cubeTexture=this._defaultTexture}this._cubeTextureNode.value=this._cubeTexture}else this._cubeTextureNode=this.envNode}}}setup(t){return this.updateBefore(t),this._cubeTextureNode}}function AC(t){const e=t.target;e.removeEventListener("dispose",AC);const i=TC.get(e);void 0!==i&&(TC.delete(e),i.dispose())}function EC(t,e){e===rf?t.mapping=nf:e===af&&(t.mapping=sf)}const CC=sS(wC);class RC extends zE{static get type(){return"BasicEnvironmentNode"}constructor(t=null){super(),this.envNode=t}setup(t){t.context.environment=CC(this.envNode)}}class NC extends zE{static get type(){return"BasicLightMapNode"}constructor(t=null){super(),this.lightMapNode=t}setup(t){const e=uS(1/Math.PI);t.context.irradianceLightMap=this.lightMapNode.mul(e)}}class PC{start(){}finish(){}direct(){}directRectArea(){}indirect(){}ambientOcclusion(){}}class IC extends PC{constructor(){super()}indirect(t,e,i){const n=t.ambientOcclusion,s=t.reflectedLight,r=i.context.irradianceLightMap;s.indirectDiffuse.assign(MS(0)),r?s.indirectDiffuse.addAssign(r):s.indirectDiffuse.addAssign(MS(1,1,1,0)),s.indirectDiffuse.mulAssign(n),s.indirectDiffuse.mulAssign(VS.rgb)}finish(t,e,i){const n=i.material,s=t.outgoingLight,r=i.context.environment;if(r)switch(n.combine){case 0:s.rgb.assign(UT(s.rgb,s.rgb.mul(r.rgb),qA.mul($A)));break;case 1:s.rgb.assign(UT(s.rgb,r.rgb,qA.mul($A)));break;case 2:s.rgb.addAssign(r.rgb.mul(qA.mul($A)))}}}const LC=new Cv;class DC extends mC{static get type(){return"MeshBasicNodeMaterial"}constructor(t){super(),this.isMeshBasicNodeMaterial=!0,this.lights=!0,this.setDefaultValues(LC),this.setValues(t)}setupNormal(){return Qw}setupEnvironment(t){const e=super.setupEnvironment(t);return e?new RC(e):null}setupLightMap(t){let e=null;return t.material.lightMap&&(e=new NC(xE)),e}setupOutgoingLight(){return VS.rgb}setupLightingModel(){return new IC}}const UC=aS((({f0:t,f90:e,dotVH:i})=>{const n=i.mul(-5.55473).sub(6.98316).mul(i).exp2();return t.mul(n.oneMinus()).add(e.mul(n))})),FC=aS((t=>t.diffuseColor.mul(1/Math.PI))),BC=aS((({dotNH:t})=>sM.mul(uS(.5)).add(1).mul(uS(1/Math.PI)).mul(t.pow(sM)))),OC=aS((({lightDirection:t})=>{const e=t.add(qw).normalize(),i=eA.dot(e).clamp(),n=qw.dot(e).clamp(),s=UC({f0:iM,f90:1,dotVH:n}),r=uS(.25),a=BC({dotNH:i});return s.mul(r).mul(a)}));class zC extends IC{constructor(t=!0){super(),this.specular=t}direct({lightDirection:t,lightColor:e,reflectedLight:i}){const n=eA.dot(t).clamp().mul(e);i.directDiffuse.addAssign(n.mul(FC({diffuseColor:VS.rgb}))),!0===this.specular&&i.directSpecular.addAssign(n.mul(OC({lightDirection:t})).mul(qA))}indirect({ambientOcclusion:t,irradiance:e,reflectedLight:i}){i.indirectDiffuse.addAssign(e.mul(FC({diffuseColor:VS}))),i.indirectDiffuse.mulAssign(t)}}const kC=new py;class VC extends mC{static get type(){return"MeshLambertNodeMaterial"}constructor(t){super(),this.isMeshLambertNodeMaterial=!0,this.lights=!0,this.setDefaultValues(kC),this.setValues(t)}setupEnvironment(t){const e=super.setupEnvironment(t);return e?new RC(e):null}setupLightingModel(){return new zC(!1)}}const GC=new cy;class HC extends mC{static get type(){return"MeshPhongNodeMaterial"}constructor(t){super(),this.isMeshPhongNodeMaterial=!0,this.lights=!0,this.shininessNode=null,this.specularNode=null,this.setDefaultValues(GC),this.setValues(t)}setupEnvironment(t){const e=super.setupEnvironment(t);return e?new RC(e):null}setupLightingModel(){return new zC}setupVariants(){const t=(this.shininessNode?uS(this.shininessNode):VA).max(1e-4);sM.assign(t);const e=this.specularNode||WA;iM.assign(e)}copy(t){return this.shininessNode=t.shininessNode,this.specularNode=t.specularNode,super.copy(t)}}const WC=aS((t=>{if(!1===t.geometry.hasAttribute("normal"))return uS(0);const e=Qw.dFdx().abs().max(Qw.dFdy().abs());return e.x.max(e.y).max(e.z)})),jC=aS((t=>{const{roughness:e}=t,i=WC();let n=e.max(.0525);return n=n.add(i),n=n.min(1),n})),XC=aS((({alpha:t,dotNL:e,dotNV:i})=>{const n=t.pow2(),s=e.mul(n.add(n.oneMinus().mul(i.pow2())).sqrt()),r=i.mul(n.add(n.oneMinus().mul(e.pow2())).sqrt());return yM(.5,s.add(r).max(zM))})).setLayout({name:"V_GGX_SmithCorrelated",type:"float",inputs:[{name:"alpha",type:"float"},{name:"dotNL",type:"float"},{name:"dotNV",type:"float"}]}),qC=aS((({alphaT:t,alphaB:e,dotTV:i,dotBV:n,dotTL:s,dotBL:r,dotNV:a,dotNL:o})=>{const l=o.mul(_S(t.mul(i),e.mul(n),a).length()),h=a.mul(_S(t.mul(s),e.mul(r),o).length());return yM(.5,l.add(h)).saturate()})).setLayout({name:"V_GGX_SmithCorrelated_Anisotropic",type:"float",inputs:[{name:"alphaT",type:"float",qualifier:"in"},{name:"alphaB",type:"float",qualifier:"in"},{name:"dotTV",type:"float",qualifier:"in"},{name:"dotBV",type:"float",qualifier:"in"},{name:"dotTL",type:"float",qualifier:"in"},{name:"dotBL",type:"float",qualifier:"in"},{name:"dotNV",type:"float",qualifier:"in"},{name:"dotNL",type:"float",qualifier:"in"}]}),$C=aS((({alpha:t,dotNH:e})=>{const i=t.pow2(),n=e.pow2().mul(i.oneMinus()).oneMinus();return i.div(n.pow2()).mul(1/Math.PI)})).setLayout({name:"D_GGX",type:"float",inputs:[{name:"alpha",type:"float"},{name:"dotNH",type:"float"}]}),YC=uS(1/Math.PI),ZC=aS((({alphaT:t,alphaB:e,dotNH:i,dotTH:n,dotBH:s})=>{const r=t.mul(e),a=_S(e.mul(n),t.mul(s),r.mul(i)),o=a.dot(a),l=r.div(o);return YC.mul(r.mul(l.pow2()))})).setLayout({name:"D_GGX_Anisotropic",type:"float",inputs:[{name:"alphaT",type:"float",qualifier:"in"},{name:"alphaB",type:"float",qualifier:"in"},{name:"dotNH",type:"float",qualifier:"in"},{name:"dotTH",type:"float",qualifier:"in"},{name:"dotBH",type:"float",qualifier:"in"}]}),KC=aS((t=>{const{lightDirection:e,f0:i,f90:n,roughness:s,f:r,USE_IRIDESCENCE:a,USE_ANISOTROPY:o}=t,l=t.normalView||eA,h=s.pow2(),c=e.add(qw).normalize(),u=l.dot(e).clamp(),d=l.dot(qw).clamp(),p=l.dot(c).clamp(),m=qw.dot(c).clamp();let f,g,x=UC({f0:i,f90:n,dotVH:m});if(Qb(a)&&(x=YS.mix(x,r)),Qb(o)){const t=tM.dot(e),i=tM.dot(qw),n=tM.dot(c),s=eM.dot(e),r=eM.dot(qw),a=eM.dot(c);f=qC({alphaT:JS,alphaB:h,dotTV:i,dotBV:r,dotTL:t,dotBL:s,dotNV:d,dotNL:u}),g=ZC({alphaT:JS,alphaB:h,dotNH:p,dotTH:n,dotBH:a})}else f=XC({alpha:h,dotNL:u,dotNV:d}),g=$C({alpha:h,dotNH:p});return x.mul(f).mul(g)})),JC=aS((({roughness:t,dotNV:e})=>{const i=MS(-1,-.0275,-.572,.022),n=MS(1,.0425,1.04,-.04),s=t.mul(i).add(n),r=s.x.mul(s.x).min(e.mul(-9.28).exp2()).mul(s.x).add(s.y);return fS(-1.04,1.04).mul(r).add(s.zw)})).setLayout({name:"DFGApprox",type:"vec2",inputs:[{name:"roughness",type:"float"},{name:"dotNV",type:"vec3"}]}),QC=aS((t=>{const{dotNV:e,specularColor:i,specularF90:n,roughness:s}=t,r=JC({dotNV:e,roughness:s});return i.mul(r.x).add(n.mul(r.y))})),tR=aS((({f:t,f90:e,dotVH:i})=>{const n=i.oneMinus().saturate(),s=n.mul(n),r=n.mul(s,s).clamp(0,.9999);return t.sub(_S(e).mul(r)).div(r.oneMinus())})).setLayout({name:"Schlick_to_F0",type:"vec3",inputs:[{name:"f",type:"vec3"},{name:"f90",type:"float"},{name:"dotVH",type:"float"}]}),eR=aS((({roughness:t,dotNH:e})=>{const i=t.pow2(),n=uS(1).div(i),s=e.pow2().oneMinus().max(.0078125);return uS(2).add(n).mul(s.pow(n.mul(.5))).div(2*Math.PI)})).setLayout({name:"D_Charlie",type:"float",inputs:[{name:"roughness",type:"float"},{name:"dotNH",type:"float"}]}),iR=aS((({dotNV:t,dotNL:e})=>uS(1).div(uS(4).mul(e.add(t).sub(e.mul(t)))))).setLayout({name:"V_Neubelt",type:"float",inputs:[{name:"dotNV",type:"float"},{name:"dotNL",type:"float"}]}),nR=aS((({lightDirection:t})=>{const e=t.add(qw).normalize(),i=eA.dot(t).clamp(),n=eA.dot(qw).clamp(),s=eA.dot(e).clamp(),r=eR({roughness:$S,dotNH:s}),a=iR({dotNV:n,dotNL:i});return qS.mul(r).mul(a)})),sR=aS((({N:t,V:e,roughness:i})=>{const n=t.dot(e).saturate(),s=fS(i,n.oneMinus().sqrt());return s.assign(s.mul(.984375).add(.0078125)),s})).setLayout({name:"LTC_Uv",type:"vec2",inputs:[{name:"N",type:"vec3"},{name:"V",type:"vec3"},{name:"roughness",type:"float"}]}),rR=aS((({f:t})=>{const e=t.length();return ST(e.mul(e).add(t.z).div(e.add(1)),0)})).setLayout({name:"LTC_ClippedSphereFormFactor",type:"float",inputs:[{name:"f",type:"vec3"}]}),aR=aS((({v1:t,v2:e})=>{const i=t.dot(e),n=i.abs().toVar(),s=n.mul(.0145206).add(.4965155).mul(n).add(.8543985).toVar(),r=n.add(4.1616724).mul(n).add(3.417594).toVar(),a=s.div(r),o=i.greaterThan(0).select(a,ST(i.mul(i).oneMinus(),1e-7).inverseSqrt().mul(.5).sub(a));return t.cross(e).mul(o)})).setLayout({name:"LTC_EdgeVectorFormFactor",type:"vec3",inputs:[{name:"v1",type:"vec3"},{name:"v2",type:"vec3"}]}),oR=aS((({N:t,V:e,P:i,mInv:n,p0:s,p1:r,p2:a,p3:o})=>{const l=r.sub(s).toVar(),h=o.sub(s).toVar(),c=l.cross(h),u=_S().toVar();return hS(c.dot(i.sub(s)).greaterThanEqual(0),(()=>{const l=e.sub(t.mul(e.dot(t))).normalize(),h=t.cross(l).negate(),c=n.mul(CS(l,h,t).transpose()).toVar(),d=c.mul(s.sub(i)).normalize().toVar(),p=c.mul(r.sub(i)).normalize().toVar(),m=c.mul(a.sub(i)).normalize().toVar(),f=c.mul(o.sub(i)).normalize().toVar(),g=_S(0).toVar();g.addAssign(aR({v1:d,v2:p})),g.addAssign(aR({v1:p,v2:m})),g.addAssign(aR({v1:m,v2:f})),g.addAssign(aR({v1:f,v2:d})),u.assign(_S(rR({f:g})))})),u})).setLayout({name:"LTC_Evaluate",type:"vec3",inputs:[{name:"N",type:"vec3"},{name:"V",type:"vec3"},{name:"P",type:"vec3"},{name:"mInv",type:"mat3"},{name:"p0",type:"vec3"},{name:"p1",type:"vec3"},{name:"p2",type:"vec3"},{name:"p3",type:"vec3"}]}),lR=1/6,hR=t=>_M(lR,_M(t,_M(t,t.negate().add(3)).sub(3)).add(1)),cR=t=>_M(lR,_M(t,_M(t,_M(3,t).sub(6))).add(4)),uR=t=>_M(lR,_M(t,_M(t,_M(-3,t).add(3)).add(3)).add(1)),dR=t=>_M(lR,NT(t,3)),pR=t=>hR(t).add(cR(t)),mR=t=>uR(t).add(dR(t)),fR=t=>xM(-1,cR(t).div(hR(t).add(cR(t)))),gR=t=>xM(1,dR(t).div(uR(t).add(dR(t)))),xR=(t,e,i)=>{const n=t.uvNode,s=_M(n,e.zw).add(.5),r=JM(s),a=eT(s),o=pR(a.x),l=mR(a.x),h=fR(a.x),c=gR(a.x),u=fR(a.y),d=gR(a.y),p=fS(r.x.add(h),r.y.add(u)).sub(.5).mul(e.xy),m=fS(r.x.add(c),r.y.add(u)).sub(.5).mul(e.xy),f=fS(r.x.add(h),r.y.add(d)).sub(.5).mul(e.xy),g=fS(r.x.add(c),r.y.add(d)).sub(.5).mul(e.xy),x=pR(a.y).mul(xM(o.mul(t.uv(p).level(i)),l.mul(t.uv(m).level(i)))),v=mR(a.y).mul(xM(o.mul(t.uv(f).level(i)),l.mul(t.uv(g).level(i))));return x.add(v)},vR=aS((([t,e=uS(3)])=>{const i=fS(t.size(dS(e))),n=fS(t.size(dS(e.add(1)))),s=yM(1,i),r=yM(1,n),a=xR(t,MS(s,i),JM(e)),o=xR(t,MS(r,n),QM(e));return eT(e).mix(a,o)})),_R=aS((([t,e,i,n,s])=>{const r=_S(BT(e.negate(),tT(t),yM(1,n))),a=_S(cT(s[0].xyz),cT(s[1].xyz),cT(s[2].xyz));return tT(r).mul(i.mul(a))})).setLayout({name:"getVolumeTransmissionRay",type:"vec3",inputs:[{name:"n",type:"vec3"},{name:"v",type:"vec3"},{name:"thickness",type:"float"},{name:"ior",type:"float"},{name:"modelMatrix",type:"mat4"}]}),yR=aS((([t,e])=>t.mul(FT(e.mul(2).sub(2),0,1)))).setLayout({name:"applyIorToRoughness",type:"float",inputs:[{name:"roughness",type:"float"},{name:"ior",type:"float"}]}),bR=QE(),SR=QE(),MR=aS((([t,e,i],{material:n})=>{const s=(1==n.side?bR:SR).uv(t),r=YM($E.x).mul(yR(e,i));return vR(s,r)})),TR=aS((([t,e,i])=>(hS(i.notEqual(0),(()=>{const n=$M(e).negate().div(i);return XM(n.negate().mul(t))})),_S(1)))).setLayout({name:"volumeAttenuation",type:"vec3",inputs:[{name:"transmissionDistance",type:"float"},{name:"attenuationColor",type:"vec3"},{name:"attenuationDistance",type:"float"}]}),wR=aS((([t,e,i,n,s,r,a,o,l,h,c,u,d,p,m])=>{let f,g;if(m){f=MS().toVar(),g=_S().toVar();const s=c.sub(1).mul(m.mul(.025)),r=_S(c.sub(s),c,c.add(s));LE({start:0,end:3},(({i:s})=>{const c=r.element(s),m=_R(t,e,u,c,o),x=a.add(m),v=h.mul(l.mul(MS(x,1))),_=fS(v.xy.div(v.w)).toVar();_.addAssign(1),_.divAssign(2),_.assign(fS(_.x,_.y.oneMinus()));const y=MR(_,i,c);f.element(s).assign(y.element(s)),f.a.addAssign(y.a),g.element(s).assign(n.element(s).mul(TR(cT(m),d,p).element(s)))})),f.a.divAssign(3)}else{const s=_R(t,e,u,c,o),r=a.add(s),m=h.mul(l.mul(MS(r,1))),x=fS(m.xy.div(m.w)).toVar();x.addAssign(1),x.divAssign(2),x.assign(fS(x.x,x.y.oneMinus())),f=MR(x,i,c),g=n.mul(TR(cT(s),d,p))}const x=g.rgb.mul(f.rgb),v=t.dot(e).clamp(),_=_S(QC({dotNV:v,specularColor:s,specularF90:r,roughness:i})),y=g.r.add(g.g,g.b).div(3);return MS(_.oneMinus().mul(x),f.a.oneMinus().mul(y).oneMinus())})),AR=CS(3.2404542,-.969266,.0556434,-1.5371385,1.8760108,-.2040259,-.4985314,.041556,1.0572252),ER=(t,e)=>t.sub(e).div(t.add(e)).pow2(),CR=aS((({outsideIOR:t,eta2:e,cosTheta1:i,thinFilmThickness:n,baseF0:s})=>{const r=UT(t,e,OT(0,.03,n)),a=t.div(r).pow2().mul(i.pow2().oneMinus()).oneMinus();hS(a.lessThan(0),(()=>_S(1)));const o=a.sqrt(),l=ER(r,t),h=UC({f0:l,f90:1,dotVH:i}),c=h.oneMinus(),u=r.lessThan(t).select(Math.PI,0),d=uS(Math.PI).sub(u),p=(t=>{const e=t.sqrt();return _S(1).add(e).div(_S(1).sub(e))})(s.clamp(0,.9999)),m=ER(p,r.toVec3()),f=UC({f0:m,f90:1,dotVH:o}),g=_S(p.x.lessThan(r).select(Math.PI,0),p.y.lessThan(r).select(Math.PI,0),p.z.lessThan(r).select(Math.PI,0)),x=r.mul(n,o,2),v=_S(d).add(g),_=h.mul(f).clamp(1e-5,.9999),y=_.sqrt(),b=c.pow2().mul(f).div(_S(1).sub(_)),S=h.add(b).toVar(),M=b.sub(c).toVar();return LE({start:1,end:2,condition:"<=",name:"m"},(({m:t})=>{M.mulAssign(y);const e=((t,e)=>{const i=t.mul(2*Math.PI*1e-9),n=_S(54856e-17,44201e-17,52481e-17),s=_S(1681e3,1795300,2208400),r=_S(43278e5,93046e5,66121e5),a=uS(9747e-17*Math.sqrt(2*Math.PI*45282e5)).mul(i.mul(2239900).add(e.x).cos()).mul(i.pow2().mul(-45282e5).exp());let o=n.mul(r.mul(2*Math.PI).sqrt()).mul(s.mul(i).add(e).cos()).mul(i.pow2().negate().mul(r).exp());return o=_S(o.x.add(a),o.y,o.z).div(1.0685e-7),AR.mul(o)})(uS(t).mul(x),uS(t).mul(v)).mul(2);S.addAssign(M.mul(e))})),S.max(_S(0))})).setLayout({name:"evalIridescence",type:"vec3",inputs:[{name:"outsideIOR",type:"float"},{name:"eta2",type:"float"},{name:"cosTheta1",type:"float"},{name:"thinFilmThickness",type:"float"},{name:"baseF0",type:"vec3"}]}),RR=aS((({normal:t,viewDir:e,roughness:i})=>{const n=t.dot(e).saturate(),s=i.pow2(),r=GT(i.lessThan(.25),uS(-339.2).mul(s).add(uS(161.4).mul(i)).sub(25.9),uS(-8.48).mul(s).add(uS(14.3).mul(i)).sub(9.95)),a=GT(i.lessThan(.25),uS(44).mul(s).sub(uS(23.7).mul(i)).add(3.26),uS(1.97).mul(s).sub(uS(3.27).mul(i)).add(.72));return GT(i.lessThan(.25),0,uS(.1).mul(i).sub(.025)).add(r.mul(n).add(a).exp()).mul(1/Math.PI).saturate()})),NR=_S(.04),PR=uS(1);class IR extends PC{constructor(t=!1,e=!1,i=!1,n=!1,s=!1,r=!1){super(),this.clearcoat=t,this.sheen=e,this.iridescence=i,this.anisotropy=n,this.transmission=s,this.dispersion=r,this.clearcoatRadiance=null,this.clearcoatSpecularDirect=null,this.clearcoatSpecularIndirect=null,this.sheenSpecularDirect=null,this.sheenSpecularIndirect=null,this.iridescenceFresnel=null,this.iridescenceF0=null}start(t){if(!0===this.clearcoat&&(this.clearcoatRadiance=_S().toVar("clearcoatRadiance"),this.clearcoatSpecularDirect=_S().toVar("clearcoatSpecularDirect"),this.clearcoatSpecularIndirect=_S().toVar("clearcoatSpecularIndirect")),!0===this.sheen&&(this.sheenSpecularDirect=_S().toVar("sheenSpecularDirect"),this.sheenSpecularIndirect=_S().toVar("sheenSpecularIndirect")),!0===this.iridescence){const t=eA.dot(qw).clamp();this.iridescenceFresnel=CR({outsideIOR:uS(1),eta2:ZS,cosTheta1:t,thinFilmThickness:KS,baseF0:iM}),this.iridescenceF0=tR({f:this.iridescenceFresnel,f90:1,dotVH:t})}if(!0===this.transmission){const e=Ww,i=Uw.sub(Ww).normalize(),n=iA;t.backdrop=wR(n,i,HS,VS,iM,nM,e,Ow,Dw,Lw,lM,cM,dM,uM,this.dispersion?pM:null),t.backdropAlpha=hM,VS.a.mulAssign(UT(1,t.backdrop.a,hM))}}computeMultiscattering(t,e,i){const n=eA.dot(qw).clamp(),s=JC({roughness:HS,dotNV:n}),r=(this.iridescenceF0?YS.mix(iM,this.iridescenceF0):iM).mul(s.x).add(i.mul(s.y)),a=s.x.add(s.y).oneMinus(),o=iM.add(iM.oneMinus().mul(.047619)),l=r.mul(o).div(a.mul(o).oneMinus());t.addAssign(r),e.addAssign(l.mul(a))}direct({lightDirection:t,lightColor:e,reflectedLight:i}){const n=eA.dot(t).clamp().mul(e);if(!0===this.sheen&&this.sheenSpecularDirect.addAssign(n.mul(nR({lightDirection:t}))),!0===this.clearcoat){const i=nA.dot(t).clamp().mul(e);this.clearcoatSpecularDirect.addAssign(i.mul(KC({lightDirection:t,f0:NR,f90:PR,roughness:XS,normalView:nA})))}i.directDiffuse.addAssign(n.mul(FC({diffuseColor:VS.rgb}))),i.directSpecular.addAssign(n.mul(KC({lightDirection:t,f0:iM,f90:1,roughness:HS,iridescence:this.iridescence,f:this.iridescenceFresnel,USE_IRIDESCENCE:this.iridescence,USE_ANISOTROPY:this.anisotropy})))}directRectArea({lightColor:t,lightPosition:e,halfWidth:i,halfHeight:n,reflectedLight:s,ltc_1:r,ltc_2:a}){const o=e.add(i).sub(n),l=e.sub(i).sub(n),h=e.sub(i).add(n),c=e.add(i).add(n),u=eA,d=qw,p=Xw.toVar(),m=sR({N:u,V:d,roughness:HS}),f=r.uv(m).toVar(),g=a.uv(m).toVar(),x=CS(_S(f.x,0,f.y),_S(0,1,0),_S(f.z,0,f.w)).toVar(),v=iM.mul(g.x).add(iM.oneMinus().mul(g.y)).toVar();s.directSpecular.addAssign(t.mul(v).mul(oR({N:u,V:d,P:p,mInv:x,p0:o,p1:l,p2:h,p3:c}))),s.directDiffuse.addAssign(t.mul(VS).mul(oR({N:u,V:d,P:p,mInv:CS(1,0,0,0,1,0,0,0,1),p0:o,p1:l,p2:h,p3:c})))}indirect(t,e,i){this.indirectDiffuse(t,e,i),this.indirectSpecular(t,e,i),this.ambientOcclusion(t,e,i)}indirectDiffuse({irradiance:t,reflectedLight:e}){e.indirectDiffuse.addAssign(t.mul(FC({diffuseColor:VS})))}indirectSpecular({radiance:t,iblIrradiance:e,reflectedLight:i}){if(!0===this.sheen&&this.sheenSpecularIndirect.addAssign(e.mul(qS,RR({normal:eA,viewDir:qw,roughness:$S}))),!0===this.clearcoat){const t=nA.dot(qw).clamp(),e=QC({dotNV:t,specularColor:NR,specularF90:PR,roughness:XS});this.clearcoatSpecularIndirect.addAssign(this.clearcoatRadiance.mul(e))}const n=_S().toVar("singleScattering"),s=_S().toVar("multiScattering"),r=e.mul(1/Math.PI);this.computeMultiscattering(n,s,nM);const a=n.add(s),o=VS.mul(a.r.max(a.g).max(a.b).oneMinus());i.indirectSpecular.addAssign(t.mul(n)),i.indirectSpecular.addAssign(s.mul(r)),i.indirectDiffuse.addAssign(o.mul(r))}ambientOcclusion({ambientOcclusion:t,reflectedLight:e}){const i=eA.dot(qw).clamp().add(t),n=HS.mul(-16).oneMinus().negate().exp2(),s=t.sub(i.pow(n).oneMinus()).clamp();!0===this.clearcoat&&this.clearcoatSpecularIndirect.mulAssign(t),!0===this.sheen&&this.sheenSpecularIndirect.mulAssign(t),e.indirectDiffuse.mulAssign(t),e.indirectSpecular.mulAssign(s)}finish(t){const{outgoingLight:e}=t;if(!0===this.clearcoat){const t=nA.dot(qw).clamp(),i=UC({dotVH:t,f0:NR,f90:PR}),n=e.mul(jS.mul(i).oneMinus()).add(this.clearcoatSpecularDirect.add(this.clearcoatSpecularIndirect).mul(jS));e.assign(n)}if(!0===this.sheen){const t=qS.r.max(qS.g).max(qS.b).mul(.157).oneMinus(),i=e.mul(t).add(this.sheenSpecularDirect,this.sheenSpecularIndirect);e.assign(i)}}}const LR=uS(1),DR=uS(-2),UR=uS(.8),FR=uS(-1),BR=uS(.4),OR=uS(2),zR=uS(.305),kR=uS(3),VR=uS(.21),GR=uS(4),HR=uS(4),WR=uS(16),jR=aS((([t])=>{const e=_S(lT(t)).toVar(),i=uS(-1).toVar();return hS(e.x.greaterThan(e.z),(()=>{hS(e.x.greaterThan(e.y),(()=>{i.assign(GT(t.x.greaterThan(0),0,3))})).Else((()=>{i.assign(GT(t.y.greaterThan(0),1,4))}))})).Else((()=>{hS(e.z.greaterThan(e.y),(()=>{i.assign(GT(t.z.greaterThan(0),2,5))})).Else((()=>{i.assign(GT(t.y.greaterThan(0),1,4))}))})),i})).setLayout({name:"getFace",type:"float",inputs:[{name:"direction",type:"vec3"}]}),XR=aS((([t,e])=>{const i=fS().toVar();return hS(e.equal(0),(()=>{i.assign(fS(t.z,t.y).div(lT(t.x)))})).ElseIf(e.equal(1),(()=>{i.assign(fS(t.x.negate(),t.z.negate()).div(lT(t.y)))})).ElseIf(e.equal(2),(()=>{i.assign(fS(t.x.negate(),t.y).div(lT(t.z)))})).ElseIf(e.equal(3),(()=>{i.assign(fS(t.z.negate(),t.y).div(lT(t.x)))})).ElseIf(e.equal(4),(()=>{i.assign(fS(t.x.negate(),t.z).div(lT(t.y)))})).Else((()=>{i.assign(fS(t.x,t.y).div(lT(t.z)))})),_M(.5,i.add(1))})).setLayout({name:"getUV",type:"vec2",inputs:[{name:"direction",type:"vec3"},{name:"face",type:"float"}]}),qR=aS((([t])=>{const e=uS(0).toVar();return hS(t.greaterThanEqual(UR),(()=>{e.assign(LR.sub(t).mul(FR.sub(DR)).div(LR.sub(UR)).add(DR))})).ElseIf(t.greaterThanEqual(BR),(()=>{e.assign(UR.sub(t).mul(OR.sub(FR)).div(UR.sub(BR)).add(FR))})).ElseIf(t.greaterThanEqual(zR),(()=>{e.assign(BR.sub(t).mul(kR.sub(OR)).div(BR.sub(zR)).add(OR))})).ElseIf(t.greaterThanEqual(VR),(()=>{e.assign(zR.sub(t).mul(GR.sub(kR)).div(zR.sub(VR)).add(kR))})).Else((()=>{e.assign(uS(-2).mul(YM(_M(1.16,t))))})),e})).setLayout({name:"roughnessToMip",type:"float",inputs:[{name:"roughness",type:"float"}]}),$R=aS((([t,e])=>{const i=t.toVar();i.assign(_M(2,i).sub(1));const n=_S(i,1).toVar();return hS(e.equal(0),(()=>{n.assign(n.zyx)})).ElseIf(e.equal(1),(()=>{n.assign(n.xzy),n.xz.mulAssign(-1)})).ElseIf(e.equal(2),(()=>{n.x.mulAssign(-1)})).ElseIf(e.equal(3),(()=>{n.assign(n.zyx),n.xz.mulAssign(-1)})).ElseIf(e.equal(4),(()=>{n.assign(n.xzy),n.xy.mulAssign(-1)})).ElseIf(e.equal(5),(()=>{n.z.mulAssign(-1)})),n})).setLayout({name:"getDirection",type:"vec3",inputs:[{name:"uv",type:"vec2"},{name:"face",type:"float"}]}),YR=aS((([t,e,i,n,s,r])=>{const a=uS(i),o=_S(e),l=FT(qR(a),DR,r),h=eT(l),c=JM(l),u=_S(ZR(t,o,c,n,s,r)).toVar();return hS(h.notEqual(0),(()=>{const e=_S(ZR(t,o,c.add(1),n,s,r)).toVar();u.assign(UT(u,e,h))})),u})),ZR=aS((([t,e,i,n,s,r])=>{const a=uS(i).toVar(),o=_S(e),l=uS(jR(o)).toVar(),h=uS(ST(HR.sub(a),0)).toVar();a.assign(ST(a,HR));const c=uS(qM(a)).toVar(),u=fS(XR(o,l).mul(c.sub(2)).add(1)).toVar();return hS(l.greaterThan(2),(()=>{u.y.addAssign(c),l.subAssign(3)})),u.x.addAssign(l.mul(c)),u.x.addAssign(h.mul(_M(3,WR))),u.y.addAssign(_M(4,qM(r).sub(c))),u.x.mulAssign(n),u.y.mulAssign(s),t.uv(u).grad(fS(),fS())})),KR=aS((({envMap:t,mipInt:e,outputDirection:i,theta:n,axis:s,CUBEUV_TEXEL_WIDTH:r,CUBEUV_TEXEL_HEIGHT:a,CUBEUV_MAX_MIP:o})=>{const l=nT(n),h=i.mul(l).add(s.cross(i).mul(iT(n))).add(s.mul(s.dot(i).mul(l.oneMinus())));return ZR(t,h,e,r,a,o)})),JR=aS((({n:t,latitudinal:e,poleAxis:i,outputDirection:n,weights:s,samples:r,dTheta:a,mipInt:o,envMap:l,CUBEUV_TEXEL_WIDTH:h,CUBEUV_TEXEL_HEIGHT:c,CUBEUV_MAX_MIP:u})=>{const d=_S(GT(e,i,RT(i,n))).toVar();hS(VM(d.equals(_S(0))),(()=>{d.assign(_S(n.z,0,n.x.negate()))})),d.assign(tT(d));const p=_S().toVar();return p.addAssign(s.element(dS(0)).mul(KR({theta:0,axis:d,outputDirection:n,mipInt:o,envMap:l,CUBEUV_TEXEL_WIDTH:h,CUBEUV_TEXEL_HEIGHT:c,CUBEUV_MAX_MIP:u}))),LE({start:dS(1),end:t},(({i:t})=>{hS(t.greaterThanEqual(r),(()=>{_w("break").append()}));const e=uS(a.mul(uS(t))).toVar();p.addAssign(s.element(t).mul(KR({theta:e.mul(-1),axis:d,outputDirection:n,mipInt:o,envMap:l,CUBEUV_TEXEL_WIDTH:h,CUBEUV_TEXEL_HEIGHT:c,CUBEUV_MAX_MIP:u}))),p.addAssign(s.element(t).mul(KR({theta:e,axis:d,outputDirection:n,mipInt:o,envMap:l,CUBEUV_TEXEL_WIDTH:h,CUBEUV_TEXEL_HEIGHT:c,CUBEUV_MAX_MIP:u})))})),MS(p,1)}));let QR=null;const tN=new WeakMap;class eN extends _b{static get type(){return"PMREMNode"}constructor(t,e=null,i=null){super("vec3"),this._value=t,this._pmrem=null,this.uvNode=e,this.levelNode=i,this._generator=null;const n=new Zg;n.isRenderTargetTexture=!0,this._texture=Rw(n),this._width=BS(0),this._height=BS(0),this._maxMip=BS(0),this.updateBeforeType=cb}set value(t){this._value=t,this._pmrem=null}get value(){return this._value}updateFromTexture(t){const e=function(t){const e=Math.log2(t)-2,i=1/t;return{texelWidth:1/(3*Math.max(Math.pow(2,e),112)),texelHeight:i,maxMip:e}}(t.image.height);this._texture.value=t,this._width.value=e.texelWidth,this._height.value=e.texelHeight,this._maxMip.value=e.maxMip}updateBefore(){let t=this._pmrem;const e=t?t.pmremVersion:-1,i=this._value;e!==i.pmremVersion&&(t=!0===i.isPMREMTexture?i:function(t){let e=tN.get(t);if((void 0!==e?e.pmremVersion:-1)!==t.pmremVersion){const i=t.image;if(t.isCubeTexture){if(!function(t){if(null==t)return!1;let e=0;const i=6;for(let n=0;n<i;n++)void 0!==t[n]&&e++;return e===i}(i))return null;e=QR.fromCubemap(t,e)}else{if(!function(t){return null!=t&&t.height>0}(i))return null;e=QR.fromEquirectangular(t,e)}e.pmremVersion=t.pmremVersion,tN.set(t,e)}return e.texture}(i),null!==t&&(this._pmrem=t,this.updateFromTexture(t)))}setup(t){null===QR&&(QR=t.createPMREMGenerator()),this.updateBefore(t);let e=this.uvNode;null===e&&t.context.getUV&&(e=t.context.getUV(this));const i=this.value;t.renderer.coordinateSystem===xg&&!0!==i.isPMREMTexture&&!0===i.isRenderTargetTexture&&(e=_S(e.x.negate(),e.yz));let n=this.levelNode;return null===n&&t.context.getTextureLevel&&(n=t.context.getTextureLevel(this)),YR(this._texture,e,n,this._width,this._height,this._maxMip)}}const iN=sS(eN),nN=new WeakMap;class sN extends zE{static get type(){return"EnvironmentNode"}constructor(t=null){super(),this.envNode=t}setup(t){const{material:e}=t;let i=this.envNode;if(i.isTextureNode||i.isMaterialReferenceNode){const t=i.isTextureNode?i.value:e[i.property];let n=nN.get(t);void 0===n&&(n=iN(t),nN.set(t,n)),i=n}const n=e.envMap?yA("envMapIntensity","float",t.material):yA("environmentIntensity","float",t.scene),s=!0===e.useAnisotropy||e.anisotropy>0?RA:eA,r=i.context(rN(HS,s)).mul(n),a=i.context(aN(iA)).mul(Math.PI).mul(n),o=pw(r),l=pw(a);t.context.radiance.addAssign(o),t.context.iblIrradiance.addAssign(l);const h=t.context.lightingModel.clearcoatRadiance;if(h){const t=i.context(rN(XS,nA)).mul(n),e=pw(t);h.addAssign(e)}}}const rN=(t,e)=>{let i=null;return{getUV:()=>(null===i&&(i=qw.negate().reflect(e),i=t.mul(t).mix(i,e).normalize(),i=i.transformDirection(Dw)),i),getTextureLevel:()=>t}},aN=t=>({getUV:()=>t,getTextureLevel:()=>uS(1)}),oN=new ly;class lN extends mC{static get type(){return"MeshStandardNodeMaterial"}constructor(t){super(),this.isMeshStandardNodeMaterial=!0,this.lights=!0,this.emissiveNode=null,this.metalnessNode=null,this.roughnessNode=null,this.setDefaultValues(oN),this.setValues(t)}setupEnvironment(t){let e=super.setupEnvironment(t);return null===e&&t.environmentNode&&(e=t.environmentNode),e?new sN(e):null}setupLightingModel(){return new IR}setupSpecular(){const t=UT(_S(.04),VS.rgb,WS);iM.assign(t),nM.assign(1)}setupVariants(){const t=this.metalnessNode?uS(this.metalnessNode):ZA;WS.assign(t);let e=this.roughnessNode?uS(this.roughnessNode):YA;e=jC({roughness:e}),HS.assign(e),this.setupSpecular(),VS.assign(MS(VS.rgb.mul(t.oneMinus()),VS.a))}copy(t){return this.emissiveNode=t.emissiveNode,this.metalnessNode=t.metalnessNode,this.roughnessNode=t.roughnessNode,super.copy(t)}}const hN=new hy;class cN extends lN{static get type(){return"MeshPhysicalNodeMaterial"}constructor(t){super(),this.isMeshPhysicalNodeMaterial=!0,this.clearcoatNode=null,this.clearcoatRoughnessNode=null,this.clearcoatNormalNode=null,this.sheenNode=null,this.sheenRoughnessNode=null,this.iridescenceNode=null,this.iridescenceIORNode=null,this.iridescenceThicknessNode=null,this.specularIntensityNode=null,this.specularColorNode=null,this.iorNode=null,this.transmissionNode=null,this.thicknessNode=null,this.attenuationDistanceNode=null,this.attenuationColorNode=null,this.dispersionNode=null,this.anisotropyNode=null,this.setDefaultValues(hN),this.setValues(t)}get useClearcoat(){return this.clearcoat>0||null!==this.clearcoatNode}get useIridescence(){return this.iridescence>0||null!==this.iridescenceNode}get useSheen(){return this.sheen>0||null!==this.sheenNode}get useAnisotropy(){return this.anisotropy>0||null!==this.anisotropyNode}get useTransmission(){return this.transmission>0||null!==this.transmissionNode}get useDispersion(){return this.dispersion>0||null!==this.dispersionNode}setupSpecular(){const t=this.iorNode?uS(this.iorNode):cE;lM.assign(t),iM.assign(UT(bT(PT(lM.sub(1).div(lM.add(1))).mul(XA),_S(1)).mul(jA),VS.rgb,WS)),nM.assign(UT(jA,1,WS))}setupLightingModel(){return new IR(this.useClearcoat,this.useSheen,this.useIridescence,this.useAnisotropy,this.useTransmission,this.useDispersion)}setupVariants(t){if(super.setupVariants(t),this.useClearcoat){const t=this.clearcoatNode?uS(this.clearcoatNode):JA,e=this.clearcoatRoughnessNode?uS(this.clearcoatRoughnessNode):QA;jS.assign(t),XS.assign(jC({roughness:e}))}if(this.useSheen){const t=this.sheenNode?_S(this.sheenNode):iE,e=this.sheenRoughnessNode?uS(this.sheenRoughnessNode):nE;qS.assign(t),$S.assign(e)}if(this.useIridescence){const t=this.iridescenceNode?uS(this.iridescenceNode):rE,e=this.iridescenceIORNode?uS(this.iridescenceIORNode):aE,i=this.iridescenceThicknessNode?uS(this.iridescenceThicknessNode):oE;YS.assign(t),ZS.assign(e),KS.assign(i)}if(this.useAnisotropy){const t=(this.anisotropyNode?fS(this.anisotropyNode):sE).toVar();QS.assign(t.length()),hS(QS.equal(0),(()=>{t.assign(fS(1,0))})).Else((()=>{t.divAssign(fS(QS)),QS.assign(QS.saturate())})),JS.assign(QS.pow2().mix(HS.pow2(),1)),tM.assign(CA[0].mul(t.x).add(CA[1].mul(t.y))),eM.assign(CA[1].mul(t.x).sub(CA[0].mul(t.y)))}if(this.useTransmission){const t=this.transmissionNode?uS(this.transmissionNode):lE,e=this.thicknessNode?uS(this.thicknessNode):hE,i=this.attenuationDistanceNode?uS(this.attenuationDistanceNode):uE,n=this.attenuationColorNode?_S(this.attenuationColorNode):dE;if(hM.assign(t),cM.assign(e),uM.assign(i),dM.assign(n),this.useDispersion){const t=this.dispersionNode?uS(this.dispersionNode):gE;pM.assign(t)}}}setupClearcoatNormal(){return this.clearcoatNormalNode?_S(this.clearcoatNormalNode):tE}setup(t){t.context.setupClearcoatNormal=()=>this.setupClearcoatNormal(t),super.setup(t)}copy(t){return this.clearcoatNode=t.clearcoatNode,this.clearcoatRoughnessNode=t.clearcoatRoughnessNode,this.clearcoatNormalNode=t.clearcoatNormalNode,this.sheenNode=t.sheenNode,this.sheenRoughnessNode=t.sheenRoughnessNode,this.iridescenceNode=t.iridescenceNode,this.iridescenceIORNode=t.iridescenceIORNode,this.iridescenceThicknessNode=t.iridescenceThicknessNode,this.specularIntensityNode=t.specularIntensityNode,this.specularColorNode=t.specularColorNode,this.transmissionNode=t.transmissionNode,this.thicknessNode=t.thicknessNode,this.attenuationDistanceNode=t.attenuationDistanceNode,this.attenuationColorNode=t.attenuationColorNode,this.dispersionNode=t.dispersionNode,this.anisotropyNode=t.anisotropyNode,super.copy(t)}}const uN=aS((({normal:t,lightDirection:e,builder:i})=>{const n=t.dot(e),s=fS(n.mul(.5).add(.5),0);if(i.material.gradientMap){const t=MA("gradientMap","texture").context({getUV:()=>s});return _S(t.r)}{const t=s.fwidth().mul(.5);return UT(_S(.7),_S(1),OT(uS(.7).sub(t.x),uS(.7).add(t.x),s.x))}}));class dN extends PC{direct({lightDirection:t,lightColor:e,reflectedLight:i},n,s){const r=uN({normal:Zw,lightDirection:t,builder:s}).mul(e);i.directDiffuse.addAssign(r.mul(FC({diffuseColor:VS.rgb})))}indirect({ambientOcclusion:t,irradiance:e,reflectedLight:i}){i.indirectDiffuse.addAssign(e.mul(FC({diffuseColor:VS}))),i.indirectDiffuse.mulAssign(t)}}const pN=new uy;class mN extends mC{static get type(){return"MeshToonNodeMaterial"}constructor(t){super(),this.isMeshToonNodeMaterial=!0,this.lights=!0,this.setDefaultValues(pN),this.setValues(t)}setupLightingModel(){return new dN}}class fN extends _b{static get type(){return"MatcapUVNode"}constructor(){super("vec2")}setup(){const t=_S(qw.z,0,qw.x.negate()).normalize(),e=qw.cross(t);return fS(t.dot(eA),e.dot(eA)).mul(.495).add(.5)}}const gN=rS(fN),xN=new my;class vN extends mC{static get type(){return"MeshMatcapNodeMaterial"}constructor(t){super(),this.lights=!1,this.isMeshMatcapNodeMaterial=!0,this.setDefaultValues(xN),this.setValues(t)}setupVariants(t){const e=gN;let i;i=t.material.matcap?MA("matcap","texture").context({getUV:()=>e}):_S(UT(.2,.8,e.y)),VS.rgb.mulAssign(i.rgb)}}const _N=new ty;class yN extends mC{static get type(){return"PointsNodeMaterial"}constructor(t){super(),this.isPointsNodeMaterial=!0,this.lights=!1,this.transparent=!0,this.sizeNode=null,this.setDefaultValues(_N),this.setValues(t)}copy(t){return this.sizeNode=t.sizeNode,super.copy(t)}}class bN extends _b{static get type(){return"RotateNode"}constructor(t,e){super(),this.positionNode=t,this.rotationNode=e}getNodeType(t){return this.positionNode.getNodeType(t)}setup(t){const{rotationNode:e,positionNode:i}=this;if("vec2"===this.getNodeType(t)){const t=e.cos(),n=e.sin();return ES(t,n,n.negate(),t).mul(i)}{const t=e,n=RS(MS(1,0,0,0),MS(0,nT(t.x),iT(t.x).negate(),0),MS(0,iT(t.x),nT(t.x),0),MS(0,0,0,1)),s=RS(MS(nT(t.y),0,iT(t.y),0),MS(0,1,0,0),MS(iT(t.y).negate(),0,nT(t.y),0),MS(0,0,0,1)),r=RS(MS(nT(t.z),iT(t.z).negate(),0,0),MS(iT(t.z),nT(t.z),0,0),MS(0,0,1,0),MS(0,0,0,1));return n.mul(s).mul(r).mul(MS(i,1)).xyz}}}const SN=sS(bN),MN=new M_;class TN extends mC{static get type(){return"SpriteNodeMaterial"}constructor(t){super(),this.isSpriteNodeMaterial=!0,this.lights=!1,this._useSizeAttenuation=!0,this.positionNode=null,this.rotationNode=null,this.scaleNode=null,this.setDefaultValues(MN),this.setValues(t)}setupPosition({object:t,camera:e,context:i}){const n=this.sizeAttenuation,{positionNode:s,rotationNode:r,scaleNode:a}=this,o=Gw;let l=kw.mul(_S(s||0)),h=fS(Ow[0].xyz.length(),Ow[1].xyz.length());if(null!==a&&(h=h.mul(a)),!n)if(e.isPerspectiveCamera)h=h.mul(l.z.negate());else{const t=uS(2).div(Lw.element(1).element(1));h=h.mul(t.mul(2))}let c=o.xy;if(t.center&&!0===t.center.isVector2){const t=((t,e,i)=>eS(new iw(t,e,i)))("center","vec2");c=c.sub(t.sub(.5))}c=c.mul(h);const u=uS(r||eE),d=SN(c,u);l=MS(l.xy.add(d),l.zw);const p=Lw.mul(l);return i.vertex=o,p}copy(t){return this.positionNode=t.positionNode,this.rotationNode=t.rotationNode,this.scaleNode=t.scaleNode,super.copy(t)}get sizeAttenuation(){return this._useSizeAttenuation}set sizeAttenuation(t){this._useSizeAttenuation!==t&&(this._useSizeAttenuation=t,this.needsUpdate=!0)}}class wN extends PC{constructor(){super(),this.shadowNode=uS(1).toVar("shadowMask")}direct({shadowMask:t}){this.shadowNode.mulAssign(t)}finish(t){VS.a.mulAssign(this.shadowNode.oneMinus()),t.outgoingLight.rgb.assign(VS.rgb)}}const AN=new oy;class EN extends mC{static get type(){return"ShadowNodeMaterial"}constructor(t){super(),this.isShadowNodeMaterial=!0,this.lights=!0,this.setDefaultValues(AN),this.setValues(t)}setupLightingModel(){return new wN}}aS((({texture:t,uv:e})=>{const i=1e-4,n=_S().toVar();return hS(e.x.lessThan(i),(()=>{n.assign(_S(1,0,0))})).ElseIf(e.y.lessThan(i),(()=>{n.assign(_S(0,1,0))})).ElseIf(e.z.lessThan(i),(()=>{n.assign(_S(0,0,1))})).ElseIf(e.x.greaterThan(.9999),(()=>{n.assign(_S(-1,0,0))})).ElseIf(e.y.greaterThan(.9999),(()=>{n.assign(_S(0,-1,0))})).ElseIf(e.z.greaterThan(.9999),(()=>{n.assign(_S(0,0,-1))})).Else((()=>{const i=.01,s=t.uv(e.add(_S(-.01,0,0))).r.sub(t.uv(e.add(_S(i,0,0))).r),r=t.uv(e.add(_S(0,-.01,0))).r.sub(t.uv(e.add(_S(0,i,0))).r),a=t.uv(e.add(_S(0,0,-.01))).r.sub(t.uv(e.add(_S(0,0,i))).r);n.assign(_S(s,r,a))})),n.normalize()}));class CN{constructor(t,e){this.nodes=t,this.info=e,this.animationLoop=null,this.requestId=null,this._init()}_init(){const t=(e,i)=>{this.requestId=self.requestAnimationFrame(t),!0===this.info.autoReset&&this.info.reset(),this.nodes.nodeFrame.update(),this.info.frame=this.nodes.nodeFrame.frameId,null!==this.animationLoop&&this.animationLoop(e,i)};t()}dispose(){self.cancelAnimationFrame(this.requestId),this.requestId=null}setAnimationLoop(t){this.animationLoop=t}}class RN{constructor(){this.weakMap=new WeakMap}get(t){let e=this.weakMap;for(let i=0;i<t.length;i++)if(e=e.get(t[i]),void 0===e)return;return e.get(t[t.length-1])}set(t,e){let i=this.weakMap;for(let n=0;n<t.length;n++){const e=t[n];!1===i.has(e)&&i.set(e,new WeakMap),i=i.get(e)}return i.set(t[t.length-1],e)}delete(t){let e=this.weakMap;for(let i=0;i<t.length;i++)if(e=e.get(t[i]),void 0===e)return!1;return e.delete(t[t.length-1])}}const NN=new B_;class PN{constructor(){this.version=0,this.globalClippingCount=0,this.localClippingCount=0,this.localClippingEnabled=!1,this.localClipIntersection=!1,this.planes=[],this.parentVersion=0,this.viewNormalMatrix=new Ig,this.cacheKey=0}projectPlanes(t,e){const i=t.length,n=this.planes;for(let s=0;s<i;s++){NN.copy(t[s]).applyMatrix4(this.viewMatrix,this.viewNormalMatrix);const i=n[e+s],r=NN.normal;i.x=-r.x,i.y=-r.y,i.z=-r.z,i.w=NN.constant}}updateGlobal(t,e){const i=t.clippingPlanes;this.viewMatrix=e.matrixWorldInverse,this.viewNormalMatrix.getNormalMatrix(this.viewMatrix);let n=!1;if(Array.isArray(i)&&0!==i.length){const t=i.length;if(t!==this.globalClippingCount){const e=[];for(let i=0;i<t;i++)e.push(new Kg);this.globalClippingCount=t,this.planes=e,n=!0}this.projectPlanes(i,0)}else 0!==this.globalClippingCount&&(this.globalClippingCount=0,this.planes=[],n=!0);t.localClippingEnabled!==this.localClippingEnabled&&(this.localClippingEnabled=t.localClippingEnabled,n=!0),n&&(this.version++,this.cacheKey=ib(this.globalClippingCount,!0===this.localClippingEnabled?1:0))}update(t,e){let i=!1;if(this!==t&&t.version!==this.parentVersion&&(this.globalClippingCount=e.isShadowNodeMaterial?0:t.globalClippingCount,this.localClippingEnabled=t.localClippingEnabled,this.planes=Array.from(t.planes),this.parentVersion=t.version,this.viewMatrix=t.viewMatrix,this.viewNormalMatrix=t.viewNormalMatrix,i=!0),this.localClippingEnabled){const t=e.clippingPlanes;if(Array.isArray(t)&&0!==t.length){const e=t.length,n=this.planes,s=this.globalClippingCount;if(i||e!==this.localClippingCount){n.length=s+e;for(let t=0;t<e;t++)n[s+t]=new Kg;this.localClippingCount=e,i=!0}this.projectPlanes(t,s)}else 0!==this.localClippingCount&&(this.localClippingCount=0,i=!0);this.localClipIntersection!==e.clipIntersection&&(this.localClipIntersection=e.clipIntersection,i=!0)}i&&(this.version+=t.version,this.cacheKey=ib(t.cacheKey,this.localClippingCount,!0===this.localClipIntersection?1:0))}}let IN=0;class LN{constructor(t,e,i,n,s,r,a,o,l){this._nodes=t,this._geometries=e,this.id=IN++,this.renderer=i,this.object=n,this.material=s,this.scene=r,this.camera=a,this.lightsNode=o,this.context=l,this.geometry=n.geometry,this.version=s.version,this.drawRange=null,this.attributes=null,this.pipeline=null,this.vertexBuffers=null,this.drawParams=null,this.bundle=null,this.updateClipping(l.clippingContext),this.clippingContextVersion=this.clippingContext.version,this.initialNodesCacheKey=this.getDynamicCacheKey(),this.initialCacheKey=this.getCacheKey(),this._nodeBuilderState=null,this._bindings=null,this._monitor=null,this.onDispose=null,this.isRenderObject=!0,this.onMaterialDispose=()=>{this.dispose()},this.material.addEventListener("dispose",this.onMaterialDispose)}updateClipping(t){const e=this.material;let i=this.clippingContext;Array.isArray(e.clippingPlanes)?(i!==t&&i||(i=new PN,this.clippingContext=i),i.update(t,e)):this.clippingContext!==t&&(this.clippingContext=t)}get clippingNeedsUpdate(){return this.clippingContext.version!==this.clippingContextVersion&&(this.clippingContextVersion=this.clippingContext.version,!0)}getNodeBuilderState(){return this._nodeBuilderState||(this._nodeBuilderState=this._nodes.getForRender(this))}getMonitor(){return this._monitor||(this._monitor=this.getNodeBuilderState().monitor)}getBindings(){return this._bindings||(this._bindings=this.getNodeBuilderState().createBindings())}getIndex(){return this._geometries.getIndex(this)}getIndirect(){return this._geometries.getIndirect(this)}getChainArray(){return[this.object,this.material,this.context,this.lightsNode]}getAttributes(){if(null!==this.attributes)return this.attributes;const t=this.getNodeBuilderState().nodeAttributes,e=this.geometry,i=[],n=new Set;for(const s of t){const t=s.node&&s.node.attribute?s.node.attribute:e.getAttribute(s.name);if(void 0===t)continue;i.push(t);const r=t.isInterleavedBufferAttribute?t.data:t;n.add(r)}return this.attributes=i,this.vertexBuffers=Array.from(n.values()),i}getVertexBuffers(){return null===this.vertexBuffers&&this.getAttributes(),this.vertexBuffers}getDrawParameters(){const{object:t,material:e,geometry:i,group:n,drawRange:s}=this,r=this.drawParams||(this.drawParams={vertexCount:0,firstVertex:0,instanceCount:0,firstInstance:0}),a=this.getIndex(),o=null!==a,l=i.isInstancedBufferGeometry?i.instanceCount:t.count>1?t.count:1;if(0===l)return null;if(r.instanceCount=l,!0===t.isBatchedMesh)return r;let h=1;!0!==e.wireframe||t.isPoints||t.isLineSegments||t.isLine||t.isLineLoop||(h=2);let c=s.start*h,u=(s.start+s.count)*h;null!==n&&(c=Math.max(c,n.start*h),u=Math.min(u,(n.start+n.count)*h));const d=i.attributes.position;let p=1/0;o?p=a.count:null!=d&&(p=d.count),c=Math.max(c,0),u=Math.min(u,p);const m=u-c;return m<0||m===1/0?null:(r.vertexCount=m,r.firstVertex=c,r)}getGeometryCacheKey(){const{geometry:t}=this;let e="";for(const i of Object.keys(t.attributes).sort()){const n=t.attributes[i];e+=i+",",n.data&&(e+=n.data.stride+","),n.offset&&(e+=n.offset+","),n.itemSize&&(e+=n.itemSize+","),n.normalized&&(e+="n,")}return t.index&&(e+="index,"),e}getMaterialCacheKey(){const{object:t,material:e}=this;let i=e.customProgramCacheKey();for(const n of function(t){const e=Object.keys(t);let i=Object.getPrototypeOf(t);for(;i;){const t=Object.getOwnPropertyDescriptors(i);for(const i in t)if(void 0!==t[i]){const n=t[i];n&&"function"==typeof n.get&&e.push(i)}i=Object.getPrototypeOf(i)}return e}(e)){if(/^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test(n))continue;const t=e[n];let s;if(null!==t){const e=typeof t;"number"===e?s=0!==t?"1":"0":"object"===e?(s="{",t.isTexture&&(s+=t.mapping),s+="}"):s=String(t)}else s=String(t);i+=s+","}return i+=this.clippingContext.cacheKey+",",t.geometry&&(i+=this.getGeometryCacheKey()),t.skeleton&&(i+=t.skeleton.bones.length+","),t.morphTargetInfluences&&(i+=t.morphTargetInfluences.length+","),t.isBatchedMesh&&(i+=t._matricesTexture.uuid+",",null!==t._colorsTexture&&(i+=t._colorsTexture.uuid+",")),t.count>1&&(i+=t.uuid+","),tb(i)}get needsUpdate(){return this.initialNodesCacheKey!==this.getDynamicCacheKey()||this.clippingNeedsUpdate}getDynamicCacheKey(){let t=this._nodes.getCacheKey(this.scene,this.lightsNode);return this.object.receiveShadow&&(t+=1),t}getCacheKey(){return this.getMaterialCacheKey()+this.getDynamicCacheKey()}dispose(){this.material.removeEventListener("dispose",this.onMaterialDispose),this.onDispose()}}const DN=[];class UN{constructor(t,e,i,n,s,r){this.renderer=t,this.nodes=e,this.geometries=i,this.pipelines=n,this.bindings=s,this.info=r,this.chainMaps={}}get(t,e,i,n,s,r,a){const o=this.getChainMap(a);DN[0]=t,DN[1]=e,DN[2]=r,DN[3]=s;let l=o.get(DN);return void 0===l?(l=this.createRenderObject(this.nodes,this.geometries,this.renderer,t,e,i,n,s,r,a),o.set(DN,l)):(l.updateClipping(r.clippingContext),(l.version!==e.version||l.needsUpdate)&&(l.initialCacheKey!==l.getCacheKey()?(l.dispose(),l=this.get(t,e,i,n,s,r,a)):l.version=e.version)),l}getChainMap(t="default"){return this.chainMaps[t]||(this.chainMaps[t]=new RN)}dispose(){this.chainMaps={}}createRenderObject(t,e,i,n,s,r,a,o,l,h){const c=this.getChainMap(h),u=new LN(t,e,i,n,s,r,a,o,l);return u.onDispose=()=>{this.pipelines.delete(u),this.bindings.delete(u),this.nodes.delete(u),c.delete(u.getChainArray())},u}}class FN{constructor(){this.data=new WeakMap}get(t){let e=this.data.get(t);return void 0===e&&(e={},this.data.set(t,e)),e}delete(t){let e;return this.data.has(t)&&(e=this.data.get(t),this.data.delete(t)),e}has(t){return this.data.has(t)}dispose(){this.data=new WeakMap}}const BN=1,ON=2,zN=3,kN=4,VN=16;class GN extends FN{constructor(t){super(),this.backend=t}delete(t){const e=super.delete(t);return void 0!==e&&this.backend.destroyAttribute(t),e}update(t,e){const i=this.get(t);if(void 0===i.version)e===BN?this.backend.createAttribute(t):e===ON?this.backend.createIndexAttribute(t):e===zN?this.backend.createStorageAttribute(t):e===kN&&this.backend.createIndirectStorageAttribute(t),i.version=this._getBufferAttribute(t).version;else{const e=this._getBufferAttribute(t);(i.version<e.version||e.usage===gg)&&(this.backend.updateAttribute(t),i.version=e.version)}}_getBufferAttribute(t){return t.isInterleavedBufferAttribute&&(t=t.data),t}}function HN(t){return null!==t.index?t.index.version:t.attributes.position.version}function WN(t){const e=[],i=t.index,n=t.attributes.position;if(null!==i){const t=i.array;for(let i=0,n=t.length;i<n;i+=3){const n=t[i+0],s=t[i+1],r=t[i+2];e.push(n,s,s,r,r,n)}}else{for(let t=0,i=n.array.length/3-1;t<i;t+=3){const i=t+0,n=t+1,s=t+2;e.push(i,n,n,s,s,i)}}const s=new(function(t){for(let e=t.length-1;e>=0;--e)if(t[e]>=65535)return!0;return!1}(e)?Bv:Fv)(e,1);return s.version=HN(t),s}class jN extends FN{constructor(t,e){super(),this.attributes=t,this.info=e,this.wireframes=new WeakMap,this.attributeCall=new WeakMap}has(t){const e=t.geometry;return super.has(e)&&!0===this.get(e).initialized}updateForRender(t){!1===this.has(t)&&this.initGeometry(t),this.updateAttributes(t)}initGeometry(t){const e=t.geometry;this.get(e).initialized=!0,this.info.memory.geometries++;const i=()=>{this.info.memory.geometries--;const n=e.index,s=t.getAttributes();null!==n&&this.attributes.delete(n);for(const t of s)this.attributes.delete(t);const r=this.wireframes.get(e);void 0!==r&&this.attributes.delete(r),e.removeEventListener("dispose",i)};e.addEventListener("dispose",i)}updateAttributes(t){const e=t.getAttributes();for(const s of e)s.isStorageBufferAttribute||s.isStorageInstancedBufferAttribute?this.updateAttribute(s,zN):this.updateAttribute(s,BN);const i=this.getIndex(t);null!==i&&this.updateAttribute(i,ON);const n=t.geometry.indirect;null!==n&&this.updateAttribute(n,kN)}updateAttribute(t,e){const i=this.info.render.calls;t.isInterleavedBufferAttribute?void 0===this.attributeCall.get(t)?(this.attributes.update(t,e),this.attributeCall.set(t,i)):this.attributeCall.get(t.data)!==i&&(this.attributes.update(t,e),this.attributeCall.set(t.data,i),this.attributeCall.set(t,i)):this.attributeCall.get(t)!==i&&(this.attributes.update(t,e),this.attributeCall.set(t,i))}getIndirect(t){return t.geometry.indirect}getIndex(t){const{geometry:e,material:i}=t;let n=e.index;if(!0===i.wireframe){const t=this.wireframes;let i=t.get(e);void 0===i?(i=WN(e),t.set(e,i)):i.version!==HN(e)&&(this.attributes.delete(i),i=WN(e),t.set(e,i)),n=i}return n}}class XN{constructor(){this.autoReset=!0,this.frame=0,this.calls=0,this.render={calls:0,frameCalls:0,drawCalls:0,triangles:0,points:0,lines:0,timestamp:0,previousFrameCalls:0,timestampCalls:0},this.compute={calls:0,frameCalls:0,timestamp:0,previousFrameCalls:0,timestampCalls:0},this.memory={geometries:0,textures:0}}update(t,e,i){this.render.drawCalls++,t.isMesh||t.isSprite?this.render.triangles+=i*(e/3):t.isPoints?this.render.points+=i*e:t.isLineSegments?this.render.lines+=i*(e/2):t.isLine&&(this.render.lines+=i*(e-1))}updateTimestamp(t,e){0===this[t].timestampCalls&&(this[t].timestamp=0),this[t].timestamp+=e,this[t].timestampCalls++,this[t].timestampCalls>=this[t].previousFrameCalls&&(this[t].timestampCalls=0)}reset(){const t=this.render.frameCalls;this.render.previousFrameCalls=t;const e=this.compute.frameCalls;this.compute.previousFrameCalls=e,this.render.drawCalls=0,this.render.frameCalls=0,this.compute.frameCalls=0,this.render.triangles=0,this.render.points=0,this.render.lines=0}dispose(){this.reset(),this.calls=0,this.render.calls=0,this.compute.calls=0,this.render.timestamp=0,this.compute.timestamp=0,this.memory.geometries=0,this.memory.textures=0}}class qN{constructor(t){this.cacheKey=t,this.usedTimes=0}}class $N extends qN{constructor(t,e,i){super(t),this.vertexProgram=e,this.fragmentProgram=i}}class YN extends qN{constructor(t,e){super(t),this.computeProgram=e,this.isComputePipeline=!0}}let ZN=0;class KN{constructor(t,e,i=null,n=null){this.id=ZN++,this.code=t,this.stage=e,this.transforms=i,this.attributes=n,this.usedTimes=0}}class JN extends FN{constructor(t,e){super(),this.backend=t,this.nodes=e,this.bindings=null,this.caches=new Map,this.programs={vertex:new Map,fragment:new Map,compute:new Map}}getForCompute(t,e){const{backend:i}=this,n=this.get(t);if(this._needsComputeUpdate(t)){const s=n.pipeline;s&&(s.usedTimes--,s.computeProgram.usedTimes--);const r=this.nodes.getForCompute(t);let a=this.programs.compute.get(r.computeShader);void 0===a&&(s&&0===s.computeProgram.usedTimes&&this._releaseProgram(s.computeProgram),a=new KN(r.computeShader,"compute",r.transforms,r.nodeAttributes),this.programs.compute.set(r.computeShader,a),i.createProgram(a));const o=this._getComputeCacheKey(t,a);let l=this.caches.get(o);void 0===l&&(s&&0===s.usedTimes&&this._releasePipeline(s),l=this._getComputePipeline(t,a,o,e)),l.usedTimes++,a.usedTimes++,n.version=t.version,n.pipeline=l}return n.pipeline}getForRender(t,e=null){const{backend:i}=this,n=this.get(t);if(this._needsRenderUpdate(t)){const s=n.pipeline;s&&(s.usedTimes--,s.vertexProgram.usedTimes--,s.fragmentProgram.usedTimes--);const r=t.getNodeBuilderState();let a=this.programs.vertex.get(r.vertexShader);void 0===a&&(s&&0===s.vertexProgram.usedTimes&&this._releaseProgram(s.vertexProgram),a=new KN(r.vertexShader,"vertex"),this.programs.vertex.set(r.vertexShader,a),i.createProgram(a));let o=this.programs.fragment.get(r.fragmentShader);void 0===o&&(s&&0===s.fragmentProgram.usedTimes&&this._releaseProgram(s.fragmentProgram),o=new KN(r.fragmentShader,"fragment"),this.programs.fragment.set(r.fragmentShader,o),i.createProgram(o));const l=this._getRenderCacheKey(t,a,o);let h=this.caches.get(l);void 0===h?(s&&0===s.usedTimes&&this._releasePipeline(s),h=this._getRenderPipeline(t,a,o,l,e)):t.pipeline=h,h.usedTimes++,a.usedTimes++,o.usedTimes++,n.pipeline=h}return n.pipeline}delete(t){const e=this.get(t).pipeline;return e&&(e.usedTimes--,0===e.usedTimes&&this._releasePipeline(e),e.isComputePipeline?(e.computeProgram.usedTimes--,0===e.computeProgram.usedTimes&&this._releaseProgram(e.computeProgram)):(e.fragmentProgram.usedTimes--,e.vertexProgram.usedTimes--,0===e.vertexProgram.usedTimes&&this._releaseProgram(e.vertexProgram),0===e.fragmentProgram.usedTimes&&this._releaseProgram(e.fragmentProgram))),super.delete(t)}dispose(){super.dispose(),this.caches=new Map,this.programs={vertex:new Map,fragment:new Map,compute:new Map}}updateForRender(t){this.getForRender(t)}_getComputePipeline(t,e,i,n){i=i||this._getComputeCacheKey(t,e);let s=this.caches.get(i);return void 0===s&&(s=new YN(i,e),this.caches.set(i,s),this.backend.createComputePipeline(s,n)),s}_getRenderPipeline(t,e,i,n,s){n=n||this._getRenderCacheKey(t,e,i);let r=this.caches.get(n);return void 0===r&&(r=new $N(n,e,i),this.caches.set(n,r),t.pipeline=r,this.backend.createRenderPipeline(t,s)),r}_getComputeCacheKey(t,e){return t.id+","+e.id}_getRenderCacheKey(t,e,i){return e.id+","+i.id+","+this.backend.getRenderCacheKey(t)}_releasePipeline(t){this.caches.delete(t.cacheKey)}_releaseProgram(t){const e=t.code,i=t.stage;this.programs[i].delete(e)}_needsComputeUpdate(t){const e=this.get(t);return void 0===e.pipeline||e.version!==t.version}_needsRenderUpdate(t){return void 0===this.get(t).pipeline||this.backend.needsRenderUpdate(t)}}class QN extends FN{constructor(t,e,i,n,s,r){super(),this.backend=t,this.textures=i,this.pipelines=s,this.attributes=n,this.nodes=e,this.info=r,this.pipelines.bindings=this}getForRender(t){const e=t.getBindings();for(const i of e){const t=this.get(i);void 0===t.bindGroup&&(this._init(i),this.backend.createBindings(i,e),t.bindGroup=i)}return e}getForCompute(t){const e=this.nodes.getForCompute(t).bindings;for(const i of e){const t=this.get(i);void 0===t.bindGroup&&(this._init(i),this.backend.createBindings(i,e),t.bindGroup=i)}return e}updateForCompute(t){this._updateBindings(this.getForCompute(t))}updateForRender(t){this._updateBindings(this.getForRender(t))}_updateBindings(t){for(const e of t)this._update(e,t)}_init(t){for(const e of t.bindings)if(e.isSampledTexture)this.textures.updateTexture(e.texture);else if(e.isStorageBuffer){const t=e.attribute,i=t.isIndirectStorageBufferAttribute?kN:zN;this.attributes.update(t,i)}}_update(t,e){const{backend:i}=this;let n=!1;for(const s of t.bindings){if(s.isNodeUniformsGroup){if(!this.nodes.updateGroup(s))continue}if(s.isUniformBuffer){s.update()&&i.updateBinding(s)}else if(s.isSampler)s.update();else if(s.isSampledTexture){s.needsBindingsUpdate(this.textures.get(s.texture).generation)&&(n=!0);const t=s.update(),e=s.texture;t&&this.textures.updateTexture(e);const r=i.get(e);if(!0===i.isWebGPUBackend&&void 0===r.texture&&void 0===r.externalTexture&&(this.textures.updateTexture(e),n=!0),!0===e.isStorageTexture){const t=this.get(e);!0===s.store?t.needsMipmap=!0:this.textures.needsMipmaps(e)&&!0===t.needsMipmap&&(this.backend.generateMipmaps(e),t.needsMipmap=!1)}}}!0===n&&this.backend.updateBindings(t,e)}}function tP(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.material.id!==e.material.id?t.material.id-e.material.id:t.z!==e.z?t.z-e.z:t.id-e.id}function eP(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.z!==e.z?e.z-t.z:t.id-e.id}function iP(t){return(t.transmission>0||t.transmissionNode)&&2===t.side&&!1===t.forceSinglePass}class nP{constructor(t,e,i){this.renderItems=[],this.renderItemsIndex=0,this.opaque=[],this.transparentDoublePass=[],this.transparent=[],this.bundles=[],this.lightsNode=t.getNode(e,i),this.lightsArray=[],this.scene=e,this.camera=i,this.occlusionQueryCount=0}begin(){return this.renderItemsIndex=0,this.opaque.length=0,this.transparentDoublePass.length=0,this.transparent.length=0,this.bundles.length=0,this.lightsArray.length=0,this.occlusionQueryCount=0,this}getNextRenderItem(t,e,i,n,s,r){let a=this.renderItems[this.renderItemsIndex];return void 0===a?(a={id:t.id,object:t,geometry:e,material:i,groupOrder:n,renderOrder:t.renderOrder,z:s,group:r},this.renderItems[this.renderItemsIndex]=a):(a.id=t.id,a.object=t,a.geometry=e,a.material=i,a.groupOrder=n,a.renderOrder=t.renderOrder,a.z=s,a.group=r),this.renderItemsIndex++,a}push(t,e,i,n,s,r){const a=this.getNextRenderItem(t,e,i,n,s,r);!0===t.occlusionTest&&this.occlusionQueryCount++,!0===i.transparent||i.transmission>0?(iP(i)&&this.transparentDoublePass.push(a),this.transparent.push(a)):this.opaque.push(a)}unshift(t,e,i,n,s,r){const a=this.getNextRenderItem(t,e,i,n,s,r);!0===i.transparent||i.transmission>0?(iP(i)&&this.transparentDoublePass.unshift(a),this.transparent.unshift(a)):this.opaque.unshift(a)}pushBundle(t){this.bundles.push(t)}pushLight(t){this.lightsArray.push(t)}sort(t,e){this.opaque.length>1&&this.opaque.sort(t||tP),this.transparentDoublePass.length>1&&this.transparentDoublePass.sort(e||eP),this.transparent.length>1&&this.transparent.sort(e||eP)}finish(){this.lightsNode.setLights(this.lightsArray);for(let t=this.renderItemsIndex,e=this.renderItems.length;t<e;t++){const e=this.renderItems[t];if(null===e.id)break;e.id=null,e.object=null,e.geometry=null,e.material=null,e.groupOrder=null,e.renderOrder=null,e.z=null,e.group=null}}}class sP{constructor(t){this.lighting=t,this.lists=new RN}get(t,e){const i=this.lists,n=[t,e];let s=i.get(n);return void 0===s&&(s=new nP(this.lighting,t,e),i.set(n,s)),s}dispose(){this.lists=new RN}}let rP=0;class aP{constructor(){this.id=rP++,this.color=!0,this.clearColor=!0,this.clearColorValue={r:0,g:0,b:0,a:1},this.depth=!0,this.clearDepth=!0,this.clearDepthValue=1,this.stencil=!1,this.clearStencil=!0,this.clearStencilValue=1,this.viewport=!1,this.viewportValue=new Kg,this.scissor=!1,this.scissorValue=new Kg,this.textures=null,this.depthTexture=null,this.activeCubeFace=0,this.sampleCount=1,this.width=0,this.height=0,this.isRenderContext=!0}getCacheKey(){return oP(this)}}function oP(t){const{textures:e,activeCubeFace:i}=t,n=[i];for(const s of e)n.push(s.id);return eb(n)}class lP{constructor(){this.chainMaps={}}get(t,e,i=null){const n=[t,e];let s;if(null===i)s="default";else{const t=i.texture.format;s=`${i.textures.length}:${t}:${i.samples}:${i.depthBuffer}:${i.stencilBuffer}`}const r=this.getChainMap(s);let a=r.get(n);return void 0===a&&(a=new aP,r.set(n,a)),null!==i&&(a.sampleCount=0===i.samples?1:i.samples),a}getChainMap(t){return this.chainMaps[t]||(this.chainMaps[t]=new RN)}dispose(){this.chainMaps={}}}const hP=new ix;class cP extends FN{constructor(t,e,i){super(),this.renderer=t,this.backend=e,this.info=i}updateRenderTarget(t,e=0){const i=this.get(t),n=0===t.samples?1:t.samples,s=i.depthTextureMips||(i.depthTextureMips={}),r=t.textures,a=this.getSize(r[0]),o=a.width>>e,l=a.height>>e;let h=t.depthTexture||s[e];const c=!0===t.depthBuffer||!0===t.stencilBuffer;let u=!1;void 0===h&&c&&(h=new sy,h.format=t.stencilBuffer?Cf:Ef,h.type=t.stencilBuffer?Tf:bf,h.image.width=o,h.image.height=l,s[e]=h),i.width===a.width&&a.height===i.height||(u=!0,h&&(h.needsUpdate=!0,h.image.width=o,h.image.height=l)),i.width=a.width,i.height=a.height,i.textures=r,i.depthTexture=h||null,i.depth=t.depthBuffer,i.stencil=t.stencilBuffer,i.renderTarget=t,i.sampleCount!==n&&(u=!0,h&&(h.needsUpdate=!0),i.sampleCount=n);const d={sampleCount:n};for(let p=0;p<r.length;p++){const t=r[p];u&&(t.needsUpdate=!0),this.updateTexture(t,d)}if(h&&this.updateTexture(h,d),!0!==i.initialized){i.initialized=!0;const e=()=>{t.removeEventListener("dispose",e);for(let t=0;t<r.length;t++)this._destroyTexture(r[t]);h&&this._destroyTexture(h),this.delete(t)};t.addEventListener("dispose",e)}}updateTexture(t,e={}){const i=this.get(t);if(!0===i.initialized&&i.version===t.version)return;const n=t.isRenderTargetTexture||t.isDepthTexture||t.isFramebufferTexture,s=this.backend;if(n&&!0===i.initialized&&(s.destroySampler(t),s.destroyTexture(t)),t.isFramebufferTexture){const e=this.renderer.getRenderTarget();t.type=e?e.texture.type:gf}const{width:r,height:a,depth:o}=this.getSize(t);if(e.width=r,e.height=a,e.depth=o,e.needsMipmaps=this.needsMipmaps(t),e.levels=e.needsMipmaps?this.getMipLevels(t,r,a):1,n||!0===t.isStorageTexture)s.createSampler(t),s.createTexture(t,e),i.generation=t.version;else{if(!0!==i.initialized&&s.createSampler(t),t.version>0){const n=t.image;if(void 0===n);else if(!1===n.complete);else{if(t.images){const i=[];for(const e of t.images)i.push(e);e.images=i}else e.image=n;void 0!==i.isDefaultTexture&&!0!==i.isDefaultTexture||(s.createTexture(t,e),i.isDefaultTexture=!1,i.generation=t.version),!0===t.source.dataReady&&s.updateTexture(t,e),e.needsMipmaps&&0===t.mipmaps.length&&s.generateMipmaps(t)}}else s.createDefaultTexture(t),i.isDefaultTexture=!0,i.generation=t.version}if(!0!==i.initialized){i.initialized=!0,i.generation=t.version,this.info.memory.textures++;const e=()=>{t.removeEventListener("dispose",e),this._destroyTexture(t),this.info.memory.textures--};t.addEventListener("dispose",e)}i.version=t.version}getSize(t,e=hP){let i=t.images?t.images[0]:t.image;return i?(void 0!==i.image&&(i=i.image),e.width=i.width,e.height=i.height,e.depth=t.isCubeTexture?6:i.depth||1):e.width=e.height=e.depth=1,e}getMipLevels(t,e,i){let n;return n=t.isCompressedTexture?t.mipmaps.length:Math.floor(Math.log2(Math.max(e,i)))+1,n}needsMipmaps(t){return this.isEnvironmentTexture(t)||!0===t.isCompressedTexture||t.generateMipmaps}isEnvironmentTexture(t){const e=t.mapping;return e===rf||e===af||e===nf||e===sf}_destroyTexture(t){this.backend.destroySampler(t),this.backend.destroyTexture(t),this.delete(t)}}class uP extends Tv{constructor(t,e,i,n=1){super(t,e,i),this.a=n}set(t,e,i,n=1){return this.a=n,super.set(t,e,i)}copy(t){return void 0!==t.a&&(this.a=t.a),super.copy(t)}clone(){return new this.constructor(this.r,this.g,this.b,this.a)}}class dP extends OS{static get type(){return"ParameterNode"}constructor(t,e=null){super(t,e),this.isParameterNode=!0}getHash(){return this.uuid}generate(){return this.name}}class pP extends gb{static get type(){return"StackNode"}constructor(t=null){super(),this.nodes=[],this.outputNode=null,this.parent=t,this._currentCond=null,this.isStackNode=!0}getNodeType(t){return this.outputNode?this.outputNode.getNodeType(t):"void"}add(t){return this.nodes.push(t),this}If(t,e){const i=new tS(e);return this._currentCond=GT(t,i),this.add(this._currentCond)}ElseIf(t,e){const i=new tS(e),n=GT(t,i);return this._currentCond.elseNode=n,this._currentCond=n,this}Else(t){return this._currentCond.elseNode=new tS(t),this}build(t,...e){const i=lS();oS(this);for(const n of this.nodes)n.build(t,"void");return oS(i),this.outputNode?this.outputNode.build(t,...e):super.build(t,...e)}else(...t){return this.Else(...t)}elseif(...t){return this.ElseIf(...t)}}const mP=sS(pP);new B_,new ix,new ix,new ix,new Ix,new ix(0,0,-1),new Kg,new ix,new ix,new Kg,new Pg;const fP=new Jg;qE.flipX(),fP.depthTexture=new sy(1,1);const gP=new Uy(-1,1,1,-1,0,1);class xP extends qv{constructor(t=!1){super();const e=!1===t?[0,-1,0,1,2,1]:[0,2,0,0,2,0];this.setAttribute("position",new zv([-1,3,0,-1,-1,0,3,-1,0],3)),this.setAttribute("uv",new zv(e,2))}}const vP=new xP;class _P extends r_{constructor(t=null){super(vP,t),this.camera=gP,this.isQuadMesh=!0}renderAsync(t){return t.renderAsync(this,gP)}render(t){t.render(this,gP)}}const yP=new Gx,bP=new Ix;class SP extends gb{static get type(){return"SceneNode"}constructor(t=SP.BACKGROUND_BLURRINESS,e=null){super(),this.scope=t,this.scene=e}setup(t){const e=this.scope,i=null!==this.scene?this.scene:t.scene;let n;return e===SP.BACKGROUND_BLURRINESS?n=yA("backgroundBlurriness","float",i):e===SP.BACKGROUND_INTENSITY?n=yA("backgroundIntensity","float",i):e===SP.BACKGROUND_ROTATION&&(n=BS("mat4").label("backgroundRotation").setGroup(DS).onRenderUpdate((()=>{const t=i.background;return null!==t&&t.isTexture&&300!==t.mapping?(yP.copy(i.backgroundRotation),yP.x*=-1,yP.y*=-1,yP.z*=-1,bP.makeRotationFromEuler(yP)):bP.identity(),bP}))),n}}SP.BACKGROUND_BLURRINESS="backgroundBlurriness",SP.BACKGROUND_INTENSITY="backgroundIntensity",SP.BACKGROUND_ROTATION="backgroundRotation";const MP=rS(SP,SP.BACKGROUND_BLURRINESS),TP=rS(SP,SP.BACKGROUND_INTENSITY),wP=rS(SP,SP.BACKGROUND_ROTATION),AP="point-list",EP="line-list",CP="line-strip",RP="triangle-list",NP="triangle-strip",PP="never",IP="less",LP="equal",DP="less-equal",UP="greater",FP="not-equal",BP="greater-equal",OP="always",zP="store",kP="load",VP="clear",GP="ccw",HP="none",WP="front",jP="back",XP="uint16",qP="uint32",$P={R8Unorm:"r8unorm",R8Snorm:"r8snorm",R8Uint:"r8uint",R8Sint:"r8sint",R16Uint:"r16uint",R16Sint:"r16sint",R16Float:"r16float",RG8Unorm:"rg8unorm",RG8Snorm:"rg8snorm",RG8Uint:"rg8uint",RG8Sint:"rg8sint",R32Uint:"r32uint",R32Sint:"r32sint",R32Float:"r32float",RG16Uint:"rg16uint",RG16Sint:"rg16sint",RG16Float:"rg16float",RGBA8Unorm:"rgba8unorm",RGBA8UnormSRGB:"rgba8unorm-srgb",RGBA8Snorm:"rgba8snorm",RGBA8Uint:"rgba8uint",RGBA8Sint:"rgba8sint",BGRA8Unorm:"bgra8unorm",BGRA8UnormSRGB:"bgra8unorm-srgb",RGB9E5UFloat:"rgb9e5ufloat",RGB10A2Unorm:"rgb10a2unorm",RG11B10uFloat:"rgb10a2unorm",RG32Uint:"rg32uint",RG32Sint:"rg32sint",RG32Float:"rg32float",RGBA16Uint:"rgba16uint",RGBA16Sint:"rgba16sint",RGBA16Float:"rgba16float",RGBA32Uint:"rgba32uint",RGBA32Sint:"rgba32sint",RGBA32Float:"rgba32float",Stencil8:"stencil8",Depth16Unorm:"depth16unorm",Depth24Plus:"depth24plus",Depth24PlusStencil8:"depth24plus-stencil8",Depth32Float:"depth32float",Depth32FloatStencil8:"depth32float-stencil8",BC1RGBAUnorm:"bc1-rgba-unorm",BC1RGBAUnormSRGB:"bc1-rgba-unorm-srgb",BC2RGBAUnorm:"bc2-rgba-unorm",BC2RGBAUnormSRGB:"bc2-rgba-unorm-srgb",BC3RGBAUnorm:"bc3-rgba-unorm",BC3RGBAUnormSRGB:"bc3-rgba-unorm-srgb",BC4RUnorm:"bc4-r-unorm",BC4RSnorm:"bc4-r-snorm",BC5RGUnorm:"bc5-rg-unorm",BC5RGSnorm:"bc5-rg-snorm",BC6HRGBUFloat:"bc6h-rgb-ufloat",BC6HRGBFloat:"bc6h-rgb-float",BC7RGBAUnorm:"bc7-rgba-unorm",BC7RGBAUnormSRGB:"bc7-rgba-srgb",ETC2RGB8Unorm:"etc2-rgb8unorm",ETC2RGB8UnormSRGB:"etc2-rgb8unorm-srgb",ETC2RGB8A1Unorm:"etc2-rgb8a1unorm",ETC2RGB8A1UnormSRGB:"etc2-rgb8a1unorm-srgb",ETC2RGBA8Unorm:"etc2-rgba8unorm",ETC2RGBA8UnormSRGB:"etc2-rgba8unorm-srgb",EACR11Unorm:"eac-r11unorm",EACR11Snorm:"eac-r11snorm",EACRG11Unorm:"eac-rg11unorm",EACRG11Snorm:"eac-rg11snorm",ASTC4x4Unorm:"astc-4x4-unorm",ASTC4x4UnormSRGB:"astc-4x4-unorm-srgb",ASTC5x4Unorm:"astc-5x4-unorm",ASTC5x4UnormSRGB:"astc-5x4-unorm-srgb",ASTC5x5Unorm:"astc-5x5-unorm",ASTC5x5UnormSRGB:"astc-5x5-unorm-srgb",ASTC6x5Unorm:"astc-6x5-unorm",ASTC6x5UnormSRGB:"astc-6x5-unorm-srgb",ASTC6x6Unorm:"astc-6x6-unorm",ASTC6x6UnormSRGB:"astc-6x6-unorm-srgb",ASTC8x5Unorm:"astc-8x5-unorm",ASTC8x5UnormSRGB:"astc-8x5-unorm-srgb",ASTC8x6Unorm:"astc-8x6-unorm",ASTC8x6UnormSRGB:"astc-8x6-unorm-srgb",ASTC8x8Unorm:"astc-8x8-unorm",ASTC8x8UnormSRGB:"astc-8x8-unorm-srgb",ASTC10x5Unorm:"astc-10x5-unorm",ASTC10x5UnormSRGB:"astc-10x5-unorm-srgb",ASTC10x6Unorm:"astc-10x6-unorm",ASTC10x6UnormSRGB:"astc-10x6-unorm-srgb",ASTC10x8Unorm:"astc-10x8-unorm",ASTC10x8UnormSRGB:"astc-10x8-unorm-srgb",ASTC10x10Unorm:"astc-10x10-unorm",ASTC10x10UnormSRGB:"astc-10x10-unorm-srgb",ASTC12x10Unorm:"astc-12x10-unorm",ASTC12x10UnormSRGB:"astc-12x10-unorm-srgb",ASTC12x12Unorm:"astc-12x12-unorm",ASTC12x12UnormSRGB:"astc-12x12-unorm-srgb"},YP="clamp-to-edge",ZP="repeat",KP="mirror-repeat",JP="linear",QP="nearest",tI="zero",eI="one",iI="src",nI="one-minus-src",sI="src-alpha",rI="one-minus-src-alpha",aI="dst",oI="one-minus-dst",lI="dst-alpha",hI="one-minus-dst-alpha",cI="src-alpha-saturated",uI="constant",dI="one-minus-constant",pI="add",mI="subtract",fI="reverse-subtract",gI="min",xI="max",vI=0,_I=15,yI="keep",bI="zero",SI="replace",MI="invert",TI="increment-clamp",wI="decrement-clamp",AI="increment-wrap",EI="decrement-wrap",CI="storage",RI="read-only-storage",NI="write-only",PI="read-only",II="float",LI="unfilterable-float",DI="depth",UI="sint",FI="uint",BI="2d",OI="3d",zI="2d",kI="2d-array",VI="cube",GI="3d",HI="all",WI="vertex",jI="instance",XI={DepthClipControl:"depth-clip-control",Depth32FloatStencil8:"depth32float-stencil8",TextureCompressionBC:"texture-compression-bc",TextureCompressionETC2:"texture-compression-etc2",TextureCompressionASTC:"texture-compression-astc",TimestampQuery:"timestamp-query",IndirectFirstInstance:"indirect-first-instance",ShaderF16:"shader-f16",RG11B10UFloat:"rg11b10ufloat-renderable",BGRA8UNormStorage:"bgra8unorm-storage",Float32Filterable:"float32-filterable",ClipDistances:"clip-distances",DualSourceBlending:"dual-source-blending",Subgroups:"subgroups"},qI=new Pg;class $I extends Cw{static get type(){return"PassTextureNode"}constructor(t,e){super(e),this.passNode=t,this.setUpdateMatrix(!1)}setup(t){return t.object.isQuadMesh&&this.passNode.build(t),super.setup(t)}clone(){return new this.constructor(this.passNode,this.value)}}class YI extends $I{static get type(){return"PassMultipleTextureNode"}constructor(t,e,i=!1){super(t,null),this.textureName=e,this.previousTexture=i}updateTexture(){this.value=this.previousTexture?this.passNode.getPreviousTexture(this.textureName):this.passNode.getTexture(this.textureName)}setup(t){return this.updateTexture(),super.setup(t)}clone(){return new this.constructor(this.passNode,this.textureName,this.previousTexture)}}class ZI extends _b{static get type(){return"PassNode"}constructor(t,e,i,n={}){super("vec4"),this.scope=t,this.scene=e,this.camera=i,this.options=n,this._pixelRatio=1,this._width=1,this._height=1;const s=new sy;s.isRenderTargetTexture=!0,s.name="depth";const r=new Jg(this._width*this._pixelRatio,this._height*this._pixelRatio,{type:Mf,...n});r.texture.name="output",r.depthTexture=s,this.renderTarget=r,this.updateBeforeType=hb,this._textures={output:r.texture,depth:s},this._textureNodes={},this._linearDepthNodes={},this._viewZNodes={},this._previousTextures={},this._previousTextureNodes={},this._cameraNear=BS(0),this._cameraFar=BS(0),this._mrt=null,this.isPassNode=!0}setMRT(t){return this._mrt=t,this}getMRT(){return this._mrt}isGlobal(){return!0}getTexture(t){let e=this._textures[t];if(void 0===e){e=this.renderTarget.texture.clone(),e.isRenderTargetTexture=!0,e.name=t,this._textures[t]=e,this.renderTarget.textures.push(e)}return e}getPreviousTexture(t){let e=this._previousTextures[t];return void 0===e&&(e=this.getTexture(t).clone(),e.isRenderTargetTexture=!0,this._previousTextures[t]=e),e}toggleTexture(t){const e=this._previousTextures[t];if(void 0!==e){const i=this._textures[t],n=this.renderTarget.textures.indexOf(i);this.renderTarget.textures[n]=e,this._textures[t]=e,this._previousTextures[t]=i,this._textureNodes[t].updateTexture(),this._previousTextureNodes[t].updateTexture()}}getTextureNode(t="output"){let e=this._textureNodes[t];return void 0===e&&(e=eS(new YI(this,t)),e.updateTexture(),this._textureNodes[t]=e),e}getPreviousTextureNode(t="output"){let e=this._previousTextureNodes[t];return void 0===e&&(void 0===this._textureNodes[t]&&this.getTextureNode(t),e=eS(new YI(this,t,!0)),e.updateTexture(),this._previousTextureNodes[t]=e),e}getViewZNode(t="depth"){let e=this._viewZNodes[t];if(void 0===e){const i=this._cameraNear,n=this._cameraFar;this._viewZNodes[t]=e=aC(this.getTextureNode(t),i,n)}return e}getLinearDepthNode(t="depth"){let e=this._linearDepthNodes[t];if(void 0===e){const i=this._cameraNear,n=this._cameraFar,s=this.getViewZNode(t);this._linearDepthNodes[t]=e=sC(s,i,n)}return e}setup({renderer:t}){return this.renderTarget.samples=void 0===this.options.samples?t.samples:this.options.samples,!0===t.backend.isWebGLBackend&&(this.renderTarget.samples=0),this.renderTarget.depthTexture.isMultisampleRenderTargetTexture=this.renderTarget.samples>1,this.scope===ZI.COLOR?this.getTextureNode():this.getLinearDepthNode()}updateBefore(t){const{renderer:e}=t,{scene:i,camera:n}=this;this._pixelRatio=e.getPixelRatio();const s=e.getSize(qI);this.setSize(s.width,s.height);const r=e.getRenderTarget(),a=e.getMRT();this._cameraNear.value=n.near,this._cameraFar.value=n.far;for(const o in this._previousTextures)this.toggleTexture(o);e.setRenderTarget(this.renderTarget),e.setMRT(this._mrt),e.render(i,n),e.setRenderTarget(r),e.setMRT(a)}setSize(t,e){this._width=t,this._height=e;const i=this._width*this._pixelRatio,n=this._height*this._pixelRatio;this.renderTarget.setSize(i,n)}setPixelRatio(t){this._pixelRatio=t,this.setSize(this._width,this._height)}dispose(){this.renderTarget.dispose()}}ZI.COLOR="color",ZI.DEPTH="depth";const KI=aS((([t,e])=>t.mul(e).clamp())).setLayout({name:"linearToneMapping",type:"vec3",inputs:[{name:"color",type:"vec3"},{name:"exposure",type:"float"}]}),JI=aS((([t,e])=>(t=t.mul(e)).div(t.add(1)).clamp())).setLayout({name:"reinhardToneMapping",type:"vec3",inputs:[{name:"color",type:"vec3"},{name:"exposure",type:"float"}]}),QI=aS((([t,e])=>{const i=(t=(t=t.mul(e)).sub(.004).max(0)).mul(t.mul(6.2).add(.5)),n=t.mul(t.mul(6.2).add(1.7)).add(.06);return i.div(n).pow(2.2)})).setLayout({name:"cineonToneMapping",type:"vec3",inputs:[{name:"color",type:"vec3"},{name:"exposure",type:"float"}]}),tL=aS((([t])=>{const e=t.mul(t.add(.0245786)).sub(90537e-9),i=t.mul(t.add(.432951).mul(.983729)).add(.238081);return e.div(i)})),eL=aS((([t,e])=>{const i=CS(.59719,.35458,.04823,.076,.90834,.01566,.0284,.13383,.83777),n=CS(1.60475,-.53108,-.07367,-.10208,1.10813,-.00605,-.00327,-.07276,1.07602);return t=t.mul(e).div(.6),t=i.mul(t),t=tL(t),(t=n.mul(t)).clamp()})).setLayout({name:"acesFilmicToneMapping",type:"vec3",inputs:[{name:"color",type:"vec3"},{name:"exposure",type:"float"}]}),iL=CS(_S(1.6605,-.1246,-.0182),_S(-.5876,1.1329,-.1006),_S(-.0728,-.0083,1.1187)),nL=CS(_S(.6274,.0691,.0164),_S(.3293,.9195,.088),_S(.0433,.0113,.8956)),sL=aS((([t])=>{const e=_S(t).toVar(),i=_S(e.mul(e)).toVar(),n=_S(i.mul(i)).toVar();return uS(15.5).mul(n.mul(i)).sub(_M(40.14,n.mul(e))).add(_M(31.96,n).sub(_M(6.868,i.mul(e))).add(_M(.4298,i).add(_M(.1191,e).sub(.00232))))})),rL=aS((([t,e])=>{const i=_S(t).toVar(),n=CS(_S(.856627153315983,.137318972929847,.11189821299995),_S(.0951212405381588,.761241990602591,.0767994186031903),_S(.0482516061458583,.101439036467562,.811302368396859)),s=CS(_S(1.1271005818144368,-.1413297634984383,-.14132976349843826),_S(-.11060664309660323,1.157823702216272,-.11060664309660294),_S(-.016493938717834573,-.016493938717834257,1.2519364065950405)),r=uS(-12.47393),a=uS(4.026069);return i.mulAssign(e),i.assign(nL.mul(i)),i.assign(n.mul(i)),i.assign(ST(i,1e-10)),i.assign(YM(i)),i.assign(i.sub(r).div(a.sub(r))),i.assign(FT(i,0,1)),i.assign(sL(i)),i.assign(s.mul(i)),i.assign(NT(ST(_S(0),i),_S(2.2))),i.assign(iL.mul(i)),i.assign(FT(i,0,1)),i})).setLayout({name:"agxToneMapping",type:"vec3",inputs:[{name:"color",type:"vec3"},{name:"exposure",type:"float"}]}),aL=aS((([t,e])=>{const i=uS(.76),n=uS(.15);t=t.mul(e);const s=bT(t.r,bT(t.g,t.b)),r=GT(s.lessThan(.08),s.sub(_M(6.25,s.mul(s))),.04);t.subAssign(r);const a=ST(t.r,ST(t.g,t.b));hS(a.lessThan(i),(()=>t));const o=vM(1,i),l=vM(1,o.mul(o).div(a.add(o.sub(i))));t.mulAssign(l.div(a));const h=vM(1,yM(1,n.mul(a.sub(l)).add(1)));return UT(t,_S(l),h)})).setLayout({name:"neutralToneMapping",type:"vec3",inputs:[{name:"color",type:"vec3"},{name:"exposure",type:"float"}]});class oL extends gb{static get type(){return"CodeNode"}constructor(t="",e=[],i=""){super("code"),this.isCodeNode=!0,this.code=t,this.language=i,this.includes=e}isGlobal(){return!0}setIncludes(t){return this.includes=t,this}getIncludes(){return this.includes}generate(t){const e=this.getIncludes(t);for(const n of e)n.build(t);const i=t.getCodeFromNode(this,this.getNodeType(t));return i.code=this.code,i.code}serialize(t){super.serialize(t),t.code=this.code,t.language=this.language}deserialize(t){super.deserialize(t),this.code=t.code,this.language=t.language}}class lL extends oL{static get type(){return"FunctionNode"}constructor(t="",e=[],i=""){super(t,e,i)}getNodeType(t){return this.getNodeFunction(t).type}getInputs(t){return this.getNodeFunction(t).inputs}getNodeFunction(t){const e=t.getDataFromNode(this);let i=e.nodeFunction;return void 0===i&&(i=t.parser.parseFunction(this.code),e.nodeFunction=i),i}generate(t,e){super.generate(t);const i=this.getNodeFunction(t),n=i.name,s=i.type,r=t.getCodeFromNode(this,s);""!==n&&(r.name=n);const a=t.getPropertyName(r),o=this.getNodeFunction(t).getCode(a);return r.code=o+"\n","property"===e?a:t.format(`${a}()`,s,e)}}class hL extends gb{static get type(){return"FogNode"}constructor(t,e){super("float"),this.isFogNode=!0,this.colorNode=t,this.factorNode=e}getViewZNode(t){let e;const i=t.context.getViewZ;return void 0!==i&&(e=i(this)),(e||Xw.z).negate()}setup(){return this.factorNode}}class cL extends hL{static get type(){return"FogRangeNode"}constructor(t,e,i){super(t),this.isFogRangeNode=!0,this.nearNode=e,this.farNode=i}setup(t){const e=this.getViewZNode(t);return OT(this.nearNode,this.farNode,e)}}const uL=sS(cL);class dL extends hL{static get type(){return"FogExp2Node"}constructor(t,e){super(t),this.isFogExp2Node=!0,this.densityNode=e}setup(t){const e=this.getViewZNode(t),i=this.densityNode;return i.mul(i,e,e).negate().exp().oneMinus()}}const pL=sS(dL);sS(class extends gb{constructor(t){super(),this.scope=t}generate(t){const{scope:e}=this,{renderer:i}=t;!0===i.backend.isWebGLBackend?t.addFlowCode(`\t// ${e}Barrier \n`):t.addLineFlowCode(`${e}Barrier()`,this)}});class mL extends _b{static get type(){return"AtomicFunctionNode"}constructor(t,e,i,n=null){super("uint"),this.method=t,this.pointerNode=e,this.valueNode=i,this.storeNode=n}getInputType(t){return this.pointerNode.getNodeType(t)}getNodeType(t){return this.getInputType(t)}generate(t){const e=this.method,i=this.getNodeType(t),n=this.getInputType(t),s=this.pointerNode,r=this.valueNode,a=[];a.push(`&${s.build(t,n)}`),a.push(r.build(t,n));const o=`${t.getMethod(e,i)}( ${a.join(", ")} )`;if(null!==this.storeNode){const e=this.storeNode.build(t,n);t.addLineFlowCode(`${e} = ${o}`,this)}else t.addLineFlowCode(o,this)}}let fL;function gL(t){fL=fL||new WeakMap;let e=fL.get(t);return void 0===e&&fL.set(t,e={}),e}function xL(t){const e=gL(t);return e.position||(e.position=BS(new ix).setGroup(DS).onRenderUpdate(((e,i)=>i.value.setFromMatrixPosition(t.matrixWorld))))}function vL(t){const e=gL(t);return e.viewPosition||(e.viewPosition=BS(new ix).setGroup(DS).onRenderUpdate((({camera:e},i)=>{i.value=i.value||new ix,i.value.setFromMatrixPosition(t.matrixWorld),i.value.applyMatrix4(e.matrixWorldInverse)})))}mL.ATOMIC_LOAD="atomicLoad",mL.ATOMIC_STORE="atomicStore",mL.ATOMIC_ADD="atomicAdd",mL.ATOMIC_SUB="atomicSub",mL.ATOMIC_MAX="atomicMax",mL.ATOMIC_MIN="atomicMin",mL.ATOMIC_AND="atomicAnd",mL.ATOMIC_OR="atomicOr",mL.ATOMIC_XOR="atomicXor",sS(mL);const _L=t=>Dw.transformDirection(xL(t).sub(function(t){const e=gL(t);return e.targetPosition||(e.targetPosition=BS(new ix).setGroup(DS).onRenderUpdate(((e,i)=>i.value.setFromMatrixPosition(t.target.matrixWorld))))}(t))),yL=(t,e)=>{for(const i of e)if(i.isAnalyticLightNode&&i.light.id===t)return i;return null},bL=new WeakMap;class SL extends gb{static get type(){return"LightsNode"}constructor(){super("vec3"),this.totalDiffuseNode=_S().toVar("totalDiffuse"),this.totalSpecularNode=_S().toVar("totalSpecular"),this.outgoingLightNode=_S().toVar("outgoingLight"),this._lights=[],this._lightNodes=null,this._lightNodesHash=null,this.global=!0}getHash(t){if(null===this._lightNodesHash){null===this._lightNodes&&this.setupLightsNode(t);const e=[];for(const t of this._lightNodes)e.push(t.getSelf().getHash());this._lightNodesHash="lights-"+e.join(",")}return this._lightNodesHash}analyze(t){const e=t.getDataFromNode(this);for(const i of e.nodes)i.build(t)}setupLightsNode(t){const e=[],i=this._lightNodes,n=(t=>t.sort(((t,e)=>t.id-e.id)))(this._lights),s=t.renderer.library;for(const r of n)if(r.isNode)e.push(eS(r));else{let t=null;if(null!==i&&(t=yL(r.id,i)),null===t){const t=s.getLightNodeClass(r.constructor);if(null===t)continue;let i=null;bL.has(r)?i=bL.get(r):(i=eS(new t(r)),bL.set(r,i)),e.push(i)}}this._lightNodes=e}setupLights(t,e){for(const i of e)i.build(t)}setup(t){null===this._lightNodes&&this.setupLightsNode(t);const e=t.context,i=e.lightingModel;let n=this.outgoingLightNode;if(i){const{_lightNodes:s,totalDiffuseNode:r,totalSpecularNode:a}=this;e.outgoingLight=n;const o=t.addStack();t.getDataFromNode(this).nodes=o.nodes,i.start(e,o,t),this.setupLights(t,s),i.indirect(e,o,t);const{backdrop:l,backdropAlpha:h}=e,{directDiffuse:c,directSpecular:u,indirectDiffuse:d,indirectSpecular:p}=e.reflectedLight;let m=c.add(d);null!==l&&(m=_S(null!==h?h.mix(m,l):l),e.material.transparent=!0),r.assign(m),a.assign(u.add(p)),n.assign(r.add(a)),i.finish(e,o,t),n=n.bypass(t.removeStack())}return n}setLights(t){return this._lights=t,this._lightNodes=null,this._lightNodesHash=null,this}getLights(){return this._lights}get hasLights(){return this._lights.length>0}}const ML=aS((({depthTexture:t,shadowCoord:e})=>Rw(t,e.xy).compare(e.z))),TL=aS((({depthTexture:t,shadowCoord:e,shadow:i})=>{const n=(e,i)=>Rw(t,e).compare(i),s=yA("mapSize","vec2",i).setGroup(DS),r=yA("radius","float",i).setGroup(DS),a=fS(1).div(s),o=a.x.negate().mul(r),l=a.y.negate().mul(r),h=a.x.mul(r),c=a.y.mul(r),u=o.div(2),d=l.div(2),p=h.div(2),m=c.div(2);return xM(n(e.xy.add(fS(o,l)),e.z),n(e.xy.add(fS(0,l)),e.z),n(e.xy.add(fS(h,l)),e.z),n(e.xy.add(fS(u,d)),e.z),n(e.xy.add(fS(0,d)),e.z),n(e.xy.add(fS(p,d)),e.z),n(e.xy.add(fS(o,0)),e.z),n(e.xy.add(fS(u,0)),e.z),n(e.xy,e.z),n(e.xy.add(fS(p,0)),e.z),n(e.xy.add(fS(h,0)),e.z),n(e.xy.add(fS(u,m)),e.z),n(e.xy.add(fS(0,m)),e.z),n(e.xy.add(fS(p,m)),e.z),n(e.xy.add(fS(o,c)),e.z),n(e.xy.add(fS(0,c)),e.z),n(e.xy.add(fS(h,c)),e.z)).mul(1/17)})),wL=aS((({depthTexture:t,shadowCoord:e,shadow:i})=>{const n=(e,i)=>Rw(t,e).compare(i),s=yA("mapSize","vec2",i).setGroup(DS),r=fS(1).div(s),a=r.x,o=r.y,l=e.xy,h=eT(l.mul(s).add(.5));return l.subAssign(h.mul(r)),xM(n(l,e.z),n(l.add(fS(a,0)),e.z),n(l.add(fS(0,o)),e.z),n(l.add(r),e.z),UT(n(l.add(fS(a.negate(),0)),e.z),n(l.add(fS(a.mul(2),0)),e.z),h.x),UT(n(l.add(fS(a.negate(),o)),e.z),n(l.add(fS(a.mul(2),o)),e.z),h.x),UT(n(l.add(fS(0,o.negate())),e.z),n(l.add(fS(0,o.mul(2))),e.z),h.y),UT(n(l.add(fS(a,o.negate())),e.z),n(l.add(fS(a,o.mul(2))),e.z),h.y),UT(UT(n(l.add(fS(a.negate(),o.negate())),e.z),n(l.add(fS(a.mul(2),o.negate())),e.z),h.x),UT(n(l.add(fS(a.negate(),o.mul(2))),e.z),n(l.add(fS(a.mul(2),o.mul(2))),e.z),h.x),h.y)).mul(1/9)})),AL=aS((({depthTexture:t,shadowCoord:e})=>{const i=uS(1).toVar(),n=Rw(t).uv(e.xy).rg,s=TT(e.z,n.x);return hS(s.notEqual(uS(1)),(()=>{const t=e.z.sub(n.x),r=ST(0,n.y.mul(n.y));let a=r.div(r.add(t.mul(t)));a=FT(vM(a,.3).div(.95-.3)),i.assign(FT(ST(s,a)))})),i})),EL=aS((({samples:t,radius:e,size:i,shadowPass:n})=>{const s=uS(0).toVar(),r=uS(0).toVar(),a=t.lessThanEqual(uS(1)).select(uS(0),uS(2).div(t.sub(1))),o=t.lessThanEqual(uS(1)).select(uS(0),uS(-1));LE({start:dS(0),end:dS(t),type:"int",condition:"<"},(({i:t})=>{const l=o.add(uS(t).mul(a)),h=n.uv(xM(YE.xy,fS(0,l).mul(e)).div(i)).x;s.addAssign(h),r.addAssign(h.mul(h))})),s.divAssign(t),r.divAssign(t);const l=ZM(r.sub(s.mul(s)));return fS(s,l)})),CL=aS((({samples:t,radius:e,size:i,shadowPass:n})=>{const s=uS(0).toVar(),r=uS(0).toVar(),a=t.lessThanEqual(uS(1)).select(uS(0),uS(2).div(t.sub(1))),o=t.lessThanEqual(uS(1)).select(uS(0),uS(-1));LE({start:dS(0),end:dS(t),type:"int",condition:"<"},(({i:t})=>{const l=o.add(uS(t).mul(a)),h=n.uv(xM(YE.xy,fS(l,0).mul(e)).div(i));s.addAssign(h.x),r.addAssign(xM(h.y.mul(h.y),h.x.mul(h.x)))})),s.divAssign(t),r.divAssign(t);const l=ZM(r.sub(s.mul(s)));return fS(s,l)})),RL=[ML,TL,wL,AL];let NL=null;const PL=new _P;class IL extends gb{static get type(){return"ShadowNode"}constructor(t,e=null){super(),this.light=t,this.shadow=e||t.shadow,this.shadowMap=null,this.vsmShadowMapVertical=null,this.vsmShadowMapHorizontal=null,this.vsmMaterialVertical=null,this.vsmMaterialHorizontal=null,this.updateBeforeType=cb,this._node=null,this.isShadowNode=!0}setupShadow(t){const{object:e,renderer:i}=t;null===NL&&(NL=new mC,NL.fragmentNode=MS(0,0,0,1),NL.isShadowNodeMaterial=!0,NL.name="ShadowMaterial");const n=this.shadow,s=i.shadowMap.type,r=new sy(n.mapSize.width,n.mapSize.height);r.compareFunction=513;const a=t.createRenderTarget(n.mapSize.width,n.mapSize.height);if(a.depthTexture=r,n.camera.updateProjectionMatrix(),3===s){r.compareFunction=null,this.vsmShadowMapVertical=t.createRenderTarget(n.mapSize.width,n.mapSize.height,{format:Pf,type:Mf}),this.vsmShadowMapHorizontal=t.createRenderTarget(n.mapSize.width,n.mapSize.height,{format:Pf,type:Mf});const e=Rw(r),i=Rw(this.vsmShadowMapVertical.texture),s=yA("blurSamples","float",n).setGroup(DS),a=yA("radius","float",n).setGroup(DS),o=yA("mapSize","vec2",n).setGroup(DS);let l=this.vsmMaterialVertical||(this.vsmMaterialVertical=new mC);l.fragmentNode=EL({samples:s,radius:a,size:o,shadowPass:e}).context(t.getSharedContext()),l.name="VSMVertical",l=this.vsmMaterialHorizontal||(this.vsmMaterialHorizontal=new mC),l.fragmentNode=CL({samples:s,radius:a,size:o,shadowPass:i}).context(t.getSharedContext()),l.name="VSMHorizontal"}const o=yA("intensity","float",n).setGroup(DS),l=yA("bias","float",n).setGroup(DS),h=yA("normalBias","float",n).setGroup(DS),c=e.material.shadowPositionNode||Ww;let u,d=BS(n.matrix).setGroup(DS).mul(c.add(iA.mul(h)));if(n.camera.isOrthographicCamera||!0!==i.logarithmicDepthBuffer)d=d.xyz.div(d.w),u=d.z,i.coordinateSystem===vg&&(u=u.mul(2).sub(1));else{const t=d.w;d=d.xy.div(t);const e=BS("float").onRenderUpdate((()=>n.camera.near)),i=BS("float").onRenderUpdate((()=>n.camera.far));u=oC(t,e,i)}d=_S(d.x,d.y.oneMinus(),u.add(l));const p=d.x.greaterThanEqual(0).and(d.x.lessThanEqual(1)).and(d.y.greaterThanEqual(0)).and(d.y.lessThanEqual(1)).and(d.z.lessThanEqual(1)),m=n.filterNode||RL[i.shadowMap.type]||null;if(null===m)throw new Error("THREE.WebGPURenderer: Shadow map type not supported yet.");const f=Rw(a.texture,d),g=p.select(m({depthTexture:3===s?this.vsmShadowMapHorizontal.texture:r,shadowCoord:d,shadow:n}),uS(1));return this.shadowMap=a,this.shadow.map=a,UT(1,g.rgb.mix(f,1),o.mul(f.a))}setup(t){if(!1!==t.renderer.shadowMap.enabled)return null!==this._node?this._node:this._node=this.setupShadow(t)}updateShadow(t){const{shadowMap:e,light:i,shadow:n}=this,{renderer:s,scene:r,camera:a}=t,o=s.shadowMap.type,l=e.depthTexture.version;this._depthVersionCached=l;const h=r.overrideMaterial;r.overrideMaterial=NL,e.setSize(n.mapSize.width,n.mapSize.height),n.updateMatrices(i),n.camera.layers.mask=a.layers.mask;const c=s.getRenderTarget(),u=s.getRenderObjectFunction();s.setRenderObjectFunction(((t,...e)=>{(!0===t.castShadow||t.receiveShadow&&3===o)&&s.renderObject(t,...e)})),s.setRenderTarget(e),s.render(r,n.camera),s.setRenderObjectFunction(u),!0!==i.isPointLight&&3===o&&this.vsmPass(s),s.setRenderTarget(c),r.overrideMaterial=h}vsmPass(t){const{shadow:e}=this;this.vsmShadowMapVertical.setSize(e.mapSize.width,e.mapSize.height),this.vsmShadowMapHorizontal.setSize(e.mapSize.width,e.mapSize.height),t.setRenderTarget(this.vsmShadowMapVertical),PL.material=this.vsmMaterialVertical,PL.render(t),t.setRenderTarget(this.vsmShadowMapHorizontal),PL.material=this.vsmMaterialHorizontal,PL.render(t)}dispose(){this.shadowMap.dispose(),this.shadowMap=null,null!==this.vsmShadowMapVertical&&(this.vsmShadowMapVertical.dispose(),this.vsmShadowMapVertical=null,this.vsmMaterialVertical.dispose(),this.vsmMaterialVertical=null),null!==this.vsmShadowMapHorizontal&&(this.vsmShadowMapHorizontal.dispose(),this.vsmShadowMapHorizontal=null,this.vsmMaterialHorizontal.dispose(),this.vsmMaterialHorizontal=null),this.updateBeforeType=lb}updateBefore(t){const{shadow:e}=this;(e.needsUpdate||e.autoUpdate)&&(this.updateShadow(t),this.shadowMap.depthTexture.version===this._depthVersionCached&&(e.needsUpdate=!1))}}class LL extends zE{static get type(){return"AnalyticLightNode"}constructor(t=null){super(),this.updateType=hb,this.light=t,this.color=new Tv,this.colorNode=BS(this.color).setGroup(DS),this.baseColorNode=null,this.shadowNode=null,this.shadowColorNode=null,this.isAnalyticLightNode=!0}getCacheKey(){return ib(super.getCacheKey(),this.light.id,this.light.castShadow?1:0)}getHash(){return this.light.uuid}setupShadow(t){const{renderer:e}=t;if(!1===e.shadowMap.enabled)return;let i=this.shadowColorNode;if(null===i){const t=this.light.shadow.shadowNode;let e;void 0!==t?e=eS(t):(n=this.light,e=eS(new IL(n,s))),this.shadowNode=e,this.shadowColorNode=i=this.colorNode.mul(e),this.baseColorNode=this.colorNode}var n,s;this.colorNode=i}setup(t){this.colorNode=this.baseColorNode||this.colorNode,this.light.castShadow?t.object.receiveShadow&&this.setupShadow(t):null!==this.shadowNode&&this.shadowNode.dispose()}update(){const{light:t}=this;this.color.copy(t.color).multiplyScalar(t.intensity)}}const DL=aS((t=>{const{lightDistance:e,cutoffDistance:i,decayExponent:n}=t,s=e.pow(n).max(.01).reciprocal();return i.greaterThan(0).select(s.mul(e.div(i).pow4().oneMinus().clamp().pow2()),s)})),UL=aS((({color:t,lightViewPosition:e,cutoffDistance:i,decayExponent:n},s)=>{const r=s.context.lightingModel,a=e.sub(Xw),o=a.normalize(),l=a.length(),h=DL({lightDistance:l,cutoffDistance:i,decayExponent:n}),c=t.mul(h),u=s.context.reflectedLight;r.direct({lightDirection:o,lightColor:c,reflectedLight:u},s.stack,s)}));class FL extends LL{static get type(){return"PointLightNode"}constructor(t=null){super(t),this.cutoffDistanceNode=BS(0).setGroup(DS),this.decayExponentNode=BS(0).setGroup(DS)}update(t){const{light:e}=this;super.update(t),this.cutoffDistanceNode.value=e.distance,this.decayExponentNode.value=e.decay}setup(){UL({color:this.colorNode,lightViewPosition:vL(this.light),cutoffDistance:this.cutoffDistanceNode,decayExponent:this.decayExponentNode}).append()}}const BL=aS((([t,e])=>{const i=t.x,n=t.y,s=t.z;let r=e.element(0).mul(.886227);return r=r.add(e.element(1).mul(1.023328).mul(n)),r=r.add(e.element(2).mul(1.023328).mul(s)),r=r.add(e.element(3).mul(1.023328).mul(i)),r=r.add(e.element(4).mul(.858086).mul(i).mul(n)),r=r.add(e.element(5).mul(.858086).mul(n).mul(s)),r=r.add(e.element(6).mul(s.mul(s).mul(.743125).sub(.247708))),r=r.add(e.element(7).mul(.858086).mul(i).mul(s)),r=r.add(e.element(8).mul(.429043).mul(_M(i,i).sub(_M(n,n)))),r})),OL=new uP;class zL extends FN{constructor(t,e){super(),this.renderer=t,this.nodes=e}update(t,e,i){const n=this.renderer,s=this.nodes.getBackgroundNode(t)||t.background;let r=!1;if(null===s)n._clearColor.getRGB(OL,ng),OL.a=n._clearColor.a;else if(!0===s.isColor)s.getRGB(OL,ng),OL.a=1,r=!0;else if(!0===s.isNode){const i=this.get(t),r=s;OL.copy(n._clearColor);let a=i.backgroundMesh;if(void 0===a){const t=WT(MS(r).mul(TP),{getUV:()=>wP.mul(tA),getTextureLevel:()=>MP});let e=bE();e=e.setZ(e.w);const n=new mC;n.name="Background.material",n.side=1,n.depthTest=!1,n.depthWrite=!1,n.fog=!1,n.lights=!1,n.vertexNode=e,n.colorNode=t,i.backgroundMeshNode=t,i.backgroundMesh=a=new r_(new ay(1,32,32),n),a.frustumCulled=!1,a.name="Background.mesh",a.onBeforeRender=function(t,e,i){this.matrixWorld.copyPosition(i.matrixWorld)}}const o=r.getCacheKey();i.backgroundCacheKey!==o&&(i.backgroundMeshNode.node=MS(r).mul(TP),i.backgroundMeshNode.needsUpdate=!0,a.material.needsUpdate=!0,i.backgroundCacheKey=o),e.unshift(a,a.geometry,a.material,0,0,null)}if(!0===n.autoClear||!0===r){const t=i.clearColorValue;t.r=OL.r,t.g=OL.g,t.b=OL.b,t.a=OL.a,!0!==n.backend.isWebGLBackend&&!0!==n.alpha||(t.r*=t.a,t.g*=t.a,t.b*=t.a),i.depthClearValue=n._clearDepth,i.stencilClearValue=n._clearStencil,i.clearColor=!0===n.autoClearColor,i.clearDepth=!0===n.autoClearDepth,i.clearStencil=!0===n.autoClearStencil}else i.clearColor=!1,i.clearDepth=!1,i.clearStencil=!1}}let kL=0;class VL{constructor(t="",e=[],i=0,n=[]){this.name=t,this.bindings=e,this.index=i,this.bindingsReference=n,this.id=kL++}}class GL{constructor(t,e,i,n,s,r,a,o,l,h=[]){this.vertexShader=t,this.fragmentShader=e,this.computeShader=i,this.transforms=h,this.nodeAttributes=n,this.bindings=s,this.updateNodes=r,this.updateBeforeNodes=a,this.updateAfterNodes=o,this.monitor=l,this.usedTimes=0}createBindings(){const t=[];for(const e of this.bindings){if(!0!==e.bindings[0].groupNode.shared){const i=new VL(e.name,[],e.index,e);t.push(i);for(const t of e.bindings)i.bindings.push(t.clone())}else t.push(e)}return t}}class HL{constructor(t,e,i=null){this.isNodeAttribute=!0,this.name=t,this.type=e,this.node=i}}class WL{constructor(t,e,i){this.isNodeUniform=!0,this.name=t,this.type=e,this.node=i.getSelf()}get value(){return this.node.value}set value(t){this.node.value=t}get id(){return this.node.id}get groupNode(){return this.node.groupNode}}class jL{constructor(t,e){this.isNodeVar=!0,this.name=t,this.type=e}}class XL extends jL{constructor(t,e){super(t,e),this.needsInterpolation=!1,this.isNodeVarying=!0}}class qL{constructor(t,e,i=""){this.name=t,this.type=e,this.code=i,Object.defineProperty(this,"isNodeCode",{value:!0})}}let $L=0;class YL{constructor(t=null){this.id=$L++,this.nodesData=new WeakMap,this.parent=t}getData(t){let e=this.nodesData.get(t);return void 0===e&&null!==this.parent&&(e=this.parent.getData(t)),e}setData(t,e){this.nodesData.set(t,e)}}class ZL{constructor(t,e){this.name=t,this.value=e,this.boundary=0,this.itemSize=0,this.offset=0}setValue(t){this.value=t}getValue(){return this.value}}class KL extends ZL{constructor(t,e=0){super(t,e),this.isNumberUniform=!0,this.boundary=4,this.itemSize=1}}class JL extends ZL{constructor(t,e=new Pg){super(t,e),this.isVector2Uniform=!0,this.boundary=8,this.itemSize=2}}class QL extends ZL{constructor(t,e=new ix){super(t,e),this.isVector3Uniform=!0,this.boundary=16,this.itemSize=3}}class tD extends ZL{constructor(t,e=new Kg){super(t,e),this.isVector4Uniform=!0,this.boundary=16,this.itemSize=4}}class eD extends ZL{constructor(t,e=new Tv){super(t,e),this.isColorUniform=!0,this.boundary=16,this.itemSize=3}}class iD extends ZL{constructor(t,e=new Ig){super(t,e),this.isMatrix3Uniform=!0,this.boundary=48,this.itemSize=12}}class nD extends ZL{constructor(t,e=new Ix){super(t,e),this.isMatrix4Uniform=!0,this.boundary=64,this.itemSize=16}}class sD extends KL{constructor(t){super(t.name,t.value),this.nodeUniform=t}getValue(){return this.nodeUniform.value}}class rD extends JL{constructor(t){super(t.name,t.value),this.nodeUniform=t}getValue(){return this.nodeUniform.value}}class aD extends QL{constructor(t){super(t.name,t.value),this.nodeUniform=t}getValue(){return this.nodeUniform.value}}class oD extends tD{constructor(t){super(t.name,t.value),this.nodeUniform=t}getValue(){return this.nodeUniform.value}}class lD extends eD{constructor(t){super(t.name,t.value),this.nodeUniform=t}getValue(){return this.nodeUniform.value}}class hD extends iD{constructor(t){super(t.name,t.value),this.nodeUniform=t}getValue(){return this.nodeUniform.value}}class cD extends nD{constructor(t){super(t.name,t.value),this.nodeUniform=t}getValue(){return this.nodeUniform.value}}const uD=[.125,.215,.35,.446,.526,.582],dD=20,pD=new Uy(-1,1,1,-1,0,1),mD=new m_(90,1),fD=new Tv;let gD=null,xD=0,vD=0;const _D=(1+Math.sqrt(5))/2,yD=1/_D,bD=[new ix(-_D,yD,0),new ix(_D,yD,0),new ix(-yD,0,_D),new ix(yD,0,_D),new ix(0,_D,-yD),new ix(0,_D,yD),new ix(-1,1,-1),new ix(1,1,-1),new ix(-1,1,1),new ix(1,1,1)],SD=[3,1,5,0,4,2],MD=$R(Mw(),Sw("faceIndex")).normalize(),TD=_S(MD.x,MD.y.negate(),MD.z);class wD{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._lodMeshes=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._backgroundBox=null}fromScene(t,e=0,i=.1,n=100){gD=this._renderer.getRenderTarget(),xD=this._renderer.getActiveCubeFace(),vD=this._renderer.getActiveMipmapLevel(),this._setSize(256);const s=this._allocateTargets();return s.depthBuffer=!0,this._sceneToCubeUV(t,i,n,s),e>0&&this._blur(s,0,0,e),this._applyPMREM(s),this._cleanup(s),s}fromEquirectangular(t,e=null){return this._fromTexture(t,e)}fromCubemap(t,e=null){return this._fromTexture(t,e)}async compileCubemapShader(){null===this._cubemapMaterial&&(this._cubemapMaterial=RD(),await this._compileMaterial(this._cubemapMaterial))}async compileEquirectangularShader(){null===this._equirectMaterial&&(this._equirectMaterial=ND(),await this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),null!==this._cubemapMaterial&&this._cubemapMaterial.dispose(),null!==this._equirectMaterial&&this._equirectMaterial.dispose(),null!==this._backgroundBox&&(this._backgroundBox.geometry.dispose(),this._backgroundBox.material.dispose())}_setSize(t){this._lodMax=Math.floor(Math.log2(t)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){null!==this._blurMaterial&&this._blurMaterial.dispose(),null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose();for(let t=0;t<this._lodPlanes.length;t++)this._lodPlanes[t].dispose()}_cleanup(t){this._renderer.setRenderTarget(gD,xD,vD),t.scissorTest=!1,ED(t,0,0,t.width,t.height)}_fromTexture(t,e){t.mapping===nf||t.mapping===sf?this._setSize(0===t.image.length?16:t.image[0].width||t.image[0].image.width):this._setSize(t.image.width/4),gD=this._renderer.getRenderTarget(),xD=this._renderer.getActiveCubeFace(),vD=this._renderer.getActiveMipmapLevel();const i=e||this._allocateTargets();return this._textureToCubeUV(t,i),this._applyPMREM(i),this._cleanup(i),i}_allocateTargets(){const t=3*Math.max(this._cubeSize,112),e=4*this._cubeSize,i={magFilter:pf,minFilter:pf,generateMipmaps:!1,type:Mf,format:Af,colorSpace:ng},n=AD(t,e,i);if(null===this._pingPongRenderTarget||this._pingPongRenderTarget.width!==t||this._pingPongRenderTarget.height!==e){null!==this._pingPongRenderTarget&&this._dispose(),this._pingPongRenderTarget=AD(t,e,i);const{_lodMax:n}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas,lodMeshes:this._lodMeshes}=function(t){const e=[],i=[],n=[],s=[];let r=t;const a=t-4+1+uD.length;for(let o=0;o<a;o++){const a=Math.pow(2,r);i.push(a);let l=1/a;o>t-4?l=uD[o-t+4-1]:0===o&&(l=0),n.push(l);const h=1/(a-2),c=-h,u=1+h,d=[c,c,u,c,u,u,c,c,u,u,c,u],p=6,m=6,f=3,g=2,x=1,v=new Float32Array(f*m*p),_=new Float32Array(g*m*p),y=new Float32Array(x*m*p);for(let t=0;t<p;t++){const e=t%3*2/3-1,i=t>2?0:-1,n=[e,i,0,e+2/3,i,0,e+2/3,i+1,0,e,i,0,e+2/3,i+1,0,e,i+1,0],s=SD[t];v.set(n,f*m*s),_.set(d,g*m*s);const r=[s,s,s,s,s,s];y.set(r,x*m*s)}const b=new qv;b.setAttribute("position",new Uv(v,f)),b.setAttribute("uv",new Uv(_,g)),b.setAttribute("faceIndex",new Uv(y,x)),e.push(b),s.push(new r_(b,null)),r>4&&r--}return{lodPlanes:e,sizeLods:i,sigmas:n,lodMeshes:s}}(n)),this._blurMaterial=function(t,e,i){const n=xA(new Array(dD).fill(0)),s=BS(new ix(0,1,0)),r=BS(0),a=uS(dD),o=BS(0),l=BS(1),h=Rw(null),c=BS(0),u=uS(1/e),d=uS(1/i),p=uS(t),m={n:a,latitudinal:o,weights:n,poleAxis:s,outputDirection:TD,dTheta:r,samples:l,envMap:h,mipInt:c,CUBEUV_TEXEL_WIDTH:u,CUBEUV_TEXEL_HEIGHT:d,CUBEUV_MAX_MIP:p},f=CD("blur");return f.uniforms=m,f.fragmentNode=JR({...m,latitudinal:o.equal(1)}),f}(n,t,e)}return n}async _compileMaterial(t){const e=new r_(this._lodPlanes[0],t);await this._renderer.compile(e,pD)}_sceneToCubeUV(t,e,i,n){const s=mD;s.near=e,s.far=i;const r=[-1,1,-1,-1,-1,-1],a=[1,1,1,-1,-1,-1],o=this._renderer,l=o.autoClear;o.getClearColor(fD),o.autoClear=!1;let h=this._backgroundBox;if(null===h){const t=new Cv({name:"PMREM.Background",side:1,depthWrite:!1,depthTest:!1});h=new r_(new o_,t)}let c=!1;const u=t.background;u?u.isColor&&(h.material.color.copy(u),t.background=null,c=!0):(h.material.color.copy(fD),c=!0),o.setRenderTarget(n),o.clear(),c&&o.render(h,s);for(let d=0;d<6;d++){const e=d%3;0===e?(s.up.set(0,r[d],0),s.lookAt(a[d],0,0)):1===e?(s.up.set(0,0,r[d]),s.lookAt(0,a[d],0)):(s.up.set(0,r[d],0),s.lookAt(0,0,a[d]));const i=this._cubeSize;ED(n,e*i,d>2?i:0,i,i),o.render(t,s)}o.autoClear=l,t.background=u}_textureToCubeUV(t,e){const i=this._renderer,n=t.mapping===nf||t.mapping===sf;n?null===this._cubemapMaterial&&(this._cubemapMaterial=RD(t)):null===this._equirectMaterial&&(this._equirectMaterial=ND(t));const s=n?this._cubemapMaterial:this._equirectMaterial;s.fragmentNode.value=t;const r=this._lodMeshes[0];r.material=s;const a=this._cubeSize;ED(e,0,0,3*a,2*a),i.setRenderTarget(e),i.render(r,pD)}_applyPMREM(t){const e=this._renderer,i=e.autoClear;e.autoClear=!1;const n=this._lodPlanes.length;for(let s=1;s<n;s++){const e=Math.sqrt(this._sigmas[s]*this._sigmas[s]-this._sigmas[s-1]*this._sigmas[s-1]),i=bD[(n-s-1)%bD.length];this._blur(t,s-1,s,e,i)}e.autoClear=i}_blur(t,e,i,n,s){const r=this._pingPongRenderTarget;this._halfBlur(t,r,e,i,n,"latitudinal",s),this._halfBlur(r,t,i,i,n,"longitudinal",s)}_halfBlur(t,e,i,n,s,r,a){const o=this._renderer,l=this._blurMaterial,h=this._lodMeshes[n];h.material=l;const c=l.uniforms,u=this._sizeLods[i]-1,d=isFinite(s)?Math.PI/(2*u):2*Math.PI/39,p=s/d,m=isFinite(s)?1+Math.floor(3*p):dD,f=[];let g=0;for(let _=0;_<dD;++_){const t=_/p,e=Math.exp(-t*t/2);f.push(e),0===_?g+=e:_<m&&(g+=2*e)}for(let _=0;_<f.length;_++)f[_]=f[_]/g;t.texture.frame=(t.texture.frame||0)+1,c.envMap.value=t.texture,c.samples.value=m,c.weights.array=f,c.latitudinal.value="latitudinal"===r?1:0,a&&(c.poleAxis.value=a);const{_lodMax:x}=this;c.dTheta.value=d,c.mipInt.value=x-i;const v=this._sizeLods[n];ED(e,3*v*(n>x-4?n-x+4:0),4*(this._cubeSize-v),3*v,2*v),o.setRenderTarget(e),o.render(h,pD)}}function AD(t,e,i){const n=new Jg(t,e,i);return n.texture.mapping=306,n.texture.name="PMREM.cubeUv",n.texture.isPMREMTexture=!0,n.scissorTest=!0,n}function ED(t,e,i,n,s){t.viewport.set(e,i,n,s),t.scissor.set(e,i,n,s)}function CD(t){const e=new mC;return e.depthTest=!1,e.depthWrite=!1,e.blending=0,e.name=`PMREM_${t}`,e}function RD(t){const e=CD("cubemap");return e.fragmentNode=dA(t,TD),e}function ND(t){const e=CD("equirect");return e.fragmentNode=Rw(t,SC(TD),0),e}const PD=new WeakMap,ID=new Map([[2,"vec2"],[3,"vec3"],[4,"vec4"],[9,"mat3"],[16,"mat4"]]),LD=new Map([[Int8Array,"int"],[Int16Array,"int"],[Int32Array,"int"],[Uint8Array,"uint"],[Uint16Array,"uint"],[Uint32Array,"uint"],[Float32Array,"float"]]),DD=t=>/e/g.test(t)?String(t).replace(/\+/g,""):(t=Number(t))+(t%1?"":".0");class UD{constructor(t,e,i){this.object=t,this.material=t&&t.material||null,this.geometry=t&&t.geometry||null,this.renderer=e,this.parser=i,this.scene=null,this.camera=null,this.nodes=[],this.sequentialNodes=[],this.updateNodes=[],this.updateBeforeNodes=[],this.updateAfterNodes=[],this.hashNodes={},this.monitor=null,this.lightsNode=null,this.environmentNode=null,this.fogNode=null,this.clippingContext=null,this.vertexShader=null,this.fragmentShader=null,this.computeShader=null,this.flowNodes={vertex:[],fragment:[],compute:[]},this.flowCode={vertex:"",fragment:"",compute:""},this.uniforms={vertex:[],fragment:[],compute:[],index:0},this.structs={vertex:[],fragment:[],compute:[],index:0},this.bindings={vertex:{},fragment:{},compute:{}},this.bindingsIndexes={},this.bindGroups=null,this.attributes=[],this.bufferAttributes=[],this.varyings=[],this.codes={},this.vars={},this.flow={code:""},this.chaining=[],this.stack=mP(),this.stacks=[],this.tab="\t",this.currentFunctionNode=null,this.context={material:this.material},this.cache=new YL,this.globalCache=this.cache,this.flowsData=new WeakMap,this.shaderStage=null,this.buildStage=null,this.useComparisonMethod=!1}getBindGroupsCache(){let t=PD.get(this.renderer);return void 0===t&&(t=new RN,PD.set(this.renderer,t)),t}createRenderTarget(t,e,i){return new Jg(t,e,i)}createCubeRenderTarget(t,e){return new MC(t,e)}createPMREMGenerator(){return new wD(this.renderer)}includes(t){return this.nodes.includes(t)}_getBindGroup(t,e){const i=this.getBindGroupsCache(),n=[];let s,r=!0;for(const a of e)n.push(a),r=r&&!0!==a.groupNode.shared;return r?(s=i.get(n),void 0===s&&(s=new VL(t,n,this.bindingsIndexes[t].group,n),i.set(n,s))):s=new VL(t,n,this.bindingsIndexes[t].group,n),s}getBindGroupArray(t,e){const i=this.bindings[e];let n=i[t];return void 0===n&&(void 0===this.bindingsIndexes[t]&&(this.bindingsIndexes[t]={binding:0,group:Object.keys(this.bindingsIndexes).length}),i[t]=n=[]),n}getBindings(){let t=this.bindGroups;if(null===t){const e={},i=this.bindings;for(const t of pb)for(const n in i[t]){const s=i[t][n];(e[n]||(e[n]=[])).push(...s)}t=[];for(const n in e){const i=e[n],s=this._getBindGroup(n,i);t.push(s)}this.bindGroups=t}return t}sortBindingGroups(){const t=this.getBindings();t.sort(((t,e)=>t.bindings[0].groupNode.order-e.bindings[0].groupNode.order));for(let e=0;e<t.length;e++){const i=t[e];this.bindingsIndexes[i.name].group=e,i.index=e}}setHashNode(t,e){this.hashNodes[e]=t}addNode(t){!1===this.nodes.includes(t)&&(this.nodes.push(t),this.setHashNode(t,t.getHash(this)))}addSequentialNode(t){!1===this.sequentialNodes.includes(t)&&this.sequentialNodes.push(t)}buildUpdateNodes(){for(const t of this.nodes){t.getUpdateType()!==lb&&this.updateNodes.push(t.getSelf())}for(const t of this.sequentialNodes){const e=t.getUpdateBeforeType(),i=t.getUpdateAfterType();e!==lb&&this.updateBeforeNodes.push(t.getSelf()),i!==lb&&this.updateAfterNodes.push(t.getSelf())}}get currentNode(){return this.chaining[this.chaining.length-1]}isFilteredTexture(t){return t.magFilter===pf||t.magFilter===mf||t.magFilter===df||t.magFilter===ff||t.minFilter===pf||t.minFilter===mf||t.minFilter===df||t.minFilter===ff}addChain(t){this.chaining.push(t)}removeChain(t){if(this.chaining.pop()!==t)throw new Error("NodeBuilder: Invalid node chaining!")}getMethod(t){return t}getNodeFromHash(t){return this.hashNodes[t]}addFlow(t,e){return this.flowNodes[t].push(e),e}setContext(t){this.context=t}getContext(){return this.context}getSharedContext(){return this.context,this.context}setCache(t){this.cache=t}getCache(){return this.cache}getCacheFromNode(t,e=!0){const i=this.getDataFromNode(t);return void 0===i.cache&&(i.cache=new YL(e?this.getCache():null)),i.cache}isAvailable(){return!1}getVertexIndex(){}getInstanceIndex(){}getDrawIndex(){}getFrontFacing(){}getFragCoord(){}isFlipY(){return!1}increaseUsage(t){const e=this.getDataFromNode(t);return e.usageCount=void 0===e.usageCount?1:e.usageCount+1,e.usageCount}generateTexture(){}generateTextureLod(){}generateConst(t,e=null){if(null===e&&("float"===t||"int"===t||"uint"===t?e=0:"bool"===t?e=!1:"color"===t?e=new Tv:"vec2"===t?e=new Pg:"vec3"===t?e=new ix:"vec4"===t&&(e=new Kg)),"float"===t)return DD(e);if("int"===t)return`${Math.round(e)}`;if("uint"===t)return e>=0?`${Math.round(e)}u`:"0u";if("bool"===t)return e?"true":"false";if("color"===t)return`${this.getType("vec3")}( ${DD(e.r)}, ${DD(e.g)}, ${DD(e.b)} )`;const i=this.getTypeLength(t),n=this.getComponentType(t),s=t=>this.generateConst(n,t);if(2===i)return`${this.getType(t)}( ${s(e.x)}, ${s(e.y)} )`;if(3===i)return`${this.getType(t)}( ${s(e.x)}, ${s(e.y)}, ${s(e.z)} )`;if(4===i)return`${this.getType(t)}( ${s(e.x)}, ${s(e.y)}, ${s(e.z)}, ${s(e.w)} )`;if(i>4&&e&&(e.isMatrix3||e.isMatrix4))return`${this.getType(t)}( ${e.elements.map(s).join(", ")} )`;if(i>4)return`${this.getType(t)}()`;throw new Error(`NodeBuilder: Type '${t}' not found in generate constant attempt.`)}getType(t){return"color"===t?"vec3":t}hasGeometryAttribute(t){return this.geometry&&void 0!==this.geometry.getAttribute(t)}getAttribute(t,e){const i=this.attributes;for(const s of i)if(s.name===t)return s;const n=new HL(t,e);return i.push(n),n}getPropertyName(t){return t.name}isVector(t){return/vec\d/.test(t)}isMatrix(t){return/mat\d/.test(t)}isReference(t){return"void"===t||"property"===t||"sampler"===t||"texture"===t||"cubeTexture"===t||"storageTexture"===t||"depthTexture"===t||"texture3D"===t}needsToWorkingColorSpace(){return!1}getComponentTypeFromTexture(t){const e=t.type;if(t.isDataTexture){if(e===yf)return"int";if(e===bf)return"uint"}return"float"}getElementType(t){return"mat2"===t?"vec2":"mat3"===t?"vec3":"mat4"===t?"vec4":this.getComponentType(t)}getComponentType(t){if("float"===(t=this.getVectorType(t))||"bool"===t||"int"===t||"uint"===t)return t;const e=/(b|i|u|)(vec|mat)([2-4])/.exec(t);return null===e?null:"b"===e[1]?"bool":"i"===e[1]?"int":"u"===e[1]?"uint":"float"}getVectorType(t){return"color"===t?"vec3":"texture"===t||"cubeTexture"===t||"storageTexture"===t||"texture3D"===t?"vec4":t}getTypeFromLength(t,e="float"){if(1===t)return e;const i=ID.get(t);return("float"===e?"":e[0])+i}getTypeFromArray(t){return LD.get(t.constructor)}getTypeFromAttribute(t){let e=t;t.isInterleavedBufferAttribute&&(e=t.data);const i=e.array,n=t.itemSize,s=t.normalized;let r;return t instanceof Ov||!0===s||(r=this.getTypeFromArray(i)),this.getTypeFromLength(n,r)}getTypeLength(t){const e=this.getVectorType(t),i=/vec([2-4])/.exec(e);return null!==i?Number(i[1]):"float"===e||"bool"===e||"int"===e||"uint"===e?1:!0===/mat2/.test(t)?4:!0===/mat3/.test(t)?9:!0===/mat4/.test(t)?16:0}getVectorFromMatrix(t){return t.replace("mat","vec")}changeComponentType(t,e){return this.getTypeFromLength(this.getTypeLength(t),e)}getIntegerType(t){const e=this.getComponentType(t);return"int"===e||"uint"===e?t:this.changeComponentType(t,"int")}addStack(){return this.stack=mP(this.stack),this.stacks.push(lS()||this.stack),oS(this.stack),this.stack}removeStack(){const t=this.stack;return this.stack=t.parent,oS(this.stacks.pop()),t}getDataFromNode(t,e=this.shaderStage,i=null){let n=(i=null===i?t.isGlobal(this)?this.globalCache:this.cache:i).getData(t);return void 0===n&&(n={},i.setData(t,n)),void 0===n[e]&&(n[e]={}),n[e]}getNodeProperties(t,e="any"){const i=this.getDataFromNode(t,e);return i.properties||(i.properties={outputNode:null})}getBufferAttributeFromNode(t,e){const i=this.getDataFromNode(t);let n=i.bufferAttribute;if(void 0===n){const s=this.uniforms.index++;n=new HL("nodeAttribute"+s,e,t),this.bufferAttributes.push(n),i.bufferAttribute=n}return n}getStructTypeFromNode(t,e=this.shaderStage){const i=this.getDataFromNode(t,e);if(void 0===i.structType){const n=this.structs.index++;t.name=`StructType${n}`,this.structs[e].push(t),i.structType=t}return t}getUniformFromNode(t,e,i=this.shaderStage,n=null){const s=this.getDataFromNode(t,i,this.globalCache);let r=s.uniform;if(void 0===r){const a=this.uniforms.index++;r=new WL(n||"nodeUniform"+a,e,t),this.uniforms[i].push(r),s.uniform=r}return r}getVarFromNode(t,e=null,i=t.getNodeType(this),n=this.shaderStage){const s=this.getDataFromNode(t,n);let r=s.variable;if(void 0===r){const t=this.vars[n]||(this.vars[n]=[]);null===e&&(e="nodeVar"+t.length),r=new jL(e,i),t.push(r),s.variable=r}return r}getVaryingFromNode(t,e=null,i=t.getNodeType(this)){const n=this.getDataFromNode(t,"any");let s=n.varying;if(void 0===s){const t=this.varyings,r=t.length;null===e&&(e="nodeVarying"+r),s=new XL(e,i),t.push(s),n.varying=s}return s}getCodeFromNode(t,e,i=this.shaderStage){const n=this.getDataFromNode(t);let s=n.code;if(void 0===s){const t=this.codes[i]||(this.codes[i]=[]),r=t.length;s=new qL("nodeCode"+r,e),t.push(s),n.code=s}return s}addFlowCodeHierarchy(t,e){const{flowCodes:i,flowCodeBlock:n}=this.getDataFromNode(t);let s=!0,r=e;for(;r;){if(!0===n.get(r)){s=!1;break}r=this.getDataFromNode(r).parentNodeBlock}if(s)for(const a of i)this.addLineFlowCode(a)}addLineFlowCodeBlock(t,e,i){const n=this.getDataFromNode(t),s=n.flowCodes||(n.flowCodes=[]),r=n.flowCodeBlock||(n.flowCodeBlock=new WeakMap);s.push(e),r.set(i,!0)}addLineFlowCode(t,e=null){return""===t||(null!==e&&this.context.nodeBlock&&this.addLineFlowCodeBlock(e,t,this.context.nodeBlock),t=this.tab+t,/;\s*$/.test(t)||(t+=";\n"),this.flow.code+=t),this}addFlowCode(t){return this.flow.code+=t,this}addFlowTab(){return this.tab+="\t",this}removeFlowTab(){return this.tab=this.tab.slice(0,-1),this}getFlowData(t){return this.flowsData.get(t)}flowNode(t){const e=t.getNodeType(this),i=this.flowChildNode(t,e);return this.flowsData.set(t,i),i}buildFunctionNode(t){const e=new lL,i=this.currentFunctionNode;return this.currentFunctionNode=e,e.code=this.buildFunctionCode(t),this.currentFunctionNode=i,e}flowShaderNode(t){const e=t.layout,i={[Symbol.iterator](){let t=0;const e=Object.values(this);return{next:()=>({value:e[t],done:t++>=e.length})}}};for(const r of e.inputs)i[r.name]=new dP(r.type,r.name);t.layout=null;const n=t.call(i),s=this.flowStagesNode(n,e.type);return t.layout=e,s}flowStagesNode(t,e=null){const i=this.flow,n=this.vars,s=this.cache,r=this.buildStage,a=this.stack,o={code:""};this.flow=o,this.vars={},this.cache=new YL,this.stack=mP();for(const l of db)this.setBuildStage(l),o.result=t.build(this,e);return o.vars=this.getVars(this.shaderStage),this.flow=i,this.vars=n,this.cache=s,this.stack=a,this.setBuildStage(r),o}getFunctionOperator(){return null}flowChildNode(t,e=null){const i=this.flow,n={code:""};return this.flow=n,n.result=t.build(this,e),this.flow=i,n}flowNodeFromShaderStage(t,e,i=null,n=null){const s=this.shaderStage;this.setShaderStage(t);const r=this.flowChildNode(e,i);return null!==n&&(r.code+=`${this.tab+n} = ${r.result};\n`),this.flowCode[t]=this.flowCode[t]+r.code,this.setShaderStage(s),r}getAttributesArray(){return this.attributes.concat(this.bufferAttributes)}getAttributes(){}getVaryings(){}getVar(t,e){return`${this.getType(t)} ${e}`}getVars(t){let e="";const i=this.vars[t];if(void 0!==i)for(const n of i)e+=`${this.getVar(n.type,n.name)}; `;return e}getUniforms(){}getCodes(t){const e=this.codes[t];let i="";if(void 0!==e)for(const n of e)i+=n.code+"\n";return i}getHash(){return this.vertexShader+this.fragmentShader+this.computeShader}setShaderStage(t){this.shaderStage=t}getShaderStage(){return this.shaderStage}setBuildStage(t){this.buildStage=t}getBuildStage(){return this.buildStage}buildCode(){}build(){const{object:t,material:e,renderer:i}=this;if(null!==e){let t=i.library.fromMaterial(e);null===t&&(t=new mC),t.build(this)}else this.addFlow("compute",t);for(const n of db){this.setBuildStage(n),this.context.vertex&&this.context.vertex.isNode&&this.flowNodeFromShaderStage("vertex",this.context.vertex);for(const t of pb){this.setShaderStage(t);const e=this.flowNodes[t];for(const t of e)"generate"===n?this.flowNode(t):t.build(this)}}return this.setBuildStage(null),this.setShaderStage(null),this.buildCode(),this.buildUpdateNodes(),this}getNodeUniform(t,e){if("float"===e||"int"===e||"uint"===e)return new sD(t);if("vec2"===e||"ivec2"===e||"uvec2"===e)return new rD(t);if("vec3"===e||"ivec3"===e||"uvec3"===e)return new aD(t);if("vec4"===e||"ivec4"===e||"uvec4"===e)return new oD(t);if("color"===e)return new lD(t);if("mat3"===e)return new hD(t);if("mat4"===e)return new cD(t);throw new Error(`Uniform "${e}" not declared.`)}createNodeMaterial(t="NodeMaterial"){throw new Error(`THREE.NodeBuilder: createNodeMaterial() was deprecated. Use new ${t}() instead.`)}format(t,e,i){if((e=this.getVectorType(e))===(i=this.getVectorType(i))||null===i||this.isReference(i))return t;const n=this.getTypeLength(e),s=this.getTypeLength(i);return 16===n&&9===s?`${this.getType(i)}(${t}[0].xyz, ${t}[1].xyz, ${t}[2].xyz)`:9===n&&4===s?`${this.getType(i)}(${t}[0].xy, ${t}[1].xy)`:n>4||s>4||0===s?t:n===s?`${this.getType(i)}( ${t} )`:n>s?this.format(`${t}.${"xyz".slice(0,s)}`,this.getTypeFromLength(s,this.getComponentType(e)),i):4===s&&n>1?`${this.getType(i)}( ${this.format(t,e,"vec3")}, 1.0 )`:2===n?`${this.getType(i)}( ${this.format(t,e,"vec2")}, 0.0 )`:(1===n&&s>1&&e!==this.getComponentType(i)&&(t=`${this.getType(this.getComponentType(i))}( ${t} )`),`${this.getType(i)}( ${t} )`)}getSignature(){return`// Three.js r${zm} - Node System\n`}}class FD{constructor(){this.time=0,this.deltaTime=0,this.frameId=0,this.renderId=0,this.startTime=null,this.updateMap=new WeakMap,this.updateBeforeMap=new WeakMap,this.updateAfterMap=new WeakMap,this.renderer=null,this.material=null,this.camera=null,this.object=null,this.scene=null}_getMaps(t,e){let i=t.get(e);return void 0===i&&(i={renderMap:new WeakMap,frameMap:new WeakMap},t.set(e,i)),i}updateBeforeNode(t){const e=t.getUpdateBeforeType(),i=t.updateReference(this);if(e===hb){const{frameMap:e}=this._getMaps(this.updateBeforeMap,i);e.get(i)!==this.frameId&&!1!==t.updateBefore(this)&&e.set(i,this.frameId)}else if(e===cb){const{renderMap:e}=this._getMaps(this.updateBeforeMap,i);e.get(i)!==this.renderId&&!1!==t.updateBefore(this)&&e.set(i,this.renderId)}else e===ub&&t.updateBefore(this)}updateAfterNode(t){const e=t.getUpdateAfterType(),i=t.updateReference(this);if(e===hb){const{frameMap:e}=this._getMaps(this.updateAfterMap,i);e.get(i)!==this.frameId&&!1!==t.updateAfter(this)&&e.set(i,this.frameId)}else if(e===cb){const{renderMap:e}=this._getMaps(this.updateAfterMap,i);e.get(i)!==this.renderId&&!1!==t.updateAfter(this)&&e.set(i,this.renderId)}else e===ub&&t.updateAfter(this)}updateNode(t){const e=t.getUpdateType(),i=t.updateReference(this);if(e===hb){const{frameMap:e}=this._getMaps(this.updateMap,i);e.get(i)!==this.frameId&&!1!==t.update(this)&&e.set(i,this.frameId)}else if(e===cb){const{renderMap:e}=this._getMaps(this.updateMap,i);e.get(i)!==this.renderId&&!1!==t.update(this)&&e.set(i,this.renderId)}else e===ub&&t.update(this)}update(){this.frameId++,void 0===this.lastTime&&(this.lastTime=performance.now()),this.deltaTime=(performance.now()-this.lastTime)/1e3,this.lastTime=performance.now(),this.time+=this.deltaTime}}class BD{constructor(t,e,i=null,n="",s=!1){this.type=t,this.name=e,this.count=i,this.qualifier=n,this.isConst=s}}BD.isNodeFunctionInput=!0;class OD extends LL{static get type(){return"DirectionalLightNode"}constructor(t=null){super(t)}setup(t){super.setup(t);const e=t.context.lightingModel,i=this.colorNode,n=_L(this.light),s=t.context.reflectedLight;e.direct({lightDirection:n,lightColor:i,reflectedLight:s},t.stack,t)}}const zD=new Ix,kD=new Ix;let VD=null;class GD extends LL{static get type(){return"RectAreaLightNode"}constructor(t=null){super(t),this.halfHeight=BS(new ix).setGroup(DS),this.halfWidth=BS(new ix).setGroup(DS),this.updateType=cb}update(t){super.update(t);const{light:e}=this,i=t.camera.matrixWorldInverse;kD.identity(),zD.copy(e.matrixWorld),zD.premultiply(i),kD.extractRotation(zD),this.halfWidth.value.set(.5*e.width,0,0),this.halfHeight.value.set(0,.5*e.height,0),this.halfWidth.value.applyMatrix4(kD),this.halfHeight.value.applyMatrix4(kD)}setup(t){let e,i;super.setup(t),t.isAvailable("float32Filterable")?(e=Rw(VD.LTC_FLOAT_1),i=Rw(VD.LTC_FLOAT_2)):(e=Rw(VD.LTC_HALF_1),i=Rw(VD.LTC_HALF_2));const{colorNode:n,light:s}=this,r=t.context.lightingModel,a=vL(s),o=t.context.reflectedLight;r.directRectArea({lightColor:n,lightPosition:a,halfWidth:this.halfWidth,halfHeight:this.halfHeight,reflectedLight:o,ltc_1:e,ltc_2:i},t.stack,t)}static setLTC(t){VD=t}}class HD extends LL{static get type(){return"SpotLightNode"}constructor(t=null){super(t),this.coneCosNode=BS(0).setGroup(DS),this.penumbraCosNode=BS(0).setGroup(DS),this.cutoffDistanceNode=BS(0).setGroup(DS),this.decayExponentNode=BS(0).setGroup(DS)}update(t){super.update(t);const{light:e}=this;this.coneCosNode.value=Math.cos(e.angle),this.penumbraCosNode.value=Math.cos(e.angle*(1-e.penumbra)),this.cutoffDistanceNode.value=e.distance,this.decayExponentNode.value=e.decay}getSpotAttenuation(t){const{coneCosNode:e,penumbraCosNode:i}=this;return OT(e,i,t)}setup(t){super.setup(t);const e=t.context.lightingModel,{colorNode:i,cutoffDistanceNode:n,decayExponentNode:s,light:r}=this,a=vL(r).sub(Xw),o=a.normalize(),l=o.dot(_L(r)),h=this.getSpotAttenuation(l),c=a.length(),u=DL({lightDistance:c,cutoffDistance:n,decayExponent:s}),d=i.mul(h).mul(u),p=t.context.reflectedLight;e.direct({lightDirection:o,lightColor:d,reflectedLight:p},t.stack,t)}}class WD extends HD{static get type(){return"IESSpotLightNode"}getSpotAttenuation(t){const e=this.light.iesMap;let i=null;if(e&&!0===e.isTexture){const n=t.acos().mul(1/Math.PI);i=Rw(e,fS(n,0),0).r}else i=super.getSpotAttenuation(t);return i}}class jD extends LL{static get type(){return"AmbientLightNode"}constructor(t=null){super(t)}setup({context:t}){t.irradiance.addAssign(this.colorNode)}}class XD extends LL{static get type(){return"HemisphereLightNode"}constructor(t=null){super(t),this.lightPositionNode=xL(t),this.lightDirectionNode=this.lightPositionNode.normalize(),this.groundColorNode=BS(new Tv).setGroup(DS)}update(t){const{light:e}=this;super.update(t),this.lightPositionNode.object3d=e,this.groundColorNode.value.copy(e.groundColor).multiplyScalar(e.intensity)}setup(t){const{colorNode:e,groundColorNode:i,lightDirectionNode:n}=this,s=Qw.dot(n).mul(.5).add(.5),r=UT(i,e,s);t.context.irradiance.addAssign(r)}}class qD extends LL{static get type(){return"LightProbeNode"}constructor(t=null){super(t);const e=[];for(let i=0;i<9;i++)e.push(new ix);this.lightProbe=xA(e)}update(t){const{light:e}=this;super.update(t);for(let i=0;i<9;i++)this.lightProbe.array[i].copy(e.sh.coefficients[i]).multiplyScalar(e.intensity)}setup(t){const e=BL(tA,this.lightProbe);t.context.irradiance.addAssign(e)}}class $D{parseFunction(){}}class YD{constructor(t,e,i="",n=""){this.type=t,this.inputs=e,this.name=i,this.precision=n}getCode(){}}YD.isNodeFunction=!0;const ZD=/^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i,KD=/[a-z_0-9]+/gi,JD="#pragma main";class QD extends YD{constructor(t){const{type:e,inputs:i,name:n,precision:s,inputsCode:r,blockCode:a,headerCode:o}=(t=>{const e=(t=t.trim()).indexOf(JD),i=-1!==e?t.slice(e+12):t,n=i.match(ZD);if(null!==n&&5===n.length){const s=n[4],r=[];let a=null;for(;null!==(a=KD.exec(s));)r.push(a);const o=[];let l=0;for(;l<r.length;){const t="const"===r[l][0];!0===t&&l++;let e=r[l][0];"in"===e||"out"===e||"inout"===e?l++:e="";const i=r[l++][0];let n=Number.parseInt(r[l][0]);!1===Number.isNaN(n)?l++:n=null;const s=r[l++][0];o.push(new BD(i,s,n,e,t))}const h=i.substring(n[0].length),c=void 0!==n[3]?n[3]:"";return{type:n[2],inputs:o,name:c,precision:void 0!==n[1]?n[1]:"",inputsCode:s,blockCode:h,headerCode:-1!==e?t.slice(0,e):""}}throw new Error("FunctionNode: Function is not a GLSL code.")})(t);super(e,i,n,s),this.inputsCode=r,this.blockCode=a,this.headerCode=o}getCode(t=this.name){let e;const i=this.blockCode;if(""!==i){const{type:n,inputsCode:s,headerCode:r,precision:a}=this;let o=`${n} ${t} ( ${s.trim()} )`;""!==a&&(o=`${a} ${o}`),e=r+o+i}else e="";return e}}class tU extends $D{parseFunction(t){return new QD(t)}}const eU=new WeakMap;class iU extends FN{constructor(t,e){super(),this.renderer=t,this.backend=e,this.nodeFrame=new FD,this.nodeBuilderCache=new Map,this.callHashCache=new RN,this.groupsData=new RN}updateGroup(t){const e=t.groupNode,i=e.name;if(i===US.name)return!0;if(i===DS.name){const e=this.get(t),i=this.nodeFrame.renderId;return e.renderId!==i&&(e.renderId=i,!0)}if(i===LS.name){const e=this.get(t),i=this.nodeFrame.frameId;return e.frameId!==i&&(e.frameId=i,!0)}const n=[e,t];let s=this.groupsData.get(n);return void 0===s&&this.groupsData.set(n,s={}),s.version!==e.version&&(s.version=e.version,!0)}getForRenderCacheKey(t){return t.initialCacheKey}getForRender(t){const e=this.get(t);let i=e.nodeBuilderState;if(void 0===i){const{nodeBuilderCache:n}=this,s=this.getForRenderCacheKey(t);if(i=n.get(s),void 0===i){const e=this.backend.createNodeBuilder(t.object,this.renderer);e.scene=t.scene,e.material=t.material,e.camera=t.camera,e.context.material=t.material,e.lightsNode=t.lightsNode,e.environmentNode=this.getEnvironmentNode(t.scene),e.fogNode=this.getFogNode(t.scene),e.clippingContext=t.clippingContext,e.build(),i=this._createNodeBuilderState(e),n.set(s,i)}i.usedTimes++,e.nodeBuilderState=i}return i}delete(t){if(t.isRenderObject){const e=this.get(t).nodeBuilderState;e.usedTimes--,0===e.usedTimes&&this.nodeBuilderCache.delete(this.getForRenderCacheKey(t))}return super.delete(t)}getForCompute(t){const e=this.get(t);let i=e.nodeBuilderState;if(void 0===i){const n=this.backend.createNodeBuilder(t,this.renderer);n.build(),i=this._createNodeBuilderState(n),e.nodeBuilderState=i}return i}_createNodeBuilderState(t){return new GL(t.vertexShader,t.fragmentShader,t.computeShader,t.getAttributesArray(),t.getBindings(),t.updateNodes,t.updateBeforeNodes,t.updateAfterNodes,t.monitor,t.transforms)}getEnvironmentNode(t){return t.environmentNode||this.get(t).environmentNode||null}getBackgroundNode(t){return t.backgroundNode||this.get(t).backgroundNode||null}getFogNode(t){return t.fogNode||this.get(t).fogNode||null}getCacheKey(t,e){const i=[t,e],n=this.renderer.info.calls;let s=this.callHashCache.get(i);if(void 0===s||s.callId!==n){const r=this.getEnvironmentNode(t),a=this.getFogNode(t),o=[];e&&o.push(e.getCacheKey(!0)),r&&o.push(r.getCacheKey()),a&&o.push(a.getCacheKey()),o.push(this.renderer.shadowMap.enabled?1:0),s={callId:n,cacheKey:eb(o)},this.callHashCache.set(i,s)}return s.cacheKey}updateScene(t){this.updateEnvironment(t),this.updateFog(t),this.updateBackground(t)}get isToneMappingState(){return!this.renderer.getRenderTarget()}updateBackground(t){const e=this.get(t),i=t.background;if(i){const n=0===t.backgroundBlurriness&&e.backgroundBlurriness>0||t.backgroundBlurriness>0&&0===e.backgroundBlurriness;if(e.background!==i||n){let n=null;if(!0===i.isCubeTexture||i.mapping===rf||i.mapping===af||306===i.mapping)if(t.backgroundBlurriness>0||306===i.mapping)n=iN(i);else{let t;t=!0===i.isCubeTexture?dA(i):Rw(i),n=CC(t)}else!0===i.isTexture?n=Rw(i,qE.flipY()).setUpdateMatrix(!0):i.isColor;e.backgroundNode=n,e.background=i,e.backgroundBlurriness=t.backgroundBlurriness}}else e.backgroundNode&&(delete e.backgroundNode,delete e.background)}updateFog(t){const e=this.get(t),i=t.fog;if(i){if(e.fog!==i){let t=null;if(i.isFogExp2){const e=yA("color","color",i).setGroup(DS),n=yA("density","float",i).setGroup(DS);t=pL(e,n)}else if(i.isFog){const e=yA("color","color",i).setGroup(DS),n=yA("near","float",i).setGroup(DS),s=yA("far","float",i).setGroup(DS);t=uL(e,n,s)}e.fogNode=t,e.fog=i}}else delete e.fogNode,delete e.fog}updateEnvironment(t){const e=this.get(t),i=t.environment;if(i){if(e.environment!==i){let t=null;!0===i.isCubeTexture?t=dA(i):!0===i.isTexture&&(t=Rw(i)),e.environmentNode=t,e.environment=i}}else e.environmentNode&&(delete e.environmentNode,delete e.environment)}getNodeFrame(t=this.renderer,e=null,i=null,n=null,s=null){const r=this.nodeFrame;return r.renderer=t,r.scene=e,r.object=i,r.camera=n,r.material=s,r}getNodeFrameForRender(t){return this.getNodeFrame(t.renderer,t.scene,t.object,t.camera,t.material)}getOutputCacheKey(){const t=this.renderer;return t.toneMapping+","+t.currentColorSpace}hasOutputChange(t){return eU.get(t)!==this.getOutputCacheKey()}getOutputNode(t){const e=this.renderer,i=this.getOutputCacheKey(),n=Rw(t,qE).renderOutput(e.toneMapping,e.currentColorSpace);return eU.set(t,i),n}updateBefore(t){const e=t.getNodeBuilderState();for(const i of e.updateBeforeNodes)this.getNodeFrameForRender(t).updateBeforeNode(i)}updateAfter(t){const e=t.getNodeBuilderState();for(const i of e.updateAfterNodes)this.getNodeFrameForRender(t).updateAfterNode(i)}updateForCompute(t){const e=this.getNodeFrame(),i=this.getForCompute(t);for(const n of i.updateNodes)e.updateNode(n)}updateForRender(t){const e=this.getNodeFrameForRender(t),i=t.getNodeBuilderState();for(const n of i.updateNodes)e.updateNode(n)}needsRefresh(t){const e=this.getNodeFrameForRender(t);return t.getMonitor().needsRefresh(t,e)}dispose(){super.dispose(),this.nodeFrame=new FD,this.nodeBuilderCache=new Map}}class nU{constructor(t,e){this.scene=t,this.camera=e}clone(){return Object.assign(new this.constructor,this)}}class sU{constructor(){this.lists=new RN}get(t,e){const i=this.lists,n=[t,e];let s=i.get(n);return void 0===s&&(s=new nU(t,e),i.set(n,s)),s}dispose(){this.lists=new RN}}class rU{constructor(){this.lightNodes=new WeakMap,this.materialNodes=new Map,this.toneMappingNodes=new Map}fromMaterial(t){if(t.isNodeMaterial)return t;let e=null;const i=this.getMaterialNodeClass(t.type);if(null!==i){e=new i;for(const i in t)e[i]=t[i]}return e}addToneMapping(t,e){this.addType(t,e,this.toneMappingNodes)}getToneMappingFunction(t){return this.toneMappingNodes.get(t)||null}getMaterialNodeClass(t){return this.materialNodes.get(t)||null}addMaterial(t,e){this.addType(t,e.type,this.materialNodes)}getLightNodeClass(t){return this.lightNodes.get(t)||null}addLight(t,e){this.addClass(t,e,this.lightNodes)}addType(t,e,i){if(!i.has(e)){if("function"!=typeof t)throw new Error(`Node class ${t.name} is not a class.`);if("function"==typeof e||"object"==typeof e)throw new Error(`Base class ${e} is not a class.`);i.set(e,t)}}addClass(t,e,i){if(!i.has(e)){if("function"!=typeof t)throw new Error(`Node class ${t.name} is not a class.`);if("function"!=typeof e)throw new Error(`Base class ${e.name} is not a class.`);i.set(e,t)}}}const aU=new SL;class oU extends RN{constructor(){super()}createNode(t=[]){return(new SL).setLights(t)}getNode(t,e){if(t.isQuadMesh)return aU;const i=[t,e];let n=this.get(i);return void 0===n&&(n=this.createNode(),this.set(i,n)),n}}const lU=new __,hU=new Pg,cU=new Kg,uU=new k_,dU=new Ix,pU=new Kg;class mU{constructor(t,e={}){this.isRenderer=!0;const{logarithmicDepthBuffer:i=!1,alpha:n=!0,depth:s=!0,stencil:r=!1,antialias:a=!1,samples:o=0,getFallback:l=null}=e;this.domElement=t.getDomElement(),this.backend=t,this.samples=o||!0===a?4:0,this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.alpha=n,this.logarithmicDepthBuffer=i,this.outputColorSpace=ig,this.toneMapping=0,this.toneMappingExposure=1,this.sortObjects=!0,this.depth=s,this.stencil=r,this.clippingPlanes=[],this.info=new XN,this.nodes={modelViewMatrix:null,modelNormalViewMatrix:null},this.library=new rU,this.lighting=new oU,this._getFallback=l,this._pixelRatio=1,this._width=this.domElement.width,this._height=this.domElement.height,this._viewport=new Kg(0,0,this._width,this._height),this._scissor=new Kg(0,0,this._width,this._height),this._scissorTest=!1,this._attributes=null,this._geometries=null,this._nodes=null,this._animation=null,this._bindings=null,this._objects=null,this._pipelines=null,this._bundles=null,this._renderLists=null,this._renderContexts=null,this._textures=null,this._background=null,this._quad=new _P(new mC),this._quad.material.type="Renderer_output",this._currentRenderContext=null,this._opaqueSort=null,this._transparentSort=null,this._frameBufferTarget=null;const h=!0===this.alpha?0:1;this._clearColor=new uP(0,0,0,h),this._clearDepth=1,this._clearStencil=0,this._renderTarget=null,this._activeCubeFace=0,this._activeMipmapLevel=0,this._mrt=null,this._renderObjectFunction=null,this._currentRenderObjectFunction=null,this._currentRenderBundle=null,this._handleObjectFunction=this._renderObjectDirect,this._isDeviceLost=!1,this.onDeviceLost=this._onDeviceLost,this._initialized=!1,this._initPromise=null,this._compilationPromises=null,this.transparent=!0,this.opaque=!0,this.shadowMap={enabled:!1,type:1},this.xr={enabled:!1},this.debug={checkShaderErrors:!0,onShaderError:null,getShaderAsync:async(t,e,i)=>{await this.compileAsync(t,e);const n=this._renderLists.get(t,e),s=this._renderContexts.get(t,e,this._renderTarget),r=t.overrideMaterial||i.material,a=this._objects.get(i,r,t,e,n.lightsNode,s),{fragmentShader:o,vertexShader:l}=a.getNodeBuilderState();return{fragmentShader:o,vertexShader:l}}}}async init(){if(this._initialized)throw new Error("Renderer: Backend has already been initialized.");return null!==this._initPromise||(this._initPromise=new Promise((async(t,e)=>{let i=this.backend;try{await i.init(this)}catch(n){if(null===this._getFallback)return void e(n);try{this.backend=i=this._getFallback(n),await i.init(this)}catch(s){return void e(s)}}this._nodes=new iU(this,i),this._animation=new CN(this._nodes,this.info),this._attributes=new GN(i),this._background=new zL(this,this._nodes),this._geometries=new jN(this._attributes,this.info),this._textures=new cP(this,i,this.info),this._pipelines=new JN(i,this._nodes),this._bindings=new QN(i,this._nodes,this._textures,this._attributes,this._pipelines,this.info),this._objects=new UN(this,this._nodes,this._geometries,this._pipelines,this._bindings,this.info),this._renderLists=new sP(this.lighting),this._bundles=new sU,this._renderContexts=new lP,this._initialized=!0,t()}))),this._initPromise}get coordinateSystem(){return this.backend.coordinateSystem}async compileAsync(t,e,i=null){if(!0===this._isDeviceLost)return;!1===this._initialized&&await this.init();const n=this._nodes.nodeFrame,s=n.renderId,r=this._currentRenderContext,a=this._currentRenderObjectFunction,o=this._compilationPromises,l=!0===t.isScene?t:lU;null===i&&(i=t);const h=this._renderTarget,c=this._renderContexts.get(i,e,h),u=this._activeMipmapLevel,d=[];this._currentRenderContext=c,this._currentRenderObjectFunction=this.renderObject,this._handleObjectFunction=this._createObjectPipeline,this._compilationPromises=d,n.renderId++,n.update(),c.depth=this.depth,c.stencil=this.stencil,c.clippingContext||(c.clippingContext=new PN),c.clippingContext.updateGlobal(this,e),l.onBeforeRender(this,t,e,h);const p=this._renderLists.get(t,e);if(p.begin(),this._projectObject(t,e,0,p),i!==t&&i.traverseVisible((function(t){t.isLight&&t.layers.test(e.layers)&&p.pushLight(t)})),p.finish(),null!==h){this._textures.updateRenderTarget(h,u);const t=this._textures.get(h);c.textures=t.textures,c.depthTexture=t.depthTexture}else c.textures=null,c.depthTexture=null;this._nodes.updateScene(l),this._background.update(l,p,c);const m=p.opaque,f=p.transparent,g=p.lightsNode;!0===this.opaque&&m.length>0&&this._renderObjects(m,e,l,g),!0===this.transparent&&f.length>0&&this._renderTransparents(f,e,l,g),n.renderId=s,this._currentRenderContext=r,this._currentRenderObjectFunction=a,this._compilationPromises=o,this._handleObjectFunction=this._renderObjectDirect,await Promise.all(d)}async renderAsync(t,e){!1===this._initialized&&await this.init();const i=this._renderScene(t,e);await this.backend.resolveTimestampAsync(i,"render")}async waitForGPU(){await this.backend.waitForGPU()}setMRT(t){return this._mrt=t,this}getMRT(){return this._mrt}_onDeviceLost(t){let e=`THREE.WebGPURenderer: ${t.api} Device Lost:\n\nMessage: ${t.message}`;t.reason&&(e+=`\nReason: ${t.reason}`),this._isDeviceLost=!0}_renderBundle(t,e,i){const{bundleGroup:n,camera:s,renderList:r}=t,a=this._currentRenderContext,o=this._bundles.get(n,s),l=this.backend.get(o);void 0===l.renderContexts&&(l.renderContexts=new Set);const h=n.version!==l.version,c=!1===l.renderContexts.has(a)||h;if(l.renderContexts.add(a),c){this.backend.beginBundle(a),(void 0===l.renderObjects||h)&&(l.renderObjects=[]),this._currentRenderBundle=o;const t=r.opaque;!0===this.opaque&&t.length>0&&this._renderObjects(t,s,e,i),this._currentRenderBundle=null,this.backend.finishBundle(a,o),l.version=n.version}else{const{renderObjects:t}=l;for(let e=0,i=t.length;e<i;e++){const i=t[e];this._nodes.needsRefresh(i)&&(this._nodes.updateBefore(i),this._nodes.updateForRender(i),this._bindings.updateForRender(i),this._nodes.updateAfter(i))}}this.backend.addBundle(a,o)}render(t,e){if(!1===this._initialized)return this.renderAsync(t,e);this._renderScene(t,e)}_getFrameBufferTarget(){const{currentToneMapping:t,currentColorSpace:e}=this;if(!1===(0!==t)&&!1===(e!==ng))return null;const{width:i,height:n}=this.getDrawingBufferSize(hU),{depth:s,stencil:r}=this;let a=this._frameBufferTarget;return null===a&&(a=new Jg(i,n,{depthBuffer:s,stencilBuffer:r,type:Mf,format:Af,colorSpace:ng,generateMipmaps:!1,minFilter:pf,magFilter:pf,samples:this.samples}),a.isPostProcessingRenderTarget=!0,this._frameBufferTarget=a),a.depthBuffer=s,a.stencilBuffer=r,a.setSize(i,n),a.viewport.copy(this._viewport),a.scissor.copy(this._scissor),a.viewport.multiplyScalar(this._pixelRatio),a.scissor.multiplyScalar(this._pixelRatio),a.scissorTest=this._scissorTest,a}_renderScene(t,e,i=!0){if(!0===this._isDeviceLost)return;const n=i?this._getFrameBufferTarget():null,s=this._nodes.nodeFrame,r=s.renderId,a=this._currentRenderContext,o=this._currentRenderObjectFunction,l=!0===t.isScene?t:lU,h=this._renderTarget,c=this._activeCubeFace,u=this._activeMipmapLevel;let d;null!==n?(d=n,this.setRenderTarget(d)):d=h;const p=this._renderContexts.get(t,e,d);this._currentRenderContext=p,this._currentRenderObjectFunction=this._renderObjectFunction||this.renderObject,this.info.calls++,this.info.render.calls++,this.info.render.frameCalls++,s.renderId=this.info.calls;const m=this.coordinateSystem;e.coordinateSystem!==m&&(e.coordinateSystem=m,e.updateProjectionMatrix()),!0===t.matrixWorldAutoUpdate&&t.updateMatrixWorld(),null===e.parent&&!0===e.matrixWorldAutoUpdate&&e.updateMatrixWorld();let f=this._viewport,g=this._scissor,x=this._pixelRatio;null!==d&&(f=d.viewport,g=d.scissor,x=1),this.getDrawingBufferSize(hU),cU.set(0,0,hU.width,hU.height);const v=void 0===f.minDepth?0:f.minDepth,_=void 0===f.maxDepth?1:f.maxDepth;p.viewportValue.copy(f).multiplyScalar(x).floor(),p.viewportValue.width>>=u,p.viewportValue.height>>=u,p.viewportValue.minDepth=v,p.viewportValue.maxDepth=_,p.viewport=!1===p.viewportValue.equals(cU),p.scissorValue.copy(g).multiplyScalar(x).floor(),p.scissor=this._scissorTest&&!1===p.scissorValue.equals(cU),p.scissorValue.width>>=u,p.scissorValue.height>>=u,p.clippingContext||(p.clippingContext=new PN),p.clippingContext.updateGlobal(this,e),l.onBeforeRender(this,t,e,d),dU.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),uU.setFromProjectionMatrix(dU,m);const y=this._renderLists.get(t,e);if(y.begin(),this._projectObject(t,e,0,y),y.finish(),!0===this.sortObjects&&y.sort(this._opaqueSort,this._transparentSort),null!==d){this._textures.updateRenderTarget(d,u);const t=this._textures.get(d);p.textures=t.textures,p.depthTexture=t.depthTexture,p.width=t.width,p.height=t.height,p.renderTarget=d,p.depth=d.depthBuffer,p.stencil=d.stencilBuffer}else p.textures=null,p.depthTexture=null,p.width=this.domElement.width,p.height=this.domElement.height,p.depth=this.depth,p.stencil=this.stencil;p.width>>=u,p.height>>=u,p.activeCubeFace=c,p.activeMipmapLevel=u,p.occlusionQueryCount=y.occlusionQueryCount,this._nodes.updateScene(l),this._background.update(l,y,p),this.backend.beginRender(p);const{bundles:b,lightsNode:S,transparentDoublePass:M,transparent:T,opaque:w}=y;if(b.length>0&&this._renderBundles(b,l,S),!0===this.opaque&&w.length>0&&this._renderObjects(w,e,l,S),!0===this.transparent&&T.length>0&&this._renderTransparents(T,M,e,l,S),this.backend.finishRender(p),s.renderId=r,this._currentRenderContext=a,this._currentRenderObjectFunction=o,null!==n){this.setRenderTarget(h,c,u);const t=this._quad;this._nodes.hasOutputChange(d.texture)&&(t.material.fragmentNode=this._nodes.getOutputNode(d.texture),t.material.needsUpdate=!0),this._renderScene(t,t.camera,!1)}return l.onAfterRender(this,t,e,d),p}getMaxAnisotropy(){return this.backend.getMaxAnisotropy()}getActiveCubeFace(){return this._activeCubeFace}getActiveMipmapLevel(){return this._activeMipmapLevel}async setAnimationLoop(t){!1===this._initialized&&await this.init(),this._animation.setAnimationLoop(t)}async getArrayBufferAsync(t){return await this.backend.getArrayBufferAsync(t)}getContext(){return this.backend.getContext()}getPixelRatio(){return this._pixelRatio}getDrawingBufferSize(t){return t.set(this._width*this._pixelRatio,this._height*this._pixelRatio).floor()}getSize(t){return t.set(this._width,this._height)}setPixelRatio(t=1){this._pixelRatio!==t&&(this._pixelRatio=t,this.setSize(this._width,this._height,!1))}setDrawingBufferSize(t,e,i){this._width=t,this._height=e,this._pixelRatio=i,this.domElement.width=Math.floor(t*i),this.domElement.height=Math.floor(e*i),this.setViewport(0,0,t,e),this._initialized&&this.backend.updateSize()}setSize(t,e,i=!0){this._width=t,this._height=e,this.domElement.width=Math.floor(t*this._pixelRatio),this.domElement.height=Math.floor(e*this._pixelRatio),!0===i&&(this.domElement.style.width=t+"px",this.domElement.style.height=e+"px"),this.setViewport(0,0,t,e),this._initialized&&this.backend.updateSize()}setOpaqueSort(t){this._opaqueSort=t}setTransparentSort(t){this._transparentSort=t}getScissor(t){const e=this._scissor;return t.x=e.x,t.y=e.y,t.width=e.width,t.height=e.height,t}setScissor(t,e,i,n){const s=this._scissor;t.isVector4?s.copy(t):s.set(t,e,i,n)}getScissorTest(){return this._scissorTest}setScissorTest(t){this._scissorTest=t,this.backend.setScissorTest(t)}getViewport(t){return t.copy(this._viewport)}setViewport(t,e,i,n,s=0,r=1){const a=this._viewport;t.isVector4?a.copy(t):a.set(t,e,i,n),a.minDepth=s,a.maxDepth=r}getClearColor(t){return t.copy(this._clearColor)}setClearColor(t,e=1){this._clearColor.set(t),this._clearColor.a=e}getClearAlpha(){return this._clearColor.a}setClearAlpha(t){this._clearColor.a=t}getClearDepth(){return this._clearDepth}setClearDepth(t){this._clearDepth=t}getClearStencil(){return this._clearStencil}setClearStencil(t){this._clearStencil=t}isOccluded(t){const e=this._currentRenderContext;return e&&this.backend.isOccluded(e,t)}clear(t=!0,e=!0,i=!0){if(!1===this._initialized)return this.clearAsync(t,e,i);const n=this._renderTarget||this._getFrameBufferTarget();let s=null;if(null!==n&&(this._textures.updateRenderTarget(n),s=this._textures.get(n)),this.backend.clear(t,e,i,s),null!==n&&null===this._renderTarget){const t=this._quad;this._nodes.hasOutputChange(n.texture)&&(t.material.fragmentNode=this._nodes.getOutputNode(n.texture),t.material.needsUpdate=!0),this._renderScene(t,t.camera,!1)}}clearColor(){return this.clear(!0,!1,!1)}clearDepth(){return this.clear(!1,!0,!1)}clearStencil(){return this.clear(!1,!1,!0)}async clearAsync(t=!0,e=!0,i=!0){!1===this._initialized&&await this.init(),this.clear(t,e,i)}clearColorAsync(){return this.clearAsync(!0,!1,!1)}clearDepthAsync(){return this.clearAsync(!1,!0,!1)}clearStencilAsync(){return this.clearAsync(!1,!1,!0)}get currentToneMapping(){return null!==this._renderTarget?0:this.toneMapping}get currentColorSpace(){return null!==this._renderTarget?ng:this.outputColorSpace}dispose(){this.info.dispose(),this.backend.dispose(),this._animation.dispose(),this._objects.dispose(),this._pipelines.dispose(),this._nodes.dispose(),this._bindings.dispose(),this._renderLists.dispose(),this._renderContexts.dispose(),this._textures.dispose(),this.setRenderTarget(null),this.setAnimationLoop(null)}setRenderTarget(t,e=0,i=0){this._renderTarget=t,this._activeCubeFace=e,this._activeMipmapLevel=i}getRenderTarget(){return this._renderTarget}setRenderObjectFunction(t){this._renderObjectFunction=t}getRenderObjectFunction(){return this._renderObjectFunction}compute(t){if(!0===this.isDeviceLost)return;if(!1===this._initialized)return this.computeAsync(t);const e=this._nodes.nodeFrame,i=e.renderId;this.info.calls++,this.info.compute.calls++,this.info.compute.frameCalls++,e.renderId=this.info.calls;const n=this.backend,s=this._pipelines,r=this._bindings,a=this._nodes,o=Array.isArray(t)?t:[t];if(void 0===o[0]||!0!==o[0].isComputeNode)throw new Error("THREE.Renderer: .compute() expects a ComputeNode.");n.beginCompute(t);for(const l of o){if(!1===s.has(l)){const t=()=>{l.removeEventListener("dispose",t),s.delete(l),r.delete(l),a.delete(l)};l.addEventListener("dispose",t);const e=l.onInitFunction;null!==e&&e.call(l,{renderer:this})}a.updateForCompute(l),r.updateForCompute(l);const e=r.getForCompute(l),i=s.getForCompute(l,e);n.compute(t,l,e,i)}n.finishCompute(t),e.renderId=i}async computeAsync(t){!1===this._initialized&&await this.init(),this.compute(t),await this.backend.resolveTimestampAsync(t,"compute")}async hasFeatureAsync(t){return!1===this._initialized&&await this.init(),this.backend.hasFeature(t)}hasFeature(t){return!1!==this._initialized&&this.backend.hasFeature(t)}copyFramebufferToTexture(t,e=null){if(null!==e)if(e.isVector2)e=pU.set(e.x,e.y,t.image.width,t.image.height).floor();else{if(!e.isVector4)return;e=pU.copy(e).floor()}else e=pU.set(0,0,t.image.width,t.image.height);let i,n=this._currentRenderContext;null!==n?i=n.renderTarget:(i=this._renderTarget||this._getFrameBufferTarget(),null!==i&&(this._textures.updateRenderTarget(i),n=this._textures.get(i))),this._textures.updateTexture(t,{renderTarget:i}),this.backend.copyFramebufferToTexture(t,n,e)}copyTextureToTexture(t,e,i=null,n=null,s=0){this._textures.updateTexture(t),this._textures.updateTexture(e),this.backend.copyTextureToTexture(t,e,i,n,s)}readRenderTargetPixelsAsync(t,e,i,n,s,r=0,a=0){return this.backend.copyTextureToBuffer(t.textures[r],e,i,n,s,a)}_projectObject(t,e,i,n){if(!1===t.visible)return;if(t.layers.test(e.layers))if(t.isGroup)i=t.renderOrder;else if(t.isLOD)!0===t.autoUpdate&&t.update(e);else if(t.isLight)n.pushLight(t);else if(t.isSprite){if(!t.frustumCulled||uU.intersectsSprite(t)){!0===this.sortObjects&&pU.setFromMatrixPosition(t.matrixWorld).applyMatrix4(dU);const{geometry:e,material:s}=t;s.visible&&n.push(t,e,s,i,pU.z,null)}}else if(t.isLineLoop);else if((t.isMesh||t.isLine||t.isPoints)&&(!t.frustumCulled||uU.intersectsObject(t))){const{geometry:e,material:s}=t;if(!0===this.sortObjects&&(null===e.boundingSphere&&e.computeBoundingSphere(),pU.copy(e.boundingSphere.center).applyMatrix4(t.matrixWorld).applyMatrix4(dU)),Array.isArray(s)){const r=e.groups;for(let a=0,o=r.length;a<o;a++){const o=r[a],l=s[o.materialIndex];l&&l.visible&&n.push(t,e,l,i,pU.z,o)}}else s.visible&&n.push(t,e,s,i,pU.z,null)}if(!0===t.isBundleGroup&&void 0!==this.backend.beginBundle){const i=n;(n=this._renderLists.get(t,e)).begin(),i.pushBundle({bundleGroup:t,camera:e,renderList:n}),n.finish()}const s=t.children;for(let r=0,a=s.length;r<a;r++)this._projectObject(s[r],e,i,n)}_renderBundles(t,e,i){for(const n of t)this._renderBundle(n,e,i)}_renderTransparents(t,e,i,n,s){if(e.length>0){for(const{material:t}of e)t.side=1;this._renderObjects(e,i,n,s,"backSide");for(const{material:t}of e)t.side=0;this._renderObjects(t,i,n,s);for(const{material:t}of e)t.side=2}else this._renderObjects(t,i,n,s)}_renderObjects(t,e,i,n,s=null){for(let r=0,a=t.length;r<a;r++){const a=t[r],{object:o,geometry:l,material:h,group:c}=a;if(e.isArrayCamera){const t=e.cameras;for(let e=0,r=t.length;e<r;e++){const r=t[e];if(o.layers.test(r.layers)){const t=r.viewport,e=void 0===t.minDepth?0:t.minDepth,a=void 0===t.maxDepth?1:t.maxDepth,u=this._currentRenderContext.viewportValue;u.copy(t).multiplyScalar(this._pixelRatio).floor(),u.minDepth=e,u.maxDepth=a,this.backend.updateViewport(this._currentRenderContext),this._currentRenderObjectFunction(o,i,r,l,h,c,n,s)}}}else this._currentRenderObjectFunction(o,i,e,l,h,c,n,s)}}renderObject(t,e,i,n,s,r,a,o=null){let l,h,c;if(t.onBeforeRender(this,e,i,n,s,r),null!==e.overrideMaterial){const t=e.overrideMaterial;s.positionNode&&s.positionNode.isNode&&(l=t.positionNode,t.positionNode=s.positionNode),t.isShadowNodeMaterial&&(t.side=null===s.shadowSide?s.side:s.shadowSide,s.depthNode&&s.depthNode.isNode&&(c=t.depthNode,t.depthNode=s.depthNode),s.shadowNode&&s.shadowNode.isNode&&(h=t.fragmentNode,t.fragmentNode=s.shadowNode),this.localClippingEnabled&&(s.clipShadows?(t.clippingPlanes!==s.clippingPlanes&&(t.clippingPlanes=s.clippingPlanes,t.needsUpdate=!0),t.clipIntersection!==s.clipIntersection&&(t.clipIntersection=s.clipIntersection)):Array.isArray(t.clippingPlanes)&&(t.clippingPlanes=null,t.needsUpdate=!0))),s=t}!0===s.transparent&&2===s.side&&!1===s.forceSinglePass?(s.side=1,this._handleObjectFunction(t,s,e,i,a,r,"backSide"),s.side=0,this._handleObjectFunction(t,s,e,i,a,r,o),s.side=2):this._handleObjectFunction(t,s,e,i,a,r,o),void 0!==l&&(e.overrideMaterial.positionNode=l),void 0!==c&&(e.overrideMaterial.depthNode=c),void 0!==h&&(e.overrideMaterial.fragmentNode=h),t.onAfterRender(this,e,i,n,s,r)}_renderObjectDirect(t,e,i,n,s,r,a){const o=this._objects.get(t,e,i,n,s,this._currentRenderContext,a);o.drawRange=t.geometry.drawRange,o.group=r;const l=this._nodes.needsRefresh(o);if(l&&(this._nodes.updateBefore(o),this._geometries.updateForRender(o),this._nodes.updateForRender(o),this._bindings.updateForRender(o)),this._pipelines.updateForRender(o),null!==this._currentRenderBundle){this.backend.get(this._currentRenderBundle).renderObjects.push(o),o.bundle=this._currentRenderBundle.scene}this.backend.draw(o,this.info),l&&this._nodes.updateAfter(o)}_createObjectPipeline(t,e,i,n,s,r){const a=this._objects.get(t,e,i,n,s,this._currentRenderContext,r);this._nodes.updateBefore(a),this._geometries.updateForRender(a),this._nodes.updateForRender(a),this._bindings.updateForRender(a),this._pipelines.getForRender(a,this._compilationPromises),this._nodes.updateAfter(a)}get compile(){return this.compileAsync}}class fU{constructor(t=""){this.name=t,this.visibility=0}setVisibility(t){this.visibility|=t}clone(){return Object.assign(new this.constructor,this)}}class gU extends fU{constructor(t,e=null){super(t),this.isBuffer=!0,this.bytesPerElement=Float32Array.BYTES_PER_ELEMENT,this._buffer=e}get byteLength(){return(t=this._buffer.byteLength)+(VN-t%VN)%VN;var t}get buffer(){return this._buffer}update(){return!0}}class xU extends gU{constructor(t,e=null){super(t,e),this.isUniformBuffer=!0}}let vU=0;class _U extends xU{constructor(t,e){super("UniformBuffer_"+vU++,t?t.value:null),this.nodeUniform=t,this.groupNode=e}get buffer(){return this.nodeUniform.value}}class yU extends xU{constructor(t){super(t),this.isUniformsGroup=!0,this._values=null,this.uniforms=[]}addUniform(t){return this.uniforms.push(t),this}removeUniform(t){const e=this.uniforms.indexOf(t);return-1!==e&&this.uniforms.splice(e,1),this}get values(){return null===this._values&&(this._values=Array.from(this.buffer)),this._values}get buffer(){let t=this._buffer;if(null===t){const e=this.byteLength;t=new Float32Array(new ArrayBuffer(e)),this._buffer=t}return t}get byteLength(){let t=0;for(let e=0,i=this.uniforms.length;e<i;e++){const i=this.uniforms[e],{boundary:n,itemSize:s}=i,r=t%VN;0!==r&&VN-r-n<0?t+=VN-r:r%n!=0&&(t+=r%n),i.offset=t/this.bytesPerElement,t+=s*this.bytesPerElement}return Math.ceil(t/VN)*VN}update(){let t=!1;for(const e of this.uniforms)!0===this.updateByType(e)&&(t=!0);return t}updateByType(t){return t.isNumberUniform?this.updateNumber(t):t.isVector2Uniform?this.updateVector2(t):t.isVector3Uniform?this.updateVector3(t):t.isVector4Uniform?this.updateVector4(t):t.isColorUniform?this.updateColor(t):t.isMatrix3Uniform?this.updateMatrix3(t):t.isMatrix4Uniform?this.updateMatrix4(t):void 0}updateNumber(t){let e=!1;const i=this.values,n=t.getValue(),s=t.offset;if(i[s]!==n){this.buffer[s]=i[s]=n,e=!0}return e}updateVector2(t){let e=!1;const i=this.values,n=t.getValue(),s=t.offset;if(i[s+0]!==n.x||i[s+1]!==n.y){const t=this.buffer;t[s+0]=i[s+0]=n.x,t[s+1]=i[s+1]=n.y,e=!0}return e}updateVector3(t){let e=!1;const i=this.values,n=t.getValue(),s=t.offset;if(i[s+0]!==n.x||i[s+1]!==n.y||i[s+2]!==n.z){const t=this.buffer;t[s+0]=i[s+0]=n.x,t[s+1]=i[s+1]=n.y,t[s+2]=i[s+2]=n.z,e=!0}return e}updateVector4(t){let e=!1;const i=this.values,n=t.getValue(),s=t.offset;if(i[s+0]!==n.x||i[s+1]!==n.y||i[s+2]!==n.z||i[s+4]!==n.w){const t=this.buffer;t[s+0]=i[s+0]=n.x,t[s+1]=i[s+1]=n.y,t[s+2]=i[s+2]=n.z,t[s+3]=i[s+3]=n.w,e=!0}return e}updateColor(t){let e=!1;const i=this.values,n=t.getValue(),s=t.offset;if(i[s+0]!==n.r||i[s+1]!==n.g||i[s+2]!==n.b){const t=this.buffer;t[s+0]=i[s+0]=n.r,t[s+1]=i[s+1]=n.g,t[s+2]=i[s+2]=n.b,e=!0}return e}updateMatrix3(t){let e=!1;const i=this.values,n=t.getValue().elements,s=t.offset;if(i[s+0]!==n[0]||i[s+1]!==n[1]||i[s+2]!==n[2]||i[s+4]!==n[3]||i[s+5]!==n[4]||i[s+6]!==n[5]||i[s+8]!==n[6]||i[s+9]!==n[7]||i[s+10]!==n[8]){const t=this.buffer;t[s+0]=i[s+0]=n[0],t[s+1]=i[s+1]=n[1],t[s+2]=i[s+2]=n[2],t[s+4]=i[s+4]=n[3],t[s+5]=i[s+5]=n[4],t[s+6]=i[s+6]=n[5],t[s+8]=i[s+8]=n[6],t[s+9]=i[s+9]=n[7],t[s+10]=i[s+10]=n[8],e=!0}return e}updateMatrix4(t){let e=!1;const i=this.values,n=t.getValue().elements,s=t.offset;if(!1===function(t,e,i){for(let n=0,s=e.length;n<s;n++)if(t[i+n]!==e[n])return!1;return!0}(i,n,s)){this.buffer.set(n,s),function(t,e,i){for(let n=0,s=e.length;n<s;n++)t[i+n]=e[n]}(i,n,s),e=!0}return e}}let bU=0;class SU extends yU{constructor(t,e){super(t),this.id=bU++,this.groupNode=e,this.isNodeUniformsGroup=!0}getNodes(){const t=[];for(const e of this.uniforms){const i=e.nodeUniform.node;if(!i)throw new Error("NodeUniformsGroup: Uniform has no node.");t.push(i)}return t}}let MU=0;class TU extends fU{constructor(t,e){super(t),this.id=MU++,this.texture=e,this.version=e?e.version:0,this.store=!1,this.generation=null,this.isSampledTexture=!0}needsBindingsUpdate(t){const{texture:e}=this;return t!==this.generation?(this.generation=t,!0):e.isVideoTexture}update(){const{texture:t,version:e}=this;return e!==t.version&&(this.version=t.version,!0)}}class wU extends TU{constructor(t,e,i,n=null){super(t,e?e.value:null),this.textureNode=e,this.groupNode=i,this.access=n}needsBindingsUpdate(t){return this.textureNode.value!==this.texture||super.needsBindingsUpdate(t)}update(){const{textureNode:t}=this;return this.texture!==t.value?(this.texture=t.value,!0):super.update()}}class AU extends wU{constructor(t,e,i,n){super(t,e,i,n),this.isSampledCubeTexture=!0}}class EU extends wU{constructor(t,e,i,n){super(t,e,i,n),this.isSampledTexture3D=!0}}const CU={atan2:"atan",textureDimensions:"textureSize",equals:"equal"},RU={low:"lowp",medium:"mediump",high:"highp"},NU={swizzleAssign:!0,storageBuffer:!1},PU="\nprecision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp sampler3D;\nprecision highp samplerCube;\nprecision highp sampler2DArray;\n\nprecision highp usampler2D;\nprecision highp usampler3D;\nprecision highp usamplerCube;\nprecision highp usampler2DArray;\n\nprecision highp isampler2D;\nprecision highp isampler3D;\nprecision highp isamplerCube;\nprecision highp isampler2DArray;\n\nprecision lowp sampler2DShadow;\n";class IU extends UD{constructor(t,e){super(t,e,new tU),this.uniformGroups={},this.transforms=[],this.extensions={},this.useComparisonMethod=!0}needsColorSpaceToLinearSRGB(t){return!0===t.isVideoTexture&&t.colorSpace!==eg}getMethod(t){return CU[t]||t}getOutputStructName(){return""}buildFunctionCode(t){const e=t.layout,i=this.flowShaderNode(t),n=[];for(const s of e.inputs)n.push(this.getType(s.type)+" "+s.name);return`${this.getType(e.type)} ${e.name}( ${n.join(", ")} ) {\n\n\t${i.vars}\n\n${i.code}\n\treturn ${i.result};\n\n}`}setupPBO(t){const e=t.value;if(void 0===e.pbo){const t=e.array,i=e.count*e.itemSize,{itemSize:n}=e,s=e.array.constructor.name.toLowerCase().includes("int");let r=s?Nf:Rf;2===n?r=s?If:Pf:3===n?r=s?1032:wf:4===n&&(r=s?Lf:Af);const a={Float32Array:Sf,Uint8Array:gf,Uint16Array:_f,Uint32Array:bf,Int8Array:xf,Int16Array:vf,Int32Array:yf,Uint8ClampedArray:gf},o=Math.pow(2,Math.ceil(Math.log2(Math.sqrt(i/n))));let l=Math.ceil(i/n/o);o*l*n<i&&l++;const h=o*l*n,c=new t.constructor(h);c.set(t,0),e.array=c;const u=new T_(e.array,o,l,r,a[e.array.constructor.name]||Sf);u.needsUpdate=!0,u.isPBOTexture=!0;const d=new Cw(u,null,null);d.setPrecision("high"),e.pboNode=d,e.pbo=d.value,this.getUniformFromNode(e.pboNode,"texture",this.shaderStage,this.context.label)}}getPropertyName(t,e=this.shaderStage){return t.isNodeUniform&&!0!==t.node.isTextureNode&&!0!==t.node.isBufferNode?e.charAt(0)+"_"+t.name:super.getPropertyName(t,e)}generatePBO(t){const{node:e,indexNode:i}=t,n=e.value;if(this.renderer.backend.has(n)){this.renderer.backend.get(n).pbo=n.pbo}const s=this.getUniformFromNode(n.pboNode,"texture",this.shaderStage,this.context.label),r=this.getPropertyName(s);this.increaseUsage(i);const a=i.build(this,"uint"),o=this.getDataFromNode(t);let l=o.propertyName;if(void 0===l){const i=this.getVarFromNode(t);l=this.getPropertyName(i);const s=this.getDataFromNode(e);let h=s.propertySizeName;void 0===h&&(h=l+"Size",this.getVarFromNode(e,h,"uint"),this.addLineFlowCode(`${h} = uint( textureSize( ${r}, 0 ).x )`,t),s.propertySizeName=h);const{itemSize:c}=n,u="."+mb.join("").slice(0,c),d=`ivec2(${a} % ${h}, ${a} / ${h})`,p=this.generateTextureLoad(null,r,d,null,"0");let m="vec4";n.pbo.type===bf?m="uvec4":n.pbo.type===yf&&(m="ivec4"),this.addLineFlowCode(`${l} = ${m}(${p})${u}`,t),o.propertyName=l}return l}generateTextureLoad(t,e,i,n,s="0"){return n?`texelFetch( ${e}, ivec3( ${i}, ${n} ), ${s} )`:`texelFetch( ${e}, ${i}, ${s} )`}generateTexture(t,e,i,n){return t.isDepthTexture?`texture( ${e}, ${i} ).x`:(n&&(i=`vec3( ${i}, ${n} )`),`texture( ${e}, ${i} )`)}generateTextureLevel(t,e,i,n){return`textureLod( ${e}, ${i}, ${n} )`}generateTextureBias(t,e,i,n){return`texture( ${e}, ${i}, ${n} )`}generateTextureGrad(t,e,i,n){return`textureGrad( ${e}, ${i}, ${n[0]}, ${n[1]} )`}generateTextureCompare(t,e,i,n,s,r=this.shaderStage){if("fragment"===r)return`texture( ${e}, vec3( ${i}, ${n} ) )`}getVars(t){const e=[],i=this.vars[t];if(void 0!==i)for(const n of i)e.push(`${this.getVar(n.type,n.name)};`);return e.join("\n\t")}getUniforms(t){const e=this.uniforms[t],i=[],n={};for(const r of e){let e=null,s=!1;if("texture"===r.type){const t=r.node.value;let i="";!0===t.isDataTexture&&(t.type===bf?i="u":t.type===yf&&(i="i")),e=t.compareFunction?`sampler2DShadow ${r.name};`:!0===t.isDataArrayTexture||!0===t.isCompressedArrayTexture?`${i}sampler2DArray ${r.name};`:`${i}sampler2D ${r.name};`}else if("cubeTexture"===r.type)e=`samplerCube ${r.name};`;else if("texture3D"===r.type)e=`sampler3D ${r.name};`;else if("buffer"===r.type){const t=r.node,i=this.getType(t.bufferType),n=t.bufferCount,s=n>0?n:"";e=`${t.name} {\n\t${i} ${r.name}[${s}];\n};\n`}else{e=`${this.getVectorType(r.type)} ${this.getPropertyName(r,t)};`,s=!0}const a=r.node.precision;if(null!==a&&(e=RU[a]+" "+e),s){e="\t"+e;const t=r.groupNode.name;(n[t]||(n[t]=[])).push(e)}else e="uniform "+e,i.push(e)}let s="";for(const r in n){const e=n[r];s+=this._getGLSLUniformStruct(t+"_"+r,e.join("\n"))+"\n"}return s+=i.join("\n"),s}getTypeFromAttribute(t){let e=super.getTypeFromAttribute(t);if(/^[iu]/.test(e)&&t.gpuType!==yf){let i=t;t.isInterleavedBufferAttribute&&(i=t.data);const n=i.array;!1==(n instanceof Uint32Array||n instanceof Int32Array)&&(e=e.slice(1))}return e}getAttributes(t){let e="";if("vertex"===t||"compute"===t){const t=this.getAttributesArray();let i=0;for(const n of t)e+=`layout( location = ${i++} ) in ${n.type} ${n.name};\n`}return e}getStructMembers(t){const e=[],i=t.getMemberTypes();for(let n=0;n<i.length;n++){const t=i[n];e.push(`layout( location = ${n} ) out ${t} m${n};`)}return e.join("\n")}getStructs(t){const e=[],i=this.structs[t];if(0===i.length)return"layout( location = 0 ) out vec4 fragColor;\n";for(let n=0,s=i.length;n<s;n++){const t=i[n];let s="\n";s+=this.getStructMembers(t),s+="\n",e.push(s)}return e.join("\n\n")}getVaryings(t){let e="";const i=this.varyings;if("vertex"===t||"compute"===t)for(const n of i){"compute"===t&&(n.needsInterpolation=!0);const i=n.type;e+=`${i.includes("int")||i.includes("uv")||i.includes("iv")?"flat ":""}${n.needsInterpolation?"out":"/*out*/"} ${i} ${n.name};\n`}else if("fragment"===t)for(const n of i)if(n.needsInterpolation){const t=n.type;e+=`${t.includes("int")||t.includes("uv")||t.includes("iv")?"flat ":""}in ${t} ${n.name};\n`}return e}getVertexIndex(){return"uint( gl_VertexID )"}getInstanceIndex(){return"uint( gl_InstanceID )"}getInvocationLocalIndex(){return`uint( gl_InstanceID ) % ${this.object.workgroupSize.reduce(((t,e)=>t*e),1)}u`}getDrawIndex(){return this.renderer.backend.extensions.has("WEBGL_multi_draw")?"uint( gl_DrawID )":null}getFrontFacing(){return"gl_FrontFacing"}getFragCoord(){return"gl_FragCoord.xy"}getFragDepth(){return"gl_FragDepth"}enableExtension(t,e,i=this.shaderStage){const n=this.extensions[i]||(this.extensions[i]=new Map);!1===n.has(t)&&n.set(t,{name:t,behavior:e})}getExtensions(t){const e=[];if("vertex"===t){const e=this.renderer.backend.extensions;this.object.isBatchedMesh&&e.has("WEBGL_multi_draw")&&this.enableExtension("GL_ANGLE_multi_draw","require",t)}const i=this.extensions[t];if(void 0!==i)for(const{name:n,behavior:s}of i.values())e.push(`#extension ${n} : ${s}`);return e.join("\n")}isAvailable(t){let e=NU[t];if(void 0===e){if("float32Filterable"===t){const t=this.renderer.backend.extensions;t.has("OES_texture_float_linear")?(t.get("OES_texture_float_linear"),e=!0):e=!1}NU[t]=e}return e}isFlipY(){return!0}registerTransform(t,e){this.transforms.push({varyingName:t,attributeNode:e})}getTransforms(){const t=this.transforms;let e="";for(let i=0;i<t.length;i++){const n=t[i],s=this.getPropertyName(n.attributeNode);e+=`${n.varyingName} = ${s};\n\t`}return e}_getGLSLUniformStruct(t,e){return`\nlayout( std140 ) uniform ${t} {\n${e}\n};`}_getGLSLVertexCode(t){return`#version 300 es\n\n${this.getSignature()}\n\n// extensions \n${t.extensions}\n\n// precision\n${PU}\n\n// uniforms\n${t.uniforms}\n\n// varyings\n${t.varyings}\n\n// attributes\n${t.attributes}\n\n// codes\n${t.codes}\n\nvoid main() {\n\n\t// vars\n\t${t.vars}\n\n\t// transforms\n\t${t.transforms}\n\n\t// flow\n\t${t.flow}\n\n\tgl_PointSize = 1.0;\n\n}\n`}_getGLSLFragmentCode(t){return`#version 300 es\n\n${this.getSignature()}\n\n// precision\n${PU}\n\n// uniforms\n${t.uniforms}\n\n// varyings\n${t.varyings}\n\n// codes\n${t.codes}\n\n${t.structs}\n\nvoid main() {\n\n\t// vars\n\t${t.vars}\n\n\t// flow\n\t${t.flow}\n\n}\n`}buildCode(){const t=null!==this.material?{fragment:{},vertex:{}}:{compute:{}};this.sortBindingGroups();for(const e in t){let i="// code\n\n";i+=this.flowCode[e];const n=this.flowNodes[e],s=n[n.length-1];for(const t of n){const n=this.getFlowData(t),r=t.name;r&&(i.length>0&&(i+="\n"),i+=`\t// flow -> ${r}\n\t`),i+=`${n.code}\n\t`,t===s&&"compute"!==e&&(i+="// result\n\t","vertex"===e?(i+="gl_Position = ",i+=`${n.result};`):"fragment"===e&&(t.outputNode.isOutputStructNode||(i+="fragColor = ",i+=`${n.result};`)))}const r=t[e];r.extensions=this.getExtensions(e),r.uniforms=this.getUniforms(e),r.attributes=this.getAttributes(e),r.varyings=this.getVaryings(e),r.vars=this.getVars(e),r.structs=this.getStructs(e),r.codes=this.getCodes(e),r.transforms=this.getTransforms(e),r.flow=i}null!==this.material?(this.vertexShader=this._getGLSLVertexCode(t.vertex),this.fragmentShader=this._getGLSLFragmentCode(t.fragment)):this.computeShader=this._getGLSLVertexCode(t.compute)}getUniformFromNode(t,e,i,n=null){const s=super.getUniformFromNode(t,e,i,n),r=this.getDataFromNode(t,i,this.globalCache);let a=r.uniformGPU;if(void 0===a){const n=t.groupNode,o=n.name,l=this.getBindGroupArray(o,i);if("texture"===e)a=new wU(s.name,s.node,n),l.push(a);else if("cubeTexture"===e)a=new AU(s.name,s.node,n),l.push(a);else if("texture3D"===e)a=new EU(s.name,s.node,n),l.push(a);else if("buffer"===e){t.name=`NodeBuffer_${t.id}`,s.name=`buffer${t.id}`;const e=new _U(t,n);e.name=t.name,l.push(e),a=e}else{const t=this.uniformGroups[i]||(this.uniformGroups[i]={});let r=t[o];void 0===r&&(r=new SU(i+"_"+o,n),t[o]=r,l.push(r)),a=this.getNodeUniform(s,e),r.addUniform(a)}r.uniformGPU=a}return s}}let LU=null,DU=null,UU=null;class FU{constructor(t={}){this.parameters=Object.assign({},t),this.data=new WeakMap,this.renderer=null,this.domElement=null}async init(t){this.renderer=t}begin(){}finish(){}draw(){}createProgram(){}destroyProgram(){}createBindings(){}updateBindings(){}createRenderPipeline(){}createComputePipeline(){}destroyPipeline(){}needsRenderUpdate(){}getRenderCacheKey(){}createNodeBuilder(){}createSampler(){}createDefaultTexture(){}createTexture(){}copyTextureToBuffer(){}createAttribute(){}createIndexAttribute(){}updateAttribute(){}destroyAttribute(){}getContext(){}updateSize(){}resolveTimestampAsync(){}hasFeatureAsync(){}hasFeature(){}getInstanceCount(t){const{object:e,geometry:i}=t;return i.isInstancedBufferGeometry?i.instanceCount:e.count>1?e.count:1}getDrawingBufferSize(){return LU=LU||new Pg,this.renderer.getDrawingBufferSize(LU)}getScissor(){return DU=DU||new Kg,this.renderer.getScissor(DU)}setScissorTest(){}getClearColor(){const t=this.renderer;return UU=UU||new uP,t.getClearColor(UU),UU.getRGB(UU,this.renderer.currentColorSpace),UU}getDomElement(){let t=this.domElement;return null===t&&(t=void 0!==this.parameters.canvas?this.parameters.canvas:function(){const t=Dg("canvas");return t.style.display="block",t}(),"setAttribute"in t&&t.setAttribute("data-engine",`three.js r${zm} webgpu`),this.domElement=t),t}set(t,e){this.data.set(t,e)}get(t){let e=this.data.get(t);return void 0===e&&(e={},this.data.set(t,e)),e}has(t){return this.data.has(t)}delete(t){this.data.delete(t)}dispose(){}}let BU=0;class OU{constructor(t,e){this.buffers=[t.bufferGPU,e],this.type=t.type,this.bufferType=t.bufferType,this.pbo=t.pbo,this.byteLength=t.byteLength,this.bytesPerElement=t.BYTES_PER_ELEMENT,this.version=t.version,this.isInteger=t.isInteger,this.activeBufferIndex=0,this.baseId=t.id}get id(){return`${this.baseId}|${this.activeBufferIndex}`}get bufferGPU(){return this.buffers[this.activeBufferIndex]}get transformBuffer(){return this.buffers[1^this.activeBufferIndex]}switchBuffers(){this.activeBufferIndex^=1}}class zU{constructor(t){this.backend=t}createAttribute(t,e){const i=this.backend,{gl:n}=i,s=t.array,r=t.usage||n.STATIC_DRAW,a=t.isInterleavedBufferAttribute?t.data:t,o=i.get(a);let l,h=o.bufferGPU;if(void 0===h&&(h=this._createBuffer(n,e,s,r),o.bufferGPU=h,o.bufferType=e,o.version=a.version),s instanceof Float32Array)l=n.FLOAT;else if(s instanceof Uint16Array)l=t.isFloat16BufferAttribute?n.HALF_FLOAT:n.UNSIGNED_SHORT;else if(s instanceof Int16Array)l=n.SHORT;else if(s instanceof Uint32Array)l=n.UNSIGNED_INT;else if(s instanceof Int32Array)l=n.INT;else if(s instanceof Int8Array)l=n.BYTE;else if(s instanceof Uint8Array)l=n.UNSIGNED_BYTE;else{if(!(s instanceof Uint8ClampedArray))throw new Error("THREE.WebGLBackend: Unsupported buffer data format: "+s);l=n.UNSIGNED_BYTE}let c={bufferGPU:h,bufferType:e,type:l,byteLength:s.byteLength,bytesPerElement:s.BYTES_PER_ELEMENT,version:t.version,pbo:t.pbo,isInteger:l===n.INT||l===n.UNSIGNED_INT||t.gpuType===yf,id:BU++};if(t.isStorageBufferAttribute||t.isStorageInstancedBufferAttribute){const t=this._createBuffer(n,e,s,r);c=new OU(c,t)}i.set(t,c)}updateAttribute(t){const e=this.backend,{gl:i}=e,n=t.array,s=t.isInterleavedBufferAttribute?t.data:t,r=e.get(s),a=r.bufferType,o=t.isInterleavedBufferAttribute?t.data.updateRanges:t.updateRanges;if(i.bindBuffer(a,r.bufferGPU),0===o.length)i.bufferSubData(a,0,n);else{for(let t=0,e=o.length;t<e;t++){const e=o[t];i.bufferSubData(a,e.start*n.BYTES_PER_ELEMENT,n,e.start,e.count)}s.clearUpdateRanges()}i.bindBuffer(a,null),r.version=s.version}destroyAttribute(t){const e=this.backend,{gl:i}=e;t.isInterleavedBufferAttribute&&e.delete(t.data);const n=e.get(t);i.deleteBuffer(n.bufferGPU),e.delete(t)}async getArrayBufferAsync(t){const e=this.backend,{gl:i}=e,n=t.isInterleavedBufferAttribute?t.data:t,{bufferGPU:s}=e.get(n),r=t.array,a=r.byteLength;i.bindBuffer(i.COPY_READ_BUFFER,s);const o=i.createBuffer();i.bindBuffer(i.COPY_WRITE_BUFFER,o),i.bufferData(i.COPY_WRITE_BUFFER,a,i.STREAM_READ),i.copyBufferSubData(i.COPY_READ_BUFFER,i.COPY_WRITE_BUFFER,0,0,a),await e.utils._clientWaitAsync();const l=new t.array.constructor(r.length);return i.bindBuffer(i.COPY_WRITE_BUFFER,o),i.getBufferSubData(i.COPY_WRITE_BUFFER,0,l),i.deleteBuffer(o),i.bindBuffer(i.COPY_READ_BUFFER,null),i.bindBuffer(i.COPY_WRITE_BUFFER,null),l.buffer}_createBuffer(t,e,i,n){const s=t.createBuffer();return t.bindBuffer(e,s),t.bufferData(e,i,n),t.bindBuffer(e,null),s}}let kU,VU,GU=!1;class HU{constructor(t){this.backend=t,this.gl=this.backend.gl,this.enabled={},this.currentFlipSided=null,this.currentCullFace=null,this.currentProgram=null,this.currentBlendingEnabled=!1,this.currentBlending=null,this.currentBlendSrc=null,this.currentBlendDst=null,this.currentBlendSrcAlpha=null,this.currentBlendDstAlpha=null,this.currentPremultipledAlpha=null,this.currentPolygonOffsetFactor=null,this.currentPolygonOffsetUnits=null,this.currentColorMask=null,this.currentDepthFunc=null,this.currentDepthMask=null,this.currentStencilFunc=null,this.currentStencilRef=null,this.currentStencilFuncMask=null,this.currentStencilFail=null,this.currentStencilZFail=null,this.currentStencilZPass=null,this.currentStencilMask=null,this.currentLineWidth=null,this.currentBoundFramebuffers={},this.currentDrawbuffers=new WeakMap,this.maxTextures=this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS),this.currentTextureSlot=null,this.currentBoundTextures={},this.currentBoundBufferBases={},!1===GU&&(this._init(this.gl),GU=!0)}_init(t){kU={[Gm]:t.FUNC_ADD,[Hm]:t.FUNC_SUBTRACT,[Wm]:t.FUNC_REVERSE_SUBTRACT},VU={[jm]:t.ZERO,[Xm]:t.ONE,[qm]:t.SRC_COLOR,[Ym]:t.SRC_ALPHA,[ef]:t.SRC_ALPHA_SATURATE,[Qm]:t.DST_COLOR,[Km]:t.DST_ALPHA,[$m]:t.ONE_MINUS_SRC_COLOR,[Zm]:t.ONE_MINUS_SRC_ALPHA,[tf]:t.ONE_MINUS_DST_COLOR,[Jm]:t.ONE_MINUS_DST_ALPHA}}enable(t){const{enabled:e}=this;!0!==e[t]&&(this.gl.enable(t),e[t]=!0)}disable(t){const{enabled:e}=this;!1!==e[t]&&(this.gl.disable(t),e[t]=!1)}setFlipSided(t){if(this.currentFlipSided!==t){const{gl:e}=this;t?e.frontFace(e.CW):e.frontFace(e.CCW),this.currentFlipSided=t}}setCullFace(t){const{gl:e}=this;0!==t?(this.enable(e.CULL_FACE),t!==this.currentCullFace&&(1===t?e.cullFace(e.BACK):2===t?e.cullFace(e.FRONT):e.cullFace(e.FRONT_AND_BACK))):this.disable(e.CULL_FACE),this.currentCullFace=t}setLineWidth(t){const{currentLineWidth:e,gl:i}=this;t!==e&&(i.lineWidth(t),this.currentLineWidth=t)}setBlending(t,e,i,n,s,r,a,o){const{gl:l}=this;if(0!==t){if(!1===this.currentBlendingEnabled&&(this.enable(l.BLEND),this.currentBlendingEnabled=!0),5===t)s=s||e,r=r||i,a=a||n,e===this.currentBlendEquation&&s===this.currentBlendEquationAlpha||(l.blendEquationSeparate(kU[e],kU[s]),this.currentBlendEquation=e,this.currentBlendEquationAlpha=s),i===this.currentBlendSrc&&n===this.currentBlendDst&&r===this.currentBlendSrcAlpha&&a===this.currentBlendDstAlpha||(l.blendFuncSeparate(VU[i],VU[n],VU[r],VU[a]),this.currentBlendSrc=i,this.currentBlendDst=n,this.currentBlendSrcAlpha=r,this.currentBlendDstAlpha=a),this.currentBlending=t,this.currentPremultipledAlpha=!1;else if(t!==this.currentBlending||o!==this.currentPremultipledAlpha){if(this.currentBlendEquation===Gm&&this.currentBlendEquationAlpha===Gm||(l.blendEquation(l.FUNC_ADD),this.currentBlendEquation=Gm,this.currentBlendEquationAlpha=Gm),o)switch(t){case 1:l.blendFuncSeparate(l.ONE,l.ONE_MINUS_SRC_ALPHA,l.ONE,l.ONE_MINUS_SRC_ALPHA);break;case 2:l.blendFunc(l.ONE,l.ONE);break;case 3:l.blendFuncSeparate(l.ZERO,l.ONE_MINUS_SRC_COLOR,l.ZERO,l.ONE);break;case 4:l.blendFuncSeparate(l.ZERO,l.SRC_COLOR,l.ZERO,l.SRC_ALPHA)}else switch(t){case 1:l.blendFuncSeparate(l.SRC_ALPHA,l.ONE_MINUS_SRC_ALPHA,l.ONE,l.ONE_MINUS_SRC_ALPHA);break;case 2:l.blendFunc(l.SRC_ALPHA,l.ONE);break;case 3:l.blendFuncSeparate(l.ZERO,l.ONE_MINUS_SRC_COLOR,l.ZERO,l.ONE);break;case 4:l.blendFunc(l.ZERO,l.SRC_COLOR)}this.currentBlendSrc=null,this.currentBlendDst=null,this.currentBlendSrcAlpha=null,this.currentBlendDstAlpha=null,this.currentBlending=t,this.currentPremultipledAlpha=o}}else!0===this.currentBlendingEnabled&&(this.disable(l.BLEND),this.currentBlendingEnabled=!1)}setColorMask(t){this.currentColorMask!==t&&(this.gl.colorMask(t,t,t,t),this.currentColorMask=t)}setDepthTest(t){const{gl:e}=this;t?this.enable(e.DEPTH_TEST):this.disable(e.DEPTH_TEST)}setDepthMask(t){this.currentDepthMask!==t&&(this.gl.depthMask(t),this.currentDepthMask=t)}setDepthFunc(t){if(this.currentDepthFunc!==t){const{gl:e}=this;switch(t){case 0:e.depthFunc(e.NEVER);break;case 1:e.depthFunc(e.ALWAYS);break;case 2:e.depthFunc(e.LESS);break;case 3:default:e.depthFunc(e.LEQUAL);break;case 4:e.depthFunc(e.EQUAL);break;case 5:e.depthFunc(e.GEQUAL);break;case 6:e.depthFunc(e.GREATER);break;case 7:e.depthFunc(e.NOTEQUAL)}this.currentDepthFunc=t}}setStencilTest(t){const{gl:e}=this;t?this.enable(e.STENCIL_TEST):this.disable(e.STENCIL_TEST)}setStencilMask(t){this.currentStencilMask!==t&&(this.gl.stencilMask(t),this.currentStencilMask=t)}setStencilFunc(t,e,i){this.currentStencilFunc===t&&this.currentStencilRef===e&&this.currentStencilFuncMask===i||(this.gl.stencilFunc(t,e,i),this.currentStencilFunc=t,this.currentStencilRef=e,this.currentStencilFuncMask=i)}setStencilOp(t,e,i){this.currentStencilFail===t&&this.currentStencilZFail===e&&this.currentStencilZPass===i||(this.gl.stencilOp(t,e,i),this.currentStencilFail=t,this.currentStencilZFail=e,this.currentStencilZPass=i)}setMaterial(t,e){const{gl:i}=this;2===t.side?this.disable(i.CULL_FACE):this.enable(i.CULL_FACE);let n=1===t.side;e&&(n=!n),this.setFlipSided(n),1===t.blending&&!1===t.transparent?this.setBlending(0):this.setBlending(t.blending,t.blendEquation,t.blendSrc,t.blendDst,t.blendEquationAlpha,t.blendSrcAlpha,t.blendDstAlpha,t.premultipliedAlpha),this.setDepthFunc(t.depthFunc),this.setDepthTest(t.depthTest),this.setDepthMask(t.depthWrite),this.setColorMask(t.colorWrite);const s=t.stencilWrite;this.setStencilTest(s),s&&(this.setStencilMask(t.stencilWriteMask),this.setStencilFunc(t.stencilFunc,t.stencilRef,t.stencilFuncMask),this.setStencilOp(t.stencilFail,t.stencilZFail,t.stencilZPass)),this.setPolygonOffset(t.polygonOffset,t.polygonOffsetFactor,t.polygonOffsetUnits),!0===t.alphaToCoverage&&this.backend.renderer.samples>1?this.enable(i.SAMPLE_ALPHA_TO_COVERAGE):this.disable(i.SAMPLE_ALPHA_TO_COVERAGE)}setPolygonOffset(t,e,i){const{gl:n}=this;t?(this.enable(n.POLYGON_OFFSET_FILL),this.currentPolygonOffsetFactor===e&&this.currentPolygonOffsetUnits===i||(n.polygonOffset(e,i),this.currentPolygonOffsetFactor=e,this.currentPolygonOffsetUnits=i)):this.disable(n.POLYGON_OFFSET_FILL)}useProgram(t){return this.currentProgram!==t&&(this.gl.useProgram(t),this.currentProgram=t,!0)}bindFramebuffer(t,e){const{gl:i,currentBoundFramebuffers:n}=this;return n[t]!==e&&(i.bindFramebuffer(t,e),n[t]=e,t===i.DRAW_FRAMEBUFFER&&(n[i.FRAMEBUFFER]=e),t===i.FRAMEBUFFER&&(n[i.DRAW_FRAMEBUFFER]=e),!0)}drawBuffers(t,e){const{gl:i}=this;let n=[],s=!1;if(null!==t.textures){n=this.currentDrawbuffers.get(e),void 0===n&&(n=[],this.currentDrawbuffers.set(e,n));const r=t.textures;if(n.length!==r.length||n[0]!==i.COLOR_ATTACHMENT0){for(let t=0,e=r.length;t<e;t++)n[t]=i.COLOR_ATTACHMENT0+t;n.length=r.length,s=!0}}else n[0]!==i.BACK&&(n[0]=i.BACK,s=!0);s&&i.drawBuffers(n)}activeTexture(t){const{gl:e,currentTextureSlot:i,maxTextures:n}=this;void 0===t&&(t=e.TEXTURE0+n-1),i!==t&&(e.activeTexture(t),this.currentTextureSlot=t)}bindTexture(t,e,i){const{gl:n,currentTextureSlot:s,currentBoundTextures:r,maxTextures:a}=this;void 0===i&&(i=null===s?n.TEXTURE0+a-1:s);let o=r[i];void 0===o&&(o={type:void 0,texture:void 0},r[i]=o),o.type===t&&o.texture===e||(s!==i&&(n.activeTexture(i),this.currentTextureSlot=i),n.bindTexture(t,e),o.type=t,o.texture=e)}bindBufferBase(t,e,i){const{gl:n}=this,s=`${t}-${e}`;return this.currentBoundBufferBases[s]!==i&&(n.bindBufferBase(t,e,i),this.currentBoundBufferBases[s]=i,!0)}unbindTexture(){const{gl:t,currentTextureSlot:e,currentBoundTextures:i}=this,n=i[e];void 0!==n&&void 0!==n.type&&(t.bindTexture(n.type,null),n.type=void 0,n.texture=void 0)}}class WU{constructor(t){this.backend=t,this.gl=this.backend.gl,this.extensions=t.extensions}convert(t,e=""){const{gl:i,extensions:n}=this;let s;if(t===gf)return i.UNSIGNED_BYTE;if(1017===t)return i.UNSIGNED_SHORT_4_4_4_4;if(1018===t)return i.UNSIGNED_SHORT_5_5_5_1;if(35902===t)return i.UNSIGNED_INT_5_9_9_9_REV;if(t===xf)return i.BYTE;if(t===vf)return i.SHORT;if(t===_f)return i.UNSIGNED_SHORT;if(t===yf)return i.INT;if(t===bf)return i.UNSIGNED_INT;if(t===Sf)return i.FLOAT;if(t===Mf)return i.HALF_FLOAT;if(1021===t)return i.ALPHA;if(t===wf)return i.RGB;if(t===Af)return i.RGBA;if(1024===t)return i.LUMINANCE;if(1025===t)return i.LUMINANCE_ALPHA;if(t===Ef)return i.DEPTH_COMPONENT;if(t===Cf)return i.DEPTH_STENCIL;if(t===Rf)return i.RED;if(t===Nf)return i.RED_INTEGER;if(t===Pf)return i.RG;if(t===If)return i.RG_INTEGER;if(t===Lf)return i.RGBA_INTEGER;if(t===Df||t===Uf||t===Ff||t===Bf)if(e===ig){if(s=n.get("WEBGL_compressed_texture_s3tc_srgb"),null===s)return null;if(t===Df)return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(t===Uf)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(t===Ff)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(t===Bf)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(s=n.get("WEBGL_compressed_texture_s3tc"),null===s)return null;if(t===Df)return s.COMPRESSED_RGB_S3TC_DXT1_EXT;if(t===Uf)return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(t===Ff)return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(t===Bf)return s.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(35840===t||35841===t||35842===t||35843===t){if(s=n.get("WEBGL_compressed_texture_pvrtc"),null===s)return null;if(35840===t)return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(35841===t)return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(35842===t)return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(35843===t)return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(36196===t||t===Of||t===zf){if(s=n.get("WEBGL_compressed_texture_etc"),null===s)return null;if(36196===t||t===Of)return e===ig?s.COMPRESSED_SRGB8_ETC2:s.COMPRESSED_RGB8_ETC2;if(t===zf)return e===ig?s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:s.COMPRESSED_RGBA8_ETC2_EAC}if(t===kf||t===Vf||t===Gf||t===Hf||t===Wf||t===jf||t===Xf||t===qf||t===$f||t===Yf||t===Zf||t===Kf||t===Jf||t===Qf){if(s=n.get("WEBGL_compressed_texture_astc"),null===s)return null;if(t===kf)return e===ig?s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:s.COMPRESSED_RGBA_ASTC_4x4_KHR;if(t===Vf)return e===ig?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:s.COMPRESSED_RGBA_ASTC_5x4_KHR;if(t===Gf)return e===ig?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:s.COMPRESSED_RGBA_ASTC_5x5_KHR;if(t===Hf)return e===ig?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:s.COMPRESSED_RGBA_ASTC_6x5_KHR;if(t===Wf)return e===ig?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:s.COMPRESSED_RGBA_ASTC_6x6_KHR;if(t===jf)return e===ig?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:s.COMPRESSED_RGBA_ASTC_8x5_KHR;if(t===Xf)return e===ig?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:s.COMPRESSED_RGBA_ASTC_8x6_KHR;if(t===qf)return e===ig?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:s.COMPRESSED_RGBA_ASTC_8x8_KHR;if(t===$f)return e===ig?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:s.COMPRESSED_RGBA_ASTC_10x5_KHR;if(t===Yf)return e===ig?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:s.COMPRESSED_RGBA_ASTC_10x6_KHR;if(t===Zf)return e===ig?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:s.COMPRESSED_RGBA_ASTC_10x8_KHR;if(t===Kf)return e===ig?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:s.COMPRESSED_RGBA_ASTC_10x10_KHR;if(t===Jf)return e===ig?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:s.COMPRESSED_RGBA_ASTC_12x10_KHR;if(t===Qf)return e===ig?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:s.COMPRESSED_RGBA_ASTC_12x12_KHR}if(t===tg){if(s=n.get("EXT_texture_compression_bptc"),null===s)return null;if(t===tg)return e===ig?s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:s.COMPRESSED_RGBA_BPTC_UNORM_EXT}if(36283===t||36284===t||36285===t||36286===t){if(s=n.get("EXT_texture_compression_rgtc"),null===s)return null;if(t===tg)return s.COMPRESSED_RED_RGTC1_EXT;if(36284===t)return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(36285===t)return s.COMPRESSED_RED_GREEN_RGTC2_EXT;if(36286===t)return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}return t===Tf?i.UNSIGNED_INT_24_8:void 0!==i[t]?i[t]:null}_clientWaitAsync(){const{gl:t}=this,e=t.fenceSync(t.SYNC_GPU_COMMANDS_COMPLETE,0);return t.flush(),new Promise(((i,n)=>{!function s(){const r=t.clientWaitSync(e,t.SYNC_FLUSH_COMMANDS_BIT,0);if(r===t.WAIT_FAILED)return t.deleteSync(e),void n();r!==t.TIMEOUT_EXPIRED?(t.deleteSync(e),i()):requestAnimationFrame(s)}()}))}}let jU,XU,qU,$U=!1;class YU{constructor(t){this.backend=t,this.gl=t.gl,this.extensions=t.extensions,this.defaultTextures={},!1===$U&&(this._init(this.gl),$U=!0)}_init(t){jU={[of]:t.REPEAT,[lf]:t.CLAMP_TO_EDGE,[hf]:t.MIRRORED_REPEAT},XU={[cf]:t.NEAREST,[uf]:t.NEAREST_MIPMAP_NEAREST,[df]:t.NEAREST_MIPMAP_LINEAR,[pf]:t.LINEAR,[mf]:t.LINEAR_MIPMAP_NEAREST,[ff]:t.LINEAR_MIPMAP_LINEAR},qU={[og]:t.NEVER,[mg]:t.ALWAYS,[lg]:t.LESS,[cg]:t.LEQUAL,[hg]:t.EQUAL,[pg]:t.GEQUAL,[ug]:t.GREATER,[dg]:t.NOTEQUAL}}filterFallback(t){const{gl:e}=this;return t===cf||t===uf||t===df?e.NEAREST:e.LINEAR}getGLTextureType(t){const{gl:e}=this;let i;return i=!0===t.isCubeTexture?e.TEXTURE_CUBE_MAP:!0===t.isDataArrayTexture||!0===t.isCompressedArrayTexture?e.TEXTURE_2D_ARRAY:!0===t.isData3DTexture?e.TEXTURE_3D:e.TEXTURE_2D,i}getInternalFormat(t,e,i,n,s=!1){const{gl:r,extensions:a}=this;if(null!==t&&void 0!==r[t])return r[t];let o=e;return e===r.RED&&(i===r.FLOAT&&(o=r.R32F),i===r.HALF_FLOAT&&(o=r.R16F),i===r.UNSIGNED_BYTE&&(o=r.R8),i===r.UNSIGNED_SHORT&&(o=r.R16),i===r.UNSIGNED_INT&&(o=r.R32UI),i===r.BYTE&&(o=r.R8I),i===r.SHORT&&(o=r.R16I),i===r.INT&&(o=r.R32I)),e===r.RED_INTEGER&&(i===r.UNSIGNED_BYTE&&(o=r.R8UI),i===r.UNSIGNED_SHORT&&(o=r.R16UI),i===r.UNSIGNED_INT&&(o=r.R32UI),i===r.BYTE&&(o=r.R8I),i===r.SHORT&&(o=r.R16I),i===r.INT&&(o=r.R32I)),e===r.RG&&(i===r.FLOAT&&(o=r.RG32F),i===r.HALF_FLOAT&&(o=r.RG16F),i===r.UNSIGNED_BYTE&&(o=r.RG8),i===r.UNSIGNED_SHORT&&(o=r.RG16),i===r.UNSIGNED_INT&&(o=r.RG32UI),i===r.BYTE&&(o=r.RG8I),i===r.SHORT&&(o=r.RG16I),i===r.INT&&(o=r.RG32I)),e===r.RG_INTEGER&&(i===r.UNSIGNED_BYTE&&(o=r.RG8UI),i===r.UNSIGNED_SHORT&&(o=r.RG16UI),i===r.UNSIGNED_INT&&(o=r.RG32UI),i===r.BYTE&&(o=r.RG8I),i===r.SHORT&&(o=r.RG16I),i===r.INT&&(o=r.RG32I)),e===r.RGB&&(i===r.FLOAT&&(o=r.RGB32F),i===r.HALF_FLOAT&&(o=r.RGB16F),i===r.UNSIGNED_BYTE&&(o=r.RGB8),i===r.UNSIGNED_SHORT&&(o=r.RGB16),i===r.UNSIGNED_INT&&(o=r.RGB32UI),i===r.BYTE&&(o=r.RGB8I),i===r.SHORT&&(o=r.RGB16I),i===r.INT&&(o=r.RGB32I),i===r.UNSIGNED_BYTE&&(o=n===ig&&!1===s?r.SRGB8:r.RGB8),i===r.UNSIGNED_SHORT_5_6_5&&(o=r.RGB565),i===r.UNSIGNED_SHORT_5_5_5_1&&(o=r.RGB5_A1),i===r.UNSIGNED_SHORT_4_4_4_4&&(o=r.RGB4),i===r.UNSIGNED_INT_5_9_9_9_REV&&(o=r.RGB9_E5)),e===r.RGB_INTEGER&&(i===r.UNSIGNED_BYTE&&(o=r.RGB8UI),i===r.UNSIGNED_SHORT&&(o=r.RGB16UI),i===r.UNSIGNED_INT&&(o=r.RGB32UI),i===r.BYTE&&(o=r.RGB8I),i===r.SHORT&&(o=r.RGB16I),i===r.INT&&(o=r.RGB32I)),e===r.RGBA&&(i===r.FLOAT&&(o=r.RGBA32F),i===r.HALF_FLOAT&&(o=r.RGBA16F),i===r.UNSIGNED_BYTE&&(o=r.RGBA8),i===r.UNSIGNED_SHORT&&(o=r.RGBA16),i===r.UNSIGNED_INT&&(o=r.RGBA32UI),i===r.BYTE&&(o=r.RGBA8I),i===r.SHORT&&(o=r.RGBA16I),i===r.INT&&(o=r.RGBA32I),i===r.UNSIGNED_BYTE&&(o=n===ig&&!1===s?r.SRGB8_ALPHA8:r.RGBA8),i===r.UNSIGNED_SHORT_4_4_4_4&&(o=r.RGBA4),i===r.UNSIGNED_SHORT_5_5_5_1&&(o=r.RGB5_A1)),e===r.RGBA_INTEGER&&(i===r.UNSIGNED_BYTE&&(o=r.RGBA8UI),i===r.UNSIGNED_SHORT&&(o=r.RGBA16UI),i===r.UNSIGNED_INT&&(o=r.RGBA32UI),i===r.BYTE&&(o=r.RGBA8I),i===r.SHORT&&(o=r.RGBA16I),i===r.INT&&(o=r.RGBA32I)),e===r.DEPTH_COMPONENT&&(i===r.UNSIGNED_INT&&(o=r.DEPTH24_STENCIL8),i===r.FLOAT&&(o=r.DEPTH_COMPONENT32F)),e===r.DEPTH_STENCIL&&i===r.UNSIGNED_INT_24_8&&(o=r.DEPTH24_STENCIL8),o!==r.R16F&&o!==r.R32F&&o!==r.RG16F&&o!==r.RG32F&&o!==r.RGBA16F&&o!==r.RGBA32F||a.get("EXT_color_buffer_float"),o}setTextureParameters(t,e){const{gl:i,extensions:n,backend:s}=this;i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL,e.flipY),i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL,e.premultiplyAlpha),i.pixelStorei(i.UNPACK_ALIGNMENT,e.unpackAlignment),i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL,i.NONE),i.texParameteri(t,i.TEXTURE_WRAP_S,jU[e.wrapS]),i.texParameteri(t,i.TEXTURE_WRAP_T,jU[e.wrapT]),t!==i.TEXTURE_3D&&t!==i.TEXTURE_2D_ARRAY||i.texParameteri(t,i.TEXTURE_WRAP_R,jU[e.wrapR]),i.texParameteri(t,i.TEXTURE_MAG_FILTER,XU[e.magFilter]);const r=void 0!==e.mipmaps&&e.mipmaps.length>0,a=e.minFilter===pf&&r?ff:e.minFilter;if(i.texParameteri(t,i.TEXTURE_MIN_FILTER,XU[a]),e.compareFunction&&(i.texParameteri(t,i.TEXTURE_COMPARE_MODE,i.COMPARE_REF_TO_TEXTURE),i.texParameteri(t,i.TEXTURE_COMPARE_FUNC,qU[e.compareFunction])),!0===n.has("EXT_texture_filter_anisotropic")){if(e.magFilter===cf)return;if(e.minFilter!==df&&e.minFilter!==ff)return;if(e.type===Sf&&!1===n.has("OES_texture_float_linear"))return;if(e.anisotropy>1){const r=n.get("EXT_texture_filter_anisotropic");i.texParameterf(t,r.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(e.anisotropy,s.getMaxAnisotropy()))}}}createDefaultTexture(t){const{gl:e,backend:i,defaultTextures:n}=this,s=this.getGLTextureType(t);let r=n[s];void 0===r&&(r=e.createTexture(),i.state.bindTexture(s,r),e.texParameteri(s,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(s,e.TEXTURE_MAG_FILTER,e.NEAREST),n[s]=r),i.set(t,{textureGPU:r,glTextureType:s,isDefault:!0})}createTexture(t,e){const{gl:i,backend:n}=this,{levels:s,width:r,height:a,depth:o}=e,l=n.utils.convert(t.format,t.colorSpace),h=n.utils.convert(t.type),c=this.getInternalFormat(t.internalFormat,l,h,t.colorSpace,t.isVideoTexture),u=i.createTexture(),d=this.getGLTextureType(t);n.state.bindTexture(d,u),this.setTextureParameters(d,t),t.isDataArrayTexture||t.isCompressedArrayTexture?i.texStorage3D(i.TEXTURE_2D_ARRAY,s,c,r,a,o):t.isData3DTexture?i.texStorage3D(i.TEXTURE_3D,s,c,r,a,o):t.isVideoTexture||i.texStorage2D(d,s,c,r,a),n.set(t,{textureGPU:u,glTextureType:d,glFormat:l,glType:h,glInternalFormat:c})}copyBufferToTexture(t,e){const{gl:i,backend:n}=this,{textureGPU:s,glTextureType:r,glFormat:a,glType:o}=n.get(e),{width:l,height:h}=e.source.data;i.bindBuffer(i.PIXEL_UNPACK_BUFFER,t),n.state.bindTexture(r,s),i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL,!1),i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),i.texSubImage2D(r,0,0,0,l,h,a,o,0),i.bindBuffer(i.PIXEL_UNPACK_BUFFER,null),n.state.unbindTexture()}updateTexture(t,e){const{gl:i}=this,{width:n,height:s}=e,{textureGPU:r,glTextureType:a,glFormat:o,glType:l,glInternalFormat:h}=this.backend.get(t);if(t.isRenderTargetTexture||void 0===r)return;const c=t=>t.isDataTexture?t.image.data:t instanceof ImageBitmap||t instanceof OffscreenCanvas||t instanceof HTMLImageElement||t instanceof HTMLCanvasElement?t:t.data;if(this.backend.state.bindTexture(a,r),this.setTextureParameters(a,t),t.isCompressedTexture){const n=t.mipmaps,s=e.image;for(let e=0;e<n.length;e++){const r=n[e];t.isCompressedArrayTexture?t.format!==i.RGBA?null!==o&&i.compressedTexSubImage3D(i.TEXTURE_2D_ARRAY,e,0,0,0,r.width,r.height,s.depth,o,r.data):i.texSubImage3D(i.TEXTURE_2D_ARRAY,e,0,0,0,r.width,r.height,s.depth,o,l,r.data):null!==o&&i.compressedTexSubImage2D(i.TEXTURE_2D,e,0,0,r.width,r.height,o,r.data)}}else if(t.isCubeTexture){const t=e.images;for(let e=0;e<6;e++){const r=c(t[e]);i.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,0,0,n,s,o,l,r)}}else if(t.isDataArrayTexture){const t=e.image;i.texSubImage3D(i.TEXTURE_2D_ARRAY,0,0,0,0,t.width,t.height,t.depth,o,l,t.data)}else if(t.isData3DTexture){const t=e.image;i.texSubImage3D(i.TEXTURE_3D,0,0,0,0,t.width,t.height,t.depth,o,l,t.data)}else if(t.isVideoTexture)t.update(),i.texImage2D(a,0,h,o,l,e.image);else{const t=c(e.image);i.texSubImage2D(a,0,0,0,n,s,o,l,t)}}generateMipmaps(t){const{gl:e,backend:i}=this,{textureGPU:n,glTextureType:s}=i.get(t);i.state.bindTexture(s,n),e.generateMipmap(s)}deallocateRenderBuffers(t){const{gl:e,backend:i}=this;if(t){const n=i.get(t);if(n.renderBufferStorageSetup=void 0,n.framebuffers){for(const t in n.framebuffers)e.deleteFramebuffer(n.framebuffers[t]);delete n.framebuffers}if(n.depthRenderbuffer&&(e.deleteRenderbuffer(n.depthRenderbuffer),delete n.depthRenderbuffer),n.stencilRenderbuffer&&(e.deleteRenderbuffer(n.stencilRenderbuffer),delete n.stencilRenderbuffer),n.msaaFrameBuffer&&(e.deleteFramebuffer(n.msaaFrameBuffer),delete n.msaaFrameBuffer),n.msaaRenderbuffers){for(let t=0;t<n.msaaRenderbuffers.length;t++)e.deleteRenderbuffer(n.msaaRenderbuffers[t]);delete n.msaaRenderbuffers}}}destroyTexture(t){const{gl:e,backend:i}=this,{textureGPU:n,renderTarget:s}=i.get(t);this.deallocateRenderBuffers(s),e.deleteTexture(n),i.delete(t)}copyTextureToTexture(t,e,i=null,n=null,s=0){const{gl:r,backend:a}=this,{state:o}=this.backend,{textureGPU:l,glTextureType:h,glType:c,glFormat:u}=a.get(e);let d,p,m,f,g,x;null!==i?(d=i.max.x-i.min.x,p=i.max.y-i.min.y,m=i.min.x,f=i.min.y):(d=t.image.width,p=t.image.height,m=0,f=0),null!==n?(g=n.x,x=n.y):(g=0,x=0),o.bindTexture(h,l),r.pixelStorei(r.UNPACK_ALIGNMENT,e.unpackAlignment),r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL,e.flipY),r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL,e.premultiplyAlpha),r.pixelStorei(r.UNPACK_ALIGNMENT,e.unpackAlignment);const v=r.getParameter(r.UNPACK_ROW_LENGTH),_=r.getParameter(r.UNPACK_IMAGE_HEIGHT),y=r.getParameter(r.UNPACK_SKIP_PIXELS),b=r.getParameter(r.UNPACK_SKIP_ROWS),S=r.getParameter(r.UNPACK_SKIP_IMAGES),M=t.isCompressedTexture?t.mipmaps[s]:t.image;if(r.pixelStorei(r.UNPACK_ROW_LENGTH,M.width),r.pixelStorei(r.UNPACK_IMAGE_HEIGHT,M.height),r.pixelStorei(r.UNPACK_SKIP_PIXELS,m),r.pixelStorei(r.UNPACK_SKIP_ROWS,f),t.isRenderTargetTexture||t.isDepthTexture){const i=a.get(t),n=a.get(e),s=a.get(i.renderTarget),l=a.get(n.renderTarget),h=s.framebuffers[i.cacheKey],c=l.framebuffers[n.cacheKey];o.bindFramebuffer(r.READ_FRAMEBUFFER,h),o.bindFramebuffer(r.DRAW_FRAMEBUFFER,c);let u=r.COLOR_BUFFER_BIT;t.isDepthTexture&&(u=r.DEPTH_BUFFER_BIT),r.blitFramebuffer(m,f,d,p,g,x,d,p,u,r.NEAREST),o.bindFramebuffer(r.READ_FRAMEBUFFER,null),o.bindFramebuffer(r.DRAW_FRAMEBUFFER,null)}else t.isDataTexture?r.texSubImage2D(r.TEXTURE_2D,s,g,x,d,p,u,c,M.data):t.isCompressedTexture?r.compressedTexSubImage2D(r.TEXTURE_2D,s,g,x,M.width,M.height,u,M.data):r.texSubImage2D(r.TEXTURE_2D,s,g,x,d,p,u,c,M);r.pixelStorei(r.UNPACK_ROW_LENGTH,v),r.pixelStorei(r.UNPACK_IMAGE_HEIGHT,_),r.pixelStorei(r.UNPACK_SKIP_PIXELS,y),r.pixelStorei(r.UNPACK_SKIP_ROWS,b),r.pixelStorei(r.UNPACK_SKIP_IMAGES,S),0===s&&e.generateMipmaps&&r.generateMipmap(r.TEXTURE_2D),o.unbindTexture()}copyFramebufferToTexture(t,e,i){const{gl:n}=this,{state:s}=this.backend,{textureGPU:r}=this.backend.get(t),{x:a,y:o,z:l,w:h}=i,c=!0===t.isDepthTexture||e.renderTarget&&e.renderTarget.samples>0,u=e.renderTarget?e.renderTarget.height:this.backend.gerDrawingBufferSize().y;if(c){const i=0!==a||0!==o;let c,d;if(!0===t.isDepthTexture?(c=n.DEPTH_BUFFER_BIT,d=n.DEPTH_ATTACHMENT,e.stencil&&(c|=n.STENCIL_BUFFER_BIT)):(c=n.COLOR_BUFFER_BIT,d=n.COLOR_ATTACHMENT0),i){const t=this.backend.get(e.renderTarget),i=t.framebuffers[e.getCacheKey()],d=t.msaaFrameBuffer;s.bindFramebuffer(n.DRAW_FRAMEBUFFER,i),s.bindFramebuffer(n.READ_FRAMEBUFFER,d);const p=u-o-h;n.blitFramebuffer(a,p,a+l,p+h,a,p,a+l,p+h,c,n.NEAREST),s.bindFramebuffer(n.READ_FRAMEBUFFER,i),s.bindTexture(n.TEXTURE_2D,r),n.copyTexSubImage2D(n.TEXTURE_2D,0,0,0,a,p,l,h),s.unbindTexture()}else{const t=n.createFramebuffer();s.bindFramebuffer(n.DRAW_FRAMEBUFFER,t),n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,d,n.TEXTURE_2D,r,0),n.blitFramebuffer(0,0,l,h,0,0,l,h,c,n.NEAREST),n.deleteFramebuffer(t)}}else s.bindTexture(n.TEXTURE_2D,r),n.copyTexSubImage2D(n.TEXTURE_2D,0,0,0,a,u-h-o,l,h),s.unbindTexture();t.generateMipmaps&&this.generateMipmaps(t),this.backend._setFramebuffer(e)}setupRenderBufferStorage(t,e){const{gl:i}=this,n=e.renderTarget,{samples:s,depthTexture:r,depthBuffer:a,stencilBuffer:o,width:l,height:h}=n;if(i.bindRenderbuffer(i.RENDERBUFFER,t),a&&!o){let e=i.DEPTH_COMPONENT24;s>0?(r&&r.isDepthTexture&&r.type===i.FLOAT&&(e=i.DEPTH_COMPONENT32F),i.renderbufferStorageMultisample(i.RENDERBUFFER,s,e,l,h)):i.renderbufferStorage(i.RENDERBUFFER,e,l,h),i.framebufferRenderbuffer(i.FRAMEBUFFER,i.DEPTH_ATTACHMENT,i.RENDERBUFFER,t)}else a&&o&&(s>0?i.renderbufferStorageMultisample(i.RENDERBUFFER,s,i.DEPTH24_STENCIL8,l,h):i.renderbufferStorage(i.RENDERBUFFER,i.DEPTH_STENCIL,l,h),i.framebufferRenderbuffer(i.FRAMEBUFFER,i.DEPTH_STENCIL_ATTACHMENT,i.RENDERBUFFER,t))}async copyTextureToBuffer(t,e,i,n,s,r){const{backend:a,gl:o}=this,{textureGPU:l,glFormat:h,glType:c}=this.backend.get(t),u=o.createFramebuffer();o.bindFramebuffer(o.READ_FRAMEBUFFER,u);const d=t.isCubeTexture?o.TEXTURE_CUBE_MAP_POSITIVE_X+r:o.TEXTURE_2D;o.framebufferTexture2D(o.READ_FRAMEBUFFER,o.COLOR_ATTACHMENT0,d,l,0);const p=this._getTypedArrayType(c),m=n*s*this._getBytesPerTexel(c,h),f=o.createBuffer();o.bindBuffer(o.PIXEL_PACK_BUFFER,f),o.bufferData(o.PIXEL_PACK_BUFFER,m,o.STREAM_READ),o.readPixels(e,i,n,s,h,c,0),o.bindBuffer(o.PIXEL_PACK_BUFFER,null),await a.utils._clientWaitAsync();const g=new p(m/p.BYTES_PER_ELEMENT);return o.bindBuffer(o.PIXEL_PACK_BUFFER,f),o.getBufferSubData(o.PIXEL_PACK_BUFFER,0,g),o.bindBuffer(o.PIXEL_PACK_BUFFER,null),o.deleteFramebuffer(u),g}_getTypedArrayType(t){const{gl:e}=this;if(t===e.UNSIGNED_BYTE)return Uint8Array;if(t===e.UNSIGNED_SHORT_4_4_4_4)return Uint16Array;if(t===e.UNSIGNED_SHORT_5_5_5_1)return Uint16Array;if(t===e.UNSIGNED_SHORT_5_6_5)return Uint16Array;if(t===e.UNSIGNED_SHORT)return Uint16Array;if(t===e.UNSIGNED_INT)return Uint32Array;if(t===e.HALF_FLOAT)return Uint16Array;if(t===e.FLOAT)return Float32Array;throw new Error(`Unsupported WebGL type: ${t}`)}_getBytesPerTexel(t,e){const{gl:i}=this;let n=0;return t===i.UNSIGNED_BYTE&&(n=1),t!==i.UNSIGNED_SHORT_4_4_4_4&&t!==i.UNSIGNED_SHORT_5_5_5_1&&t!==i.UNSIGNED_SHORT_5_6_5&&t!==i.UNSIGNED_SHORT&&t!==i.HALF_FLOAT||(n=2),t!==i.UNSIGNED_INT&&t!==i.FLOAT||(n=4),e===i.RGBA?4*n:e===i.RGB?3*n:e===i.ALPHA?n:void 0}}class ZU{constructor(t){this.backend=t,this.gl=this.backend.gl,this.availableExtensions=this.gl.getSupportedExtensions(),this.extensions={}}get(t){let e=this.extensions[t];return void 0===e&&(e=this.gl.getExtension(t),this.extensions[t]=e),e}has(t){return this.availableExtensions.includes(t)}}class KU{constructor(t){this.backend=t,this.maxAnisotropy=null}getMaxAnisotropy(){if(null!==this.maxAnisotropy)return this.maxAnisotropy;const t=this.backend.gl,e=this.backend.extensions;if(!0===e.has("EXT_texture_filter_anisotropic")){const i=e.get("EXT_texture_filter_anisotropic");this.maxAnisotropy=t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else this.maxAnisotropy=0;return this.maxAnisotropy}}const JU={WEBGL_multi_draw:"WEBGL_multi_draw",WEBGL_compressed_texture_astc:"texture-compression-astc",WEBGL_compressed_texture_etc:"texture-compression-etc2",WEBGL_compressed_texture_etc1:"texture-compression-etc1",WEBGL_compressed_texture_pvrtc:"texture-compression-pvrtc",WEBKIT_WEBGL_compressed_texture_pvrtc:"texture-compression-pvrtc",WEBGL_compressed_texture_s3tc:"texture-compression-bc",EXT_texture_compression_bptc:"texture-compression-bptc",EXT_disjoint_timer_query_webgl2:"timestamp-query"};class QU{constructor(t){this.gl=t.gl,this.extensions=t.extensions,this.info=t.renderer.info,this.mode=null,this.index=0,this.type=null,this.object=null}render(t,e){const{gl:i,mode:n,object:s,type:r,info:a,index:o}=this;0!==o?i.drawElements(n,e,r,t):i.drawArrays(n,t,e),a.update(s,e,n,1)}renderInstances(t,e,i){const{gl:n,mode:s,type:r,index:a,object:o,info:l}=this;0!==i&&(0!==a?n.drawElementsInstanced(s,e,r,t,i):n.drawArraysInstanced(s,t,e,i),l.update(o,e,s,i))}renderMultiDraw(t,e,i){const{extensions:n,mode:s,object:r,info:a}=this;if(0===i)return;const o=n.get("WEBGL_multi_draw");if(null===o)for(let l=0;l<i;l++)this.render(t[l],e[l]);else{0!==this.index?o.multiDrawElementsWEBGL(s,e,0,this.type,t,0,i):o.multiDrawArraysWEBGL(s,t,0,e,0,i);let n=0;for(let t=0;t<i;t++)n+=e[t];a.update(r,n,s,1)}}renderMultiDrawInstances(t,e,i,n){const{extensions:s,mode:r,object:a,info:o}=this;if(0===i)return;const l=s.get("WEBGL_multi_draw");if(null===l)for(let h=0;h<i;h++)this.renderInstances(t[h],e[h],n[h]);else{0!==this.index?l.multiDrawElementsInstancedWEBGL(r,e,0,this.type,t,0,n,0,i):l.multiDrawArraysInstancedWEBGL(r,t,0,e,0,n,0,i);let s=0;for(let t=0;t<i;t++)s+=e[t]*n[t];o.update(a,s,r,1)}}}class tF extends FU{constructor(t={}){super(t),this.isWebGLBackend=!0}init(t){super.init(t);const e=this.parameters,i=void 0!==e.context?e.context:t.domElement.getContext("webgl2");function n(e){e.preventDefault();const i={api:"WebGL",message:e.statusMessage||"Unknown reason",reason:null,originalEvent:e};t.onDeviceLost(i)}this._onContextLost=n,t.domElement.addEventListener("webglcontextlost",n,!1),this.gl=i,this.extensions=new ZU(this),this.capabilities=new KU(this),this.attributeUtils=new zU(this),this.textureUtils=new YU(this),this.bufferRenderer=new QU(this),this.state=new HU(this),this.utils=new WU(this),this.vaoCache={},this.transformFeedbackCache={},this.discard=!1,this.trackTimestamp=!0===e.trackTimestamp,this.extensions.get("EXT_color_buffer_float"),this.extensions.get("WEBGL_clip_cull_distance"),this.extensions.get("OES_texture_float_linear"),this.extensions.get("EXT_color_buffer_half_float"),this.extensions.get("WEBGL_multisampled_render_to_texture"),this.extensions.get("WEBGL_render_shared_exponent"),this.extensions.get("WEBGL_multi_draw"),this.disjoint=this.extensions.get("EXT_disjoint_timer_query_webgl2"),this.parallel=this.extensions.get("KHR_parallel_shader_compile"),this._knownBindings=new WeakSet,this._currentContext=null}get coordinateSystem(){return xg}async getArrayBufferAsync(t){return await this.attributeUtils.getArrayBufferAsync(t)}async waitForGPU(){await this.utils._clientWaitAsync()}initTimestampQuery(t){if(!this.disjoint||!this.trackTimestamp)return;const e=this.get(t);if(this.queryRunning)return e.queryQueue||(e.queryQueue=[]),void e.queryQueue.push(t);e.activeQuery&&(this.gl.endQuery(this.disjoint.TIME_ELAPSED_EXT),e.activeQuery=null),e.activeQuery=this.gl.createQuery(),null!==e.activeQuery&&(this.gl.beginQuery(this.disjoint.TIME_ELAPSED_EXT,e.activeQuery),this.queryRunning=!0)}prepareTimestampBuffer(t){if(!this.disjoint||!this.trackTimestamp)return;const e=this.get(t);if(e.activeQuery&&(this.gl.endQuery(this.disjoint.TIME_ELAPSED_EXT),e.gpuQueries||(e.gpuQueries=[]),e.gpuQueries.push({query:e.activeQuery}),e.activeQuery=null,this.queryRunning=!1,e.queryQueue&&e.queryQueue.length>0)){const t=e.queryQueue.shift();this.initTimestampQuery(t)}}async resolveTimestampAsync(t,e="render"){if(!this.disjoint||!this.trackTimestamp)return;const i=this.get(t);i.gpuQueries||(i.gpuQueries=[]);for(let n=0;n<i.gpuQueries.length;n++){const t=i.gpuQueries[n],s=this.gl.getQueryParameter(t.query,this.gl.QUERY_RESULT_AVAILABLE),r=this.gl.getParameter(this.disjoint.GPU_DISJOINT_EXT);if(s&&!r){const s=this.gl.getQueryParameter(t.query,this.gl.QUERY_RESULT),r=Number(s)/1e6;this.gl.deleteQuery(t.query),i.gpuQueries.splice(n,1),n--,this.renderer.info.updateTimestamp(e,r)}}}getContext(){return this.gl}beginRender(t){const{gl:e}=this,i=this.get(t);if(this.initTimestampQuery(t),i.previousContext=this._currentContext,this._currentContext=t,this._setFramebuffer(t),this.clear(t.clearColor,t.clearDepth,t.clearStencil,t,!1),t.viewport?this.updateViewport(t):e.viewport(0,0,e.drawingBufferWidth,e.drawingBufferHeight),t.scissor){const{x:i,y:n,width:s,height:r}=t.scissorValue;e.scissor(i,t.height-r-n,s,r)}const n=t.occlusionQueryCount;n>0&&(i.currentOcclusionQueries=i.occlusionQueries,i.currentOcclusionQueryObjects=i.occlusionQueryObjects,i.lastOcclusionObject=null,i.occlusionQueries=new Array(n),i.occlusionQueryObjects=new Array(n),i.occlusionQueryIndex=0)}finishRender(t){const{gl:e,state:i}=this,n=this.get(t),s=n.previousContext,r=t.occlusionQueryCount;r>0&&(r>n.occlusionQueryIndex&&e.endQuery(e.ANY_SAMPLES_PASSED),this.resolveOccludedAsync(t));const a=t.textures;if(null!==a)for(let o=0;o<a.length;o++){const t=a[o];t.generateMipmaps&&this.generateMipmaps(t)}if(this._currentContext=s,null!==t.textures&&t.renderTarget){const n=this.get(t.renderTarget),{samples:s}=t.renderTarget;if(s>0){const s=n.framebuffers[t.getCacheKey()],r=e.COLOR_BUFFER_BIT,a=n.msaaFrameBuffer,o=t.textures;i.bindFramebuffer(e.READ_FRAMEBUFFER,a),i.bindFramebuffer(e.DRAW_FRAMEBUFFER,s);for(let i=0;i<o.length;i++)if(t.scissor){const{x:i,y:s,width:a,height:o}=t.scissorValue,l=t.height-o-s;e.blitFramebuffer(i,l,i+a,l+o,i,l,i+a,l+o,r,e.NEAREST),e.invalidateSubFramebuffer(e.READ_FRAMEBUFFER,n.invalidationArray,i,l,a,o)}else e.blitFramebuffer(0,0,t.width,t.height,0,0,t.width,t.height,r,e.NEAREST),e.invalidateFramebuffer(e.READ_FRAMEBUFFER,n.invalidationArray)}}null!==s&&(this._setFramebuffer(s),s.viewport?this.updateViewport(s):e.viewport(0,0,e.drawingBufferWidth,e.drawingBufferHeight)),this.prepareTimestampBuffer(t)}resolveOccludedAsync(t){const e=this.get(t),{currentOcclusionQueries:i,currentOcclusionQueryObjects:n}=e;if(i&&n){const t=new WeakSet,{gl:s}=this;e.currentOcclusionQueryObjects=null,e.currentOcclusionQueries=null;const r=()=>{let a=0;for(let e=0;e<i.length;e++){const r=i[e];null!==r&&(s.getQueryParameter(r,s.QUERY_RESULT_AVAILABLE)&&(s.getQueryParameter(r,s.QUERY_RESULT)>0&&t.add(n[e]),i[e]=null,s.deleteQuery(r),a++))}a<i.length?requestAnimationFrame(r):e.occluded=t};r()}}isOccluded(t,e){const i=this.get(t);return i.occluded&&i.occluded.has(e)}updateViewport(t){const e=this.gl,{x:i,y:n,width:s,height:r}=t.viewportValue;e.viewport(i,t.height-r-n,s,r)}setScissorTest(t){const e=this.gl;t?e.enable(e.SCISSOR_TEST):e.disable(e.SCISSOR_TEST)}clear(t,e,i,n=null,s=!0){const{gl:r}=this;if(null===n){const t=this.getClearColor();t.r*=t.a,t.g*=t.a,t.b*=t.a,n={textures:null,clearColorValue:t}}let a=0;if(t&&(a|=r.COLOR_BUFFER_BIT),e&&(a|=r.DEPTH_BUFFER_BIT),i&&(a|=r.STENCIL_BUFFER_BIT),0!==a){let o;if(n.clearColorValue?o=n.clearColorValue:(o=this.getClearColor(),o.r*=o.a,o.g*=o.a,o.b*=o.a),e&&this.state.setDepthMask(!0),null===n.textures)r.clearColor(o.r,o.g,o.b,o.a),r.clear(a);else{if(s&&this._setFramebuffer(n),t)for(let t=0;t<n.textures.length;t++)r.clearBufferfv(r.COLOR,t,[o.r,o.g,o.b,o.a]);e&&i?r.clearBufferfi(r.DEPTH_STENCIL,0,1,0):e?r.clearBufferfv(r.DEPTH,0,[1]):i&&r.clearBufferiv(r.STENCIL,0,[0])}}}beginCompute(t){const{state:e,gl:i}=this;e.bindFramebuffer(i.FRAMEBUFFER,null),this.initTimestampQuery(t)}compute(t,e,i,n){const{state:s,gl:r}=this;this.discard||(r.enable(r.RASTERIZER_DISCARD),this.discard=!0);const{programGPU:a,transformBuffers:o,attributes:l}=this.get(n),h=this._getVaoKey(null,l),c=this.vaoCache[h];void 0===c?this._createVao(null,l):r.bindVertexArray(c),s.useProgram(a),this._bindUniforms(i);const u=this._getTransformFeedback(o);r.bindTransformFeedback(r.TRANSFORM_FEEDBACK,u),r.beginTransformFeedback(r.POINTS),l[0].isStorageInstancedBufferAttribute?r.drawArraysInstanced(r.POINTS,0,1,e.count):r.drawArrays(r.POINTS,0,e.count),r.endTransformFeedback(),r.bindTransformFeedback(r.TRANSFORM_FEEDBACK,null);for(let d=0;d<o.length;d++){const t=o[d];t.pbo&&this.textureUtils.copyBufferToTexture(t.transformBuffer,t.pbo),t.switchBuffers()}}finishCompute(t){const e=this.gl;this.discard=!1,e.disable(e.RASTERIZER_DISCARD),this.prepareTimestampBuffer(t),this._currentContext&&this._setFramebuffer(this._currentContext)}draw(t){const{object:e,pipeline:i,material:n,context:s}=t,{programGPU:r}=this.get(i),{gl:a,state:o}=this,l=this.get(s),h=t.getDrawParameters();if(null===h)return;this._bindUniforms(t.getBindings());const c=e.isMesh&&e.matrixWorld.determinant()<0;o.setMaterial(n,c),o.useProgram(r);let u=t.staticVao;if(void 0===u){const e=this._getVaoKey(t.getIndex(),t.getAttributes());if(u=this.vaoCache[e],void 0===u){let e;({vaoGPU:u,staticVao:e}=this._createVao(t.getIndex(),t.getAttributes())),e&&(t.staticVao=u)}}a.bindVertexArray(u);const d=t.getIndex(),p=l.lastOcclusionObject;if(p!==e&&void 0!==p){if(null!==p&&!0===p.occlusionTest&&(a.endQuery(a.ANY_SAMPLES_PASSED),l.occlusionQueryIndex++),!0===e.occlusionTest){const t=a.createQuery();a.beginQuery(a.ANY_SAMPLES_PASSED,t),l.occlusionQueries[l.occlusionQueryIndex]=t,l.occlusionQueryObjects[l.occlusionQueryIndex]=e}l.lastOcclusionObject=e}const m=this.bufferRenderer;e.isPoints?m.mode=a.POINTS:e.isLineSegments?m.mode=a.LINES:e.isLine?m.mode=a.LINE_STRIP:e.isLineLoop?m.mode=a.LINE_LOOP:!0===n.wireframe?(o.setLineWidth(n.wireframeLinewidth*this.renderer.getPixelRatio()),m.mode=a.LINES):m.mode=a.TRIANGLES;const{vertexCount:f,instanceCount:g}=h;let{firstVertex:x}=h;if(m.object=e,null!==d){x*=d.array.BYTES_PER_ELEMENT;const t=this.get(d);m.index=d.count,m.type=t.type}else m.index=0;var v;e.isBatchedMesh?null!==e._multiDrawInstances?m.renderMultiDrawInstances(e._multiDrawStarts,e._multiDrawCounts,e._multiDrawCount,e._multiDrawInstances):this.hasFeature("WEBGL_multi_draw")?m.renderMultiDraw(e._multiDrawStarts,e._multiDrawCounts,e._multiDrawCount):(v="THREE.WebGLRenderer: WEBGL_multi_draw not supported.")in Ug||(Ug[v]=!0):g>1?m.renderInstances(x,f,g):m.render(x,f),a.bindVertexArray(null)}needsRenderUpdate(){return!1}getRenderCacheKey(){return""}createDefaultTexture(t){this.textureUtils.createDefaultTexture(t)}createTexture(t,e){this.textureUtils.createTexture(t,e)}updateTexture(t,e){this.textureUtils.updateTexture(t,e)}generateMipmaps(t){this.textureUtils.generateMipmaps(t)}destroyTexture(t){this.textureUtils.destroyTexture(t)}copyTextureToBuffer(t,e,i,n,s,r){return this.textureUtils.copyTextureToBuffer(t,e,i,n,s,r)}createSampler(){}destroySampler(){}createNodeBuilder(t,e){return new IU(t,e)}createProgram(t){const e=this.gl,{stage:i,code:n}=t,s="fragment"===i?e.createShader(e.FRAGMENT_SHADER):e.createShader(e.VERTEX_SHADER);e.shaderSource(s,n),e.compileShader(s),this.set(t,{shaderGPU:s})}destroyProgram(){}createRenderPipeline(t,e){const i=this.gl,n=t.pipeline,{fragmentProgram:s,vertexProgram:r}=n,a=i.createProgram(),o=this.get(s).shaderGPU,l=this.get(r).shaderGPU;if(i.attachShader(a,o),i.attachShader(a,l),i.linkProgram(a),this.set(n,{programGPU:a,fragmentShader:o,vertexShader:l}),null!==e&&this.parallel){const s=new Promise((e=>{const s=this.parallel,r=()=>{i.getProgramParameter(a,s.COMPLETION_STATUS_KHR)?(this._completeCompile(t,n),e()):requestAnimationFrame(r)};r()}));e.push(s)}else this._completeCompile(t,n)}_handleSource(t,e){const i=t.split("\n"),n=[],s=Math.max(e-6,0),r=Math.min(e+6,i.length);for(let a=s;a<r;a++){const t=a+1;n.push(`${t===e?">":" "} ${t}: ${i[a]}`)}return n.join("\n")}_getShaderErrors(t,e,i){const n=t.getShaderParameter(e,t.COMPILE_STATUS),s=t.getShaderInfoLog(e).trim();if(n&&""===s)return"";const r=/ERROR: 0:(\d+)/.exec(s);if(r){const n=parseInt(r[1]);return i.toUpperCase()+"\n\n"+s+"\n\n"+this._handleSource(t.getShaderSource(e),n)}return s}_logProgramError(t,e,i){if(this.renderer.debug.checkShaderErrors){const n=this.gl;n.getProgramInfoLog(t).trim();if(!1===n.getProgramParameter(t,n.LINK_STATUS))if("function"==typeof this.renderer.debug.onShaderError)this.renderer.debug.onShaderError(n,t,i,e);else{this._getShaderErrors(n,i,"vertex"),this._getShaderErrors(n,e,"fragment")}}}_completeCompile(t,e){const{state:i,gl:n}=this,s=this.get(e),{programGPU:r,fragmentShader:a,vertexShader:o}=s;!1===n.getProgramParameter(r,n.LINK_STATUS)&&this._logProgramError(r,a,o),i.useProgram(r);const l=t.getBindings();this._setupBindings(l,r),this.set(e,{programGPU:r})}createComputePipeline(t,e){const{state:i,gl:n}=this,s={stage:"fragment",code:"#version 300 es\nprecision highp float;\nvoid main() {}"};this.createProgram(s);const{computeProgram:r}=t,a=n.createProgram(),o=this.get(s).shaderGPU,l=this.get(r).shaderGPU,h=r.transforms,c=[],u=[];for(let f=0;f<h.length;f++){const t=h[f];c.push(t.varyingName),u.push(t.attributeNode)}n.attachShader(a,o),n.attachShader(a,l),n.transformFeedbackVaryings(a,c,n.SEPARATE_ATTRIBS),n.linkProgram(a),!1===n.getProgramParameter(a,n.LINK_STATUS)&&this._logProgramError(a,o,l),i.useProgram(a),this._setupBindings(e,a);const d=r.attributes,p=[],m=[];for(let f=0;f<d.length;f++){const t=d[f].node.attribute;p.push(t),this.has(t)||this.attributeUtils.createAttribute(t,n.ARRAY_BUFFER)}for(let f=0;f<u.length;f++){const t=u[f].attribute;this.has(t)||this.attributeUtils.createAttribute(t,n.ARRAY_BUFFER);const e=this.get(t);m.push(e)}this.set(t,{programGPU:a,transformBuffers:m,attributes:p})}createBindings(t,e){if(!1===this._knownBindings.has(e)){this._knownBindings.add(e);let t=0,i=0;for(const n of e){this.set(n,{textures:i,uniformBuffers:t});for(const e of n.bindings)e.isUniformBuffer&&t++,e.isSampledTexture&&i++}}this.updateBindings(t,e)}updateBindings(t){const{gl:e}=this,i=this.get(t);let n=i.uniformBuffers,s=i.textures;for(const r of t.bindings)if(r.isUniformsGroup||r.isUniformBuffer){const t=r.buffer,i=e.createBuffer();e.bindBuffer(e.UNIFORM_BUFFER,i),e.bufferData(e.UNIFORM_BUFFER,t,e.DYNAMIC_DRAW),this.set(r,{index:n++,bufferGPU:i})}else if(r.isSampledTexture){const{textureGPU:t,glTextureType:e}=this.get(r.texture);this.set(r,{index:s++,textureGPU:t,glTextureType:e})}}updateBinding(t){const e=this.gl;if(t.isUniformsGroup||t.isUniformBuffer){const i=this.get(t).bufferGPU,n=t.buffer;e.bindBuffer(e.UNIFORM_BUFFER,i),e.bufferData(e.UNIFORM_BUFFER,n,e.DYNAMIC_DRAW)}}createIndexAttribute(t){const e=this.gl;this.attributeUtils.createAttribute(t,e.ELEMENT_ARRAY_BUFFER)}createAttribute(t){if(this.has(t))return;const e=this.gl;this.attributeUtils.createAttribute(t,e.ARRAY_BUFFER)}createStorageAttribute(t){if(this.has(t))return;const e=this.gl;this.attributeUtils.createAttribute(t,e.ARRAY_BUFFER)}updateAttribute(t){this.attributeUtils.updateAttribute(t)}destroyAttribute(t){this.attributeUtils.destroyAttribute(t)}updateSize(){}hasFeature(t){const e=Object.keys(JU).filter((e=>JU[e]===t)),i=this.extensions;for(let n=0;n<e.length;n++)if(i.has(e[n]))return!0;return!1}getMaxAnisotropy(){return this.capabilities.getMaxAnisotropy()}copyTextureToTexture(t,e,i,n,s){this.textureUtils.copyTextureToTexture(t,e,i,n,s)}copyFramebufferToTexture(t,e,i){this.textureUtils.copyFramebufferToTexture(t,e,i)}_setFramebuffer(t){const{gl:e,state:i}=this;let n=null;if(null!==t.textures){const s=t.renderTarget,r=this.get(s),{samples:a,depthBuffer:o,stencilBuffer:l}=s,h=!0===s.isWebGLCubeRenderTarget;let c=r.msaaFrameBuffer,u=r.depthRenderbuffer;const d=oP(t);let p;if(h?(r.cubeFramebuffers||(r.cubeFramebuffers={}),p=r.cubeFramebuffers[d]):(r.framebuffers||(r.framebuffers={}),p=r.framebuffers[d]),void 0===p){p=e.createFramebuffer(),i.bindFramebuffer(e.FRAMEBUFFER,p);const n=t.textures;if(h){r.cubeFramebuffers[d]=p;const{textureGPU:t}=this.get(n[0]),i=this.renderer._activeCubeFace;e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_CUBE_MAP_POSITIVE_X+i,t,0)}else{r.framebuffers[d]=p;for(let i=0;i<n.length;i++){const s=n[i],r=this.get(s);r.renderTarget=t.renderTarget,r.cacheKey=d;const a=e.COLOR_ATTACHMENT0+i;e.framebufferTexture2D(e.FRAMEBUFFER,a,e.TEXTURE_2D,r.textureGPU,0)}i.drawBuffers(t,p)}if(null!==t.depthTexture){const i=this.get(t.depthTexture),n=l?e.DEPTH_STENCIL_ATTACHMENT:e.DEPTH_ATTACHMENT;i.renderTarget=t.renderTarget,i.cacheKey=d,e.framebufferTexture2D(e.FRAMEBUFFER,n,e.TEXTURE_2D,i.textureGPU,0)}}if(a>0){if(void 0===c){const n=[];c=e.createFramebuffer(),i.bindFramebuffer(e.FRAMEBUFFER,c);const s=[],h=t.textures;for(let i=0;i<h.length;i++){if(s[i]=e.createRenderbuffer(),e.bindRenderbuffer(e.RENDERBUFFER,s[i]),n.push(e.COLOR_ATTACHMENT0+i),o){const t=l?e.DEPTH_STENCIL_ATTACHMENT:e.DEPTH_ATTACHMENT;n.push(t)}const r=t.textures[i],h=this.get(r);e.renderbufferStorageMultisample(e.RENDERBUFFER,a,h.glInternalFormat,t.width,t.height),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0+i,e.RENDERBUFFER,s[i])}if(r.msaaFrameBuffer=c,r.msaaRenderbuffers=s,void 0===u){u=e.createRenderbuffer(),this.textureUtils.setupRenderBufferStorage(u,t),r.depthRenderbuffer=u;const i=l?e.DEPTH_STENCIL_ATTACHMENT:e.DEPTH_ATTACHMENT;n.push(i)}r.invalidationArray=n}n=r.msaaFrameBuffer}else n=p}i.bindFramebuffer(e.FRAMEBUFFER,n)}_getVaoKey(t,e){let i=[];if(null!==t){i+=":"+this.get(t).id}for(let n=0;n<e.length;n++){i+=":"+this.get(e[n]).id}return i}_createVao(t,e){const{gl:i}=this,n=i.createVertexArray();let s="",r=!0;if(i.bindVertexArray(n),null!==t){const e=this.get(t);i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,e.bufferGPU),s+=":"+e.id}for(let a=0;a<e.length;a++){const t=e[a],n=this.get(t);let o,l;s+=":"+n.id,i.bindBuffer(i.ARRAY_BUFFER,n.bufferGPU),i.enableVertexAttribArray(a),(t.isStorageBufferAttribute||t.isStorageInstancedBufferAttribute)&&(r=!1),!0===t.isInterleavedBufferAttribute?(o=t.data.stride*n.bytesPerElement,l=t.offset*n.bytesPerElement):(o=0,l=0),n.isInteger?i.vertexAttribIPointer(a,t.itemSize,n.type,o,l):i.vertexAttribPointer(a,t.itemSize,n.type,t.normalized,o,l),t.isInstancedBufferAttribute&&!t.isInterleavedBufferAttribute?i.vertexAttribDivisor(a,t.meshPerAttribute):t.isInterleavedBufferAttribute&&t.data.isInstancedInterleavedBuffer&&i.vertexAttribDivisor(a,t.data.meshPerAttribute)}return i.bindBuffer(i.ARRAY_BUFFER,null),this.vaoCache[s]=n,{vaoGPU:n,staticVao:r}}_getTransformFeedback(t){let e="";for(let s=0;s<t.length;s++)e+=":"+t[s].id;let i=this.transformFeedbackCache[e];if(void 0!==i)return i;const{gl:n}=this;i=n.createTransformFeedback(),n.bindTransformFeedback(n.TRANSFORM_FEEDBACK,i);for(let s=0;s<t.length;s++){const e=t[s];n.bindBufferBase(n.TRANSFORM_FEEDBACK_BUFFER,s,e.transformBuffer)}return n.bindTransformFeedback(n.TRANSFORM_FEEDBACK,null),this.transformFeedbackCache[e]=i,i}_setupBindings(t,e){const i=this.gl;for(const n of t)for(const t of n.bindings){const n=this.get(t).index;if(t.isUniformsGroup||t.isUniformBuffer){const s=i.getUniformBlockIndex(e,t.name);i.uniformBlockBinding(e,s,n)}else if(t.isSampledTexture){const s=i.getUniformLocation(e,t.name);i.uniform1i(s,n)}}}_bindUniforms(t){const{gl:e,state:i}=this;for(const n of t)for(const t of n.bindings){const n=this.get(t),s=n.index;t.isUniformsGroup||t.isUniformBuffer?i.bindBufferBase(e.UNIFORM_BUFFER,s,n.bufferGPU):t.isSampledTexture&&i.bindTexture(n.glTextureType,n.textureGPU,e.TEXTURE0+s)}}dispose(){this.renderer.domElement.removeEventListener("webglcontextlost",this._onContextLost)}}class eF extends fU{constructor(t,e){super(t),this.texture=e,this.version=e?e.version:0,this.isSampler=!0}}class iF extends eF{constructor(t,e,i){super(t,e?e.value:null),this.textureNode=e,this.groupNode=i}update(){this.texture=this.textureNode.value}}class nF extends gU{constructor(t,e){super(t,e?e.array:null),this.attribute=e,this.isStorageBuffer=!0}}let sF=0;class rF extends nF{constructor(t,e){super("StorageBuffer_"+sF++,t?t.value:null),this.nodeUniform=t,this.access=t?t.access:CI,this.groupNode=e}get buffer(){return this.nodeUniform.value}}class aF extends FN{constructor(t){super(),this.device=t;this.mipmapSampler=t.createSampler({minFilter:JP}),this.flipYSampler=t.createSampler({minFilter:QP}),this.transferPipelines={},this.flipYPipelines={},this.mipmapVertexShaderModule=t.createShaderModule({label:"mipmapVertex",code:"\nstruct VarysStruct {\n\t@builtin( position ) Position: vec4<f32>,\n\t@location( 0 ) vTex : vec2<f32>\n};\n\n@vertex\nfn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {\n\n\tvar Varys : VarysStruct;\n\n\tvar pos = array< vec2<f32>, 4 >(\n\t\tvec2<f32>( -1.0,  1.0 ),\n\t\tvec2<f32>(  1.0,  1.0 ),\n\t\tvec2<f32>( -1.0, -1.0 ),\n\t\tvec2<f32>(  1.0, -1.0 )\n\t);\n\n\tvar tex = array< vec2<f32>, 4 >(\n\t\tvec2<f32>( 0.0, 0.0 ),\n\t\tvec2<f32>( 1.0, 0.0 ),\n\t\tvec2<f32>( 0.0, 1.0 ),\n\t\tvec2<f32>( 1.0, 1.0 )\n\t);\n\n\tVarys.vTex = tex[ vertexIndex ];\n\tVarys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );\n\n\treturn Varys;\n\n}\n"}),this.mipmapFragmentShaderModule=t.createShaderModule({label:"mipmapFragment",code:"\n@group( 0 ) @binding( 0 )\nvar imgSampler : sampler;\n\n@group( 0 ) @binding( 1 )\nvar img : texture_2d<f32>;\n\n@fragment\nfn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {\n\n\treturn textureSample( img, imgSampler, vTex );\n\n}\n"}),this.flipYFragmentShaderModule=t.createShaderModule({label:"flipYFragment",code:"\n@group( 0 ) @binding( 0 )\nvar imgSampler : sampler;\n\n@group( 0 ) @binding( 1 )\nvar img : texture_2d<f32>;\n\n@fragment\nfn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {\n\n\treturn textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );\n\n}\n"})}getTransferPipeline(t){let e=this.transferPipelines[t];return void 0===e&&(e=this.device.createRenderPipeline({label:`mipmap-${t}`,vertex:{module:this.mipmapVertexShaderModule,entryPoint:"main"},fragment:{module:this.mipmapFragmentShaderModule,entryPoint:"main",targets:[{format:t}]},primitive:{topology:NP,stripIndexFormat:qP},layout:"auto"}),this.transferPipelines[t]=e),e}getFlipYPipeline(t){let e=this.flipYPipelines[t];return void 0===e&&(e=this.device.createRenderPipeline({label:`flipY-${t}`,vertex:{module:this.mipmapVertexShaderModule,entryPoint:"main"},fragment:{module:this.flipYFragmentShaderModule,entryPoint:"main",targets:[{format:t}]},primitive:{topology:NP,stripIndexFormat:qP},layout:"auto"}),this.flipYPipelines[t]=e),e}flipY(t,e,i=0){const n=e.format,{width:s,height:r}=e.size,a=this.getTransferPipeline(n),o=this.getFlipYPipeline(n),l=this.device.createTexture({size:{width:s,height:r,depthOrArrayLayers:1},format:n,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING}),h=t.createView({baseMipLevel:0,mipLevelCount:1,dimension:zI,baseArrayLayer:i}),c=l.createView({baseMipLevel:0,mipLevelCount:1,dimension:zI,baseArrayLayer:0}),u=this.device.createCommandEncoder({}),d=(t,e,i)=>{const n=t.getBindGroupLayout(0),s=this.device.createBindGroup({layout:n,entries:[{binding:0,resource:this.flipYSampler},{binding:1,resource:e}]}),r=u.beginRenderPass({colorAttachments:[{view:i,loadOp:VP,storeOp:zP,clearValue:[0,0,0,0]}]});r.setPipeline(t),r.setBindGroup(0,s),r.draw(4,1,0,0),r.end()};d(a,h,c),d(o,c,h),this.device.queue.submit([u.finish()]),l.destroy()}generateMipmaps(t,e,i=0){const n=this.get(t);void 0===n.useCount&&(n.useCount=0,n.layers=[]);const s=n.layers[i]||this._mipmapCreateBundles(t,e,i),r=this.device.createCommandEncoder({});this._mipmapRunBundles(r,s),this.device.queue.submit([r.finish()]),0!==n.useCount&&(n.layers[i]=s),n.useCount++}_mipmapCreateBundles(t,e,i){const n=this.getTransferPipeline(e.format),s=n.getBindGroupLayout(0);let r=t.createView({baseMipLevel:0,mipLevelCount:1,dimension:zI,baseArrayLayer:i});const a=[];for(let o=1;o<e.mipLevelCount;o++){const l=this.device.createBindGroup({layout:s,entries:[{binding:0,resource:this.mipmapSampler},{binding:1,resource:r}]}),h=t.createView({baseMipLevel:o,mipLevelCount:1,dimension:zI,baseArrayLayer:i}),c={colorAttachments:[{view:h,loadOp:VP,storeOp:zP,clearValue:[0,0,0,0]}]},u=this.device.createRenderBundleEncoder({colorFormats:[e.format]});u.setPipeline(n),u.setBindGroup(0,l),u.draw(4,1,0,0),a.push({renderBundles:[u.finish()],passDescriptor:c}),r=h}return a}_mipmapRunBundles(t,e){const i=e.length;for(let n=0;n<i;n++){const i=e[n],s=t.beginRenderPass(i.passDescriptor);s.executeBundles(i.renderBundles),s.end()}}}const oF={[og]:"never",[lg]:"less",[hg]:"equal",[cg]:"less-equal",[ug]:"greater",[pg]:"greater-equal",[mg]:"always",[dg]:"not-equal"},lF=[0,1,3,2,4,5];class hF{constructor(t){this.backend=t,this._passUtils=null,this.defaultTexture={},this.defaultCubeTexture={},this.defaultVideoFrame=null,this.colorBuffer=null,this.depthTexture=new sy,this.depthTexture.name="depthBuffer"}createSampler(t){const e=this.backend,i=e.device,n=e.get(t),s={addressModeU:this._convertAddressMode(t.wrapS),addressModeV:this._convertAddressMode(t.wrapT),addressModeW:this._convertAddressMode(t.wrapR),magFilter:this._convertFilterMode(t.magFilter),minFilter:this._convertFilterMode(t.minFilter),mipmapFilter:this._convertFilterMode(t.minFilter),maxAnisotropy:1};s.magFilter===JP&&s.minFilter===JP&&s.mipmapFilter===JP&&(s.maxAnisotropy=t.anisotropy),t.isDepthTexture&&null!==t.compareFunction&&(s.compare=oF[t.compareFunction]),n.sampler=i.createSampler(s)}createDefaultTexture(t){let e;const i=cF(t);t.isCubeTexture?e=this._getDefaultCubeTextureGPU(i):t.isVideoTexture?this.backend.get(t).externalTexture=this._getDefaultVideoFrame():e=this._getDefaultTextureGPU(i),this.backend.get(t).texture=e}createTexture(t,e={}){const i=this.backend,n=i.get(t);if(n.initialized)throw new Error("WebGPUTextureUtils: Texture already initialized.");void 0===e.needsMipmaps&&(e.needsMipmaps=!1),void 0===e.levels&&(e.levels=1),void 0===e.depth&&(e.depth=1);const{width:s,height:r,depth:a,levels:o}=e;t.isFramebufferTexture&&(e.renderTarget?e.format=this.backend.utils.getCurrentColorFormat(e.renderTarget):e.format=this.backend.utils.getPreferredCanvasFormat());const l=this._getDimension(t),h=t.internalFormat||e.format||cF(t,i.device);n.format=h;let c=void 0!==e.sampleCount?e.sampleCount:1;c=i.utils.getSampleCount(c);const u=t.isRenderTargetTexture&&!t.isMultisampleRenderTargetTexture?1:c;let d=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC;!0===t.isStorageTexture&&(d|=GPUTextureUsage.STORAGE_BINDING),!0!==t.isCompressedTexture&&!0!==t.isCompressedArrayTexture&&(d|=GPUTextureUsage.RENDER_ATTACHMENT);const p={label:t.name,size:{width:s,height:r,depthOrArrayLayers:a},mipLevelCount:o,sampleCount:u,dimension:l,format:h,usage:d};if(t.isVideoTexture){const e=t.source.data,i=new VideoFrame(e);p.size.width=i.displayWidth,p.size.height=i.displayHeight,i.close(),n.externalTexture=e}else{if(void 0===h)return this.createDefaultTexture(t);n.texture=i.device.createTexture(p)}if(t.isRenderTargetTexture&&c>1&&!t.isMultisampleRenderTargetTexture){const t=Object.assign({},p);t.label=t.label+"-msaa",t.sampleCount=c,n.msaaTexture=i.device.createTexture(t)}n.initialized=!0,n.textureDescriptorGPU=p}destroyTexture(t){const e=this.backend,i=e.get(t);i.texture.destroy(),void 0!==i.msaaTexture&&i.msaaTexture.destroy(),e.delete(t)}destroySampler(t){delete this.backend.get(t).sampler}generateMipmaps(t){const e=this.backend.get(t);if(t.isCubeTexture)for(let i=0;i<6;i++)this._generateMipmaps(e.texture,e.textureDescriptorGPU,i);else{const i=t.image.depth||1;for(let t=0;t<i;t++)this._generateMipmaps(e.texture,e.textureDescriptorGPU,t)}}getColorBuffer(){this.colorBuffer&&this.colorBuffer.destroy();const t=this.backend,{width:e,height:i}=t.getDrawingBufferSize();return this.colorBuffer=t.device.createTexture({label:"colorBuffer",size:{width:e,height:i,depthOrArrayLayers:1},sampleCount:t.utils.getSampleCount(t.renderer.samples),format:t.utils.getPreferredCanvasFormat(),usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC}),this.colorBuffer}getDepthBuffer(t=!0,e=!1){const i=this.backend,{width:n,height:s}=i.getDrawingBufferSize(),r=this.depthTexture,a=i.get(r).texture;let o,l;if(e?(o=Cf,l=Tf):t&&(o=Ef,l=bf),void 0!==a){if(r.image.width===n&&r.image.height===s&&r.format===o&&r.type===l)return a;this.destroyTexture(r)}return r.name="depthBuffer",r.format=o,r.type=l,r.image.width=n,r.image.height=s,this.createTexture(r,{sampleCount:i.utils.getSampleCount(i.renderer.samples),width:n,height:s}),i.get(r).texture}updateTexture(t,e){const i=this.backend.get(t),{textureDescriptorGPU:n}=i;if(!t.isRenderTargetTexture&&void 0!==n){if(t.isDataTexture)this._copyBufferToTexture(e.image,i.texture,n,0,t.flipY);else if(t.isDataArrayTexture||t.isData3DTexture)for(let s=0;s<e.image.depth;s++)this._copyBufferToTexture(e.image,i.texture,n,s,t.flipY,s);else if(t.isCompressedTexture||t.isCompressedArrayTexture)this._copyCompressedBufferToTexture(t.mipmaps,i.texture,n);else if(t.isCubeTexture)this._copyCubeMapToTexture(e.images,i.texture,n,t.flipY);else if(t.isVideoTexture){const e=t.source.data;i.externalTexture=e}else this._copyImageToTexture(e.image,i.texture,n,0,t.flipY);i.version=t.version,t.onUpdate&&t.onUpdate(t)}}async copyTextureToBuffer(t,e,i,n,s,r){const a=this.backend.device,o=this.backend.get(t),l=o.texture,h=o.textureDescriptorGPU.format,c=this._getBytesPerTexel(h);let u=n*c;u=256*Math.ceil(u/256);const d=a.createBuffer({size:n*s*c,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),p=a.createCommandEncoder();p.copyTextureToBuffer({texture:l,origin:{x:e,y:i,z:r}},{buffer:d,bytesPerRow:u},{width:n,height:s});const m=this._getTypedArrayType(h);a.queue.submit([p.finish()]),await d.mapAsync(GPUMapMode.READ);return new m(d.getMappedRange())}_isEnvironmentTexture(t){const e=t.mapping;return e===rf||e===af||e===nf||e===sf}_getDefaultTextureGPU(t){let e=this.defaultTexture[t];if(void 0===e){const i=new Zg;i.minFilter=cf,i.magFilter=cf,this.createTexture(i,{width:1,height:1,format:t}),this.defaultTexture[t]=e=i}return this.backend.get(e).texture}_getDefaultCubeTextureGPU(t){let e=this.defaultTexture[t];if(void 0===e){const i=new x_;i.minFilter=cf,i.magFilter=cf,this.createTexture(i,{width:1,height:1,depth:6}),this.defaultCubeTexture[t]=e=i}return this.backend.get(e).texture}_getDefaultVideoFrame(){let t=this.defaultVideoFrame;if(null===t){const e={timestamp:0,codedWidth:1,codedHeight:1,format:"RGBA"};this.defaultVideoFrame=t=new VideoFrame(new Uint8Array([0,0,0,255]),e)}return t}_copyCubeMapToTexture(t,e,i,n){for(let s=0;s<6;s++){const r=t[s],a=!0===n?lF[s]:s;r.isDataTexture?this._copyBufferToTexture(r.image,e,i,a,n):this._copyImageToTexture(r,e,i,a,n)}}_copyImageToTexture(t,e,i,n,s){this.backend.device.queue.copyExternalImageToTexture({source:t},{texture:e,mipLevel:0,origin:{x:0,y:0,z:n}},{width:t.width,height:t.height,depthOrArrayLayers:1}),!0===s&&this._flipY(e,i,n)}_getPassUtils(){let t=this._passUtils;return null===t&&(this._passUtils=t=new aF(this.backend.device)),t}_generateMipmaps(t,e,i=0){this._getPassUtils().generateMipmaps(t,e,i)}_flipY(t,e,i=0){this._getPassUtils().flipY(t,e,i)}_copyBufferToTexture(t,e,i,n,s,r=0){const a=this.backend.device,o=t.data,l=this._getBytesPerTexel(i.format),h=t.width*l;a.queue.writeTexture({texture:e,mipLevel:0,origin:{x:0,y:0,z:n}},o,{offset:t.width*t.height*l*r,bytesPerRow:h},{width:t.width,height:t.height,depthOrArrayLayers:1}),!0===s&&this._flipY(e,i,n)}_copyCompressedBufferToTexture(t,e,i){const n=this.backend.device,s=this._getBlockData(i.format),r=i.size.depthOrArrayLayers>1;for(let a=0;a<t.length;a++){const o=t[a],l=o.width,h=o.height,c=r?i.size.depthOrArrayLayers:1,u=Math.ceil(l/s.width)*s.byteLength,d=u*Math.ceil(h/s.height);for(let t=0;t<c;t++)n.queue.writeTexture({texture:e,mipLevel:a,origin:{x:0,y:0,z:t}},o.data,{offset:t*d,bytesPerRow:u,rowsPerImage:Math.ceil(h/s.height)},{width:Math.ceil(l/s.width)*s.width,height:Math.ceil(h/s.height)*s.height,depthOrArrayLayers:1})}}_getBlockData(t){return t===$P.BC1RGBAUnorm||t===$P.BC1RGBAUnormSRGB?{byteLength:8,width:4,height:4}:t===$P.BC2RGBAUnorm||t===$P.BC2RGBAUnormSRGB||t===$P.BC3RGBAUnorm||t===$P.BC3RGBAUnormSRGB?{byteLength:16,width:4,height:4}:t===$P.BC4RUnorm||t===$P.BC4RSNorm?{byteLength:8,width:4,height:4}:t===$P.BC5RGUnorm||t===$P.BC5RGSnorm||t===$P.BC6HRGBUFloat||t===$P.BC6HRGBFloat||t===$P.BC7RGBAUnorm||t===$P.BC7RGBAUnormSRGB?{byteLength:16,width:4,height:4}:t===$P.ETC2RGB8Unorm||t===$P.ETC2RGB8UnormSRGB||t===$P.ETC2RGB8A1Unorm||t===$P.ETC2RGB8A1UnormSRGB?{byteLength:8,width:4,height:4}:t===$P.ETC2RGBA8Unorm||t===$P.ETC2RGBA8UnormSRGB?{byteLength:16,width:4,height:4}:t===$P.EACR11Unorm||t===$P.EACR11Snorm?{byteLength:8,width:4,height:4}:t===$P.EACRG11Unorm||t===$P.EACRG11Snorm||t===$P.ASTC4x4Unorm||t===$P.ASTC4x4UnormSRGB?{byteLength:16,width:4,height:4}:t===$P.ASTC5x4Unorm||t===$P.ASTC5x4UnormSRGB?{byteLength:16,width:5,height:4}:t===$P.ASTC5x5Unorm||t===$P.ASTC5x5UnormSRGB?{byteLength:16,width:5,height:5}:t===$P.ASTC6x5Unorm||t===$P.ASTC6x5UnormSRGB?{byteLength:16,width:6,height:5}:t===$P.ASTC6x6Unorm||t===$P.ASTC6x6UnormSRGB?{byteLength:16,width:6,height:6}:t===$P.ASTC8x5Unorm||t===$P.ASTC8x5UnormSRGB?{byteLength:16,width:8,height:5}:t===$P.ASTC8x6Unorm||t===$P.ASTC8x6UnormSRGB?{byteLength:16,width:8,height:6}:t===$P.ASTC8x8Unorm||t===$P.ASTC8x8UnormSRGB?{byteLength:16,width:8,height:8}:t===$P.ASTC10x5Unorm||t===$P.ASTC10x5UnormSRGB?{byteLength:16,width:10,height:5}:t===$P.ASTC10x6Unorm||t===$P.ASTC10x6UnormSRGB?{byteLength:16,width:10,height:6}:t===$P.ASTC10x8Unorm||t===$P.ASTC10x8UnormSRGB?{byteLength:16,width:10,height:8}:t===$P.ASTC10x10Unorm||t===$P.ASTC10x10UnormSRGB?{byteLength:16,width:10,height:10}:t===$P.ASTC12x10Unorm||t===$P.ASTC12x10UnormSRGB?{byteLength:16,width:12,height:10}:t===$P.ASTC12x12Unorm||t===$P.ASTC12x12UnormSRGB?{byteLength:16,width:12,height:12}:void 0}_convertAddressMode(t){let e=YP;return t===of?e=ZP:t===hf&&(e=KP),e}_convertFilterMode(t){let e=JP;return t!==cf&&t!==uf&&t!==df||(e=QP),e}_getBytesPerTexel(t){return t===$P.R8Unorm||t===$P.R8Snorm||t===$P.R8Uint||t===$P.R8Sint?1:t===$P.R16Uint||t===$P.R16Sint||t===$P.R16Float||t===$P.RG8Unorm||t===$P.RG8Snorm||t===$P.RG8Uint||t===$P.RG8Sint?2:t===$P.R32Uint||t===$P.R32Sint||t===$P.R32Float||t===$P.RG16Uint||t===$P.RG16Sint||t===$P.RG16Float||t===$P.RGBA8Unorm||t===$P.RGBA8UnormSRGB||t===$P.RGBA8Snorm||t===$P.RGBA8Uint||t===$P.RGBA8Sint||t===$P.BGRA8Unorm||t===$P.BGRA8UnormSRGB||t===$P.RGB9E5UFloat||t===$P.RGB10A2Unorm||t===$P.RG11B10UFloat||t===$P.Depth32Float||t===$P.Depth24Plus||t===$P.Depth24PlusStencil8||t===$P.Depth32FloatStencil8?4:t===$P.RG32Uint||t===$P.RG32Sint||t===$P.RG32Float||t===$P.RGBA16Uint||t===$P.RGBA16Sint||t===$P.RGBA16Float?8:t===$P.RGBA32Uint||t===$P.RGBA32Sint||t===$P.RGBA32Float?16:void 0}_getTypedArrayType(t){return t===$P.R8Uint?Uint8Array:t===$P.R8Sint?Int8Array:t===$P.R8Unorm?Uint8Array:t===$P.R8Snorm?Int8Array:t===$P.RG8Uint?Uint8Array:t===$P.RG8Sint?Int8Array:t===$P.RG8Unorm?Uint8Array:t===$P.RG8Snorm?Int8Array:t===$P.RGBA8Uint?Uint8Array:t===$P.RGBA8Sint?Int8Array:t===$P.RGBA8Unorm?Uint8Array:t===$P.RGBA8Snorm?Int8Array:t===$P.R16Uint?Uint16Array:t===$P.R16Sint?Int16Array:t===$P.RG16Uint?Uint16Array:t===$P.RG16Sint?Int16Array:t===$P.RGBA16Uint?Uint16Array:t===$P.RGBA16Sint?Int16Array:t===$P.R16Float||t===$P.RG16Float||t===$P.RGBA16Float?Uint16Array:t===$P.R32Uint?Uint32Array:t===$P.R32Sint?Int32Array:t===$P.R32Float?Float32Array:t===$P.RG32Uint?Uint32Array:t===$P.RG32Sint?Int32Array:t===$P.RG32Float?Float32Array:t===$P.RGBA32Uint?Uint32Array:t===$P.RGBA32Sint?Int32Array:t===$P.RGBA32Float?Float32Array:t===$P.BGRA8Unorm||t===$P.BGRA8UnormSRGB?Uint8Array:t===$P.RGB10A2Unorm||t===$P.RGB9E5UFloat||t===$P.RG11B10UFloat?Uint32Array:t===$P.Depth32Float?Float32Array:t===$P.Depth24Plus||t===$P.Depth24PlusStencil8?Uint32Array:t===$P.Depth32FloatStencil8?Float32Array:void 0}_getDimension(t){let e;return e=t.isData3DTexture?OI:BI,e}}function cF(t,e=null){const i=t.format,n=t.type,s=t.colorSpace;let r;if(!0===t.isCompressedTexture||!0===t.isCompressedArrayTexture)switch(i){case Uf:r=s===ig?$P.BC1RGBAUnormSRGB:$P.BC1RGBAUnorm;break;case Ff:r=s===ig?$P.BC2RGBAUnormSRGB:$P.BC2RGBAUnorm;break;case Bf:r=s===ig?$P.BC3RGBAUnormSRGB:$P.BC3RGBAUnorm;break;case Of:r=s===ig?$P.ETC2RGB8UnormSRGB:$P.ETC2RGB8Unorm;break;case zf:r=s===ig?$P.ETC2RGBA8UnormSRGB:$P.ETC2RGBA8Unorm;break;case kf:r=s===ig?$P.ASTC4x4UnormSRGB:$P.ASTC4x4Unorm;break;case Vf:r=s===ig?$P.ASTC5x4UnormSRGB:$P.ASTC5x4Unorm;break;case Gf:r=s===ig?$P.ASTC5x5UnormSRGB:$P.ASTC5x5Unorm;break;case Hf:r=s===ig?$P.ASTC6x5UnormSRGB:$P.ASTC6x5Unorm;break;case Wf:r=s===ig?$P.ASTC6x6UnormSRGB:$P.ASTC6x6Unorm;break;case jf:r=s===ig?$P.ASTC8x5UnormSRGB:$P.ASTC8x5Unorm;break;case Xf:r=s===ig?$P.ASTC8x6UnormSRGB:$P.ASTC8x6Unorm;break;case qf:r=s===ig?$P.ASTC8x8UnormSRGB:$P.ASTC8x8Unorm;break;case $f:r=s===ig?$P.ASTC10x5UnormSRGB:$P.ASTC10x5Unorm;break;case Yf:r=s===ig?$P.ASTC10x6UnormSRGB:$P.ASTC10x6Unorm;break;case Zf:r=s===ig?$P.ASTC10x8UnormSRGB:$P.ASTC10x8Unorm;break;case Kf:r=s===ig?$P.ASTC10x10UnormSRGB:$P.ASTC10x10Unorm;break;case Jf:r=s===ig?$P.ASTC12x10UnormSRGB:$P.ASTC12x10Unorm;break;case Qf:r=s===ig?$P.ASTC12x12UnormSRGB:$P.ASTC12x12Unorm}else switch(i){case Af:switch(n){case xf:r=$P.RGBA8Snorm;break;case vf:r=$P.RGBA16Sint;break;case _f:r=$P.RGBA16Uint;break;case bf:r=$P.RGBA32Uint;break;case yf:r=$P.RGBA32Sint;break;case gf:r=s===ig?$P.RGBA8UnormSRGB:$P.RGBA8Unorm;break;case Mf:r=$P.RGBA16Float;break;case Sf:r=$P.RGBA32Float}break;case wf:if(35902===n)r=$P.RGB9E5UFloat;break;case Rf:switch(n){case xf:r=$P.R8Snorm;break;case vf:r=$P.R16Sint;break;case _f:r=$P.R16Uint;break;case bf:r=$P.R32Uint;break;case yf:r=$P.R32Sint;break;case gf:r=$P.R8Unorm;break;case Mf:r=$P.R16Float;break;case Sf:r=$P.R32Float}break;case Pf:switch(n){case xf:r=$P.RG8Snorm;break;case vf:r=$P.RG16Sint;break;case _f:r=$P.RG16Uint;break;case bf:r=$P.RG32Uint;break;case yf:r=$P.RG32Sint;break;case gf:r=$P.RG8Unorm;break;case Mf:r=$P.RG16Float;break;case Sf:r=$P.RG32Float}break;case Ef:switch(n){case _f:r=$P.Depth16Unorm;break;case bf:r=$P.Depth24Plus;break;case Sf:r=$P.Depth32Float}break;case Cf:switch(n){case Tf:r=$P.Depth24PlusStencil8;break;case Sf:e&&e.features.has(XI.Depth32FloatStencil8),r=$P.Depth32FloatStencil8}break;case Nf:switch(n){case yf:r=$P.R32Sint;break;case bf:r=$P.R32Uint}break;case If:switch(n){case yf:r=$P.RG32Sint;break;case bf:r=$P.RG32Uint}break;case Lf:switch(n){case yf:r=$P.RGBA32Sint;break;case bf:r=$P.RGBA32Uint}}return r}const uF=/^[fn]*\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)\s*[\-\>]*\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/i,dF=/([a-z_0-9]+)\s*:\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/gi,pF={f32:"float",i32:"int",u32:"uint",bool:"bool","vec2<f32>":"vec2","vec2<i32>":"ivec2","vec2<u32>":"uvec2","vec2<bool>":"bvec2",vec2f:"vec2",vec2i:"ivec2",vec2u:"uvec2",vec2b:"bvec2","vec3<f32>":"vec3","vec3<i32>":"ivec3","vec3<u32>":"uvec3","vec3<bool>":"bvec3",vec3f:"vec3",vec3i:"ivec3",vec3u:"uvec3",vec3b:"bvec3","vec4<f32>":"vec4","vec4<i32>":"ivec4","vec4<u32>":"uvec4","vec4<bool>":"bvec4",vec4f:"vec4",vec4i:"ivec4",vec4u:"uvec4",vec4b:"bvec4","mat2x2<f32>":"mat2",mat2x2f:"mat2","mat3x3<f32>":"mat3",mat3x3f:"mat3","mat4x4<f32>":"mat4",mat4x4f:"mat4",sampler:"sampler",texture_1d:"texture",texture_2d:"texture",texture_2d_array:"texture",texture_multisampled_2d:"cubeTexture",texture_depth_2d:"depthTexture",texture_3d:"texture3D",texture_cube:"cubeTexture",texture_cube_array:"cubeTexture",texture_storage_1d:"storageTexture",texture_storage_2d:"storageTexture",texture_storage_2d_array:"storageTexture",texture_storage_3d:"storageTexture"};class mF extends YD{constructor(t){const{type:e,inputs:i,name:n,inputsCode:s,blockCode:r,outputType:a}=(t=>{const e=(t=t.trim()).match(uF);if(null!==e&&4===e.length){const i=e[2],n=[];let s=null;for(;null!==(s=dF.exec(i));)n.push({name:s[1],type:s[2]});const r=[];for(let t=0;t<n.length;t++){const{name:e,type:i}=n[t];let s=i;s.startsWith("ptr")?s="pointer":(s.startsWith("texture")&&(s=i.split("<")[0]),s=pF[s]),r.push(new BD(s,e))}const a=t.substring(e[0].length),o=e[3]||"void",l=void 0!==e[1]?e[1]:"";return{type:pF[o]||o,inputs:r,name:l,inputsCode:i,blockCode:a,outputType:o}}throw new Error("FunctionNode: Function is not a WGSL code.")})(t);super(e,i,n),this.inputsCode=s,this.blockCode=r,this.outputType=a}getCode(t=this.name){const e="void"!==this.outputType?"-> "+this.outputType:"";return`fn ${t} ( ${this.inputsCode.trim()} ) ${e}`+this.blockCode}}class fF extends $D{parseFunction(t){return new mF(t)}}const gF=self.GPUShaderStage,xF={vertex:gF?gF.VERTEX:1,fragment:gF?gF.FRAGMENT:2,compute:gF?gF.COMPUTE:4},vF={instance:!0,swizzleAssign:!1,storageBuffer:!0},_F={"^^":"tsl_xor"},yF={float:"f32",int:"i32",uint:"u32",bool:"bool",color:"vec3<f32>",vec2:"vec2<f32>",ivec2:"vec2<i32>",uvec2:"vec2<u32>",bvec2:"vec2<bool>",vec3:"vec3<f32>",ivec3:"vec3<i32>",uvec3:"vec3<u32>",bvec3:"vec3<bool>",vec4:"vec4<f32>",ivec4:"vec4<i32>",uvec4:"vec4<u32>",bvec4:"vec4<bool>",mat2:"mat2x2<f32>",mat3:"mat3x3<f32>",mat4:"mat4x4<f32>"},bF={tsl_xor:new oL("fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }"),mod_float:new oL("fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }"),mod_vec2:new oL("fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }"),mod_vec3:new oL("fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }"),mod_vec4:new oL("fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }"),equals_bool:new oL("fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }"),equals_bvec2:new oL("fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }"),equals_bvec3:new oL("fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }"),equals_bvec4:new oL("fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }"),repeatWrapping:new oL("\nfn tsl_repeatWrapping( uv : vec2<f32>, dimension : vec2<u32> ) -> vec2<u32> {\n\n\tlet uvScaled = vec2<u32>( uv * vec2<f32>( dimension ) );\n\n\treturn ( ( uvScaled % dimension ) + dimension ) % dimension;\n\n}\n"),biquadraticTexture:new oL("\nfn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, level : i32 ) -> vec4f {\n\n\tlet iRes = vec2i( textureDimensions( map, level ) );\n\tlet res = vec2f( iRes );\n\n\tlet uvScaled = coord * res;\n\tlet uvWrapping = ( ( uvScaled % res ) + res ) % res;\n\n\t// https://www.shadertoy.com/view/WtyXRy\n\n\tlet uv = uvWrapping - 0.5;\n\tlet iuv = floor( uv );\n\tlet f = fract( uv );\n\n\tlet rg1 = textureLoad( map, vec2i( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );\n\tlet rg2 = textureLoad( map, vec2i( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );\n\tlet rg3 = textureLoad( map, vec2i( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );\n\tlet rg4 = textureLoad( map, vec2i( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );\n\n\treturn mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );\n\n}\n")},SF={dFdx:"dpdx",dFdy:"- dpdy",mod_float:"tsl_mod_float",mod_vec2:"tsl_mod_vec2",mod_vec3:"tsl_mod_vec3",mod_vec4:"tsl_mod_vec4",equals_bool:"tsl_equals_bool",equals_bvec2:"tsl_equals_bvec2",equals_bvec3:"tsl_equals_bvec3",equals_bvec4:"tsl_equals_bvec4",inversesqrt:"inverseSqrt",bitcast:"bitcast<f32>"};/Windows/g.test(navigator.userAgent)&&(bF.pow_float=new oL("fn tsl_pow_float( a : f32, b : f32 ) -> f32 { return select( -pow( -a, b ), pow( a, b ), a > 0.0 ); }"),bF.pow_vec2=new oL("fn tsl_pow_vec2( a : vec2f, b : vec2f ) -> vec2f { return vec2f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ) ); }",[bF.pow_float]),bF.pow_vec3=new oL("fn tsl_pow_vec3( a : vec3f, b : vec3f ) -> vec3f { return vec3f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ) ); }",[bF.pow_float]),bF.pow_vec4=new oL("fn tsl_pow_vec4( a : vec4f, b : vec4f ) -> vec4f { return vec4f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ), tsl_pow_float( a.w, b.w ) ); }",[bF.pow_float]),SF.pow_float="tsl_pow_float",SF.pow_vec2="tsl_pow_vec2",SF.pow_vec3="tsl_pow_vec3",SF.pow_vec4="tsl_pow_vec4");let MF="";!0!==/Firefox|Deno/g.test(navigator.userAgent)&&(MF+="diagnostic( off, derivative_uniformity );\n");class TF extends UD{constructor(t,e){super(t,e,new fF),this.uniformGroups={},this.builtins={},this.directives={},this.scopedArrays=new Map}needsToWorkingColorSpace(t){return!0===t.isVideoTexture&&t.colorSpace!==eg}_generateTextureSample(t,e,i,n,s=this.shaderStage){return"fragment"===s?n?`textureSample( ${e}, ${e}_sampler, ${i}, ${n} )`:`textureSample( ${e}, ${e}_sampler, ${i} )`:this.isFilteredTexture(t)?this.generateFilteredTexture(t,e,i):this.generateTextureLod(t,e,i,"0")}_generateVideoSample(t,e,i=this.shaderStage){if("fragment"===i)return`textureSampleBaseClampToEdge( ${t}, ${t}_sampler, vec2<f32>( ${e}.x, 1.0 - ${e}.y ) )`}_generateTextureSampleLevel(t,e,i,n,s,r=this.shaderStage){return"fragment"===r&&!1===this.isUnfilterable(t)?`textureSampleLevel( ${e}, ${e}_sampler, ${i}, ${n} )`:this.isFilteredTexture(t)?this.generateFilteredTexture(t,e,i,n):this.generateTextureLod(t,e,i,n)}generateFilteredTexture(t,e,i,n="0"){return this._include("biquadraticTexture"),`tsl_biquadraticTexture( ${e}, ${i}, i32( ${n} ) )`}generateTextureLod(t,e,i,n="0"){this._include("repeatWrapping");return`textureLoad( ${e}, tsl_repeatWrapping( ${i}, ${!0===t.isMultisampleRenderTargetTexture?`textureDimensions( ${e} )`:`textureDimensions( ${e}, 0 )`} ), i32( ${n} ) )`}generateTextureLoad(t,e,i,n,s="0u"){return n?`textureLoad( ${e}, ${i}, ${n}, ${s} )`:`textureLoad( ${e}, ${i}, ${s} )`}generateTextureStore(t,e,i,n){return`textureStore( ${e}, ${i}, ${n} )`}isUnfilterable(t){return"float"!==this.getComponentTypeFromTexture(t)||!this.isAvailable("float32Filterable")&&!0===t.isDataTexture&&t.type===Sf||!0===t.isMultisampleRenderTargetTexture}generateTexture(t,e,i,n,s=this.shaderStage){let r=null;return r=!0===t.isVideoTexture?this._generateVideoSample(e,i,s):this.isUnfilterable(t)?this.generateTextureLod(t,e,i,"0",n,s):this._generateTextureSample(t,e,i,n,s),r}generateTextureGrad(t,e,i,n,s,r=this.shaderStage){if("fragment"===r)return`textureSampleGrad( ${e}, ${e}_sampler, ${i},  ${n[0]}, ${n[1]} )`}generateTextureCompare(t,e,i,n,s,r=this.shaderStage){if("fragment"===r)return`textureSampleCompare( ${e}, ${e}_sampler, ${i}, ${n} )`}generateTextureLevel(t,e,i,n,s,r=this.shaderStage){let a=null;return a=!0===t.isVideoTexture?this._generateVideoSample(e,i,r):this._generateTextureSampleLevel(t,e,i,n,s,r),a}generateTextureBias(t,e,i,n,s,r=this.shaderStage){if("fragment"===r)return`textureSampleBias( ${e}, ${e}_sampler, ${i}, ${n} )`}getPropertyName(t,e=this.shaderStage){if(!0===t.isNodeVarying&&!0===t.needsInterpolation){if("vertex"===e)return`varyings.${t.name}`}else if(!0===t.isNodeUniform){const e=t.name,i=t.type;return"texture"===i||"cubeTexture"===i||"storageTexture"===i||"texture3D"===i?e:"buffer"===i||"storageBuffer"===i||"indirectStorageBuffer"===i?`NodeBuffer_${t.id}.${e}`:t.groupNode.name+"."+e}return super.getPropertyName(t)}getOutputStructName(){return"output"}_getUniformGroupCount(t){return Object.keys(this.uniforms[t]).length}getFunctionOperator(t){const e=_F[t];return void 0!==e?(this._include(e),e):null}getStorageAccess(t){if(t.isStorageTextureNode)switch(t.access){case PI:return"read";case NI:return"write";default:return"read_write"}else switch(t.access){case CI:return"read_write";case RI:return"read";default:return"write"}}getUniformFromNode(t,e,i,n=null){const s=super.getUniformFromNode(t,e,i,n),r=this.getDataFromNode(t,i,this.globalCache);if(void 0===r.uniformGPU){let n;const a=t.groupNode,o=a.name,l=this.getBindGroupArray(o,i);if("texture"===e||"cubeTexture"===e||"storageTexture"===e||"texture3D"===e){let r=null;if("texture"===e||"storageTexture"===e?r=new wU(s.name,s.node,a,t.access?t.access:null):"cubeTexture"===e?r=new AU(s.name,s.node,a,t.access?t.access:null):"texture3D"===e&&(r=new EU(s.name,s.node,a,t.access?t.access:null)),r.store=!0===t.isStorageTextureNode,r.setVisibility(xF[i]),"fragment"===i&&!1===this.isUnfilterable(t.value)&&!1===r.store){const t=new iF(`${s.name}_sampler`,s.node,a);t.setVisibility(xF[i]),l.push(t,r),n=[t,r]}else l.push(r),n=[r]}else if("buffer"===e||"storageBuffer"===e||"indirectStorageBuffer"===e){const s=new("buffer"===e?_U:rF)(t,a);s.setVisibility(xF[i]),l.push(s),n=s}else{const t=this.uniformGroups[i]||(this.uniformGroups[i]={});let r=t[o];void 0===r&&(r=new SU(o,a),r.setVisibility(xF[i]),t[o]=r,l.push(r)),n=this.getNodeUniform(s,e),r.addUniform(n)}r.uniformGPU=n}return s}getBuiltin(t,e,i,n=this.shaderStage){const s=this.builtins[n]||(this.builtins[n]=new Map);return!1===s.has(t)&&s.set(t,{name:t,property:e,type:i}),e}hasBuiltin(t,e=this.shaderStage){return void 0!==this.builtins[e]&&this.builtins[e].has(t)}getVertexIndex(){return"vertex"===this.shaderStage?this.getBuiltin("vertex_index","vertexIndex","u32","attribute"):"vertexIndex"}buildFunctionCode(t){const e=t.layout,i=this.flowShaderNode(t),n=[];for(const r of e.inputs)n.push(r.name+" : "+this.getType(r.type));let s=`fn ${e.name}( ${n.join(", ")} ) -> ${this.getType(e.type)} {\n${i.vars}\n${i.code}\n`;return i.result&&(s+=`\treturn ${i.result};\n`),s+="\n}\n",s}getInstanceIndex(){return"vertex"===this.shaderStage?this.getBuiltin("instance_index","instanceIndex","u32","attribute"):"instanceIndex"}getInvocationLocalIndex(){return this.getBuiltin("local_invocation_index","invocationLocalIndex","u32","attribute")}getSubgroupSize(){return this.enableSubGroups(),this.getBuiltin("subgroup_size","subgroupSize","u32","attribute")}getInvocationSubgroupIndex(){return this.enableSubGroups(),this.getBuiltin("subgroup_invocation_id","invocationSubgroupIndex","u32","attribute")}getSubgroupIndex(){return this.enableSubGroups(),this.getBuiltin("subgroup_id","subgroupIndex","u32","attribute")}getDrawIndex(){return null}getFrontFacing(){return this.getBuiltin("front_facing","isFront","bool")}getFragCoord(){return this.getBuiltin("position","fragCoord","vec4<f32>")+".xy"}getFragDepth(){return"output."+this.getBuiltin("frag_depth","depth","f32","output")}isFlipY(){return!1}enableDirective(t,e=this.shaderStage){(this.directives[e]||(this.directives[e]=new Set)).add(t)}getDirectives(t){const e=[],i=this.directives[t];if(void 0!==i)for(const n of i)e.push(`enable ${n};`);return e.join("\n")}enableSubGroups(){this.enableDirective("subgroups")}enableSubgroupsF16(){this.enableDirective("subgroups-f16")}enableClipDistances(){this.enableDirective("clip_distances")}enableShaderF16(){this.enableDirective("f16")}enableDualSourceBlending(){this.enableDirective("dual_source_blending")}getBuiltins(t){const e=[],i=this.builtins[t];if(void 0!==i)for(const{name:n,property:s,type:r}of i.values())e.push(`@builtin( ${n} ) ${s} : ${r}`);return e.join(",\n\t")}getScopedArray(t,e,i,n){return!1===this.scopedArrays.has(t)&&this.scopedArrays.set(t,{name:t,scope:e,bufferType:i,bufferCount:n}),t}getScopedArrays(t){if("compute"!==t)return;const e=[];for(const{name:i,scope:n,bufferType:s,bufferCount:r}of this.scopedArrays.values()){const t=this.getType(s);e.push(`var<${n}> ${i}: array< ${t}, ${r} >;`)}return e.join("\n")}getAttributes(t){const e=[];if("compute"===t&&(this.getBuiltin("global_invocation_id","id","vec3<u32>","attribute"),this.getBuiltin("workgroup_id","workgroupId","vec3<u32>","attribute"),this.getBuiltin("local_invocation_id","localId","vec3<u32>","attribute"),this.getBuiltin("num_workgroups","numWorkgroups","vec3<u32>","attribute"),this.renderer.hasFeature("subgroups")&&(this.enableDirective("subgroups",t),this.getBuiltin("subgroup_size","subgroupSize","u32","attribute"))),"vertex"===t||"compute"===t){const t=this.getBuiltins("attribute");t&&e.push(t);const i=this.getAttributesArray();for(let n=0,s=i.length;n<s;n++){const t=i[n],s=t.name,r=this.getType(t.type);e.push(`@location( ${n} ) ${s} : ${r}`)}}return e.join(",\n\t")}getStructMembers(t){const e=[],i=t.getMemberTypes();for(let s=0;s<i.length;s++){const t=i[s];e.push(`\t@location( ${s} ) m${s} : ${t}<f32>`)}const n=this.getBuiltins("output");return n&&e.push("\t"+n),e.join(",\n")}getStructs(t){const e=[],i=this.structs[t];for(let n=0,s=i.length;n<s;n++){const t=i[n],s=t.name;let r=`struct ${s} {\n`;r+=this.getStructMembers(t),r+="\n}",e.push(r),e.push(`\nvar<private> output : ${s};\n\n`)}return e.join("\n\n")}getVar(t,e){return`var ${e} : ${this.getType(t)}`}getVars(t){const e=[],i=this.vars[t];if(void 0!==i)for(const n of i)e.push(`\t${this.getVar(n.type,n.name)};`);return`\n${e.join("\n")}\n`}getVaryings(t){const e=[];if("vertex"===t&&this.getBuiltin("position","Vertex","vec4<f32>","vertex"),"vertex"===t||"fragment"===t){const i=this.varyings,n=this.vars[t];for(let s=0;s<i.length;s++){const r=i[s];if(r.needsInterpolation){let t=`@location( ${s} )`;/^(int|uint|ivec|uvec)/.test(r.type)&&(t+=" @interpolate( flat )"),e.push(`${t} ${r.name} : ${this.getType(r.type)}`)}else"vertex"===t&&!1===n.includes(r)&&n.push(r)}}const i=this.getBuiltins(t);i&&e.push(i);const n=e.join(",\n\t");return"vertex"===t?this._getWGSLStruct("VaryingsStruct","\t"+n):n}getUniforms(t){const e=this.uniforms[t],i=[],n=[],s=[],r={};for(const o of e){const e=o.groupNode.name,s=this.bindingsIndexes[e];if("texture"===o.type||"cubeTexture"===o.type||"storageTexture"===o.type||"texture3D"===o.type){const e=o.node.value;let n;"fragment"===t&&!1===this.isUnfilterable(e)&&!0!==o.node.isStorageTextureNode&&(!0===e.isDepthTexture&&null!==e.compareFunction?i.push(`@binding( ${s.binding++} ) @group( ${s.group} ) var ${o.name}_sampler : sampler_comparison;`):i.push(`@binding( ${s.binding++} ) @group( ${s.group} ) var ${o.name}_sampler : sampler;`));let r="";if(!0===e.isMultisampleRenderTargetTexture&&(r="_multisampled"),!0===e.isCubeTexture)n="texture_cube<f32>";else if(!0===e.isDataArrayTexture||!0===e.isCompressedArrayTexture)n="texture_2d_array<f32>";else if(!0===e.isDepthTexture)n=`texture_depth${r}_2d`;else if(!0===e.isVideoTexture)n="texture_external";else if(!0===e.isData3DTexture)n="texture_3d<f32>";else if(!0===o.node.isStorageTextureNode){n=`texture_storage_2d<${cF(e)}, ${this.getStorageAccess(o.node)}>`}else{n=`texture${r}_2d<${this.getComponentTypeFromTexture(e).charAt(0)}32>`}i.push(`@binding( ${s.binding++} ) @group( ${s.group} ) var ${o.name} : ${n};`)}else if("buffer"===o.type||"storageBuffer"===o.type||"indirectStorageBuffer"===o.type){const t=o.node,e=this.getType(t.bufferType),i=t.bufferCount,r=i>0&&"buffer"===o.type?", "+i:"",a=t.isAtomic?`atomic<${e}>`:`${e}`,l=`\t${o.name} : array< ${a}${r} >\n`,h=t.isStorageBufferNode?`storage, ${this.getStorageAccess(t)}`:"uniform";n.push(this._getWGSLStructBinding("NodeBuffer_"+t.id,l,h,s.binding++,s.group))}else{const t=this.getType(this.getVectorType(o.type)),e=o.groupNode.name;(r[e]||(r[e]={index:s.binding++,id:s.group,snippets:[]})).snippets.push(`\t${o.name} : ${t}`)}}for(const o in r){const t=r[o];s.push(this._getWGSLStructBinding(o,t.snippets.join(",\n"),"uniform",t.index,t.id))}let a=i.join("\n");return a+=n.join("\n"),a+=s.join("\n"),a}buildCode(){const t=null!==this.material?{fragment:{},vertex:{}}:{compute:{}};this.sortBindingGroups();for(const e in t){const i=t[e];i.uniforms=this.getUniforms(e),i.attributes=this.getAttributes(e),i.varyings=this.getVaryings(e),i.structs=this.getStructs(e),i.vars=this.getVars(e),i.codes=this.getCodes(e),i.directives=this.getDirectives(e),i.scopedArrays=this.getScopedArrays(e);let n="// code\n\n";n+=this.flowCode[e];const s=this.flowNodes[e],r=s[s.length-1],a=r.outputNode,o=void 0!==a&&!0===a.isOutputStructNode;for(const t of s){const s=this.getFlowData(t),l=t.name;if(l&&(n.length>0&&(n+="\n"),n+=`\t// flow -> ${l}\n\t`),n+=`${s.code}\n\t`,t===r&&"compute"!==e)if(n+="// result\n\n\t","vertex"===e)n+=`varyings.Vertex = ${s.result};`;else if("fragment"===e)if(o)i.returnType=a.nodeType,n+=`return ${s.result};`;else{let t="\t@location(0) color: vec4<f32>";const e=this.getBuiltins("output");e&&(t+=",\n\t"+e),i.returnType="OutputStruct",i.structs+=this._getWGSLStruct("OutputStruct",t),i.structs+="\nvar<private> output : OutputStruct;\n\n",n+=`output.color = ${s.result};\n\n\treturn output;`}}i.flow=n}null!==this.material?(this.vertexShader=this._getWGSLVertexCode(t.vertex),this.fragmentShader=this._getWGSLFragmentCode(t.fragment)):this.computeShader=this._getWGSLComputeCode(t.compute,(this.object.workgroupSize||[64]).join(", "))}getMethod(t,e=null){let i;return null!==e&&(i=this._getWGSLMethod(t+"_"+e)),void 0===i&&(i=this._getWGSLMethod(t)),i||t}getType(t){return yF[t]||t}isAvailable(t){let e=vF[t];return void 0===e&&("float32Filterable"===t&&(e=this.renderer.hasFeature("float32-filterable")),vF[t]=e),e}_getWGSLMethod(t){return void 0!==bF[t]&&this._include(t),SF[t]}_include(t){const e=bF[t];return e.build(this),null!==this.currentFunctionNode&&this.currentFunctionNode.includes.push(e),e}_getWGSLVertexCode(t){return`${this.getSignature()}\n// directives\n${t.directives}\n\n// uniforms\n${t.uniforms}\n\n// varyings\n${t.varyings}\nvar<private> varyings : VaryingsStruct;\n\n// codes\n${t.codes}\n\n@vertex\nfn main( ${t.attributes} ) -> VaryingsStruct {\n\n\t// vars\n\t${t.vars}\n\n\t// flow\n\t${t.flow}\n\n\treturn varyings;\n\n}\n`}_getWGSLFragmentCode(t){return`${this.getSignature()}\n// global\n${MF}\n\n// uniforms\n${t.uniforms}\n\n// structs\n${t.structs}\n\n// codes\n${t.codes}\n\n@fragment\nfn main( ${t.varyings} ) -> ${t.returnType} {\n\n\t// vars\n\t${t.vars}\n\n\t// flow\n\t${t.flow}\n\n}\n`}_getWGSLComputeCode(t,e){return`${this.getSignature()}\n// directives\n${t.directives}\n\n// system\nvar<private> instanceIndex : u32;\n\n// locals\n${t.scopedArrays}\n\n// uniforms\n${t.uniforms}\n\n// codes\n${t.codes}\n\n@compute @workgroup_size( ${e} )\nfn main( ${t.attributes} ) {\n\n\t// system\n\tinstanceIndex = id.x + id.y * numWorkgroups.x * u32(${e}) + id.z * numWorkgroups.x * numWorkgroups.y * u32(${e});\n\n\t// vars\n\t${t.vars}\n\n\t// flow\n\t${t.flow}\n\n}\n`}_getWGSLStruct(t,e){return`\nstruct ${t} {\n${e}\n};`}_getWGSLStructBinding(t,e,i,n=0,s=0){const r=t+"Struct";return`${this._getWGSLStruct(r,e)}\n@binding( ${n} ) @group( ${s} )\nvar<${i}> ${t} : ${r};`}}class wF{constructor(t){this.backend=t}getCurrentDepthStencilFormat(t){let e;return null!==t.depthTexture?e=this.getTextureFormatGPU(t.depthTexture):t.depth&&t.stencil?e=$P.Depth24PlusStencil8:t.depth&&(e=$P.Depth24Plus),e}getTextureFormatGPU(t){return this.backend.get(t).format}getCurrentColorFormat(t){let e;return e=null!==t.textures?this.getTextureFormatGPU(t.textures[0]):this.getPreferredCanvasFormat(),e}getCurrentColorSpace(t){return null!==t.textures?t.textures[0].colorSpace:this.backend.renderer.outputColorSpace}getPrimitiveTopology(t,e){return t.isPoints?AP:t.isLineSegments||t.isMesh&&!0===e.wireframe?EP:t.isLine?CP:t.isMesh?RP:void 0}getSampleCount(t){let e=1;return t>1&&(e=Math.pow(2,Math.floor(Math.log2(t))),2===e&&(e=4)),e}getSampleCountRenderContext(t){return null!==t.textures?this.getSampleCount(t.sampleCount):this.getSampleCount(this.backend.renderer.samples)}getPreferredCanvasFormat(){return navigator.userAgent.includes("Quest")?$P.BGRA8Unorm:navigator.gpu.getPreferredCanvasFormat()}}const AF=new Map([[Int8Array,["sint8","snorm8"]],[Uint8Array,["uint8","unorm8"]],[Int16Array,["sint16","snorm16"]],[Uint16Array,["uint16","unorm16"]],[Int32Array,["sint32","snorm32"]],[Uint32Array,["uint32","unorm32"]],[Float32Array,["float32"]]]),EF=new Map([[Ov,["float16"]]]),CF=new Map([[Int32Array,"sint32"],[Int16Array,"sint32"],[Uint32Array,"uint32"],[Uint16Array,"uint32"],[Float32Array,"float32"]]);class RF{constructor(t){this.backend=t}createAttribute(t,e){const i=this._getBufferAttribute(t),n=this.backend,s=n.get(i);let r=s.buffer;if(void 0===r){const a=n.device;let o=i.array;if(!1===t.normalized&&(o.constructor===Int16Array||o.constructor===Uint16Array)){const t=new Uint32Array(o.length);for(let e=0;e<o.length;e++)t[e]=o[e];o=t}if(i.array=o,(i.isStorageBufferAttribute||i.isStorageInstancedBufferAttribute)&&3===i.itemSize){o=new o.constructor(4*i.count);for(let t=0;t<i.count;t++)o.set(i.array.subarray(3*t,3*t+3),4*t);i.itemSize=4,i.array=o}const l=o.byteLength+(4-o.byteLength%4)%4;r=a.createBuffer({label:i.name,size:l,usage:e,mappedAtCreation:!0}),new o.constructor(r.getMappedRange()).set(o),r.unmap(),s.buffer=r}}updateAttribute(t){const e=this._getBufferAttribute(t),i=this.backend,n=i.device,s=i.get(e).buffer,r=e.array,a=e.updateRanges;if(0===a.length)n.queue.writeBuffer(s,0,r,0);else{for(let t=0,e=a.length;t<e;t++){const e=a[t];n.queue.writeBuffer(s,0,r,e.start*r.BYTES_PER_ELEMENT,e.count*r.BYTES_PER_ELEMENT)}e.clearUpdateRanges()}}createShaderVertexBuffers(t){const e=t.getAttributes(),i=new Map;for(let n=0;n<e.length;n++){const t=e[n],s=t.array.BYTES_PER_ELEMENT,r=this._getBufferAttribute(t);let a=i.get(r);if(void 0===a){let e,n;!0===t.isInterleavedBufferAttribute?(e=t.data.stride*s,n=t.data.isInstancedInterleavedBuffer?jI:WI):(e=t.itemSize*s,n=t.isInstancedBufferAttribute?jI:WI),!1!==t.normalized||t.array.constructor!==Int16Array&&t.array.constructor!==Uint16Array||(e=4),a={arrayStride:e,attributes:[],stepMode:n},i.set(r,a)}const o=this._getVertexFormat(t),l=!0===t.isInterleavedBufferAttribute?t.offset*s:0;a.attributes.push({shaderLocation:n,offset:l,format:o})}return Array.from(i.values())}destroyAttribute(t){const e=this.backend;e.get(this._getBufferAttribute(t)).buffer.destroy(),e.delete(t)}async getArrayBufferAsync(t){const e=this.backend,i=e.device,n=e.get(this._getBufferAttribute(t)).buffer,s=n.size,r=i.createBuffer({label:t.name,size:s,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),a=i.createCommandEncoder({});a.copyBufferToBuffer(n,0,r,0,s),r.unmap();const o=a.finish();i.queue.submit([o]),await r.mapAsync(GPUMapMode.READ);return r.getMappedRange()}_getVertexFormat(t){const{itemSize:e,normalized:i}=t,n=t.array.constructor,s=t.constructor;let r;if(1==e)r=CF.get(n);else{const t=(EF.get(s)||AF.get(n))[i?1:0];if(t){const i=n.BYTES_PER_ELEMENT*e,s=4*Math.floor((i+3)/4)/n.BYTES_PER_ELEMENT;if(s%1)throw new Error("THREE.WebGPUAttributeUtils: Bad vertex format item size.");r=`${t}x${s}`}}return r}_getBufferAttribute(t){return t.isInterleavedBufferAttribute&&(t=t.data),t}}class NF{constructor(t){this.backend=t,this.bindGroupLayoutCache=new WeakMap}createBindingsLayout(t){const e=this.backend.device,i=[];let n=0;for(const s of t.bindings){const t={binding:n++,visibility:s.visibility};if(s.isUniformBuffer||s.isStorageBuffer){const e={};s.isStorageBuffer&&(e.type=s.access),t.buffer=e}else if(s.isSampler){const e={};s.texture.isDepthTexture&&null!==s.texture.compareFunction&&(e.type="comparison"),t.sampler=e}else if(s.isSampledTexture&&s.texture.isVideoTexture)t.externalTexture={};else if(s.isSampledTexture&&s.store){const e=this.backend.get(s.texture).texture.format,i=s.access;t.storageTexture={format:e,access:i}}else if(s.isSampledTexture){const e={};if(!0===s.texture.isMultisampleRenderTargetTexture&&(e.multisampled=!0),s.texture.isDepthTexture)e.sampleType=DI;else if(s.texture.isDataTexture||s.texture.isDataArrayTexture||s.texture.isData3DTexture){const t=s.texture.type;t===yf?e.sampleType=UI:t===bf?e.sampleType=FI:t===Sf&&(this.backend.hasFeature("float32-filterable")?e.sampleType=II:e.sampleType=LI)}s.isSampledCubeTexture?e.viewDimension=VI:s.texture.isDataArrayTexture||s.texture.isCompressedArrayTexture?e.viewDimension=kI:s.isSampledTexture3D&&(e.viewDimension=GI),t.texture=e}i.push(t)}return e.createBindGroupLayout({entries:i})}createBindings(t){const{backend:e,bindGroupLayoutCache:i}=this,n=e.get(t);let s=i.get(t.bindingsReference);void 0===s&&(s=this.createBindingsLayout(t),i.set(t.bindingsReference,s));const r=this.createBindGroup(t,s);n.layout=s,n.group=r}updateBinding(t){const e=this.backend,i=e.device,n=t.buffer,s=e.get(t).buffer;i.queue.writeBuffer(s,0,n,0)}createBindGroup(t,e){const i=this.backend,n=i.device;let s=0;const r=[];for(const a of t.bindings){if(a.isUniformBuffer){const t=i.get(a);if(void 0===t.buffer){const e=a.byteLength,i=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,s=n.createBuffer({label:"bindingBuffer_"+a.name,size:e,usage:i});t.buffer=s}r.push({binding:s,resource:{buffer:t.buffer}})}else if(a.isStorageBuffer){const t=i.get(a);if(void 0===t.buffer){const e=a.attribute;t.buffer=i.get(e).buffer}r.push({binding:s,resource:{buffer:t.buffer}})}else if(a.isSampler){const t=i.get(a.texture);r.push({binding:s,resource:t.sampler})}else if(a.isSampledTexture){const t=i.get(a.texture);let e;if(void 0!==t.externalTexture)e=n.importExternalTexture({source:t.externalTexture});else{const i=a.store?1:t.texture.mipLevelCount,n=`view-${t.texture.width}-${t.texture.height}-${i}`;if(e=t[n],void 0===e){const s=HI;let r;r=a.isSampledCubeTexture?VI:a.isSampledTexture3D?GI:a.texture.isDataArrayTexture||a.texture.isCompressedArrayTexture?kI:zI,e=t[n]=t.texture.createView({aspect:s,dimension:r,mipLevelCount:i})}}r.push({binding:s,resource:e})}s++}return n.createBindGroup({label:"bindGroup_"+t.name,layout:e,entries:r})}}class PF{constructor(t){this.backend=t}_getSampleCount(t){return this.backend.utils.getSampleCountRenderContext(t)}createRenderPipeline(t,e){const{object:i,material:n,geometry:s,pipeline:r}=t,{vertexProgram:a,fragmentProgram:o}=r,l=this.backend,h=l.device,c=l.utils,u=l.get(r),d=[];for(const C of t.getBindings()){const t=l.get(C);d.push(t.layout)}const p=l.attributeUtils.createShaderVertexBuffers(t);let m;!0===n.transparent&&0!==n.blending&&(m=this._getBlending(n));let f={};!0===n.stencilWrite&&(f={compare:this._getStencilCompare(n),failOp:this._getStencilOperation(n.stencilFail),depthFailOp:this._getStencilOperation(n.stencilZFail),passOp:this._getStencilOperation(n.stencilZPass)});const g=this._getColorWriteMask(n),x=[];if(null!==t.context.textures){const e=t.context.textures;for(let t=0;t<e.length;t++){const i=c.getTextureFormatGPU(e[t]);x.push({format:i,blend:m,writeMask:g})}}else{const e=c.getCurrentColorFormat(t.context);x.push({format:e,blend:m,writeMask:g})}const v=l.get(a).module,_=l.get(o).module,y=this._getPrimitiveState(i,s,n),b=this._getDepthCompare(n),S=c.getCurrentDepthStencilFormat(t.context),M=this._getSampleCount(t.context),T={label:`renderPipeline_${n.name||n.type}_${n.id}`,vertex:Object.assign({},v,{buffers:p}),fragment:Object.assign({},_,{targets:x}),primitive:y,multisample:{count:M,alphaToCoverageEnabled:n.alphaToCoverage&&M>1},layout:h.createPipelineLayout({bindGroupLayouts:d})},w={},A=t.context.depth,E=t.context.stencil;if(!0!==A&&!0!==E||(!0===A&&(w.format=S,w.depthWriteEnabled=n.depthWrite,w.depthCompare=b),!0===E&&(w.stencilFront=f,w.stencilBack={},w.stencilReadMask=n.stencilFuncMask,w.stencilWriteMask=n.stencilWriteMask),T.depthStencil=w),null===e)u.pipeline=h.createRenderPipeline(T);else{const t=new Promise((t=>{h.createRenderPipelineAsync(T).then((e=>{u.pipeline=e,t()}))}));e.push(t)}}createBundleEncoder(t){const e=this.backend,{utils:i,device:n}=e,s=i.getCurrentDepthStencilFormat(t),r={label:"renderBundleEncoder",colorFormats:[i.getCurrentColorFormat(t)],depthStencilFormat:s,sampleCount:this._getSampleCount(t)};return n.createRenderBundleEncoder(r)}createComputePipeline(t,e){const i=this.backend,n=i.device,s=i.get(t.computeProgram).module,r=i.get(t),a=[];for(const o of e){const t=i.get(o);a.push(t.layout)}r.pipeline=n.createComputePipeline({compute:s,layout:n.createPipelineLayout({bindGroupLayouts:a})})}_getBlending(t){let e,i;const n=t.blending,s=t.blendSrc,r=t.blendDst,a=t.blendEquation;if(5===n){const n=null!==t.blendSrcAlpha?t.blendSrcAlpha:s,o=null!==t.blendDstAlpha?t.blendDstAlpha:r,l=null!==t.blendEquationAlpha?t.blendEquationAlpha:a;e={srcFactor:this._getBlendFactor(s),dstFactor:this._getBlendFactor(r),operation:this._getBlendOperation(a)},i={srcFactor:this._getBlendFactor(n),dstFactor:this._getBlendFactor(o),operation:this._getBlendOperation(l)}}else{const s=(t,n,s,r)=>{e={srcFactor:t,dstFactor:n,operation:pI},i={srcFactor:s,dstFactor:r,operation:pI}};if(t.premultipliedAlpha)switch(n){case 1:s(eI,rI,eI,rI);break;case 2:s(eI,eI,eI,eI);break;case 3:s(tI,nI,tI,eI);break;case 4:s(tI,iI,tI,sI)}else switch(n){case 1:s(sI,rI,eI,rI);break;case 2:s(sI,eI,sI,eI);break;case 3:s(tI,nI,tI,eI);break;case 4:s(tI,iI,tI,iI)}}if(void 0!==e&&void 0!==i)return{color:e,alpha:i}}_getBlendFactor(t){let e;switch(t){case 200:e=tI;break;case 201:e=eI;break;case 202:e=iI;break;case 203:e=nI;break;case Ym:e=sI;break;case Zm:e=rI;break;case 208:e=aI;break;case 209:e=oI;break;case 206:e=lI;break;case 207:e=hI;break;case 210:e=cI;break;case 211:e=uI;break;case 212:e=dI}return e}_getStencilCompare(t){let e;switch(t.stencilFunc){case 512:e=PP;break;case 519:e=OP;break;case 513:e=IP;break;case 515:e=DP;break;case 514:e=LP;break;case 518:e=BP;break;case 516:e=UP;break;case 517:e=FP}return e}_getStencilOperation(t){let e;switch(t){case ag:e=yI;break;case 0:e=bI;break;case 7681:e=SI;break;case 5386:e=MI;break;case 7682:e=TI;break;case 7683:e=wI;break;case 34055:e=AI;break;case 34056:e=EI}return e}_getBlendOperation(t){let e;switch(t){case Gm:e=pI;break;case 101:e=mI;break;case 102:e=fI;break;case 103:e=gI;break;case 104:e=xI}return e}_getPrimitiveState(t,e,i){const n={},s=this.backend.utils;switch(n.topology=s.getPrimitiveTopology(t,i),null!==e.index&&!0===t.isLine&&!0!==t.isLineSegments&&(n.stripIndexFormat=e.index.array instanceof Uint16Array?XP:qP),i.side){case 0:n.frontFace=GP,n.cullMode=jP;break;case 1:n.frontFace=GP,n.cullMode=WP;break;case 2:n.frontFace=GP,n.cullMode=HP}return n}_getColorWriteMask(t){return!0===t.colorWrite?_I:vI}_getDepthCompare(t){let e;if(!1===t.depthTest)e=OP;else{switch(t.depthFunc){case 0:e=PP;break;case 1:e=OP;break;case 2:e=IP;break;case 3:e=DP;break;case 4:e=LP;break;case 5:e=BP;break;case 6:e=UP;break;case 7:e=FP}}return e}}class IF extends FU{constructor(t={}){super(t),this.isWebGPUBackend=!0,this.parameters.alpha=void 0===t.alpha||t.alpha,this.parameters.requiredLimits=void 0===t.requiredLimits?{}:t.requiredLimits,this.trackTimestamp=!0===t.trackTimestamp,this.device=null,this.context=null,this.colorBuffer=null,this.defaultRenderPassdescriptor=null,this.utils=new wF(this),this.attributeUtils=new RF(this),this.bindingUtils=new NF(this),this.pipelineUtils=new PF(this),this.textureUtils=new hF(this),this.occludedResolveCache=new Map}async init(t){await super.init(t);const e=this.parameters;let i;if(void 0===e.device){const t={powerPreference:e.powerPreference},n=await navigator.gpu.requestAdapter(t);if(null===n)throw new Error("WebGPUBackend: Unable to create WebGPU adapter.");const s=Object.values(XI),r=[];for(const e of s)n.features.has(e)&&r.push(e);const a={requiredFeatures:r,requiredLimits:e.requiredLimits};i=await n.requestDevice(a)}else i=e.device;i.lost.then((e=>{const i={api:"WebGPU",message:e.message||"Unknown reason",reason:e.reason||null,originalEvent:e};t.onDeviceLost(i)}));const n=void 0!==e.context?e.context:t.domElement.getContext("webgpu");this.device=i,this.context=n;const s=e.alpha?"premultiplied":"opaque";this.trackTimestamp=this.trackTimestamp&&this.hasFeature(XI.TimestampQuery),this.context.configure({device:this.device,format:this.utils.getPreferredCanvasFormat(),usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,alphaMode:s}),this.updateSize()}get coordinateSystem(){return vg}async getArrayBufferAsync(t){return await this.attributeUtils.getArrayBufferAsync(t)}getContext(){return this.context}_getDefaultRenderPassDescriptor(){let t=this.defaultRenderPassdescriptor;if(null===t){const e=this.renderer;t={colorAttachments:[{view:null}]},!0!==this.renderer.depth&&!0!==this.renderer.stencil||(t.depthStencilAttachment={view:this.textureUtils.getDepthBuffer(e.depth,e.stencil).createView()});const i=t.colorAttachments[0];this.renderer.samples>0?i.view=this.colorBuffer.createView():i.resolveTarget=void 0,this.defaultRenderPassdescriptor=t}const e=t.colorAttachments[0];return this.renderer.samples>0?e.resolveTarget=this.context.getCurrentTexture().createView():e.view=this.context.getCurrentTexture().createView(),t}_getRenderPassDescriptor(t){const e=t.renderTarget,i=this.get(e);let n=i.descriptors;if(void 0===n||i.width!==e.width||i.height!==e.height||i.activeMipmapLevel!==e.activeMipmapLevel||i.samples!==e.samples){n={},i.descriptors=n;const t=()=>{e.removeEventListener("dispose",t),this.delete(e)};e.addEventListener("dispose",t)}const s=t.getCacheKey();let r=n[s];if(void 0===r){const a=t.textures,o=[];for(let e=0;e<a.length;e++){const i=this.get(a[e]),n=i.texture.createView({baseMipLevel:t.activeMipmapLevel,mipLevelCount:1,baseArrayLayer:t.activeCubeFace,dimension:zI});let s,r;void 0!==i.msaaTexture?(s=i.msaaTexture.createView(),r=n):(s=n,r=void 0),o.push({view:s,resolveTarget:r,loadOp:kP,storeOp:zP})}if(r={colorAttachments:o},t.depth){const e={view:this.get(t.depthTexture).texture.createView()};r.depthStencilAttachment=e}n[s]=r,i.width=e.width,i.height=e.height,i.samples=e.samples,i.activeMipmapLevel=e.activeMipmapLevel}return r}beginRender(t){const e=this.get(t),i=this.device,n=t.occlusionQueryCount;let s,r;n>0&&(e.currentOcclusionQuerySet&&e.currentOcclusionQuerySet.destroy(),e.currentOcclusionQueryBuffer&&e.currentOcclusionQueryBuffer.destroy(),e.currentOcclusionQuerySet=e.occlusionQuerySet,e.currentOcclusionQueryBuffer=e.occlusionQueryBuffer,e.currentOcclusionQueryObjects=e.occlusionQueryObjects,s=i.createQuerySet({type:"occlusion",count:n}),e.occlusionQuerySet=s,e.occlusionQueryIndex=0,e.occlusionQueryObjects=new Array(n),e.lastOcclusionObject=null),r=null===t.textures?this._getDefaultRenderPassDescriptor():this._getRenderPassDescriptor(t),this.initTimestampQuery(t,r),r.occlusionQuerySet=s;const a=r.depthStencilAttachment;if(null!==t.textures){const e=r.colorAttachments;for(let i=0;i<e.length;i++){const n=e[i];t.clearColor?(n.clearValue=0===i?t.clearColorValue:{r:0,g:0,b:0,a:1},n.loadOp=VP,n.storeOp=zP):(n.loadOp=kP,n.storeOp=zP)}}else{const e=r.colorAttachments[0];t.clearColor?(e.clearValue=t.clearColorValue,e.loadOp=VP,e.storeOp=zP):(e.loadOp=kP,e.storeOp=zP)}t.depth&&(t.clearDepth?(a.depthClearValue=t.clearDepthValue,a.depthLoadOp=VP,a.depthStoreOp=zP):(a.depthLoadOp=kP,a.depthStoreOp=zP)),t.stencil&&(t.clearStencil?(a.stencilClearValue=t.clearStencilValue,a.stencilLoadOp=VP,a.stencilStoreOp=zP):(a.stencilLoadOp=kP,a.stencilStoreOp=zP));const o=i.createCommandEncoder({label:"renderContext_"+t.id}),l=o.beginRenderPass(r);if(e.descriptor=r,e.encoder=o,e.currentPass=l,e.currentSets={attributes:{},bindingGroups:[],pipeline:null,index:null},e.renderBundles=[],t.viewport&&this.updateViewport(t),t.scissor){const{x:e,y:i,width:n,height:s}=t.scissorValue;l.setScissorRect(e,i,n,s)}}finishRender(t){const e=this.get(t),i=t.occlusionQueryCount;if(e.renderBundles.length>0&&e.currentPass.executeBundles(e.renderBundles),i>e.occlusionQueryIndex&&e.currentPass.endOcclusionQuery(),e.currentPass.end(),i>0){const n=8*i;let s=this.occludedResolveCache.get(n);void 0===s&&(s=this.device.createBuffer({size:n,usage:GPUBufferUsage.QUERY_RESOLVE|GPUBufferUsage.COPY_SRC}),this.occludedResolveCache.set(n,s));const r=this.device.createBuffer({size:n,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});e.encoder.resolveQuerySet(e.occlusionQuerySet,0,i,s,0),e.encoder.copyBufferToBuffer(s,0,r,0,n),e.occlusionQueryBuffer=r,this.resolveOccludedAsync(t)}if(this.prepareTimestampBuffer(t,e.encoder),this.device.queue.submit([e.encoder.finish()]),null!==t.textures){const e=t.textures;for(let t=0;t<e.length;t++){const i=e[t];!0===i.generateMipmaps&&this.textureUtils.generateMipmaps(i)}}}isOccluded(t,e){const i=this.get(t);return i.occluded&&i.occluded.has(e)}async resolveOccludedAsync(t){const e=this.get(t),{currentOcclusionQueryBuffer:i,currentOcclusionQueryObjects:n}=e;if(i&&n){const t=new WeakSet;e.currentOcclusionQueryObjects=null,e.currentOcclusionQueryBuffer=null,await i.mapAsync(GPUMapMode.READ);const s=i.getMappedRange(),r=new BigUint64Array(s);for(let e=0;e<n.length;e++)r[e]!==BigInt(0)&&t.add(n[e]);i.destroy(),e.occluded=t}}updateViewport(t){const{currentPass:e}=this.get(t),{x:i,y:n,width:s,height:r,minDepth:a,maxDepth:o}=t.viewportValue;e.setViewport(i,n,s,r,a,o)}clear(t,e,i,n=null){const s=this.device,r=this.renderer;let a,o,l,h,c=[];if(t){const t=this.getClearColor();if(!0===this.renderer.alpha){const e=t.a;o={r:t.r*e,g:t.g*e,b:t.b*e,a:e}}else o={r:t.r,g:t.g,b:t.b,a:t.a}}if(null===n){l=r.depth,h=r.stencil;const e=this._getDefaultRenderPassDescriptor();if(t){c=e.colorAttachments;const t=c[0];t.clearValue=o,t.loadOp=VP,t.storeOp=zP}(l||h)&&(a=e.depthStencilAttachment)}else{if(l=n.depth,h=n.stencil,t)for(const t of n.textures){const e=this.get(t),i=e.texture.createView();let n,s;void 0!==e.msaaTexture?(n=e.msaaTexture.createView(),s=i):(n=i,s=void 0),c.push({view:n,resolveTarget:s,clearValue:o,loadOp:VP,storeOp:zP})}if(l||h){a={view:this.get(n.depthTexture).texture.createView()}}}l&&(e?(a.depthLoadOp=VP,a.depthClearValue=r.getClearDepth(),a.depthStoreOp=zP):(a.depthLoadOp=kP,a.depthStoreOp=zP)),h&&(i?(a.stencilLoadOp=VP,a.stencilClearValue=r.getClearStencil(),a.stencilStoreOp=zP):(a.stencilLoadOp=kP,a.stencilStoreOp=zP));const u=s.createCommandEncoder({});u.beginRenderPass({colorAttachments:c,depthStencilAttachment:a}).end(),s.queue.submit([u.finish()])}beginCompute(t){const e=this.get(t),i={};this.initTimestampQuery(t,i),e.cmdEncoderGPU=this.device.createCommandEncoder(),e.passEncoderGPU=e.cmdEncoderGPU.beginComputePass(i)}compute(t,e,i,n){const{passEncoderGPU:s}=this.get(t),r=this.get(n).pipeline;s.setPipeline(r);for(let h=0,c=i.length;h<c;h++){const t=i[h],e=this.get(t);s.setBindGroup(h,e.group)}const a=this.device.limits.maxComputeWorkgroupsPerDimension,o=this.get(e);void 0===o.dispatchSize&&(o.dispatchSize={x:0,y:1,z:1});const{dispatchSize:l}=o;e.dispatchCount>a?(l.x=Math.min(e.dispatchCount,a),l.y=Math.ceil(e.dispatchCount/a)):l.x=e.dispatchCount,s.dispatchWorkgroups(l.x,l.y,l.z)}finishCompute(t){const e=this.get(t);e.passEncoderGPU.end(),this.prepareTimestampBuffer(t,e.cmdEncoderGPU),this.device.queue.submit([e.cmdEncoderGPU.finish()])}async waitForGPU(){await this.device.queue.onSubmittedWorkDone()}draw(t,e){const{object:i,context:n,pipeline:s}=t,r=t.getBindings(),a=this.get(n),o=this.get(s).pipeline,l=a.currentSets,h=a.currentPass,c=t.getDrawParameters();if(null===c)return;l.pipeline!==o&&(h.setPipeline(o),l.pipeline=o);const u=l.bindingGroups;for(let f=0,g=r.length;f<g;f++){const t=r[f],e=this.get(t);u[t.index]!==t.id&&(h.setBindGroup(t.index,e.group),u[t.index]=t.id)}const d=t.getIndex(),p=null!==d;if(!0===p&&l.index!==d){const t=this.get(d).buffer,e=d.array instanceof Uint16Array?XP:qP;h.setIndexBuffer(t,e),l.index=d}const m=t.getVertexBuffers();for(let f=0,g=m.length;f<g;f++){const t=m[f];if(l.attributes[f]!==t){const e=this.get(t).buffer;h.setVertexBuffer(f,e),l.attributes[f]=t}}if(void 0!==a.occlusionQuerySet){const t=a.lastOcclusionObject;t!==i&&(null!==t&&!0===t.occlusionTest&&(h.endOcclusionQuery(),a.occlusionQueryIndex++),!0===i.occlusionTest&&(h.beginOcclusionQuery(a.occlusionQueryIndex),a.occlusionQueryObjects[a.occlusionQueryIndex]=i),a.lastOcclusionObject=i)}if(!0===i.isBatchedMesh){const t=i._multiDrawStarts,e=i._multiDrawCounts,n=i._multiDrawCount,s=i._multiDrawInstances,r=p?d.array.BYTES_PER_ELEMENT:1;for(let i=0;i<n;i++){const n=s?s[i]:1,a=n>1?0:i;h.drawIndexed(e[i],n,t[i]/r,0,a)}}else if(!0===p){const{vertexCount:n,instanceCount:s,firstVertex:r}=c,a=t.getIndirect();if(null!==a){const t=this.get(a).buffer;h.drawIndexedIndirect(t,0)}else h.drawIndexed(n,s,r,0,0);e.update(i,n,s)}else{const{vertexCount:n,instanceCount:s,firstVertex:r}=c,a=t.getIndirect();if(null!==a){const t=this.get(a).buffer;h.drawIndirect(t,0)}else h.draw(n,s,r,0);e.update(i,n,s)}}needsRenderUpdate(t){const e=this.get(t),{object:i,material:n}=t,s=this.utils,r=s.getSampleCountRenderContext(t.context),a=s.getCurrentColorSpace(t.context),o=s.getCurrentColorFormat(t.context),l=s.getCurrentDepthStencilFormat(t.context),h=s.getPrimitiveTopology(i,n);let c=!1;return e.material===n&&e.materialVersion===n.version&&e.transparent===n.transparent&&e.blending===n.blending&&e.premultipliedAlpha===n.premultipliedAlpha&&e.blendSrc===n.blendSrc&&e.blendDst===n.blendDst&&e.blendEquation===n.blendEquation&&e.blendSrcAlpha===n.blendSrcAlpha&&e.blendDstAlpha===n.blendDstAlpha&&e.blendEquationAlpha===n.blendEquationAlpha&&e.colorWrite===n.colorWrite&&e.depthWrite===n.depthWrite&&e.depthTest===n.depthTest&&e.depthFunc===n.depthFunc&&e.stencilWrite===n.stencilWrite&&e.stencilFunc===n.stencilFunc&&e.stencilFail===n.stencilFail&&e.stencilZFail===n.stencilZFail&&e.stencilZPass===n.stencilZPass&&e.stencilFuncMask===n.stencilFuncMask&&e.stencilWriteMask===n.stencilWriteMask&&e.side===n.side&&e.alphaToCoverage===n.alphaToCoverage&&e.sampleCount===r&&e.colorSpace===a&&e.colorFormat===o&&e.depthStencilFormat===l&&e.primitiveTopology===h&&e.clippingContextCacheKey===t.clippingContext.cacheKey||(e.material=n,e.materialVersion=n.version,e.transparent=n.transparent,e.blending=n.blending,e.premultipliedAlpha=n.premultipliedAlpha,e.blendSrc=n.blendSrc,e.blendDst=n.blendDst,e.blendEquation=n.blendEquation,e.blendSrcAlpha=n.blendSrcAlpha,e.blendDstAlpha=n.blendDstAlpha,e.blendEquationAlpha=n.blendEquationAlpha,e.colorWrite=n.colorWrite,e.depthWrite=n.depthWrite,e.depthTest=n.depthTest,e.depthFunc=n.depthFunc,e.stencilWrite=n.stencilWrite,e.stencilFunc=n.stencilFunc,e.stencilFail=n.stencilFail,e.stencilZFail=n.stencilZFail,e.stencilZPass=n.stencilZPass,e.stencilFuncMask=n.stencilFuncMask,e.stencilWriteMask=n.stencilWriteMask,e.side=n.side,e.alphaToCoverage=n.alphaToCoverage,e.sampleCount=r,e.colorSpace=a,e.colorFormat=o,e.depthStencilFormat=l,e.primitiveTopology=h,e.clippingContextCacheKey=t.clippingContext.cacheKey,c=!0),c}getRenderCacheKey(t){const{object:e,material:i}=t,n=this.utils,s=t.context;return[i.transparent,i.blending,i.premultipliedAlpha,i.blendSrc,i.blendDst,i.blendEquation,i.blendSrcAlpha,i.blendDstAlpha,i.blendEquationAlpha,i.colorWrite,i.depthWrite,i.depthTest,i.depthFunc,i.stencilWrite,i.stencilFunc,i.stencilFail,i.stencilZFail,i.stencilZPass,i.stencilFuncMask,i.stencilWriteMask,i.side,n.getSampleCountRenderContext(s),n.getCurrentColorSpace(s),n.getCurrentColorFormat(s),n.getCurrentDepthStencilFormat(s),n.getPrimitiveTopology(e,i),t.getGeometryCacheKey(),t.clippingContext.cacheKey].join()}createSampler(t){this.textureUtils.createSampler(t)}destroySampler(t){this.textureUtils.destroySampler(t)}createDefaultTexture(t){this.textureUtils.createDefaultTexture(t)}createTexture(t,e){this.textureUtils.createTexture(t,e)}updateTexture(t,e){this.textureUtils.updateTexture(t,e)}generateMipmaps(t){this.textureUtils.generateMipmaps(t)}destroyTexture(t){this.textureUtils.destroyTexture(t)}copyTextureToBuffer(t,e,i,n,s,r){return this.textureUtils.copyTextureToBuffer(t,e,i,n,s,r)}initTimestampQuery(t,e){if(!this.trackTimestamp)return;const i=this.get(t);if(!i.timeStampQuerySet){const t=this.device.createQuerySet({type:"timestamp",count:2}),n={querySet:t,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1};Object.assign(e,{timestampWrites:n}),i.timeStampQuerySet=t}}prepareTimestampBuffer(t,e){if(!this.trackTimestamp)return;const i=this.get(t),n=2*BigInt64Array.BYTES_PER_ELEMENT;void 0===i.currentTimestampQueryBuffers&&(i.currentTimestampQueryBuffers={resolveBuffer:this.device.createBuffer({label:"timestamp resolve buffer",size:n,usage:GPUBufferUsage.QUERY_RESOLVE|GPUBufferUsage.COPY_SRC}),resultBuffer:this.device.createBuffer({label:"timestamp result buffer",size:n,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),isMappingPending:!1});const{resolveBuffer:s,resultBuffer:r,isMappingPending:a}=i.currentTimestampQueryBuffers;!0!==a&&(e.resolveQuerySet(i.timeStampQuerySet,0,2,s,0),e.copyBufferToBuffer(s,0,r,0,n))}async resolveTimestampAsync(t,e="render"){if(!this.trackTimestamp)return;const i=this.get(t);if(void 0===i.currentTimestampQueryBuffers)return;const{resultBuffer:n,isMappingPending:s}=i.currentTimestampQueryBuffers;!0!==s&&(i.currentTimestampQueryBuffers.isMappingPending=!0,n.mapAsync(GPUMapMode.READ).then((()=>{const t=new BigUint64Array(n.getMappedRange()),s=Number(t[1]-t[0])/1e6;this.renderer.info.updateTimestamp(e,s),n.unmap(),i.currentTimestampQueryBuffers.isMappingPending=!1})))}createNodeBuilder(t,e){return new TF(t,e)}createProgram(t){this.get(t).module={module:this.device.createShaderModule({code:t.code,label:t.stage}),entryPoint:"main"}}destroyProgram(t){this.delete(t)}createRenderPipeline(t,e){this.pipelineUtils.createRenderPipeline(t,e)}createComputePipeline(t,e){this.pipelineUtils.createComputePipeline(t,e)}beginBundle(t){const e=this.get(t);e._currentPass=e.currentPass,e._currentSets=e.currentSets,e.currentSets={attributes:{},bindingGroups:[],pipeline:null,index:null},e.currentPass=this.pipelineUtils.createBundleEncoder(t)}finishBundle(t,e){const i=this.get(t),n=i.currentPass.finish();this.get(e).bundleGPU=n,i.currentSets=i._currentSets,i.currentPass=i._currentPass}addBundle(t,e){this.get(t).renderBundles.push(this.get(e).bundleGPU)}createBindings(t){this.bindingUtils.createBindings(t)}updateBindings(t){this.bindingUtils.createBindings(t)}updateBinding(t){this.bindingUtils.updateBinding(t)}createIndexAttribute(t){this.attributeUtils.createAttribute(t,GPUBufferUsage.INDEX|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST)}createAttribute(t){this.attributeUtils.createAttribute(t,GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST)}createStorageAttribute(t){this.attributeUtils.createAttribute(t,GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST)}createIndirectStorageAttribute(t){this.attributeUtils.createAttribute(t,GPUBufferUsage.STORAGE|GPUBufferUsage.INDIRECT|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST)}updateAttribute(t){this.attributeUtils.updateAttribute(t)}destroyAttribute(t){this.attributeUtils.destroyAttribute(t)}updateSize(){this.colorBuffer=this.textureUtils.getColorBuffer(),this.defaultRenderPassdescriptor=null}getMaxAnisotropy(){return 16}hasFeature(t){return this.device.features.has(t)}copyTextureToTexture(t,e,i=null,n=null,s=0){let r=0,a=0,o=0,l=0,h=0,c=0,u=t.image.width,d=t.image.height;null!==i&&(l=i.x,h=i.y,c=i.z||0,u=i.width,d=i.height),null!==n&&(r=n.x,a=n.y,o=n.z||0);const p=this.device.createCommandEncoder({label:"copyTextureToTexture_"+t.id+"_"+e.id}),m=this.get(t).texture,f=this.get(e).texture;p.copyTextureToTexture({texture:m,mipLevel:s,origin:{x:l,y:h,z:c}},{texture:f,mipLevel:s,origin:{x:r,y:a,z:o}},[u,d,1]),this.device.queue.submit([p.finish()])}copyFramebufferToTexture(t,e,i){const n=this.get(e);let s=null;s=e.renderTarget?t.isDepthTexture?this.get(e.depthTexture).texture:this.get(e.textures[0]).texture:t.isDepthTexture?this.textureUtils.getDepthBuffer(e.depth,e.stencil):this.context.getCurrentTexture();const r=this.get(t).texture;if(s.format!==r.format)return;let a;if(n.currentPass?(n.currentPass.end(),a=n.encoder):a=this.device.createCommandEncoder({label:"copyFramebufferToTexture_"+t.id}),a.copyTextureToTexture({texture:s,origin:{x:i.x,y:i.y,z:0}},{texture:r},[i.z,i.w]),t.generateMipmaps&&this.textureUtils.generateMipmaps(t),n.currentPass){const{descriptor:t}=n;for(let e=0;e<t.colorAttachments.length;e++)t.colorAttachments[e].loadOp=kP;e.depth&&(t.depthStencilAttachment.depthLoadOp=kP),e.stencil&&(t.depthStencilAttachment.stencilLoadOp=kP),n.currentPass=a.beginRenderPass(t),n.currentSets={attributes:{},bindingGroups:[],pipeline:null,index:null}}else this.device.queue.submit([a.finish()])}}class LF extends Ry{constructor(t,e,i,n,s,r){super(t,e,i,n,s,r),this.iesMap=null}copy(t,e){return super.copy(t,e),this.iesMap=t.iesMap,this}}class DF extends rU{constructor(){super(),this.addMaterial(HC,cy),this.addMaterial(lN,ly),this.addMaterial(cN,hy),this.addMaterial(mN,uy),this.addMaterial(DC,Cv),this.addMaterial(VC,py),this.addMaterial(yC,dy),this.addMaterial(vN,my),this.addMaterial(gC,V_),this.addMaterial(vC,fy),this.addMaterial(yN,ty),this.addMaterial(TN,M_),this.addMaterial(EN,oy),this.addLight(FL,Dy),this.addLight(OD,By),this.addLight(GD,zy),this.addLight(HD,Ry),this.addLight(jD,Oy),this.addLight(XD,My),this.addLight(qD,Vy),this.addLight(WD,LF),this.addToneMapping(KI,1),this.addToneMapping(JI,2),this.addToneMapping(QI,3),this.addToneMapping(eL,4),this.addToneMapping(rL,6),this.addToneMapping(aL,7)}}class UF extends mU{constructor(t={}){let e;t.forceWebGL?e=tF:(e=IF,t.getFallback=()=>new tF(t));super(new e(t),t),this.library=new DF,this.isWebGPURenderer=!0}}"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:zm}})),"undefined"!=typeof window&&(window.__THREE__||(window.__THREE__=zm));export{bm as $,m as A,ds as B,Dn as C,p as D,Il as E,Jh as F,xo as G,ac as H,xl as I,Ki as J,em as K,th as L,On as M,Ns as N,fn as O,Fs as P,Co as Q,Su as R,xs as S,Ic as T,ad as U,Fe as V,oi as W,xh as X,Nl as Y,fm as Z,e as _,ui as a,sl as a$,mm as a0,dm as a1,ci as a2,Ao as a3,c as a4,Om as a5,Yc as a6,Ru as a7,hm as a8,Sm as a9,Vi as aA,gs as aB,Os as aC,uh as aD,ht as aE,tu as aF,ou as aG,lu as aH,hu as aI,Ys as aJ,Q as aK,mi as aL,zu as aM,Cu as aN,ih as aO,yc as aP,Sc as aQ,vc as aR,Mc as aS,Jt as aT,zl as aU,oe as aV,Mm as aW,Z as aX,Yh as aY,d as aZ,Gn as a_,Ji as aa,As as ab,Ts as ac,om as ad,_m as ae,Ue as af,j as ag,hh as ah,nm as ai,Qh as aj,Qp as ak,lh as al,Wn as am,Eo as an,Du as ao,Dc as ap,Zc as aq,ku as ar,eu as as,Dd as at,Nu as au,_d as av,kl as aw,Xo as ax,Lo as ay,u as az,cs as b,ll as b0,fc as b1,hl as b2,am as b3,$d as b4,V as b5,or as b6,mt as b7,lt as b8,rl as b9,My as bA,zy as bB,Ry as bC,Oy as bD,Ky as bE,__ as bF,m_ as bG,UF as bH,km as bI,Gy as bJ,Xy as bK,Cv as bL,Vm as bM,r_ as bN,BS as bO,of as bP,Jp as bQ,cN as bR,eT as bS,iT as bT,vh as ba,Zh as bb,by as bc,mC as bd,ey as be,Sw as bf,Rw as bg,aS as bh,NT as bi,fS as bj,Mw as bk,JM as bl,cS as bm,UT as bn,TT as bo,ix as bp,Tv as bq,ry as br,L_ as bs,w_ as bt,ny as bu,Ix as bv,Dy as bw,jy as bx,By as by,Zy as bz,Jn as c,Vn as d,q as e,nc as f,$c as g,ic as h,kc as i,ch as j,Xc as k,Bl as l,ri as m,Kh as n,Kd as o,qd as p,nl as q,sc as r,yu as s,rh as t,tc as u,Ss as v,Bu as w,$l as x,Al as y,vl as z};

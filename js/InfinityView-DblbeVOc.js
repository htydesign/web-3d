var e=Object.defineProperty,n=(n,a,i)=>((n,a,i)=>a in n?e(n,a,{enumerable:!0,configurable:!0,writable:!0,value:i}):n[a]=i)(n,"symbol"!=typeof a?a+"":a,i);import{B as a}from"./base-HDikCi6F.js";import{G as i,Q as t,a as s,aK as o,U as r,a6 as u,g as l,T as c,e as d,h,S as v,ak as m,b5 as x,b as f,a5 as g}from"./three-BHpSmIVb.js";import{f as p}from"./modelLoader-CZEJVq38.js";import{d as M,r as w,g as b,j as y,k as S,l as z,t as j,y as _,F as B,o as T}from"./@vue-H0c_gk4m.js";const D={key:0,class:"loading"},I=M({__name:"InfinityView",setup(e){const M=w(0);const I=new class extends a{constructor(){super(),n(this,"group",new i),n(this,"group1",new i),n(this,"scene1",new t),n(this,"shaderMaterial"),n(this,"orthographicCamera"),n(this,"standardMaterial"),n(this,"uniforms",{uTime:{value:0},uOffset:{value:0},uMin:{value:new s(0,0,0)},uMax:{value:new s(0,0,0)}}),n(this,"uniforms1",{uTime:{value:0},uOffset:{value:1},uMin:{value:new s(0,0,0)},uMax:{value:new s(0,0,0)}}),n(this,"time",0)}load(){var e,n;this.init("#webgl"),null==(e=this.scene)||e.add(this.group),this.scene1.add(this.group1),this.group.rotation.x=Math.PI/4,this.group1.rotation.x=-Math.PI/4,this.renderer.setScissorTest(!0),null==(n=this.controls)||n.dispose();const a=window.innerWidth/window.innerHeight;this.orthographicCamera=new o(-10*a/2,10*a/2,5,-5,-1e4,1e4),this.orthographicCamera.position.set(0,0,10),this.controls=new r(this.orthographicCamera,this.renderer.domElement),this.addObject(),this.addLight(),this.animate()}addLight(){var e,n;const a=new u(16777215);a.position.set(0,-1,0),null==(e=this.scene)||e.add(a),this.scene1.add(a.clone());const i=new l(16777215,10.5);i.position.set(0,1,0),i.castShadow=!0,i.shadow.mapSize.width=1024,i.shadow.mapSize.height=1024,i.shadow.camera.near=.1,i.shadow.camera.far=1024,null==(n=this.scene)||n.add(i),this.scene1.add(i.clone())}getMaterial(e){const n=(new c).load("./texture/uv_grid_opengl.jpg");n.wrapS=d,n.wrapT=d;const a=new h({color:7829367});return a.onBeforeCompile=n=>{Object.assign(n.uniforms,e),n.vertexShader="\n          float mapRange(float value, float inMin, float inMax, float outMin, float outMax){\n            return (value - inMin) * (outMax - outMin) / (inMax - inMin)  + outMin;\n          }\n\n          mat4 rotation3d(vec3 axis, float angle) {\n            axis = normalize(axis);\n            float s = sin(angle);\n            float c = cos(angle);\n            float oc = 1.0 - c;\n\n            return mat4(\n              oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n              oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n              oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n              0.0,                                0.0,                                0.0,                                1.0\n            );\n          }\n          vec3 rotate(vec3 v, vec3 axis, float angle) {\n            return (rotation3d(axis, angle) * vec4(v, 1.0)).xyz;\n          }\n\n          float PI = 3.1415926535897932384626433832795;\n\n          float radius = 3.0;\n          uniform vec3 uMin;\n          uniform vec3 uMax;\n          uniform float uTime;\n          uniform float uOffset;\n\n          varying vec2 vUv;\n          varying float vDiscard;\n\n        "+n.vertexShader,n.fragmentShader=`varying float vDiscard;\n            ${n.fragmentShader}\n          `,n.vertexShader=n.vertexShader.replace("#include <beginnormal_vertex>","#include <beginnormal_vertex>\n            vec3 temp = objectNormal;\n\n            float xx = mapRange(position.x, uMin.x, uMax.x, -1.0, 1.0);\n\n            float theta = (xx + uTime + uOffset * 0.5) * 2.0 * PI;\n\n            vDiscard = mod(xx + uTime + mix(0.25, -0.25, uOffset) + uOffset * 0.5, 2.0);\n\n            temp = rotate(temp, vec3(0.0, 0.0, 1.0), theta);\n\n            objectNormal = temp;\n          "),n.vertexShader=n.vertexShader.replace("#include <begin_vertex>","#include <begin_vertex>\n            vec3 pos = transformed;\n\n            vec3 dir = vec3(sin(theta), cos(theta), 0.0);\n\n            pos = radius * dir + vec3(0.0, 0.0, pos.z) + dir * pos.y;\n\n            transformed = pos;\n          "),n.fragmentShader=n.fragmentShader.replace("#include <output_fragment>","#include <output_fragment>\n            float dotShow = step(1.0, vDiscard);\n            if(dotShow > 0.5){\n              discard;\n            }\n          ")},a}addObject(){p("./fonts/helvetiker_bold.typeface.json",(e=>{M.value=e})).then((e=>{this.shaderMaterial=new v({uniforms:{uTime:{value:0},uMin:{value:new s(0,0,0)},uMax:{value:new s(0,0,0)}},vertexShader:"\n          float mapRange(float value, float inMin, float inMax, float outMin, float outMax){\n            return (value - inMin) * (outMax - outMin) / (inMax - inMin)  + outMin;\n          }\n\n          float PI = 3.1415926535897932384626433832795;\n          float radius = 2.0;\n\n          uniform vec3 uMin;\n          uniform vec3 uMax;\n\n          varying vec2 vUv;\n          varying float vDebug;\n\n          void main() {\n            vUv = uv;\n\n            float x = mapRange(position.x, uMin.x, uMax.x, -PI, PI);\n            vDebug = x;\n\n            vec3 dir = vec3(sin(x), cos(x), 0.0);\n            vec3 pos = radius * dir + vec3(0.0, 0.0, position.z) + dir * position.y;\n\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n          }\n        ",fragmentShader:"\n          varying vec2 vUv;\n          varying float vDebug;\n\n          uniform float uTime;\n          void main() {\n            vec2 uv = vUv;\n            gl_FragColor = vec4(vec3(vDebug), 1.0);\n            gl_FragColor = vec4(vUv, 1.0, 1.0);\n          }\n        "});const n=new m("ILIKE3DDD",{font:e,size:1,depth:1,curveSegments:200,bevelEnabled:!1});n.center(),n.computeBoundingBox();const a=n.clone();a.center(),a.computeBoundingBox();const i=[];for(let s=0;s<4;s++){const e=a.clone();e.center(),e.rotateX(s*Math.PI/2),e.translate(a.boundingBox.max.x*s*2,0,0),i.push(e)}const t=x(i);t.center(),t.computeBoundingBox(),this.uniforms.uMin.value=t.boundingBox.min.clone(),this.uniforms.uMax.value=t.boundingBox.max.clone(),this.uniforms1.uMin.value=t.boundingBox.min.clone(),this.uniforms1.uMax.value=t.boundingBox.max.clone();const o=this.getMaterial(this.uniforms),r=this.getMaterial(this.uniforms1),u=new f(t,o),l=new f(t,r);this.group.add(u),this.group1.add(l)}))}animate(){var e,n,a,i;null==(e=this.stats)||e.begin(),this.timer=requestAnimationFrame((()=>{this.animate()})),g.update(),this.time+=.001,this.uniforms.uTime.value=this.time,this.uniforms1.uTime.value=this.time,null==(n=this.renderer)||n.setScissor(0,0,this.innerWidth/2,this.innerHeight),this.renderer.render(this.scene,this.orthographicCamera),null==(a=this.renderer)||a.setScissor(this.innerWidth/2,0,this.innerWidth/2,this.innerHeight),this.renderer.render(this.scene1,this.orthographicCamera),null==(i=this.stats)||i.end()}};return b((()=>{I.load()})),y((()=>{I.destroy()})),(e,n)=>(T(),S(B,null,[n[0]||(n[0]=z("div",{id:"webgl"},null,-1)),n[1]||(n[1]=z("div",{class:"title-name"},"infinity",-1)),M.value<100?(T(),S("div",D,j(M.value),1)):_("",!0)],64))}});export{I as default};

var n=Object.defineProperty,e=(e,t,a)=>((e,t,a)=>t in e?n(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a)(e,"symbol"!=typeof t?t+"":t,a);import{B as t}from"./base-C9hChz8a.js";import{z as a,a5 as i,A as o,b as r,K as s,g as l,M as v,h as u,az as c,D as m,a9 as f,ac as d}from"./three-BV2RzHAl.js";import{d as h,z as g,A as p,g as y,j as x,F as _,o as b}from"./@vue-B4sUqkWa.js";const w=h({__name:"RainShaderView",setup(n){const h=new class extends t{constructor(){super(),e(this,"point"),e(this,"sky")}load(){this.init("#webgl"),this.animate(),this.createParticlesSky(),this.createSky()}createParticlesSky(){var n,e,t;const u=new a({uniforms:{u_time:{value:0},u_resolution:{value:new i(this.innerWidth,this.innerHeight)}},transparent:!0,blending:o,vertexShader:"\n        varying vec2 vUv;\n        void main(){\n          \n          // gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);\n          gl_Position = vec4(position,1.0);\n         \n          vUv=uv;\n        }\n\n      ",fragmentShader:"\n        varying vec2 vUv;\n        uniform float u_time;\n        uniform vec2 u_resolution;\n\n        float random(in vec2 uv)\n        {\n            return fract(sin(dot(uv.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n        }\n\n        float noise(in vec2 uv)\n        {\n            vec2 i = floor(uv);\n            vec2 f = fract(uv);\n            f = f * f * (3. - 2. * f);\n            \n            float lb = random(i + vec2(0., 0.));\n            float rb = random(i + vec2(1., 0.));\n            float lt = random(i + vec2(0., 1.));\n            float rt = random(i + vec2(1., 1.));\n            \n            return mix(mix(lb, rb, f.x), mix(lt, rt, f.x), f.y);\n        }\n\n        float Circle(vec2 uv, vec2 p, float r, float blur)\n        {\n            float d = length(uv - p);\n            float c = smoothstep(r + blur, r - blur, d);\n            \n            return c;\n        }\n\n        #define OCTAVES 8\n        float fbm(in vec2 uv)\n        {\n            float value = 0.;\n            float amplitude = .5;\n            \n            for (int i = 0; i < OCTAVES; i++)\n            {\n                value += noise(uv) * amplitude;\n                \n                amplitude *= .5;\n                \n                uv *= 2.;\n            }\n            \n            return value;\n        }\n\n\n        float rain(vec2 uv)\n        {\n          //雨水下落的速度\n          float travelTime = (u_time * 0.2) + 0.1;\n\n          vec2 tiling = vec2(1., .01);\n          vec2 offset = vec2(travelTime * 0.5 + uv.x * 0.2, travelTime * 0.2);\n\n          vec2 st = uv * tiling + offset;\n          \n          float rain = 0.1;  //雨水的粗细\n          float f = noise(st * 200.5) * noise(st * 125.5);  \n          f = clamp(pow(abs(f), 15.0) * 1.5 * (rain * rain * 125.0), 0.0, 0.25);\n          return f;\n        }\n\n        float moon(vec2 uv)\n        {\n          float moon = smoothstep(0.00, -0.01, length(uv - vec2(0.5, 0.75)) - 0.06);\n          moon *= smoothstep(-0.025, 0.01, length(uv - vec2(0.5 + 0.035, 0.75 + 0.01)) - 0.065);\n          moon = clamp(moon, 0., 1.);\n          \n          return moon;\n        }\n\n        void main(){\n          vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n          uv.x *= u_resolution.x / u_resolution.y;  \n          \n          float cloud = (1.-(fbm((uv +.2) * uv.y+.1 * u_time))) * uv.y;\n          cloud = clamp(0., 1., cloud);\n          \n          \n          float moon = moon(uv);\n          float rain = rain(uv);\n\n          //初始颜色\n          vec3 col = vec3(0.0, 0.0, 0.0);\n          \n          // vec3 col = vec3(0.84, 0.925, 0.941) * moon * (1. - cloud * 1.2);\n          // col = mix(col, vec3(0.8, 0.8, 1.), cloud);\n          col += vec3(1.0) * rain;\n          \n          gl_FragColor = vec4(col, 1.);\n        }\n      "});this.point=new r(new s(300,200),u),null==(n=this.point)||n.position.set(0,100,-250),null==(e=this.scene)||e.add(this.point),null==(t=this.scene)||t.add(new r(new l(30,20,50),new v({color:"red"})))}createSky(){var n,e;const t=(new u).load("./texture/sky.jpg"),a=new c({map:t,side:m}),i={u_time:{value:0},scanMap:{value:t}};this.sky=new r(new f(1e3,64,64),a),a.onBeforeCompile=n=>{Object.assign(n.uniforms,i),n.vertexShader=`\n      varying vec2 vUv;\n      ${n.vertexShader}\n      `,n.vertexShader=n.vertexShader.replace("#include <fog_vertex>","\n        #include <fog_vertex>\n        vUv = uv;\n        "),n.fragmentShader=`\n      varying vec2 vUv;\n      uniform float u_time;\n      uniform sampler2D scanMap;\n      ${n.fragmentShader}\n      `,n.fragmentShader=n.fragmentShader.replace("#include <dithering_fragment>","\n        #include <dithering_fragment>\n        vec4 vColor = texture2D(scanMap, vUv * 1.0);\n        vColor.rgb += vUv.y * sin(u_time);\n        gl_FragColor = vec4(vColor);\n        ")},this.sky.onBeforeRender=()=>{},null==(n=this.scene)||n.add(this.sky);const o=new d({metalness:.5,roughness:0,envMapIntensity:1,transmission:1,ior:1.5}),s=new f(10,64,64),l=new r(s,o);l.position.set(0,20,0),null==(e=this.scene)||e.add(l),this.light({type:"AmbientLight",x:20,y:20,z:20,intensity:1e3})}animate(){var n,e;null==(n=this.stats)||n.begin(),requestAnimationFrame((()=>{this.animate()})),this.point&&(this.point.material.uniforms.u_time.value+=.01),this.renderer.render(this.scene,this.camera),null==(e=this.stats)||e.end()}};return g((()=>{h.load()})),p((()=>{h.gui.close(),h.gui.destroy()})),(n,e)=>(b(),y(_,null,[e[0]||(e[0]=x("div",{id:"webgl"},null,-1)),e[1]||(e[1]=x("div",{class:"title-name"},"下雨",-1))],64))}});export{w as default};

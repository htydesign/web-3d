var e=Object.defineProperty,t=(t,i,n)=>((t,i,n)=>i in t?e(t,i,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[i]=n)(t,"symbol"!=typeof i?i+"":i,n);import{B as i}from"./base-BaImv3YL.js";import{V as n,a as s,a4 as o,R as r,b as a,P as m,M as l,n as v,h as u,c,d as h,S as x,l as p,W as f,aX as d,b7 as w,b8 as y,Q as z,aJ as b,b9 as g,a5 as P}from"./three-CyihR34C.js";import{d as C,z as T,A as M,g as D,j as F,F as j,o as S}from"./@vue-DISYwsDo.js";const I=C({__name:"ParticlesViewTwo",setup(e){const C=new class extends i{constructor(){super(new s(0,0,3)),t(this,"fbo"),t(this,"fbo1"),t(this,"fboScene"),t(this,"fboCamera"),t(this,"fboMaterial"),t(this,"fboMesh"),t(this,"size",256),t(this,"fboTexture"),t(this,"points"),t(this,"material"),t(this,"infoTexture"),t(this,"mouse",new n),t(this,"time",0)}load(){var e,t;this.init("#webgl"),null==(e=this.renderer)||e.setClearColor(0),this.renderer.shadowMap.enabled=!0,this.renderer.shadowMap.type=o,null==(t=this.scene)||t.remove(this.axesHelper),this.setFBO(),this.addObject(),this.setEvent(),this.animate(),this.setting()}setEvent(){const e=new r,t=new a(new m(10,10),new l({color:16777215,transparent:!0,opacity:.5}));new a(new v(.1),new l({color:16777215})),document.addEventListener("mousemove",(i=>{this.mouse.x=i.clientX/window.innerWidth*2-1,this.mouse.y=-i.clientY/window.innerHeight*2+1,e.setFromCamera(this.mouse,this.camera);const s=e.intersectObject(t);if(s.length>0){const{x:e,y:t}=s[0].point||{x:0,y:0};this.fboMaterial.uniforms.uMouse.value=new n(e,t)}}))}setting(){const e={count:0,curlCount:0};this.gui.add(e,"count",0,15,1).onChange((e=>{this.fboMaterial.uniforms.uCount.value=e})),this.gui.add(e,"curlCount",0,5,1).onChange((e=>{this.fboMaterial.uniforms.uCurlCount.value=e}))}addLight(){this.light({type:"AmbientLight",intensity:10}),this.light({type:"DirectionalLight",intensity:1e3,x:30,y:30,z:20})}initPost(){}addObject(){var e;const t=new m(1e3,1e3),i=new u({color:16777215}),n=new a(t,i);n.position.y=0,n.rotation.x=-Math.PI/2,n.receiveShadow=!0;const s=this.size**2,o=new c,r=new Float32Array(3*s),l=new Float32Array(2*s);for(let a=0;a<this.size;a++)for(let e=0;e<this.size;e++){const t=a+e*this.size;r[t+0]=Math.random(),r[t+1]=Math.random(),r[t+2]=0,l[2*t+0]=a/this.size,l[2*t+1]=e/this.size}o.setAttribute("position",new h(r,3)),o.setAttribute("uv",new h(l,2)),this.material=new x({uniforms:{uTime:{value:0},uSize:{value:1},uPosition:{value:null}},vertexShader:"\n        varying vec2 vUv;\n        varying vec4 vColor;\n        uniform sampler2D uPosition;\n        uniform float uTime;\n        void main () {\n\n          vUv = uv;\n\n          vec4 pos = texture2D(uPosition, uv);\n\n          float angle = atan(pos.y, pos.x);\n          \n          vColor = vec4(0.5 + 0.45 * sin(angle + uTime));\n\n          vec4 mvPosition = modelViewMatrix * vec4(pos.xyz, 1.0);\n\n          gl_Position = projectionMatrix * mvPosition;\n\n          gl_PointSize = 3.0 * (1.0 / - mvPosition.z);\n        }\n      ",fragmentShader:"\n        varying vec2 vUv;\n        varying vec4 vColor;\n        uniform float uTime;\n        void main () {\n          gl_FragColor = vColor;\n        }\n      "}),this.material.uniforms.uPosition.value=this.fboTexture,this.points=new p(o,this.material),null==(e=this.scene)||e.add(this.points)}getRenderTarget(){return new f(this.innerWidth,this.innerHeight,{minFilter:d,magFilter:d,format:w,type:y,stencilBuffer:!1})}setFBO(){var e,t,i,s;this.fbo=this.getRenderTarget(),this.fbo1=this.getRenderTarget(),this.fboScene=new z,this.fboCamera=new b(-1,1,1,-1,-1,1),this.fboCamera.position.set(0,0,.5),this.fboCamera.lookAt(0,0,0);const o=new m(2,2),r=new Float32Array(this.size*this.size*4);for(let n=0;n<this.size;n++)for(let e=0;e<this.size;e++){const t=4*(n+e*this.size),i=Math.random()*Math.PI*2,s=.5+.5*Math.random();r[t+0]=s*Math.cos(i),r[t+1]=s*Math.sin(i),r[t+2]=1,r[t+3]=1}this.fboTexture=new g(r,this.size,this.size,w,y),this.fboTexture.magFilter=d,this.fboTexture.minFilter=d,this.fboTexture.needsUpdate=!0,this.fboMaterial=new x({uniforms:{uTime:{value:0},uPosition:{value:this.fboTexture},uInfo:{value:null},uMouse:{value:new n},uCount:{value:1},uCurlCount:{value:0}},vertexShader:"\n  varying vec2 vUv;\n  void main () {\n\n    vUv = uv;\n\n    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n    gl_Position = projectionMatrix * mvPosition;\n\n  }\n",fragmentShader:"\n  varying vec2 vUv;\n  uniform sampler2D uPosition;\n  uniform sampler2D uInfo;\n  uniform float uTime;\n  uniform vec2 uMouse;\n  uniform float uCount;\n  uniform float uCurlCount;\n#define PI 3.1415926538\n\nconst float EPS = 0.001;\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nfloat mod289(float x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute(vec4 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\nfloat permute(float x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\nfloat taylorInvSqrt(float r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\nvec4 grad4(float j, vec4 ip) {\n    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n    vec4 p, s;\n    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n    s = vec4(lessThan(p, vec4(0.0)));\n    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n    return p;\n}\n#define F4 0.309016994374947451\n\nvec4 simplexNoiseDerivatives (vec4 v) {\n    const vec4  C = vec4( 0.138196601125011, 0.276393202250021, 0.414589803375032, -0.447213595499958);\n    vec4 i = floor(v + dot(v, vec4(F4)) );\n    vec4 x0 = v -   i + dot(i, C.xxxx);\n    vec4 i0;\n    vec3 isX = step( x0.yzw, x0.xxx );\n    vec3 isYZ = step( x0.zww, x0.yyz );\n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n    vec4 i3 = clamp( i0, 0.0, 1.0 );\n    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n    vec4 x1 = x0 - i1 + C.xxxx;\n    vec4 x2 = x0 - i2 + C.yyyy;\n    vec4 x3 = x0 - i3 + C.zzzz;\n    vec4 x4 = x0 + C.wwww;\n    i = mod289(i);\n    float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n    vec4 j1 = permute( permute( permute( permute (\n    i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n    + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n    + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n    + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n    vec4 p0 = grad4(j0, ip);\n    vec4 p1 = grad4(j1.x, ip);\n    vec4 p2 = grad4(j1.y, ip);\n    vec4 p3 = grad4(j1.z, ip);\n    vec4 p4 = grad4(j1.w, ip);\n    vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= taylorInvSqrt(dot(p4, p4));\n    vec3 values0 = vec3(dot(p0, x0), dot(p1, x1), dot(p2, x2)); //value of contributions from each corner at point\n    \n    vec2 values1 = vec2(dot(p3, x3), dot(p4, x4));\n    vec3 m0 = max(0.5 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2)), 0.0); //(0.5 - x^2) where x is the distance\n    \n    vec2 m1 = max(0.5 - vec2(dot(x3, x3), dot(x4, x4)), 0.0);\n    vec3 temp0 = -6.0 * m0 * m0 * values0;\n    vec2 temp1 = -6.0 * m1 * m1 * values1;\n    vec3 mmm0 = m0 * m0 * m0;\n    vec2 mmm1 = m1 * m1 * m1;\n    float dx = temp0[0] * x0.x + temp0[1] * x1.x + temp0[2] * x2.x + temp1[0] * x3.x + temp1[1] * x4.x + mmm0[0] * p0.x + mmm0[1] * p1.x + mmm0[2] * p2.x + mmm1[0] * p3.x + mmm1[1] * p4.x;\n    float dy = temp0[0] * x0.y + temp0[1] * x1.y + temp0[2] * x2.y + temp1[0] * x3.y + temp1[1] * x4.y + mmm0[0] * p0.y + mmm0[1] * p1.y + mmm0[2] * p2.y + mmm1[0] * p3.y + mmm1[1] * p4.y;\n    float dz = temp0[0] * x0.z + temp0[1] * x1.z + temp0[2] * x2.z + temp1[0] * x3.z + temp1[1] * x4.z + mmm0[0] * p0.z + mmm0[1] * p1.z + mmm0[2] * p2.z + mmm1[0] * p3.z + mmm1[1] * p4.z;\n    // float dw = temp0[0] * x0.w + temp0[1] * x1.w + temp0[2] * x2.w + temp1[0] * x3.w + temp1[1] * x4.w + mmm0[0] * p0.w + mmm0[1] * p1.w + mmm0[2] * p2.w + mmm1[0] * p3.w + mmm1[1] * p4.w;\n    \n    \n    // return vec4(dx, dy, dz, dw) * 49.0;\n    return vec4(dx, dy, dz, 0.0) * 49.0;\n}\nvec3 curl( in vec3 p, in float noiseTime, in float persistence ) {\n    vec4 xNoisePotentialDerivatives = vec4(0.0);\n    vec4 yNoisePotentialDerivatives = vec4(0.0);\n    // vec4 zNoisePotentialDerivatives = vec4(0.0);\n    \n    \n    for (int i = 0; i < 2; ++i) {\n        float twoPowI = pow(2.0, float(i));\n        float scale = 0.5 * twoPowI * pow(persistence, float(i));\n        xNoisePotentialDerivatives += simplexNoiseDerivatives(vec4(p * twoPowI, noiseTime)) * scale;\n        yNoisePotentialDerivatives += simplexNoiseDerivatives(vec4((p + vec3(123.4, 129845.6, -1239.1)) * twoPowI, noiseTime)) * scale;\n        // zNoisePotentialDerivatives += snoise4(vec4((p + vec3(-9519.0, 9051.0, -123.0)) * twoPowI, noiseTime)) * scale;\n    }\n    return vec3(\n    yNoisePotentialDerivatives[1] - xNoisePotentialDerivatives[1], yNoisePotentialDerivatives[2] - xNoisePotentialDerivatives[2], yNoisePotentialDerivatives[0] - xNoisePotentialDerivatives[0]\n    );\n}\n  void main () {\n    vec4 pos = texture2D(uPosition, vUv);\n    vec4 info = texture2D(uInfo, vUv);\n\n    vec2 mouse = uMouse ;\n\n    float radius = length(pos.yx);\n\n    float circularForce = 1.0 - smoothstep(0.3, 1.4, abs(pos.x - radius));\n\n    float angle = atan(pos.y, pos.x) - info.x * 0.3 * mix(0.5, 1.0, circularForce);\n\n    float targetRadius = mix(info.x ,0.8, 0.5 + 0.45 * sin(angle * uCount + uTime * 0.2));\n\n    radius += (targetRadius - radius) * mix(0.2, 0.5, circularForce);\n\n\n    vec3 targetPos = vec3(cos(angle), sin(angle), 0.0) * radius;\n\n    pos.xy += (targetPos.xy - pos.xy) * 0.1;\n\n    pos.xy += curl(pos.xyz * uCurlCount, uTime * 0.1, 0.5).xy * 0.003;\n\n    float dist = length(pos.xy - mouse);\n    vec2 dir = normalize(pos.xy - mouse) / 2.0;\n    pos.xy += dir * 5.0 * smoothstep(0.0, 1.0, 0.5 - dist);\n\n    gl_FragColor = vec4(pos.xy, 1.0, 1.0);\n  }\n"});const l=new Float32Array(this.size*this.size*4);for(let n=0;n<this.size;n++)for(let e=0;e<this.size;e++){const t=4*(n+e*this.size);l[t+0]=.5*Math.random()+.5,l[t+1]=.5*Math.random()+.5,l[t+2]=1,l[t+3]=1}this.infoTexture=new g(l,this.size,this.size,w,y),this.infoTexture.magFilter=d,this.infoTexture.minFilter=d,this.infoTexture.needsUpdate=!0,this.fboMaterial.uniforms.uInfo.value=this.infoTexture,this.fboMesh=new a(o,this.fboMaterial),this.fboScene.add(this.fboMesh),null==(e=this.renderer)||e.setRenderTarget(this.fbo),null==(t=this.renderer)||t.render(this.fboScene,this.fboCamera),null==(i=this.renderer)||i.setRenderTarget(this.fbo1),null==(s=this.renderer)||s.render(this.fboScene,this.fboCamera)}animate(){var e,t;null==(e=this.stats)||e.begin(),this.timer=requestAnimationFrame((()=>{this.animate()})),P.update(),this.time+=.05,this.fboMaterial.uniforms.uTime.value=this.time,this.material&&(this.material.uniforms.uTime.value=this.time),this.fboMaterial.uniforms.uPosition.value=this.fbo1.texture,this.material.uniforms.uPosition.value=this.fbo.texture,this.renderer.setRenderTarget(this.fbo),this.renderer.render(this.fboScene,this.fboCamera),this.renderer.setRenderTarget(null),this.renderer.render(this.scene,this.camera);const i=this.fbo;this.fbo=this.fbo1,this.fbo1=i,null==(t=this.stats)||t.end()}};return T((()=>{C.load()})),M((()=>{C.destroy()})),(e,t)=>(S(),D(j,null,[t[0]||(t[0]=F("div",{id:"webgl"},null,-1)),t[1]||(t[1]=F("div",{class:"title-name"},"粒子",-1))],64))}});export{I as default};

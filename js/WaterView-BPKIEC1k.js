var e=Object.defineProperty,n=(n,t,a)=>((n,t,a)=>t in n?e(n,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):n[t]=a)(n,"symbol"!=typeof t?t+"":t,a);import{B as t}from"./base-BaImv3YL.js";import{d as a,z as o,A as r,g as i,j as s,F as l,o as v}from"./@vue-DISYwsDo.js";import{T as u,c,d as m,S as g,l as d,e as f,a as h,x,u as p,b as y,P as T}from"./three-CyihR34C.js";const w=a({__name:"WaterView",setup(e){const a=new class extends t{constructor(){super(),n(this,"uniforms",{uTime:{value:0},uNormals:{value:null},uDotTexture:{value:null},uLightTexture:{value:null},uNoiseTexture:{value:null}}),n(this,"textLoader",new u)}load(){var e;this.init("#webgl"),null==(e=this.renderer)||e.setClearColor(336700),this.animate(),this.create()}create(){var e;const n=this.textLoader.load("./texture/sphere-normal.jpg");this.uniforms.uNormals={value:n};const t=5e4,a=new c,o=new Float32Array(15e4),r=new Float32Array(15e4),i=new Float32Array(t);for(let v=0;v<1e5;v+=3)o[v+0]=Math.random()-.5,o[v+1]=Math.random()-.5,o[v+2]=Math.random()-.5,r[v+0]=Math.random(),r[v+1]=Math.random(),r[v+2]=Math.random(),i[v+0]=.75*Math.random()+.5;a.setAttribute("position",new m(o,3)),a.setAttribute("aRandom",new m(r,3)),a.setAttribute("aSize",new m(i,1));const s=new g({transparent:!0,uniforms:this.uniforms,depthTest:!1,vertexShader:"\n        float PI = 3.141592653589793238;\n\n        vec3 getPos(float progress){            \n            float angle = progress * PI * 2.0;\n            float x = sin(angle) + 2.0 * sin(2.0 * angle);\n            float y = cos(angle) - 2.0 * cos(2.0 * angle);\n            float z = -sin(angle * 3.0);\n            return vec3(x, y, z);\n        }\n        \n        vec3 getTangent(float progress){            \n            float angle = progress * PI * 2.0;\n            float x = -cos(angle) + 4.0 * cos(2.0 * angle);\n            float y = -sin(angle) + 4.0 * sin(2.0 * angle);\n            float z = 3.0 *  -cos(angle * 3.0);\n            return normalize(vec3(x, y, z));\n        }\n        vec3 getNormal(float progress){            \n            float angle = progress * PI * 2.0;\n            float x = -sin(angle) - 8.0 * sin(2.0 * angle);\n            float y = -cos(angle) + 8.0 * cos(2.0 * angle);\n            float z = 9.0 *  -sin(angle * 3.0);\n            return normalize(vec3(x, y, z));\n        }\n\n        attribute vec3 aRandom;\n        attribute float aSize;\n\n        uniform float uTime;\n\n        varying vec2 vUv;\n\n        void main(){\n            vUv = uv;\n\n            vec3 pos = position;\n            float progress = fract(uTime * 0.01  + aRandom.x);\n\n            pos = getPos(progress);\n            vec3 normal = getNormal(progress);\n            vec3 tangent = getTangent(progress);\n            vec3 biNormal = normalize(cross(normal, tangent));\n\n            float radius = 0.3 + aRandom.z * 0.2;\n            float cx = radius * cos(aRandom.y* 2.0 * PI * uTime * 0.1 + aRandom.z * 7.0);\n            float cy = radius * sin(aRandom.y * 2.0 * PI * uTime * 0.1 + aRandom.z * 7.0);\n\n            pos += normal * cx + biNormal * cy;\n            pos *= 50.0;\n            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);          \n            gl_PointSize = aSize * 20.0 * 50.0 / -mvPosition.z;\n            gl_Position = projectionMatrix * mvPosition;\n        }\n      ",fragmentShader:"\n\n        uniform float time;\n        uniform sampler2D uNormals;\n\n        void main(){\n            vec3 color = vec3(0.136, 0.559, 0.832);\n\n            vec2 st = gl_PointCoord.xy;\n\n            float disc = length(st - vec2(0.5));\n            float alpha = smoothstep(0.5, 0.48, disc);\n\n            vec4 normalTexture = texture2D(uNormals, st);\n\n            vec3 normal = vec3(normalTexture.rg * 2.0 - 1.0, 0.0);\n            normal.z = sqrt(1.0 - normal.x * normal.x - normal.y * normal.y);\n            normal = normalize(normal);\n\n            vec3 lightPos = vec3(1.0);\n            float diffuse = max(0.0, dot(normal, lightPos));\n\n            gl_FragColor = vec4( color, alpha * diffuse * 0.15);\n        }\n      "}),l=new d(a,s);null==(e=this.scene)||e.add(l),this.createCurve(),this.createPlane()}createCurve(){var e;const n=this.textLoader.load("./texture/dot.jpg");n.wrapS=f,n.wrapT=f,this.uniforms.uDotTexture={value:n};const t=this.textLoader.load("./texture/light.jpg");t.wrapS=f,t.wrapT=f,this.uniforms.uLightTexture={value:t};const a=[];for(let l=0;l<=100;l++){const e=l/100*Math.PI*2,n=Math.sin(e)+2*Math.sin(2*e),t=Math.cos(e)-2*Math.cos(2*e),o=-Math.sin(3*e);a.push(new h(n,t,o))}const o=new x(a),r=new p(o,100,.4,100,!1),i=new g({transparent:!0,uniforms:this.uniforms,vertexShader:"\n        varying vec2 vUv;\n        varying vec3 vWorldPosition;\n        varying vec3 vNormal;\n        void main(){\n          vUv = uv;\n          vNormal = normal;\n          vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n      ",fragmentShader:"\n        varying vec2 vUv;\n        varying vec3 vWorldPosition;\n        varying vec3 vNormal;\n\n        uniform float uTime;\n        uniform sampler2D uDotTexture;\n        uniform sampler2D uLightTexture;\n        void main(){\n          float time1 = uTime * 0.04;\n\n          float texture1 = texture2D(uLightTexture, vUv - vec2(time1)).r;\n          float texture11 = texture2D(uLightTexture, vUv - time1 * 1.5).r;\n          float texture2 = texture2D(uDotTexture, vUv * vec2(8.0, 4.0) - time1 * 0.5).r;\n\n          float alpha = min(texture1, texture11) + texture2;\n          vec3 color = vec3(0.136, 0.559, 0.832);\n          vec3 color1 = vec3(0.579, 0.903, 0.983);\n\n          vec3 viewDir = - normalize(vWorldPosition - cameraPosition);\n\n          float fresnel =  dot(viewDir, vNormal);\n          fresnel = pow(fresnel, 3.0);\n\n          // gl_FragColor = vec4(color1, 1.0);\n          gl_FragColor = vec4(vUv, 0.0, 1.0);\n          gl_FragColor = vec4(color, alpha);\n          gl_FragColor = vec4(vec3(color), alpha);\n          gl_FragColor = vec4(vec3(color), alpha * fresnel);\n        }\n      "}),s=new y(r,i);s.scale.set(50,50,50),null==(e=this.scene)||e.add(s)}createPlane(){var e;const n=this.textLoader.load("./texture/noise.jpg");n.wrapS=f,n.wrapT=f,this.uniforms.uNoiseTexture={value:n};const t=new T(10,10),a=new g({uniforms:this.uniforms,transparent:!0,depthTest:!1,vertexShader:"\n        varying vec2 vUv;\n        varying vec3 vWorldPosition;\n        void main(){\n          vUv = uv;\n          vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n      ",fragmentShader:"\n        varying vec2 vUv;\n        varying vec3 vWorldPosition;\n\n        uniform float uTime;\n        uniform sampler2D uNoiseTexture;\n        void main(){\n          vec3 tt = texture2D(uNoiseTexture, vUv).rgb;\n\n          vec2 grey = vWorldPosition.xy - vec2(0.0, 200.0);\n          float uvDirection = atan(grey.y, grey.x);\n\n          float c = texture2D(uNoiseTexture, vec2(uvDirection, 0.0) + uTime * 0.04).x;\n          float c1 = texture2D(uNoiseTexture, vec2(1.0, uvDirection) + uTime * 0.04 * 1.5).x;\n          float alpha = min(c, c1);\n\n          float fade = smoothstep(0.35, 0.85, abs(vUv.y));\n\n          gl_FragColor = vec4(vec3(alpha), alpha * 0.3 * fade);\n        }"}),o=new y(t,a);o.scale.set(50,50,50),null==(e=this.scene)||e.add(o)}animate(){var e,n,t;null==(e=this.stats)||e.begin(),requestAnimationFrame((()=>{this.animate()})),this.uniforms.uTime.value+=.05,null==(n=this.renderer)||n.render(this.scene,this.camera),null==(t=this.stats)||t.end()}};return o((()=>{a.load()})),r((()=>{a.destroy()})),(e,n)=>(v(),i(l,null,[n[0]||(n[0]=s("div",{id:"webgl"},null,-1)),n[1]||(n[1]=s("div",{class:"title-name"},"æ°´",-1))],64))}});export{w as default};

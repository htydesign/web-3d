var e=Object.defineProperty,i=(i,n,t)=>((i,n,t)=>n in i?e(i,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[n]=t)(i,"symbol"!=typeof n?n+"":n,t);import{B as n}from"./base-MCXJ8rIx.js";import{G as t,V as o,R as a,a as r,C as s,B as l,M as u,b as h,c as d,d as p,D as c}from"./three-DKcIG4Oh.js";import{d as m,z as v,A as g,g as y,j as f,F as b,o as x}from"./@vue-DISYwsDo.js";const w=m({__name:"LightView",setup(e){const m=new class extends n{constructor(){super(),i(this,"box"),i(this,"planeGroup",new t),i(this,"boxGroup",new t),i(this,"raycaster"),i(this,"pointer",new o),i(this,"map",new Map),i(this,"uuid",""),i(this,"uTime",0)}load(){this.init("#webgl"),this.animate(),this.createBoxGroup(),this.gridHelper(),this.raycaster=new a,window.addEventListener("mousemove",(e=>{var i,n;e.preventDefault(),this.pointer.x=e.clientX/this.innerWidth*2-1,this.pointer.y=-e.clientY/this.innerHeight*2+1,null==(i=this.raycaster)||i.setFromCamera(this.pointer,this.camera);const t=null==(n=this.raycaster)?void 0:n.intersectObjects(this.boxGroup.children);if(t&&t.length>0){const e=t[0].object;if(this.planeGroup.children.length&&this.planeGroup.position.x==e.position.x&&this.planeGroup.position.z==e.position.z);else{this.planeGroup.clear(),e.geometry.computeBoundingBox();const{min:i,max:n}=e.geometry.boundingBox||{min:new r(.1,.2,0),max:new r(.11,.12,0)},t=Math.abs(i.x)+Math.abs(n.x)+10,o=Math.abs(i.y)+Math.abs(n.y)+10,a=Math.abs(i.z)+Math.abs(n.z)+10;this.planeMask(t,o,a,e.position)}}else this.planeGroup.clear()}))}createBoxGroup(){var e,i;const n=50,t=150,o=50,a={u_y:{value:-t/2},yHeighy:{value:t/2},uWidth:{value:3},uColor:{value:new s(16776960)}};for(let s=0;s<10;s++){const e=new l(n,t,o),i=new u({color:13421772});this.box=new h(e,i),i.onBeforeCompile=function(e){Object.assign(e.uniforms,a),e.vertexShader=e.vertexShader.replace("void main() {","\n          varying vec3 vPosition;\n          void main() {\n            // vPosition = vec3(modelMatrix * vec4( position, 1.0 ));\n            // 布局坐标\n            vPosition = position;//只考虑几何体的顶点位置xyz\n          "),e.fragmentShader=e.fragmentShader.replace("void main() {","\n          varying vec3 vPosition;\n          uniform float u_y;\n          uniform vec3 uColor;\n          uniform float uWidth;\n          uniform float yHeighy;\n          void main() {\n\n          "),e.fragmentShader=e.fragmentShader.replace("#include <dithering_fragment>","\n          #include <dithering_fragment>\n\n          for (int i = 0; i < 5; i++) {\n            float adjustedUy = u_y - yHeighy + float(i) * uWidth * 10.0 ; // 每次循环调整 u_y 的值\n            // y随着时间改变光带位置也会改变\n            if(vPosition.y >= adjustedUy && vPosition.y < adjustedUy + uWidth) {\n              float per = (vPosition.y - adjustedUy) / uWidth; // 范围0~1\n              per = pow(per, 2.0); // 平方\n              gl_FragColor.rgb = mix(vec3(uColor), gl_FragColor.rgb, per);\n            }\n            // y随着时间改变光带位置也会改变\n            if(vPosition.y <= adjustedUy && vPosition.y > adjustedUy - uWidth) {\n              float per = (adjustedUy - vPosition.y) / uWidth; // 范围0~1\n              per = pow(per, 2.0); // 平方\n              gl_FragColor.rgb = mix(vec3(uColor), gl_FragColor.rgb, per);\n            }\n          }\n\n          ")},this.box.onBeforeRender=()=>{a.u_y.value+=30*this.clock.getDelta(),a.u_y.value>t&&(a.u_y.value=-t)},this.box.position.set(400*Math.random()-200,t/2,500*Math.random()-200),this.box.name="box",this.boxGroup.add(this.box),this.scene.add(this.boxGroup)}const r={color:16776960,width:3};null==(e=this.gui)||e.addColor(r,"color").onChange((()=>{a.uColor.value=new s(r.color)})),null==(i=this.gui)||i.add(r,"width",1,10).onChange((()=>{a.uWidth.value=r.width}))}planeMask(e,i,n,t){var o;const a=new Float32Array([-e/2,0,0,e/2,0,0,e/2,i,0,e/2,i,0,-e/2,i,0,-e/2,0,0]),r=new d;r.attributes.position=new p(a,3);const s=new u({color:16776960,side:c,transparent:!0}),l=new h(r,s);l.position.set(0,0,n/2);const m={yHeigh:{value:i/3*2},uTime:{value:this.uTime}};s.onBeforeCompile=e=>{Object.assign(e.uniforms,m),e.vertexShader=e.vertexShader.replace("void main() {","\n          varying vec3 vPosition;\n          void main() {\n            // vPosition = vec3(modelMatrix * vec4( position, 1.0 ));\n            // 布局坐标\n            vPosition = position;//只考虑几何体的顶点位置xyz\n\n          "),e.fragmentShader=e.fragmentShader.replace("void main() {","\n          varying vec3 vPosition;\n          uniform float yHeigh;\n          uniform float uTime;\n          void main() {\n\n          "),e.fragmentShader=e.fragmentShader.replace("#include <dithering_fragment>","\n          #include <dithering_fragment>\n\n           gl_FragColor = vec4(outgoingLight, (1.0 - vPosition.y/yHeigh) * uTime   );\n\n          ")},l.onBeforeRender=()=>{m.uTime.value+=.05,m.uTime.value>=1&&(m.uTime.value=1)},this.planeGroup.add(l);const v=l.clone();v.position.set(0,0,-n/2),this.planeGroup.add(v);const g=l.clone();g.rotateY(Math.PI/2),g.position.set(e/2,0,0),this.planeGroup.add(g);const y=l.clone();y.rotateY(Math.PI/2),y.position.set(-e/2,0,0),this.planeGroup.add(y),this.planeGroup.position.set(t.x,0,t.z),null==(o=this.scene)||o.add(this.planeGroup)}animate(){var e,i,n;null==(e=this.stats)||e.begin(),requestAnimationFrame((()=>{this.animate()})),null==(i=this.raycaster)||i.setFromCamera(this.pointer,this.camera),this.renderer.render(this.scene,this.camera),null==(n=this.stats)||n.end()}};return v((()=>{m.load()})),g((()=>{m.gui.close(),m.gui.destroy()})),(e,i)=>(x(),y(b,null,[i[0]||(i[0]=f("div",{id:"webgl"},null,-1)),i[1]||(i[1]=f("div",{class:"title-name"},"建筑",-1))],64))}});export{w as default};
